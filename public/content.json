[{"title":"node.js--爬虫","date":"2018-09-05T17:00:01.000Z","path":"2018/09/06/⑧-【JS 工具集-拓展语言】-node.js- 爬虫/","text":"一、爬虫2.1 什么是爬虫网络爬虫（又被称为网页蜘蛛，网络机器人，在 FOAF 社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 2.2 爬虫工具python VS node.js 说到爬虫，大家想到的比较多的还是 python，确实 python 有 Scrapy 等成熟的框架，可以实现很强大的爬取功能。但是 node 也有自身的优点，凭借强大的异步特性，可以很轻松的实现高效的异步并发请求，节省 cpu 的开销。node.js 直接是在浏览器运行的，这个也是它的优点。 二、爬虫流程123456789101112结构分析 # 分析清楚页面结构，要爬哪些页面，页面的结构是怎样的，需不需要登录；有没有ajax接口，返回什么样的数据等。数据抓取 # 如今的网页的数据，大体分为同步页面和ajax接口。 # 同步页面数据的抓取就需要我们先分析网页的结构， # python 抓取数据一般是通过 正则表达式匹配 来获取需要的数据； # node有一个 cheerio 的工具，可以将获取的页面内容转换成 jquery 对象， # 然后就可以用 jquery 强大的 dom API 来获取节点相关数据， 其实大家看源码，这些 API 本质也就是正则匹配。 # ajax 接口数据一般都是 json 格式的，处理起来还是比较简单的。数据存储 # 抓取的数据后，会做简单的筛选，然后将需要的数据先保存起来，以便后续的分析处理。 # 当然我们可以用 MySQL 和 Mongodb 等数据库存储数据。为了方便，没有问题的话也可以直接采用文件存储。数据分析 # 因为我们最终是要展示数据的，所以我们要将原始的数据按照一定维度去处理分析，然后返回给客户端。 # 这个过程可以在存储的时候去处理，也可以在展示的时候，前端发送请求，后台取出存储的数据再处理。结果展示 # 这个是前端工程师的工作啦。 三、爬虫常用库3.1 Superagent：http 方面的库SuperagentSuperagent 中文网站Superagent 是个轻量的的 http 方面的库，是 nodejs 里一个非常方便的客户端请求代理模块，进行 get、post、head 等网络请求。 3.2 Cheerio ：Node.js 版 jqueryCheerioCheerio 中文Cheerio 中文简书（用来从网页中以 css selector 取数据，使用方式跟 jquery 一模一样）可以将获取的页面内容转换成 jquery 对象。然后就可以用 jquery 强大的 dom API 来获取节点相关数据， 其实大家看源码，这些 API 本质也就是正则匹配。 3.3 Async：流程控制工具包AsyncAsync 中文Async 中文简书Async 是一个流程控制工具包，提供了直接而强大的异步功能 mapLimit(arr, limit, iterator, callback)，我们主要用到这个方法，大家可以去看看官网的 API。 3.4 当然还有其他的工具恶意使用，比如：删除数组元素方法的工具，数组排序方法的工具 五、实际应用（爬虫完整）1234567891011121314151617181920//结构分析，如要登录。所以我们要先拿到登录的 cookie 才行，有的时候是 token，看自己要爬的网页来分析//获取登录cookiefunction getCookie() &#123; superagent.post('https://www.example.com') .type('form') .send(&#123; phone: phone, password: password, productCode: \"LMLC\", origin: \"PC\" &#125;) .end(function(err, res) &#123; if (err) &#123; handleErr(err.message); return; &#125; cookie = res.header['set-cookie']; //从response中得到cookie emitter.emit(\"setCookeie\"); &#125;)&#125;","tags":[]},{"title":"JavaScript【1】--[cookie,session,token 详解]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-cookie-token/","text":"一、前言","tags":[{"name":"cookie,session,token","slug":"cookie-session-token","permalink":"https://liuxmoo.com/tags/cookie-session-token/"}]},{"title":"iview-ui 使用过程的各种问题","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑮ -  bug 集合 -iview-ui 中遇到的 bug/","text":"一、前言iview-ui 组件比较丰富，但是使用起来总是会遇到一些问题。 二、安装引入的问题通常我们使用的是 vue-cli3 但是 iview-ui 使用的是 iview 提供的脚手架的引入方法，不能照搬 iview-ui 的方法。 三、 menu 的问题3.1 iview 使用 Menu 组件动态生成时 active-name 不起作用案例中给的是固定的数字，通常我会绑定动态的字符串，但是发现它没有起作用。这个 active-name 还要和另外两个函数配合使用才可以的。 123// 方法名 说明 参数updateOpened //手动更新展开的子目录，注意要在 $nextTick 里调用 没有参数updateActiveName //手动更新当前选择项，注意要在 $nextTick 里调用 没有参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- 1、给Menu组件绑定ref ,例如side_menu2、menu列表更新时，手动更新 --&gt;&lt;template&gt;&lt;!-- 侧边栏 --&gt; &lt;Sider&gt; &lt;!-- 这个 width=\"auto\" 要设置，然后才不会 超出 Sider 的宽 --&gt; &lt;Menu ref=\"left_menu\" theme=\"dark\" width=\"auto\" :active-name=\"siderMenuActiveName\" @on-select=\"changeMenu\" &gt; &lt;MenuGroup title=\"运营详情\"&gt; &lt;MenuItem name=\"overview\"&gt; &lt;i class=\"iconfont icon-shangpin2\"&gt;&lt;/i&gt; 销售动态 &lt;/MenuItem&gt; &lt;MenuItem name=\"orders\"&gt; &lt;i class=\"iconfont icon-dingdan1\"&gt;&lt;/i&gt; 订单管理 &lt;/MenuItem&gt; &lt;MenuItem name=\"chargeback\"&gt; &lt;i class=\"iconfont icon-dingdan1\"&gt;&lt;/i&gt; 退单处理 &lt;/MenuItem&gt; &lt;/MenuGroup&gt; &lt;MenuGroup title=\"商品设置\"&gt; &lt;MenuItem name=\"product\"&gt; &lt;i class=\"iconfont icon-shangpin2\"&gt;&lt;/i&gt; 商品管理 &lt;/MenuItem&gt; &lt;MenuItem name=\"swiper\"&gt; &lt;i class=\"iconfont icon-shangpin2\"&gt;&lt;/i&gt; 轮播设置 &lt;/MenuItem&gt; &lt;/MenuGroup&gt; &lt;MenuGroup title=\"物流详情\"&gt; &lt;MenuItem name=\"logistics\"&gt; &lt;i class=\"iconfont icon-wuliu-copy\"&gt;&lt;/i&gt; 物流信息 &lt;/MenuItem&gt; &lt;/MenuGroup&gt; &lt;MenuGroup title=\"用户中心\"&gt; &lt;MenuItem name=\"users\"&gt; &lt;i class=\"iconfont icon-yonghu\"&gt;&lt;/i&gt; 用户管理 &lt;/MenuItem&gt; &lt;/MenuGroup&gt; &lt;/Menu&gt; &lt;/Sider&gt;&lt;/template&gt;&lt;script&gt; data() &#123; return &#123; siderMenuActiveName: \"overview\" &#125;; &#125;, mounted() &#123; //在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。 this.$nextTick(() =&gt; &#123; this.$refs.left_menu.updateOpened(); this.$refs.left_menu.updateActiveName();// 只要不是在 template 中固定写的， //在 data 中写的，就是动态的，赋值之后，都是要使用这个方法来更新 active-name 的。 //updateOpened()，updateActiveName() 还是要求在 this.$nextTick() 中执行， // 并且 ref 是在 mounted 才会读取到的，这段代码，必然要在 mounted() 周期写了 document.querySelector( \".layout-title\" ).innerHTML = document.querySelector(\".ivu-menu-item-selected\").innerHTML; &#125;); &#125;, methods: &#123; // 侧边栏切换，侧边栏更新，我们 menu 的 name 值是要更新的，还是不要忘记手动的更新 active 值。 // 这里说的手动更新，（就是用户在点击侧边栏，然后触发事件，代码中的 updateOpened()，updateActiveName() 函数执行去更新 active-name 值！！！！） changeMenu(name) &#123; this.siderMenuActiveName = name; this.$nextTick(() =&gt; &#123; this.$refs.left_menu.updateOpened(); this.$refs.left_menu.updateActiveName(); document.querySelector( \".layout-title\" ).innerHTML = document.querySelector( \".ivu-menu-item-selected\" ).innerHTML; &#125;); this.$router.push(name); &#125; &#125;&lt;/script&gt;","tags":[]},{"title":"JavaScript---new Date]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-new Date() 日期时间处理/","text":"一、 前言new Date 类的所有内置方法，与拓展方法的列举，方便使用的时候查阅与快速引用。MDN 查看 更多的时间处理可以去看 dayjs 的使用的。 二、JavaScript Date 的内置方法1234567891011121314151617181920212223242526272829303132333435//以下结果是2018-9-10得到的。var d = new Date();d.setFullYear(year,month,date) // year 是必填项，后面 2 个是可选项，这个方法取代了 setYear 方法，因为它可以有 3 个变量 // 其中 year 对应的是就是 年份，month 对应的是 0-11,date 对应的是 1-31 ！！！！！！！！！！！！！只有月份是特殊的。 // 例如 d.setFullYear(2019,2,19) 这里 d ：2019-03-19T12:33:32.107Zvar d = new Date() //今天d.setFullYear(2019, 2, 19)console.log(d); // 2019-03-19T12:49:20.409Zd.setMonth(6)console.log(d); // 2019-07-19T12:51:05.590Zd.setDate(32)console.log(d); // 2019-08-31T12:51:05.590Z 为啥设置 32 然后天数是 1 然后月数 + 1// 就不要设置错误的过来就好了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！d.setTime()// 有设置函数也有获取函数，按照上面的变化console.log(d.getFullYear()); // 2019console.log(d.getMonth()); // 7 获取的是 月数，对应的值是 0-11 0 是 1 月console.log(d.getDate()); // 1 获取的是 天数，对应的值是 1-31 1 是 1 天console.log(d.getDay()); // 4 获取的是 星期几，对应的值是 0-6 0 是 星期 1console.log(d.getTime()); // 1564664314855 获取当前时间(从1970.1.1开始的毫秒数) 会改变的，因为时间一直在走呀，这个 时间 搓console.log(d.getHours()); // 20 （当前时间 2019-8-1 20:59:42）console.log(d.getMinutes()); // 59 （当前时间 2019-8-1 20:59:42）console.log(d.getSeconds()); // 42 （当前时间 2019-8-1 20:59:42）console.log(d.getMilliseconds()); // 656 （当前时间 2019-8-1 20:59:42）console.log(d.toLocaleDateString()); // 2019-8-1 （当前时间 2019-8-1 20:59:42）console.log(d.toLocaleString()); // 2019-8-1 20:59:42 / 2019/8/1 下午8:58:34 视本地电脑环境时间而定 （当前时间 2019-8-1 20:59:42）console.log(d.toLocaleTimeString()); // 20:59:42 (当前时间 2019-8-1 20:59:42）var day = new Date('9102-02-02T12:51:05.590Z')console.log(day.toLocaleDateString());//9102-2-2day = new Date('August 19, 1975 23:15:30')console.log(day.toLocaleString());//1975-8-19 23:15:30 12345// 将时间戳 1564664314855 转化为 2019-8-1 20:58:34 格式var d = new Date() //今天d.setTime(1564664314855)// 有设置函数也有获取函数，按照上面的变化console.log(d.toLocaleString()); // 2019-8-1 20:58:34 123// 将 时间戳 (毫秒：1564664314855) 格式化var d = new Date(1564664314855)console.log(d.toLocaleString()); // 2019-8-1 20:58:34 12345// 将 (秒：1551591644) 格式化var d = new Date(1551591644*1000)// 先转化为 时间戳， new Date 知道是什么。console.log(d.toLocaleString()); // 2019-8-1 20:58:34// 2019/8/1 下午8:58:34// 后面这个函数，会根据系统（电脑系统）的时间设置格式来显示的，可以自己去规定 三、 JavaScript Date 的原型方法扩展在JavaScript开发中，经常需要对 Date 类型的对象进行各种验证或格式化，但是 js 并没有提供那么多的那么细的函数，所以只好自己去用 prototype 扩充。 不过多人的项目应该不要去修改内置对象吧，这样多人合作的话会产生很多问题的！！！！不要去修改内置对象！！！而且在 ESlint 中根不让这样添加的！！！原型只读，不让你添加！！！给 js 的内置对象 做修改，那是一个大坑。 做法：自己封装一个类，然后类里封装一个 date 实例。除了 polyfill，永远都不要扩展原生，感觉是个坑。所以不要用下面这种形式哦。 12345# 这里的做法是错误的示范 按照后面的每个小节的方法来写。Date.prototype.isLeapYear #判断闰年Date.prototype.Format #日期格式化Date.prototype.DateAdd #日期计算Date.prototype.DateDiff #比较日期差 3.1 判断是否是闰年 Date.prototype.isLeapYear =&gt; ture or false 闰年是公历中的名词。普通年:能被 4 整除但不能被 100 整除的年份为普通闰年。（如 2004 年就是闰年，1999 年不是闰年）；世纪年:能被 400 整除的为世纪闰年。（如 2000 年是闰年， 1900 年不是闰年）；四年一闰，百年不闰，四百年再闰 123456789Date.prototype.isLeapYear = function()&#123; if (this.getYear()%4==0&amp;&amp;((this.getYear()%100!=0)||(this.getYear()%400==0))) return true return false&#125;/* Date.prototype.isLeapYear = function()&#123; return (this.getYear()%4==0&amp;&amp;((this.getYear()%100!=0)||(this.getYear()%400==0))); 这段代码写得太简单了我看不懂，它也是返回 ture or false&#125; */// 这里的做法直接去修改 js 的内置/原型对象 Date 是不理智的。 1234567891011121314// 应该封装自己的类class MyDate &#123; constructor() &#123; this.data = new Date() &#125;&#125;MyDate.prototype.isLeapYear = function() &#123; let that = this.data if (that.getYear() % 4 === 0 &amp;&amp; ((that.getYear() % 100 !== 0) || (that.getYear() % 400 === 0))) return true return false&#125;var day = new MyDate()console.log(day.isLeapYear()) 123SyntaxError: redeclaration of formal parameter year#某个变量名称已经作为函数参数出现了，但是又使用了 let 在函数体里重声明了。#在 JavaScript 中不允许使用 let 在相同的函数或块范围内重新声明相同的变量。 3.2 format 日期格式化 =&gt; 星期三 2018-9-10 20:43:36 任意选择123456789101112131415161718192021222324class MyDate &#123; constructor() &#123; this.data = new Date() &#125; format(str) &#123; var Week = ['日', '一', '二', '三', '四', '五', '六'] let that = this.data str = str.replace(/YYYY/, that.getFullYear()) str = str.replace(/YY/, (that.getYear() % 100) &gt; 9 ? (that.getYear() % 100).toString() : '0' + (that.getYear() % 100)) str = str.replace(/MM/, that.getMonth() &gt; 8 ? (that.getMonth() + 1).toString() : '0' + (that.getMonth() + 1)) str = str.replace(/DD/, that.getDate() &gt; 9 ? that.getDate().toString() : '0' + that.getDate()) // /dd/DD/ 我只要大DD str = str.replace(/hh/, that.getHours() &gt; 9 ? that.getHours().toString() : '0' + that.getHours()) /// hh|HH/ 我只要小 hh str = str.replace(/mm/, that.getMinutes() &gt; 9 ? that.getMinutes().toString() : '0' + that.getMinutes()) str = str.replace(/ss/, that.getSeconds() &gt; 9 ? that.getSeconds().toString() : '0' + that.getSeconds()) // /ss|SS/ 我只要小ss str = str.replace(/w/g, '星期' + Week[that.getDay()]) /// w|W/g 我只要小w return str &#125;&#125;var myDate = new MyDate()console.log(myDate.format('w YYYY-MM-DD hh:mm:ss')) // 结果 星期三 2018-9-10 20:43:36console.log(myDate.format('w YYYY/MM/DD hh:mm:ss')) // 结果 星期三 2018/10/10 20:43:36console.log(myDate.format('mm:ss')) // 结果 43:36console.log(myDate.format('MM')) // 结果 10 */ 格式化拓展方法使用说明：大小写太混乱了，把一些代码注释了，要区分大小写。w ：代表星期几YYYY：代表年份（4位）YY：代表年份（2位）MM：代表月份DD：代表日期hh：代表小时mm：代表分钟ss：代表秒 调用方法：new MyDate().Format(‘’) 在这里传入格式化的参数，需要什么就写入对应的字符，中间希望以什么字符空格连接都行。 3.3 daysBetween 日期天数差 =&gt; 365123456789101112131415161718192021function daysBetween(DateOne, DateTwo) &#123; let OneLeftIndex = DateOne.indexOf('-') || DateOne.indexOf('/') || DateOne.indexOf('.') let OneRightIndex = DateOne.lastIndexOf('-') || DateOne.indexOf('/') || DateOne.indexOf('.') var OneMonth = DateOne.substring(OneLeftIndex+1, OneRightIndex); var OneDay = DateOne.substring(OneRightIndex+1); var OneYear = DateOne.substring(0, OneLeftIndex); let TwoLeftIndex = DateTwo.indexOf('-') || DateTwo.indexOf('/') || DateTwo.indexOf('.') let TwoRightIndex = DateTwo.lastIndexOf('-') || DateTwo.indexOf('/') || DateTwo.indexOf('.') var TwoMonth = DateTwo.substring(TwoLeftIndex+1, TwoRightIndex); var TwoDay = DateTwo.substring(TwoRightIndex+1); var TwoYear = DateTwo.substring(0, TwoLeftIndex); var cha = ((Date.parse(OneMonth + '/' + OneDay + '/' + OneYear) - Date.parse(TwoMonth + '/' + TwoDay + '/' + TwoYear)) / 86400000); return Math.abs(cha);&#125;console.log(daysBetween('2018-11-23', '2019-2-1')) //70console.log(daysBetween('2018/3/1', '2018/3/12'))//12console.log(daysBetween('2018.11.23', '2019/11/23'))//365","tags":[{"name":"cookie,session,token","slug":"cookie-session-token","permalink":"https://liuxmoo.com/tags/cookie-session-token/"}]},{"title":"JavaScript--正则表达式","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-正则表达式/","text":"一、前言正则表达式是对字符串的组合，组合一个规则字符串，这个规则字符串用来表达对字符串的一种过滤逻辑。 二、reg 正则2.1 匹配模式全局模式 g ：找出所有匹配到的值，没有 g 的话就会值匹配一个值。不区分大小写模式 i多行模式 m 2.2 规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546() # 将括号中的字符 组合成整体[] # 将括号中的字符 当做选项 例如 正则 [ba]t 可以表示 'bt' 与 'at'# 假如字符串本身就有 [] 字符，那么要用 \\ 来转义的# 字符串 [ba]t 的正则就是 \\[ba\\]t[a-z] # 表示 a-z 之间的 小写字母[A-Z] # 表示 A-Z 之间的 大写字母[0-9] # 表示 0-9 之间的 数字&#123;&#125; # 用来填写字符出现的次数&#123;n&#125;# 匹配 n 次&#123;m,n&#125;# 匹配 m-n 次\\ # 用来转义,下面就是 ① 单词的边界 # 例如 i am a girl 中找到 am 单词 # /\\bam\\b/g 不给出边界的话可能就是单词中包含的 am 也被找到了 ② 空格符 \\s # 匹配空白符（空格、制表符、tab、换行符、中文全角空格 等等） ③ 数字 \\d # 匹配数字 0~9 任意一个 0\\d&#123;2&#125;-\\d&#123;8&#125; # 可以匹配到 021-66666666 \\d&#123;3&#125;-\\d&#123;8&#125; # 可以匹配到 421-66666666 如果第一个数字没有明确的话就不是电话号码就不对了 ④ \\w # 任意一个字母 或 数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个^ # 表示字符串的开头$ # 表示字符串的结尾| # 表示或者，匹 | 的左边或者右边？ # 匹配前面括号中的表达式（0 次 或者 1 次）do(es)? # 可以匹配到 do does doeses...........* # 表示前面的字符出现任意次数（0,1,多次均可）z* # 匹配 '' 或者 z 或者 zz zzz..... + # 表示前面的字符串出现（1 次,多次）也就是必须出现一次. # 匹配 除了换行符 \\n 之外的任意字符# 如果需要匹配以 at 结尾的字符串，那么正则可以写成 .at 就是前面可以出现其他的字符# 还是那个问题，如果字符串本身是有 . 号的，那么是需要转义的，如果需要 匹配以 .at 结尾的字符串 那么就是 \\.atw # 匹配到所有包括下划线的单词字符 ??????????????这个好像没有看到啊 2.3 综合应用2.3.1 正则表达式的方法12str.replace(reg,'') //替换匹配到的字符，返回新字符串str.match(reg) //返回到匹配字符串的数组 2.3.2 去掉字符串前面与后面的空格123let str = ' 4f 'str = str.replace(/^\\s+|\\s+$/g,'')//这里原来的的 str 是不会改变的，返回值才是改变的，要记住console.log(str.length);//2 2.3.3 写一个正则，字母开头，后面可以是数字，下划线，字母，长度6-30123456//写一个正则，字母开头，后面可以是数字，下划线，字母，长度6-13var str = 's22343231'let reg = /^[A-Za-z]+\\w&#123;5,12&#125;$/ig;let arr = str.match(reg)console.log(arr);//'s22343231'//var reg=/^\\[a-zA-Z\\]\\\\w&#123;5,29&#125;$/; 这个答案给的应该是错的！！！！！！！！！！！！ 2.3.4 查找重复的单词123456var str = \"Is is the cost of of of gasoline going up up\";var patt1 = /\\b([a-z]+) \\1\\b/ig;console.log(str.match(patt1));//[ 'Is is', 'of of', 'up up' ]// \\1 是干嘛的？？？？// 不能是 2 的其他数字而且它前面必须有空格，否则得到的就是 null 了！！！ 2.3.5 匹配网址123456789101112var str = \"http://www.liuxmoo.com:80/XXX.html\";var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/;arr = str.match(patt1);// [ 'http://www.liuxmoo.com:80/XXX.html',// 'http',// 'www.liuxmoo.com',// ':80',// '/XXX.html',// index: 0,// input: 'http://www.liuxmoo.com:80/XXX.html',// groups: undefined ]// 这个是要干嘛？？？？？没有看懂？？？？ https://blog.csdn.net/u011665991/article/details/80221451 不知道对不对，后面开看看。","tags":[]},{"title":"JavaScript【2】--[递归函数的深入了解]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-递归函数/","text":"一、前言一个函数在内部调用自身本身，这个函数就是递归函数。简单的定义: “当函数直接或者间接调用自己时，则发生了递归.”递归就是把复杂的问题细化成小问题来解决。 迭代的是人，递归的是神 –––L. Peter Deutsch。学会使用递归，我们的代码编写将会大幅度的减少。 二、 递归2.1 递归与迭代（循环）假设我需要求解 1-100 之间的数相加求和。1+2+3+4+……+100 我们最先后想到的就是迭代，也就是循环求解。 12345678function sum(n) &#123; let sum = 0 for (let i = 1; i &lt;= n; i++) &#123; sum += i &#125; return sum;&#125;a=sum(100); // 5050 刚入门学习编程的话，我们很容易就会考虑使用迭代来解决的这个问题。迭代的逻辑我们也比较容易理。但是如果一旦问题复杂化，使用迭代来解决的过程很麻烦，我们需要使用很长很臃肿的一段代码才能洗完的话，这时候学会使用递归将会大大的提高我们的代码编程速度。也让代码变得更加的简洁清晰。 首先先是分析我们的需求 1+2+3+4+……+100, 它可以理解为 100+(1+2+3+4+….+99) ，后面的是 100+(99+(98+(1+2+3+4+….+97) 这样一步一步的分解下去。当然它也可以是 1+(2+(3+(4+….+100) ，这样来分解。 1234567//100+(99+(98+(1+2+3+4+....+97) 分解function sum(n)&#123; if (n==1)return 1; return n+sum(n-1);&#125;a=sum(100);console.log(a);//5050 2.2 递归的执行过程当然像是 2.1节 这样一个简单的问题我们通常不需要使用递归来求解。下面来时一段经典的递归代码—斐波那契数，一个正整数的阶乘（英语：factorial）。 123456function factorial(n)&#123; if (n == 1)return 1 return n * factorial(n - 1)&#125;console.log(factorial(5))// 输出结果 120 上面这个递归函数的执行过程。 ①factorial(5) 调用函数 ,此时传入5 n=5 ，n不等1 ，返回 n * factorial(n - 1) 得到 5*factorial(4)②5*factorial(4)调用函数 此时传入4 n=4 ，n不等1 ，执行 5*n * factorial(n - 1) 也就是 5*4*factorial(3)③5*4*factorial(3)调用函数 此时传入3 n=3 ，n不等1 ，执行 5*4*n * factorial(n - 1) 也就是 5*4*3*factorial(2)④5*4*3*factorial(2)调用函数 此时传入2 n=2 ，n不等1 ，执行 5*4*3*n * factorial(n - 1) 也就是 5*4*3*2*factorial(1)⑤5*4*3*2*factorial(1)调用函数 此时传入1 n=1 ，n等1 ，返回 1 也就是 5*4*3*2*1⑥5*4*3*2⑦5*4*6⑧5*24⑨120","tags":[{"name":"递归函数","slug":"递归函数","permalink":"https://liuxmoo.com/tags/递归函数/"}]},{"title":"JavaScript【4】--[立即执行函数 IIFE ]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-立即执行函数/","text":"一、前言在 ES6 之前，我们为了让函数立即执行，使用的是的给函数加圆括号 () 的方法。 ES6 之后才是用 let 关键字达到立即执行， let 使用网址：，这里我们就先来了解立即执行函数。 二、立即执行函数表达式（IIFE）在 Javascript 里，圆括号不能包含声明因为这点，当圆括号为了包裹函数碰上了 function 关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。 当圆括号出现在 匿名函数的末尾想要调用函数时，它会默认将函数当成是 函数声明。 当圆括号 包裹函数时，它会默认将函数作为 表达式去解析，而不是函数声明。 123456789//这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量(function () &#123; /* code */&#125;()); //Crockford recommends this one，括号内的表达式代表 函数立即调用表达式(function () &#123; /* code */&#125;)(); //But this one works just as well，括号内的表达式代表 函数表达式","tags":[{"name":"立即执行函数","slug":"立即执行函数","permalink":"https://liuxmoo.com/tags/立即执行函数/"}]},{"title":"[编写高质量 JS 代码 ]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-高质量高效率代码编辑/","text":"一、前言网址： 代码的实现有很多种方法，但是他们的事件复杂度，空间复杂度，后期维护，等等都有所不同，都是需要考虑的问题。这篇文章是为了写出高质量代码 JavaScript 代码的合集。 内容全部由编写高质量的 JavaScript 代码的最佳实践组成，从基本语法、应用架构、工具框架、编码风格、编程思想等5大方面对 Web 前端解读 惰性求值与非惰性求值非惰性求值：不需要的干不管表达式是否被利用，只要在执行代码行中都会被计算。 1234567var a = 2;function f(x)&#123;return x;&#125;alert(f(a,a=a*a)); //2 调用函数时，传入了 2 个参数，本次调用只会使用第 1 个参数， //但是第二个参数 也就是表达式参数，它是表达式也会被计算，最红得到 a=a*a=4， 下次使用这个值的话就会被改变了alert(f(a)); //4 这里再调用函数 参入的 a 就是上一次调用被计算之后的 a=4 ，结果就是 4 了 函数作为运算符参与运算，具有非惰性求值特性，非惰性求值行为自然会对整个程序产生一定的负面影响。不管我们是否需要，它都执行了。如果在一个函数参数中无意添加了几个表达式，虽然这样不会对函数的运算结果产生影响，但是由于表达式被执行，就会对整个程序产生潜在的负面影响。例如会占用系统资源。 123456function f() &#123;&#125;f(function () &#123; while (true);&#125;())//虽然函数 f 没有参数，但是在调用时将会执行传递给它的参数表达式，该表达式是一个死循环结构的函数值，最终将导致系统崩溃。？？？ 惰性求值：你要的时候它才干惰性函数模式是一种将对函数或请求的处理延迟到真正需要结果时进行的通用概念，很多应用程序都采用了这种概念。从惰性编程的角度来思考问题，可以帮助消除代码中不必要的计算。 例如，在 Scheme 语言中，delay 特殊表单接收一个代码块，它不会立即执行这个代码块，而是将代码和参数作为一个 promise（promise：承诺，约定，誓言） 存储起来。如果需要 promise 产生一个值，就会运行这段代码。promise 随后会保存结果，这样将来再请求这个值时，该值就可以立即返回，而不用再次执行代码。 这种设计模式在 JavaScript 中大有用处，尤其是在编写跨浏览器的、高效运行的库时非常有用。 12345678910var t;function f()&#123; t = t ? t : new Date(); return t;&#125;console.log(f());/* Thu Nov 01 2018 18:14:17 GMT+0800Thu Nov 01 2018 18:14:19 GMT+0800Thu Nov 01 2018 18:14:22 GMT+0800 */// 看上面，同一段代码，不同时间执行，的结果时间是不一样的，它就是做到了惰性求值，在需要它的时候它才求值。 上面的示例使用全局变量 t 来存储时间对象，这样在每次调用函数时都必须进行重新求值，代码的效率没有得到优化，同时全局变量 t 很容易被所有代码访问和操作，存在安全隐患。 问题？？？、所以是怎么做到惰性求值的？？？ 123456789//使用闭包隐藏全局变量t，只允许在函数f内访问。但是这仍然没有提高调用时的效率，因为每次调用f依然需要求值：var f = (function () &#123; var t; return function () &#123; t = t ? t : new Date(); return t; &#125;&#125;)();f(); 1234567891011var f = function () &#123; var t = new Date(); f = function () &#123; return t; &#125; return f();&#125;;f();//函数 f 的首次调用将实例化一个新的 Date 对象并重置 f 到一个新的函数上，f 在其闭包内包含 Date 对象。在首次调用结束之前，//f 的新函数值也已被调用并提供返回值。/* 函数 f 的调用都只会简单地返回 t 保留在其闭包内的值，这样执行起来非常高效。弄清这种模式的另一种途径是，外部函数 f 的首次调用是一个保证（promise），它保证了首次调用会重定义 f 为一个非常有用的函数，保证来自于 Scheme 的惰性求值机制。？？？？？？？？？？？？？？？ */","tags":[{"name":"递归函数","slug":"递归函数","permalink":"https://liuxmoo.com/tags/递归函数/"}]},{"title":"ESlint 这个大坑","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑮ -  bug 集合 -ESlint 这个大坑/","text":"一、前言eslint 安装之后，在 vscode 中需要配置，不然使用 vue 做项目就会报出各种错误。在其他的时候也会发生这样那样的错误。 二、编辑保存的错误去看 eslint 之坑这个文章， 三、在使用 ueditor 的时候报错。12345678910111213141516171819202122232425# ueditor.config.js# 在这个配置文件中会发生错误。Module Warning (from ./node_modules/@vue/cli-plugin-eslint/node_modules/eslint-loader/index.js):error: Unnecessary escape character: \\/ (no-useless-escape) at public\\ueditor\\ueditor.config.js:458:70: 456 | &#125; else if (!/^[a-z]+:/i.test(confUrl)) &#123; 457 |&gt; 458 | docUrl = docUrl.split(\"#\")[0].split(\"?\")[0].replace(/[^\\\\\\/]+$/, ''); | ^ 459 | 460 | basePath = docUrl + \"\" + confUrl; 461 |1 error found.You may use special comments to disable some warnings.# 您可以使用下面这些 特殊注释 来禁用某些警告Use // eslint-disable-next-line to ignore the next line. 【对下一行代码 禁止规则出现警告】# 使用// eslint-disable-next-line 忽略下一行。Use /* eslint-disable */ to ignore all warnings in a file. 【整个文件范围内 禁止规则出现警告】# 使用 / * eslint-disable * / 忽略文件中的所有警告。。# 就是在某个文件顶部写上 /* eslint-disable */# name整个文件将不受 eslint 的影响，eslint 就不会来检查这个文件了。 原因： 就是因为代码中有不必要的空格，或者是空行，什么的解决： 上面的 2 种是其中的某些原因的解决办法，还有很多办法，写在夏下面。适当的选择使用，有的时候有的办法是不能使用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// ② 整个文件范围内 禁止规则出现警告// Use /* eslint-disable */ to ignore all warnings in a file. 【】// 使用 / * eslint-disable * / 忽略文件中的所有警告。。// 就是在某个文件顶部写上 /* eslint-disable */ 然后整个文件就不会受到影响了/* eslint-disable */alert('foo');alert('2');alert('3');// name整个文件将不受 eslint 的影响，eslint 就不会来检查这个文件了。// ④ 在文件中临时 禁止规则出现警告// 将需要忽略的代码块用注释包裹起来 /* eslint-disable */ alert('foo'); // 这行代码是被包裹起来的，不会被 eslint 检查 /* eslint-enable */// ⑤ 对指定规则的启用或者禁用警告/* eslint-disable no-alert, no-console */alert('foo');console.log('bar');/* eslint-enable no-alert, no-console */// ⑥ 对指定行禁用规则警告// 有 2 种方式，一个当前行，一个是下一行alert('foo'); // eslint-disable-line// eslint-disable-next-linealert('foo');// ⑦ 在指定行上禁用指定的某个规则alert('foo'); // eslint-disable-line no-alert// eslint-disable-next-line no-alertalert('foo');//⑧ 在某个特定的行上禁用多个规则alert('foo'); // eslint-disable-line no-alert, quotes, semi// eslint-disable-next-line no-alert, quotes, semialert('foo');","tags":[]},{"title":"小程序 MINA 框架 中遇到的 bug","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑮ -  bug 集合 -小程序 中遇到的 bug.1/","text":"一、前言小程序 MINA 框架的问题。 二、2.1 html 中 数据绑定的问题123456789101112&lt;view class=\"product\"&gt; &lt;block wx:for=\"&#123;&#123;productsAll.products&#125;&#125;\" wx:key=\"index\"&gt; &lt;view class=\"product-img\"&gt; &lt;!-- 这里的数组不要有括号 (item.images)[0].url,写成这样就错误了 --&gt; &lt;image src=\"&#123;&#123;item.images[0].url&#125;&#125;\" style=\"width: 100px; height: 100px; background-color: #eeeeee;\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=\"product-name\"&gt; &lt;view class=\"title\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view class=\"title\"&gt;&#123;&#123;item.price&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/block&gt;&lt;/view&gt; 2.2 JS 中读取数据12345678data: &#123; productsRequest: &#123; page: 1, size: 20 &#125;&#125; this.data.productsRequest.page // 一定不要忘记 小程序中读取是 this.data.xxx，不要漏掉 data","tags":[]},{"title":"vue 中使用 Vue-Quill-Editor 富文本编辑器","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-vue 中使用 Vue-Quill-Editor 富文本编辑器/","text":"一、前言Vue-Quill-Editor 富文本编辑器的使用！！！！ 用了然后发现得到的编辑块 css 全是烂的！！！！！！！！ 二、安装引入 npm 安装 1234567$ npm install vue-quill-editor --save$ yarn add vue-quill-editor# 拓展学习# yarn 中不需要 --save# yarn 中还是需要 -dev 的，有需要的话就使用的 es6 引入(全局引用) 123456//main.js es6 引入方法import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor' // import with ES6// useVue.use(VueQuillEditor) 组件引入（按需引用） 123456789101112131415161718192021222324252627282930&lt;!-- .vue 组件使用方法 or use with component(ES6) --&gt;&lt;template&gt; &lt;!-- use with components - bidirectional data binding（双向数据绑定） --&gt; &lt;quill-editor ref=\"myTextEditor\" v-model=\"content\" :options=\"editorOption\" @blur=\"onEditorBlur($event)\" @focus=\"onEditorFocus($event)\" @ready=\"onEditorReady($event)\"&gt; &lt;/quill-editor&gt; &lt;!-- If you need to manually control the data synchronization, you can monitor the code change event like this（如果你需要手动控制数据流，就需要像这样手动监听 changed 事件） --&gt; &lt;quill-editor ref=\"myTextEditor\" :content=\"content\" :options=\"editorOption\" @change=\"onEditorChange($event)\"&gt; &lt;/quill-editor&gt;&lt;/template&gt;&lt;script&gt;import &#123; quillEditor &#125; from 'vue-quill-editor'export default &#123; components: &#123; quillEditor &#125;&#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940// editor option example:export default &#123; data () &#123; return &#123; content: '&lt;h2&gt;I am Example&lt;/h2&gt;', editorOption: &#123; // something config &#125; &#125; &#125;, // if you need to manually control the data synchronization, parent component needs to explicitly emit an event instead of relying on implicit binding // 如果需要手动控制数据同步，父组件需要显式地处理changed事件 methods: &#123; onEditorBlur(editor) &#123; console.log('editor blur!', editor) &#125;, onEditorFocus(editor) &#123; console.log('editor focus!', editor) &#125;, onEditorReady(editor) &#123; console.log('editor ready!', editor) &#125;, onEditorChange(&#123; editor, html, text &#125;) &#123; // console.log('editor change!', editor, html, text) this.content = html &#125; &#125;, // if you need to get the current editor object, you can find the editor object like this, the $ref object is a ref attribute corresponding to the dom redefined // 如果你需要得到当前的editor对象来做一些事情，你可以像下面这样定义一个方法属性来获取当前的editor对象，实际上这里的$refs对应的是当前组件内所有关联了ref属性的组件元素对象 computed: &#123; editor() &#123; return this.$refs.myTextEditor.quillEditor &#125; &#125;, mounted() &#123; // you can use current editor object to do something(editor methods) console.log('this is my editor', this.editor) // this.editor to do something... &#125;&#125;","tags":[]},{"title":"this.$nextTick() 使用","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-this.$nextTick() 使用/","text":"一、前言this.$nextTick() 使用得到，可以很好。 二、什么时候用 this.$nextTick()12345678910created() &#123; //在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。 this.$nextTick(() =&gt; &#123; console.log(this.$refs.message.innerHTML, \"this.$refs.message.innerHTML\"); console.log( this.$refs.message_value.value, \"this.$refs.message_value.value\" ); &#125;);&#125; 在其他的函数里面，遇到需要渲染后再执行的代码块，就要是到到的。 2.1 将一个 A元素下的内容 copy 给另外一个 B元素这个情况，我们必须是要让 A 渲染完成才会获取到它的 innerHTML 的。没有渲染完成，那么 DOM 中就没有我们需要获取的内容。 123456789101112131415&lt;!-- 注意到我们使用了 ref 这个特殊的特性在 vue 中我们一般是用来在父组件标记子组件标签的，但是也可以用在原生的 html 标签中，以便我们的使用，下面就是它的一个使用情景 --&gt;&lt;p ref=\"message\"&gt;1111111&lt;/p&gt;&lt;div ref=\"tt\"&gt;&lt;/div&gt;&lt;script&gt; created() &#123; //在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。 this.$nextTick(() =&gt; &#123; this.$refs.tt.innerHTML = this.$refs.message.innerHTML // 注意到这个是 this.$refs.xxx 是 refs ，要加上 s ，html 中设置的时候是 ref ！！！！！！！！！！！！！！！！！！！ &#125;); &#125;&lt;/script&gt; 三、ref ref 可以有下划线，但是不能有中线。并且注意， ref 是在 mounted 才会存在，才可以读取到的 1234567&lt;input v-model.lazy=\"message\" v-model.trim=\"message\" placeholder=\"edit me\" ref=\"message_value\"&gt;&lt;p ref=\"message\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;script&gt;console.log(this.$refs.message.innerHTML);//获取标签内的内容console.log(this.$refs.message_value.value);//获取输入框的值&lt;/script&gt; 3.1 JS 原生的获取元素3.1.1 document.getElementByXXX12345678910111213141516171819document.getElementById(id) //方法：通过 id 取得 HTML元素。 //可返回对拥有指定 ID 的第一个对象的引用。document.getElementById(id).innerHTML // 返回该 html 下的 html 代码document.getElementsByName() //方法：通过 name 取得元素，是一个数组。//因为一个文档中的 name 属性可能不唯一（如 HTML 表单中的单选按钮通常具有相同的 name 属性），//所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。// 获得 form 中第一个 name 为 “inputText” 的元素值// var myParagragh = document.getElementsByName(\"inputText\")[0].value;document.getElementsByTagName() //方法：通过 HTML 标签取得元素，是一个数组。// var myParagragh = document.getElementsByTagName(\"p\")[1].value; 获得文档中的第二个段落的值：document.getElementsByClassName(classname)document.getElementsByClassName(\"example color\")[0].innerHTML//获取元素的值document.getElementById(\"id\").value; 1234567891011121314151617&lt;div class=\"example\"&gt; &lt;p&gt;P 元素在在第一个样式为 class=\"example\" 的 Div 元素中。Div 的索引值为 0。&lt;/p&gt;&lt;/div&gt;&lt;div class=\"example color\"&gt; &lt;p&gt;P 元素在在第一个样式为 class=\"example color\" 的 Div 元素中。Div 的索引值为 0。&lt;/p&gt;&lt;/div&gt;&lt;div class=\"example color\"&gt; &lt;p&gt;P 元素在在第一个样式为 class=\"example color\" 的 Div 元素中。Div 的索引值为 0。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;点击按钮修改第一个类为 \"example\" 的 div 元素的背景颜色。&lt;/p&gt;&lt;script&gt; function myFunction() &#123; var x = document.getElementsByClassName(\"example color\"); x[0].style.backgroundColor = \"red\"; &#125;&lt;/script&gt; 123456789101112131415161718&lt;form id=\"form1\" action=\"#\"&gt; &lt;a href=\"http://www.baidu.com/\" &gt;百度&lt;/a&gt;&lt;/br&gt; &lt;a href=\"http://www.google.cn/\" &gt;谷歌&lt;/a&gt;&lt;/br&gt; &lt;a href=\"http://www.gougou.com/\" &gt;狗狗&lt;/a&gt;&lt;/br&gt;&lt;/form&gt;&lt;script&gt; &lt;!--getElementsByTags--&gt; debugger; var hrefs = document.getElementsByTagName(\"A\"); for (var i=0; i &lt; hrefs.length; i++) &#123; var aHref = hrefs[i]; // var aHref = hrefs.item(i); if (aHref.innerHTML == \"百度\") &#123; alert(aHref.href); break; &#125; &#125;&lt;/script&gt; 3.1.2 document.querySelector(CSS selectors)匹配指定 CSS 选择器的第一个元素。如果没有找到，返回 null。如果指定了非法选择器则 抛出 SYNTAX_ERR 异常。 12345678910111213141516171819202122232425//querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。document.querySelector(\"#demo\");//指定一个或多个匹配元素的 CSS 选择器。 可以使用它们的 id, 类, 类型, 属性, 属性值等来选取元素。document.querySelector(\"p\");//获取文档中第一个 &lt;p&gt; 元素：document.querySelectorAll(\"p\");//获取文档中所有的 &lt;p&gt; 元素：document.querySelector(\".example\");//获取文档中 class=\"example\" 的第一个元素:document.querySelector(\"p.example\");//获取文档中 class=\"example\" 的第一个 &lt;p&gt; 元素:&lt;h3&gt; h3 元素&lt;/h3&gt;&lt;h2&gt; h2 元素&lt;/h2&gt;document.querySelector(\"h2, h3\").style.backgroundColor = \"red\";//只会将 h3 那段代码渲染为红色背景// 因为它是获取第一个 h2 或者是 h3, 先遇到 h3 那么就是它了，不会再找别人了&lt;h2&gt; h2 元素&lt;/h2&gt;&lt;h3&gt; h3 元素&lt;/h3&gt;document.querySelector(\"h2, h3\").style.backgroundColor = \"red\";//只会将 h2 那段代码渲染为红色背景// 因为它是获取第一个 h2 或者是 h3，先遇到 h2 那么就是它了，不会再找别人了document.querySelector(\"div span\") // 找到第一个 div 下的 span ！！！！！！！！！！！！！！！！！！！！！！！！！document.querySelector('.ivu-menu-item .ivu-menu-item-active ivu-menu-item-selected')var matches = document.querySelectorAll(\"div.note, div.alert\");//下面的例子返回一个文档中所有的 class 为 \"note\" 或者 \"alert\" 的 div 元素.// 会把所有符合要求的都找上","tags":[]},{"title":"axios 小白入门篇、速学篇","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-axios 前后端数据交换/","text":"一、前言一、 axios 简介Vue 原本有一个官方推荐的 ajax 插件 vue-resource，但是自从 Vue 更新到 2.0 之后，官方就不再更新 vue-resource，不再维护了，后面更新版本的 vue.js 框架项目都是使用 axios 来做请求后端操作。 axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换 JSON 数据 客户端支持防止 CSRF/XSRF 网站学习 三、 axios 发送请求（执行单个请求）3.1 执行 GET 请求 （几种方法）3.1.1 改造 url 传参（不建议这样传参）（别名方法）语法：axios.get(&#39;/user?ID=12345&#39;) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 method 提到外面跟在 axios 后面用 点 操作了 url 在 （） 中 作为第一个参数 data 作为第二个参数 其他的配置项还是写在 {} 配置对象中 123456789//向具有指定 ID 的用户发出请求// 方法 ① 为给定 ID 的 user 创建请求axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 3.1.2 使用 params 对象传参（这样来使用传参比较好）（别名方法）上面的是将需要传递的参数 用 ？ 与 = 号放到 url 中，下面这种方法看起来比较好，需要传递的参数一眼就可以看出来，如果需要传递的的参数多了也好写，用下面这种办法比较好吧。具体看自己习惯怎么用了 语法： axios.get(‘url’,{ params:{}, orthers:{} }) 在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 method 提到外面跟在 axios 后面用 点 操作了 url 在 （） 中 作为第一个参数 data 作为第二个参数 其他的配置项还是写在 {} 配置对象中 123456789101112// 方法 ② ：通过 params 对象传递参数axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 3.1.3 可以通过向 axios 传递相关配置来创建请求 传参（配置请求，是最原始的方法吧？）语法：axios({}) 12 // 发送 GET 请求（默认的方法）axios('/user/12345'); 3.2 POST 请求3.2.1 改造 url 的方法（不推荐用这里不写了）3.2.2 使用 params 对象（别名方法）在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 method 提到外面跟在 axios 后面用 点 操作了 url 在 （） 中 作为第一个参数 data 作为第二个参数 其他的配置项还是写在 {} 配置对象中 1234567891011// 别名方法axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone'&#125;).then(function (response) &#123;console.log(response);&#125;).catch(function (error) &#123;console.log(error);&#125;); 3.2.3 请求配置方法：axios API 使用配置方法请求后端（配置请求方法）123456789// 发送 POST 请求axios(&#123; method: 'post', url: '/user/12345', data: &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;&#125;); 3.3 PUT DELETE 方法都是一样的道理3.3.1 别名方法在使用别名方法时， url、method、data 这些属性都不必在配置中指定。 method 提到外面跟在 axios 后面用 点 操作了 url 在 （） 中 作为第一个参数 data 作为第二个参数 其他的配置项还是写在 {} 配置对象中 1234567axios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]]) 3.3.2 配置请求方法1axios(&#123;config&#125;)// 所有的方法都是写在配置里面 ，详见 [第四章]!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 四、请求配置 axios({config})4.1 单个请求配置其实请求配置的方法，其实就是 将第 2 种 params 方法中，将 url 也放到 对象中咯。!!!!!!!!!!!!!!!!!!!!!!!!!! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 这里是创建请求时可以用的配置选项。// 也就是 &#123;config&#125; 的内容!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!//只有 url 是必需的。如果没有指定 method 请求方法，请求将默认使用 get 方法。// 示例axios(&#123; url: '/user', // ①请求后端服务器接口地址 必填 ，除了这个是必填的，其他的 项 都是非必填的 method: 'get', // ②创建请求时使用的方法 否 默认是 get baseURL: 'https://some-domain.com/api/',// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL transformRequest: [function (data) &#123; return data; // 对 data 进行任意转换处理 返回所需 //③ `transformRequest` 允许在向服务器发送前，修改请求数据，且只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 数组中的函数必须返回 一个字符串，或 ArrayBuffer，或 Stream &#125;], transformResponse: [function (data) &#123; return data;// 对 data 进行任意转换处理 //④`transformResponse` 在传递给 then/catch 前，允许修改响应数据 &#125;], // headers 是重点 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //headers 包含的所有字段可以去看 http 文章 headers: &#123;// ⑥`headers` 是即将被发送的自定义请求头,可以设置在默认里面 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json',//默认值为 'application/json' 可以不用设置 //const token = localStorage.getItem('token');// 在 axios(&#123;&#125;) 前面要获取 token 赋值 'Authorization' = `$&#123;token&#125;` &#125;, params: &#123; ID: 12345 //⑦ `params` 是即将与请求一起发送的 URL 参数，必须是一个无格式对象(plain object)或 URLSearchParams 对象 &#125;, paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: 'brackets'&#125;) //⑧ `paramsSerializer` 是一个负责 `params` 序列化的函数 //(e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) &#125;, data: &#123; firstName: 'Fred' //⑨ `data` 是作为请求主体被发送的数据，只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' //在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream &#125;, timeout: 1000,// `timeout` 指定请求超时的毫秒数(0 表示无超时时间)，如果请求花费了超过 `timeout` 的时间，请求将被中断 withCredentials: false, // 默认的 `withCredentials` 表示跨域请求时是否需要使用凭证 adapter: function (config) &#123; //`adapter` 允许自定义处理请求，以使测试更轻松, //返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). &#125;, auth: &#123; username: 'janedoe',// `auth` 表示应该使用 HTTP 基础验证，并提供凭据 password: 's00pers3cret'// 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 &#125;, responseType: 'json', // 默认的类型为 'json' // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' xsrfCookieName: 'XSRF-TOKEN', // default， `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称,默认值 'X-XSRF-TOKEN' onUploadProgress: function (progressEvent) &#123; // 对原生进度事件的处理，// `onUploadProgress` 允许为上传处理进度事件 &#125;, onDownloadProgress: function (progressEvent) &#123; // 对原生进度事件的处理， `onDownloadProgress` 允许为下载处理进度事件 &#125;, maxContentLength: 2000,// `maxContentLength` 定义允许的响应内容的最大尺寸 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的值 // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。 //如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; //否则，promise 将被 rejecte &#125;, maxRedirects: 5, // 默认为 5 ， `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 //如果设置为0，将不会 follow 任何重定向 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),// `keepAlive` 默认没有启用 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项 proxy: &#123; host: '127.0.0.1', port: 9000, auth: : &#123; username: 'mikeymike', password: 'rapunz3l' &#125; // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 &#125;, cancelToken: new CancelToken(function (cancel) &#123; // `cancelToken` 指定用于取消请求的 cancel token，（查看后面的 Cancellation 这节了解更多） &#125;)&#125;) 4.2 全局配置/ defaults 默认值很多请求的配置可能存在相同的字段，特别是 url 如果我们每个请求都写长长的一段，麻烦也不好看。默认值配置（或者说是全局配置）可以让我们减少这些不必要的麻烦。 4.2.1 全局的 axios 默认值1234//main.js 或者在 interceptor/index.js 中设置axios.defaults.baseURL = 'https://api.example.com';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;// 在 main.js 或者在拦截器 interceptor 中做处理axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 4.2.2 自定义实例默认值1234567// 创建实例时设置配置的默认值var instance = axios.create(&#123; baseURL: 'https://api.example.com'&#125;);// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 4.2.3 配置的优先顺序配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get('/longRequest', &#123; timeout: 5000&#125;); 五、axios 发送请求（执行多个并发请求）?????????????????????????处理并发请求的助手函数 axios.all(iterable) axios.spread(callback) 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 六、响应结构 &amp;&amp; 拦截器（后端服务器返回的结果）6.1 相应结构1234567&#123; data: &#123;&#125;,// `data` 由服务器提供的响应 status: 200,// `status` 来自服务器响应的 HTTP 状态码 statusText: 'OK',// `statusText` 来自服务器响应的 HTTP 状态信息 headers: &#123;&#125;,// `headers` 服务器响应的头 config: &#123;&#125; // `config` 是为请求提供的配置信息&#125; 6.2 then，catch 处理响应123456789101112131415161718192021222324252627axios.get('/user/12345') .then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;) .catch(function (error) &#123; if (error.response) &#123; // 请求已发出，但服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); /* 可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get('/user/12345', &#123; validateStatus: function (status) &#123; return status &lt; 500; // 状态码在大于或等于500时才会 reject //返回 true 的时候 resolve ，false 的时候reject &#125; &#125;) */ console.log(error.response.headers); &#125; else &#123; // Something happened in setting up the request that triggered an Error console.log('Error', error.message); &#125; console.log(error.config); &#125;); 6.3 拦截器 在请求或响应被 then 或 catch 处理前拦截它们（在 then，catch 之前发生）6.3.1 添加拦截器这个链接可以学习一下：地址,不一定好，但是可以学习到一点东西 1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 123456789101112131415161718192021222324252627282930313233//bigdata 项目中的设置// interceptor.js 文件import axios from 'axios'import Router from 'router'// 请求拦截：判断 token 是否即将过期，然后请求刷新 tokenaxios.interceptors.request.use((config) =&gt; &#123; // 发送请求之前给 token 再其他的请求中就不需要给 token 了 const token = localStorage.getItem('token'); // 发送请求之前给 token 再其他的请求中就不需要给 token 了 if (token) &#123; config.headers.Authorization = `Code $&#123;token&#125;`; &#125; return config;&#125;, (error) =&gt; &#123; console.error('request interceptor: ', error) return Promise.reject(error)&#125;)// 响应拦截，对过期的 token 拦截axios.interceptors.response.use((res) =&gt; &#123; return res;&#125;, (error) =&gt; &#123; console.error('response interceptor: ', error) let status = error.response.status if (status) &#123; switch (status) &#123; case 401: Router.replace('/login');// token 失效了，跳转登录页面重新登录，过期重新登录 &#125; &#125; return Promise.reject(error);&#125;) 6.3.2 移除拦截器12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 6.3.3 为自定义 axios 实例添加拦截器12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 6.3.4 刷新 token，判断 token 是否过期，刷新 token 如何判断 token 是否过期 逻辑是后端做的啦，给前端一个判断 token ，前端将 token 传给后端，后端判断 token 是否过期。返回状态码，让前端调用获取状态码来得知是否过期。如果过期了就要重新登录，没有过期（但是后端都对 token 的时间是有限制的）就要用旧的 token 换换取新的 token。 刷新 token 为什么需要刷新 token? 因为出于安全性的考虑,一般是一天或几个小时更新 token，看项目需要。比如说，一个网站的后端 token 的有效时间是 1 个小时，用户使用的时间是几个小时， 都有在用的，就要开发人员去换取新的 token，总不能让用户一个小时就去登录一次，这样用户体验很不好。（开发者通过代码刷新 token） 实现方法一：在发送任何一次请求时，如果需要更新 token,响应体中后端的同学给我返回了 token 这个字段，token 出现在了响应体中，说明这时候是需要刷新 token 的（其他非刷新 token 的请求时是没有 token 字段的），这时用 localStorage 保存最新 token，自动覆盖掉原来旧的 token，这样下次再调用新接口时用的就是最新的 token 了，这样用户也感知不到 token 更新的过程。 七、axios 实例7.1 axios.create([config]) 创建实例可以使用自定义配置新建一个 axios 实例：axios.create([config]) 12345var instance = axios.create(&#123; baseURL: 'https://some-domain.com/api/', timeout: 1000, headers: &#123;'X-Custom-Header': 'foobar'&#125;&#125;); 7.2 实例方法12345678//以下是可用的实例方法。指定的配置将与实例的配置合并axios#request(config)axios#get(url[, config])axios#delete(url[, config])axios#head(url[, config])axios#post(url[, data[, config]])axios#put(url[, data[, config]])axios#patch(url[, data[, config]]) 八、取消请求使用 cancel token 取消请求 Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。 8.1 可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：123456789101112131415var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user/12345', &#123; cancelToken: source.token&#125;).catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log('Request canceled', thrown.message); &#125; else &#123; // 处理错误 &#125;&#125;);// 取消请求（message 参数是可选的）source.cancel('Operation canceled by the user.'); 8.2 通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：123456789101112var CancelToken = axios.CancelToken;var cancel;axios.get('/user/12345', &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;);// 取消请求cancel(); 8.3 可以使用同一个 cancel token 取消多个请求九、TypeScript 中使用 axios12import axios from 'axios';axios.get('/user?ID=12345'); 十、在 vue 中使用 axios!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!安装其他插件的时候， npm 之后，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入，那就是下面说的 修改原型链的方法，或者是大型项目中使用 vuex 封装 action 的办法。 12345Vue.use(iView)Vue.use(APlayer, &#123; defaultCover: 'https://github.com/u3u.png',//这里是默认图片设置 productionTip: true,&#125;); 10.1 axios 安装/引入123456$ npm install axios # npm 方法，推荐使用这个方法$ cnpm install axios # cnpm 方法: taobao 源 (貌似 cnpm 不稳定老是出错？)$ bower install axios # bower 方法&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; # cdn 方法 这个方法可以确认版本# 以上四种方法 四选一 10.1.1 修改原型链引入法（在 main.js 文件引入）main.js 导入 axios 12345//main.jsimport axios from 'axios' // 全局引入 axiosVue.prototype.axios = axios // 修改 vue 的原型链？？？？？需要这样么// 在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 axios 命令// Vue.prototype.$ajax = axios 使用的就是 $ajax 命令了，还是使用上面的 axios 好（这里只是为了说明学习一下） 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 在 pages.vue 中使用 axios methods: &#123; //获取每日推荐歌单,函数名不要与 data 中的数据名称重名 getRecommendEverday() &#123; let vm = this;//将 this 保存下来，避免作用域的改变 this 的值，当然用 that 保存也 ok 啦。 axios.get(`/recommend/resource`, &#123; withCredentials: true, params: &#123; ID: 12345 &#125; &#125;) .then(function(res) &#123; vm.recommendEverdays = res.data.recommend; &#125;) .catch(function(err) &#123; console.log(err); &#125;); &#125;, //获取推荐歌单，函数名不要与 data 中的数据名称重名 getRecommend() &#123; let vm = this; axios.get(`/personalized`, &#123; withCredentials: true &#125;) .then(function(response) &#123; vm.recommends = response.data.result; &#125;) .catch(function(error) &#123; console.log(error); &#125;); &#125;, // 写成箭头函数，就不需要中间变量 vm 来保存实例了， getRecommend() &#123; axios.get(`/personalized`, &#123; withCredentials: true &#125;) .then((response)=&gt;&#123; this.recommends = response.data.result; &#125;) .catch((error)=&gt; &#123; console.log(error); &#125;); &#125; &#125; then 与 catch 这两个回调函数中都有各自独立的作用域（函数作用域），如果直接在里面访问 this，无法访问到 Vue 实例，3 种弄办法解决问题。 方法 ① 就是上面的例子，先将 vue 实例 用 vm 变量保存，这样在 then，catch 中就可以通过访问 vm 得到 vue 实例 this了。 方法 ② 这时只要添加一个 .bind(this) 就能解决这个问题.then(function(res){ console.log(this.data) }.bind(this)) .catch(function(error) { console.log(error); }.bind(this)); 方法 ③ 用箭头函数咯，不要使用 function 函数。这样就可以在箭头函数中使用 this ，它依然指向 vue 实例。function 函数存在 函数作用域，this 表示的是 function 函数坏境，不再是 vue 实例。 而箭头函数中是存在 词法作用域，箭头函数会 继承 外层函数调用的 this。 箭头函数中的 this 因为绑定了词法作用域，所以始终指向自身外的第一个 this（由于自身没有声明 this，所以会去作用域链上找 this ），也就是始终等于调用它的函数的 this（以为这个 this 离它最近） [ES6 箭头函数的 this](http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0) （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 这可能也是在 vue 的声明周期 还有其他选项不能使用 箭头函数？ 10.1.2 vuex 封装 aciton 引入法（大型项目使用 vuex）目前主流的 Vue 项目，都选择 axios 来完成 ajax 请求，而大型项目都会使用 Vuex 来管理数据，这章将结合两者来发送请求。如果是大型项目才会使用到 vuex ，一般的项目就要给自己添加麻烦了。 Vuex 的 mutations，从结果上看，mutations:类似于事件，用于提交 Vuex 中的状态 stateaction: 和 mutations 也很类似，主要的区别在于，action 可以包含异步操作，而且可以通过 action 来提交 mutations 另外还有一个重要的区别：mutations:有一个固有参数 state，接收的是 Vuex 中的 state 对象action :也有一个固有参数 context，但是 context 是 state 的父级，包含 state、getters 12345678910111213141516171819202122232425262728293031323334// store.js//Vuex 的仓库是 store.js，将 axios 引入，并在 action 添加新的方法import Vue from 'Vue'import Vuex from 'vuex'// 引入 axiosimport axios from 'axios'Vue.use(Vuex)const store = new Vuex.Store(&#123; // 定义状态 state: &#123; test01: &#123; name: 'Wise Wrong' &#125;, test02: &#123; tell: '12312345678' &#125; &#125;, actions: &#123; // 封装一个 ajax 方法 saveForm (context) &#123; axios(&#123; // 这里使用的是配置的方法 创建请求 method: 'post', url: '/user', data: context.state.test02 &#125;) &#125; &#125;&#125;)export default store 1234567// pages.vue 组件调用methods: &#123; submitForm () &#123; this.$store.dispatch('saveForm') &#125;&#125;//submitForm 是绑定在组件上的一个方法，将触发 saveForm，从而通过 axios 向服务器发送请求 注意：即使已经在 main.js 中引入了 axios，并改写了原型链，也无法在 store.js 中直接使用 axios 命令.换言之，这两种方案是相互独立的 10.2 上传请求例子？？？？？？具体是要怎么做的1234567891011121314151617181920212223242526272829303132333435&lt;!-- iview-ui : Upload 组件--&gt;&lt;template&gt; &lt;div&gt; &lt;Upload :before-upload=\"handleUpload\" action=\"//jsonplaceholder.typicode.com/posts/\"&gt; &lt;Button icon=\"ios-cloud-upload-outline\"&gt;Select the file to upload&lt;/Button&gt; &lt;/Upload&gt; &lt;div v-if=\"file !== null\"&gt;Upload file: &#123;&#123; file.name &#125;&#125; &lt;Button type=\"text\" @click=\"upload\" :loading=\"loadingStatus\"&gt;&#123;&#123; loadingStatus ? 'Uploading' : 'Click to upload' &#125;&#125;&lt;/Button&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; file: null, loadingStatus: false &#125; &#125;, methods: &#123; handleUpload (file) &#123; this.file = file; return false; &#125;, upload () &#123; this.loadingStatus = true; setTimeout(() =&gt; &#123; this.file = null; this.loadingStatus = false; this.$Message.success('Success') &#125;, 1500); &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!-- iview-ui : Upload 组件--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;Upload :before-upload=\"handleUpload\" action=\"\"&gt; &lt;Button icon=\"ios-cloud-upload-outline\"&gt;请上传实例程序&lt;/Button&gt; &lt;/Upload&gt; &lt;div v-if=\"file!==null\"&gt;实例名称：&#123;&#123;file.name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;Modal v-model=\"model2\" title=\"请填写以下字段以增加实例\" mask class-name=\"vertical-center-modal\"&gt; &lt;Form ref=\"formValidate2\" :model=\"formValidate2\" :rules=\"ruleValidate2\" :label-width=\"80\"&gt; &lt;FormItem label=\"实例名称\" prop=\"name\"&gt; &lt;Upload :before-upload=\"handleUpload\" action=\"\"&gt; &lt;Button icon=\"ios-cloud-upload-outline\"&gt;请上传实例程序&lt;/Button&gt; &lt;/Upload&gt; &lt;div v-if=\"file!==null\"&gt;实例名称：&#123;&#123;file.name&#125;&#125;&lt;/div&gt; &lt;/FormItem&gt; &lt;FormItem label=\"类型\" prop=\"type\"&gt; &lt;Select v-model=\"formValidate2.type\" style=\"width:100%\" placeholder=\"请选择类型\"&gt; &lt;Option v-for=\"item in type\" :value=\"item.value\" :key=\"item.value\"&gt;&#123;&#123; item.label &#125;&#125;&lt;/Option&gt; &lt;/Select&gt; &lt;/FormItem&gt; &lt;/Form&gt; &lt;div slot=\"footer\"&gt; &lt;Button @click.native=\"cancel2\"&gt;取消&lt;/Button&gt; &lt;Button type=\"primary\" @click.native=\"ok2('formValidate2')\" :loading=\"loading\"&gt;确定&lt;/Button&gt; &lt;/div&gt; &lt;/Modal&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; file: null, loadingStatus = false &#125; &#125;, methods: &#123; handleUpload(file) &#123; this.file = file return false &#125;, ok2(name) &#123; this.loading = true this.$refs[name].validate((valid) =&gt; &#123; if (valid) &#123; let formData = new FormData(); formData.append('exec', this.file); formData.append('type', this.formValidate2.type); axios(&#123; url: 'http://hete-api.gofoer.com/v1/exec',// 上传的地址 method: 'post', headers: &#123;'content-type': 'multipart/form-data'&#125;, data: formData &#125;).then((res) =&gt; &#123; console.log(res.data) if (res.data.code === 200) &#123; this.$Message.success('添加成功！'); this.loading = false &#125; else &#123; this.$Message.error(res.data.message); this.loading = false &#125; &#125;).catch((err) =&gt; &#123; this.$Message.error(err.data.message); this.loading = false &#125;) this.model2 = false &#125; else &#123; this.$Message.info('请填写完整！'); this.loading = false &#125; &#125;) &#125;, upload () &#123; this.loadingStatus = true; setTimeout(() =&gt; &#123; this.file = null; this.loadingStatus = false; this.$Message.success('Success') &#125;, 1500); &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- iview ：Button 自定义上传 --&gt;&lt;template&gt; &lt;Button type=\"info\" icon=\"md-cloud-upload\" @click=\"handleUpload\" size=\"large\"&gt; 上传 &lt;input type=\"file\" ref=\"btnFile\" style=\"display:none\" @change=\"handleUpload\"&gt; &lt;/Button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; // 上传文件，触发事件， event handleUpload(event) &#123; if (!event.isTrusted) &#123; return; &#125; if (event.type === \"change\") &#123; //选择了文件 if (event.target.files.length !== 1) &#123;// 这里的条件是明确表示一次只能上传一个文件。 this.$Message.warning('只能选择一个文件'); return &#125; store.dispatch('CHANGE_SHOW_LOADING', true);// 上传的转圈，可以自己用其他好理解的方式写 // 下面是上传请求 axios(&#123; url: apiRoot + '/form?type=file', method:'post', contentType: 'multipart/form-data', data: &#123; file: event.target.files[0]// 事件 event event.target 下有一个 files 数组，可以获取相应的文件。 &#125; &#125;).then(() =&gt; &#123; this.$Message.success('上传成功！'); &#125;).catch((error)=&gt;&#123; this.$Message.error(`上传失败！$&#123;error.response.data.message&#125;`); &#125;).finally(()=&gt;&#123; store.dispatch('CHANGE_SHOW_LOADING', false);// 上传的转圈，可以自己用其他好理解的方式写 &#125;); this.uploadFilesOffline(event.target.files.name) &#125; else &#123; //点击了上传 let target = this.$refs.btnFile;// 获取输入框 DOM 节点 赋值给 target target.files = null;// 文件指空 target.value = null;// 值 指空 target.click();// 这里是干嘛的？？？？ target = null; //指空，防止BOM内存泄露 &#125; 10.5 上传图片，并且展示出来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;template&gt; &lt;div class=\"demo-upload-list\" v-for=\"item in uploadList\"&gt; &lt;template v-if=\"item.status === 'finished'\"&gt; &lt;img :src=\"item.url\"&gt; &lt;div class=\"demo-upload-list-cover\"&gt; &lt;Icon type=\"ios-eye-outline\" @click.native=\"handleView(item.url)\"&gt;&lt;/Icon&gt; &lt;Icon type=\"ios-trash-outline\" @click.native=\"handleRemove(item)\"&gt;&lt;/Icon&gt; &lt;/div&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;Progress v-if=\"item.showProgress\" :percent=\"item.percentage\" hide-info&gt;&lt;/Progress&gt; &lt;/template&gt; &lt;/div&gt; &lt;Upload ref=\"upload\" :show-upload-list=\"false\" :default-file-list=\"defaultList\" :format=\"['jpg','jpeg','png']\" :max-size=\"2048\" :on-format-error=\"handleFormatError\" :on-exceeded-size=\"handleMaxSize\" :before-upload=\"handleBeforeUpload\" multiple type=\"drag\" :action=\"uploadConfig.url\" :headers=\"uploadConfig.headers\" :on-success=\"handleSuccess\" style=\"display: inline-block;width:58px;\"&gt; &lt;div style=\"width: 58px;height:58px;line-height: 58px;\"&gt; &lt;Icon type=\"ios-camera\" size=\"20\"&gt;&lt;/Icon&gt; &lt;/div&gt; &lt;/Upload&gt; &lt;Modal title=\"查看大图\" v-model=\"modalViewBigImg.visible\"&gt; &lt;img :src=\"modalViewBigImg.bigUrl\" v-if=\"visible\" style=\"width: 100%\"&gt; &lt;/Modal&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; // 上传图片请求接口配置数据 uploadConfig: &#123; url: \"//api.talcoding.com/v1/images\", headers: &#123; Authorization: localStorage.getItem(\"token\") &#125; &#125;, // 这个是上传的图片的列表，格式的 iview 规定的，可以增加属性但是，但是没有必要去改这个 // name 属性的名就是 name ，不能改成 fileName 或者其他的 defaultList: [ //defaultList:[&#123; // name:'', // url:'' //&#125;] ], // 查看大图数据 modalViewBigImg:&#123; visible: false, bigUrl:'' &#125; // 展示图片列表的数据，里面的属性有 defaultList 里面是没有的 status，showProgress 都是辅助展示用的，根据自己需求 uploadList: [] // 如果这里是添加产品，获取是其他东西的页面，图片作为其中一个属性，要新增一个 data 对象方式新的数据，用于提交后端啦。 // 例如 addproductFormData:&#123;&#125; &#125; &#125;, mounted () &#123; this.uploadList = this.$refs.upload.fileList;//展示用的图片赋值，为什么要在这里赋值呀？？？？？？？？？？？？？？？？ &#125; methods: &#123; // 选择的图片后缀，格式不正确 handleFormatError (file) &#123; this.$Notice.warning(&#123; title: '文件格式不正确', desc: '文件 ' + file.name + ' 格式不正确，请上传 jpg 或 png 格式的图片。' &#125;); &#125;, // 选择的文件大小限制 handleMaxSize (file) &#123; this.$Notice.warning(&#123; title: '超出文件大小限制', desc: '文件 ' + file.name + ' 太大，不能超过 2M。' &#125;); &#125; // 上传之前的钩子 handleBeforeUpload () &#123; const check = this.uploadList.length &lt; 5; if (!check) &#123; this.$Notice.warning(&#123; title: '最多只能上传 5 张图片。' &#125;); &#125; return check; &#125;, // 上传成功,就是上传到服务器，后端了 handleSuccess (res, file) &#123; // console.log(res, \"RES\"); 后端返回的上传的图片数据 // console.log(file, \"file\"); 而 file 是 1 个文件信息列表 file(上传文件) // console.log(fileList, \"fileList\"); 最后 fileList 是上传的文件信息列表 fileList(上传文件 List) // res 就是后端返回的数据，数据格式，属性什么的都是后端规定的，前端要根据业务要求去修改数据， var f1 = &#123; name: res.fileName,//假设后端返回的数据是 fileName 的属性吧，就要这样来自己创建一个 f1 对象 url: res.url, &#125;; this.defaultList.push(f1);// 这个需要提供么，数据应该是用来列出上传的文件列表用的，与 :show-upload-list=\"false\" 这个搭配使用的吧？ //this.addproductFormData.images.push(res.id); 假设我们后端使用的数据创建产品，还要在这里赋值数据，根据前后端的数据啦 &#125;, // 查看大图 handleView (url) &#123; this.modalViewBigImg.bigUrl = url this.visible = true; &#125;, // 移除展示的图片，注意这个不是删除后端服务器的照片，只是删除这里的图片 handleRemove (file) &#123; const fileList = this.$refs.upload.fileList; this.$refs.upload.fileList.splice(fileList.indexOf(file), 1); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .demo-upload-list&#123; display: inline-block; width: 60px; height: 60px; text-align: center; line-height: 60px; border: 1px solid transparent; border-radius: 4px; overflow: hidden; background: #fff; position: relative; box-shadow: 0 1px 1px rgba(0,0,0,.2); margin-right: 4px; &#125; .demo-upload-list img&#123; width: 100%; height: 100%; &#125; .demo-upload-list-cover&#123; display: none; position: absolute; top: 0; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,.6); &#125; .demo-upload-list:hover .demo-upload-list-cover&#123; display: block; &#125; .demo-upload-list-cover i&#123; color: #fff; font-size: 20px; cursor: pointer; margin: 0 2px; &#125;&lt;/style&gt; 10.3 下载 触发浏览器的下载功能 来下载文件（后端保存的是文件路径）10.3.1 下载 1234567891011121314151617181920212223242526272829303132export function apiDownloadFiles(fielId) &#123; return axios(&#123; url: `/document/$&#123;fielId&#125;`, method: 'get', responseType: 'blob'//下载的时候设置 responseType 为 blob,看后端返回的接口 &#125;)&#125;// 上面的函数获取到的是一个 文件流，文件流，如上图// 将获取到的文件流，处理成文件apiDownloadFiles(file.id).then(res =&gt; &#123; if (res.data.type === \"application/json\") &#123;// 一定是这个 json 格式？？？？这个对么？？？？ this.$message(&#123; type: \"error\", message: \"下载失败，文件不存在或权限不足\" &#125;); &#125; else &#123; let blob = new Blob([res.data]); if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, file.fileName); &#125; else &#123; let link = document.createElement(\"a\"); let evt = document.createEvent(\"HTMLEvents\"); evt.initEvent(\"click\", false, false); link.href = URL.createObjectURL(blob); link.download = file.fileName; link.style.display = \"none\"; document.body.appendChild(link); link.click(); window.URL.revokeObjectURL(link.href); &#125; &#125;&#125;); 上面写成这样我们熟悉的样式 12345678910111213141516171819202122232425262728293031methods:&#123; downLoad(fielId)&#123; axios(&#123; url: `/document/$&#123;fielId&#125;`, method: 'get', responseType: 'blob'//下载的时候设置 responseType 为 blob,看后端返回的接口 &#125;).then(res =&gt; &#123; if (res.data.type === \"application/json\") &#123;// 一定是这个 json 格式？？？？这个对么？？？？ this.$message(&#123; type: \"error\", message: \"下载失败，文件不存在或权限不足\" &#125;); &#125; else &#123; let blob = new Blob([res.data]); if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, file.fileName); &#125; else &#123; let link = document.createElement(\"a\"); let evt = document.createEvent(\"HTMLEvents\"); evt.initEvent(\"click\", false, false); link.href = URL.createObjectURL(blob); link.download = file.fileName; link.style.display = \"none\"; document.body.appendChild(link); link.click(); window.URL.revokeObjectURL(link.href); &#125; &#125; &#125;) &#125;&#125; 10.3.2 button1234567891011121314151617181920212223242526272829303132333435363738394041424344h('Button', &#123; props: &#123; type: 'success', size: 'small' &#125;, on: &#123; click: () =&gt; &#123; console.log(\"点击详情\", params) this.download(params.index) &#125; &#125;&#125;, '导出')download(index) &#123; let text, id; text = '任务名称：' + this.data1[index].task_name + '\\n运行结果：' + (this.data1[index].success === true ? '成功' : '失败') + '\\n错误信息：' + this.data1[index].err_message + '\\n标准输出：' + this.data1[index].std_output + '\\n错误输出：' + this.data1[index].err_output + '\\n程序返回值：' + this.data1[index].return_code; axios(&#123; url: 'http://hete-api.gofoer.com/v1/cost',//这个通常不要这样写的，应该弄个全局默认 url 的！！ method: 'get' &#125;).then((res) =&gt; &#123; if (res.data.code === 200) &#123; for (let i = 0; i &lt; res.data.data.length; i++) &#123; if (res.data.data[i].task_id === this.data1[index].task_id) &#123; id = res.data.data[i].id &#125; &#125; axios(&#123; url: 'http://hete-api.gofoer.com/v1/cost/' + id, method: 'get' &#125;).then((res) =&gt; &#123; if (res.data.code === 200) &#123; text += '\\n运行时间(秒)：' + res.data.data.duration + '\\n资源消耗：\\n\\tCPU(个)：' + res.data.data.cpu + '\\n\\tGPU(个)：' + res.data.data.gpu + '\\n\\tFPGA(个)：' + res.data.data.fpga + '\\n\\t内存(M)：' + res.data.data.mem + '\\n最终费用(元)：' + res.data.data.money; console.log(text) download(text, this.data1[index].task_name + '导出结果.txt', \"text/plain\"); this.$Message.success(\"导出成功！\") &#125; else &#123; this.$Message.error(\"导出失败\"); &#125; &#125;) &#125; &#125;)&#125; 10.3.3123456# 下载请求的过程# 1、发送请求# 2、获得 response# 3、通过 response 判断返回是否为文件# 4、如果是文件则在页面中插入 frame# 5、利用 frame 实现浏览器的 get 下载 10.4 下导出 导出内容，导出页面的内容（当然这个是不请求的）十五、bug15.112345Uncaught (in promise) DOMException: Failed to execute 'open' on 'XMLHttpRequest': '' is not a valid HTTP method. at dispatchXhrRequest (webpack-internal:///./node_modules/axios/lib/adapters/xhr.js:45:13) at new Promise (&lt;anonymous&gt;) at xhrAdapter (webpack-internal:///./node_modules/axios/lib/adapters/xhr.js:12:10) at dispatchRequest (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:59:10) 是因为在 ajax 请求，或者是 axios 封装的请求中，url 或者是 method 写了 ‘’。没有写到的代码就先不要把 请求先写了，会报各种的错误。 这个错误有的时候回说是 url 的问题，可能是填写的 url 不完整，没有 http 或者 https ，或者是缺少其他的。","tags":[{"name":"axios(使用于 vue.js react.js)","slug":"axios-使用于-vue-js-react-js","permalink":"https://liuxmoo.com/tags/axios-使用于-vue-js-react-js/"}]},{"title":"axios 定时刷新 Token","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-axios 定时刷新 Token/","text":"一、前言安全起见，或者是业务需求， token 都会设置时效的。 比如说，1.超时：我们打开一个网页，很久不去操作，再去操作的话可能就需要重新登录了。2.用户操作期间：前端请求，带上旧的 token 给到服务端，服务端返回一个旧的给前端，看起来就会像是将 token 的时间延长一样，因为服务端判断 token 是否过时 会以最新的来判断的呢。 这样就可以保证用户一直在改网站操作的话就可以一直保持登录状态，离开太久了就会断开登录。 二、理解 token2.1 token 身份验证机制客户端 登录请求接口 成功后，服务器将用户信息（如用户 id）使用特殊算法加密后作为验证的标志发送给用户（即 token ），当用户 下次发起请求*（其他的请求接口，需要依赖验证） 时，会将这个 token 捎带过来，服务器再将这个 token 通过解密后进行验证，通过的话，则向客户端返回请求的数据；反之，则请求失败。 2.2 token 优点它是无状态的，且服务器不用像传统的身份认证（session）那样需要保存会话信息，减轻了服务器的压力。 2.3 vue 的 token 刷新处理2.3.1 token 与 refresh_token一般为了安全性，token 都会设置一个过期时间，在过期之后就无法请求相关接口，需要重新登录。 比如说，1.超时：我们打开一个网页，很久不去操作，再去操作的话可能就需要重新登录了。2.用户操作期间：前端请求，带上旧的 token 给到服务端，服务端返回一个旧的给前端，看起来就会像是将 token 的时间延长一样，因为服务端判断 token 是否过时 会以最新的来判断的呢。 这样就可以保证用户一直在改网站操作的话就可以一直保持登录状态，离开太久了就会断开登录。 2.3.1 先来理解后端的思路登录的时候：前端 提交的用户名，密码，（或者其他要求的信息），后端判断 用户名密码是否是真的用户，通过就会返回一个 token。 返回的信息中有不仅有 token，还有 token 的过期时间 expiretoken 过期判断：前端发送旧的 token 给到后端，后端会解析这个 token（后端会解析到 旧 token 的发放时间，以及过期时间） ， 判断是否过期，如果不过期就会返回一个新的 token 给到后端。 2.3.2 前端代码实现（在拦截器中实现） 理解需求 登录时请求 token 和 refresh_token(用来刷新token)每一次请求后端接口的时候都要在 header 里带 token，如果过期会报错 401在快过期的前半小时内（业务需求而定）用 refresh_token 重新请求可以刷新 token，使用户不必被强制退出重新登录。 解决思路 拦截器的思路： axios 设置的思路是，先设置默认的数据，比如说超时时间，url 前缀，然后设置 request 和 response 拦截器，request 拦截器是在发送请求之前执行，response拦截器是在请求返回之后执行。 刷新 token 的思路： 定时刷新 token，简而言之就是隔一段时间去刷新一次 token，当然前提是原来的 token 还没有过期的情况下，才能去刷新，否则直接跳回登录首页； 这里实现刷新 token 主要是在 response拦截器 做文章，请求返回 401 时先记录这次请求的设置 config，然后请求刷新接口，刷新成功之后再重新发送一次之前失败的请求，因为 config 保存下来，所以发送请求的时候可以先把 config 中的 token 换成最新的 token，再直接用 axios(config)，而不用担心其他的设置，从而实现重新请求。 那么问题在于如何知道刷新 token 成不成功呢，如果无脑反复请求会变成死循环，因此需要设置一个变量在 config 中，请求过刷新接口之后设置这个变量为 true，这样就不会重复刷新了。？？？？？这个思路感觉不怎么对呢？？？ token 时间限制，但是我们不希望每次请求都去请求新的 token ，应该是快要过期然后去请求新的，？？？感觉不是上面这样解决啊？？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// main.js 文件（应该是把 拦截器放到其他页面的，但是放置不成功，后面再来更新。。。。。。。。。。）import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'import iView from 'iview' //导入iview-uiimport 'iview/dist/styles/iview.css' //导入iview.cssimport axios from 'axios'import &#123; Message&#125; from 'iview'Vue.config.productionTip = falseVue.use(iView); //全局使用iviewaxios.defaults.baseURL = 'https://api.talcoding.com/v1';axios.defaults.headers.post['Content-Type'] = 'application/json';// 要在 axios 拦截器中请求，不能用同一个实例，死循环了，// 默认的实例是 axios ，这里我们还有自己去创建一个 axios 实例 tokenAxios（名字自己取）let tokenAxios = axios.create(&#123; baseURL: 'https://api.talcoding.com/v1'&#125;)// 请求拦截：带上 token 请求头axios.interceptors.request.use((config) =&gt; &#123; //const token = localStorage.getItem('token'); let sessionToken = JSON.parse(localStorage.getItem(\"sessionToken\")) || '' // if (token) &#123; if (sessionToken) &#123; let expire = new Date(sessionToken.expire).getTime() let now = new Date().getTime() //2019-03-02T06:35:07.854Z 改格式 if (expire &gt; now) &#123; // 判断没过期的情况 const min30 = 1000 * 60 * 30 // 如果快到期就去获取新的 token，这里就用自己创建的 tokenAxios 实例来请求 // 快过期才去请求新的 token 不然就会给服务端压力 if (expire - now &lt; min30) &#123; tokenAxios(&#123; url: '/session', method: 'get', headers: &#123; Authorization: `Code $&#123;sessionToken.token&#125;` &#125; &#125;).then((res) =&gt; &#123; localStorage.setItem(\"sessionToken\", JSON.stringify(res.data)) &#125;) &#125; &#125; config.headers.Authorization = `Code $&#123;sessionToken.token&#125;`; //config.headers.Authorization = `$&#123;token&#125;`; // 如果有 token 就会带上 token，至于带上的 token 是否过期就让后端逻辑去判断，在响应的时候做拦截 &#125; console.log(config); return config;&#125;, (error) =&gt; &#123; console.error('request interceptor: ', error) return Promise.reject(error)&#125;)// 响应拦截：// 判断 token 是否过期，如果过期就跳转登录页面// 响应拦截的时候处理 token 是否过时,过期时间是通过后端设置的，前端需要判断 token 的状态码是否过时就行axios.interceptors.response.use((res) =&gt; &#123; return res;&#125;, (error) =&gt; &#123; console.error('response interceptor: ', error) var status = error.response.status if (status) &#123; switch (status) &#123; case 401: Message.error(\"登录 token 过期，请重新登录\")// 注意这里的写法是 Message.error ！！！！！！不要有 this router.push('/login'); //页面跳转，router.replace 不会计入 history // 在 .vue 的 js 中用的是 this.$router.replace('/login') // 注意写法是 router.push('/login') ！！！！！！！！！！！！！！！！！！！！！！！！！！！！不要有 this &#125; &#125; return Promise.reject(error);&#125;)new Vue(&#123; router, store, render: h =&gt; h(App)&#125;).$mount('#app')","tags":[]},{"title":"react.js--生命周期 与 对应周期函数，完整组件","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-生命周期-完整组件/","text":"一、前言12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 生命周期中 render() 是必须的，这是最简单的 class 创建的组件。 每一个组件都有几个你可以重写以让代码在处理环节的特定时期运行的 “生命周期方法”。 方法中带有前缀 will 的在特定环节 之前被调用，而带有前缀 did 的方法则会在特定环节 之后被调用。 二、生命周期 官网生命周期图纸，也就是上面的周期已经被废弃了，最新的周期看下面的图片（就是官网中新的周期图）。（官网有点乱。。。。） 常用的周期 完整的周期 官网最新的生命周期，文档解析 React生命周期主要包括三个阶段：初始化阶段、运行中阶段和 销毁阶段，在React不同的生命周期里，会依次触发不同的钩子函数。 12345678910111213141516171819202122232425262728293031323334353637383940# 一、初始化阶段static defaultProps=&#123;&#125; # 设置组件的默认属性constructor(props)&#123; super(props); # 设置组件的初始化状态 # props 可以不写在小括号中（官网是写的），它是隐式的传参 # 如果不初始化状态,不绑定方法，则不需要为 React 组件实现构造函数。&#125;static getDerivedStateFromProps(props, state) # 用来替代 react v16.3 中舍弃的周期 # 组件 实例化后 和 接受新属性 时将会调用 getDerivedStateFromProps。 # 它应该返回 一个对象 来更新状态，或者返回 null 来表明新属性 不需要 更新任何状态。 # 注意，如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用。 # 如果你只想处理变化，你可能想去比较新旧值。调用this.setState() 通常不会触发 getDerivedStateFromProps()。 # componentWillMount() # react v16.3 舍弃了这个周期 # UNSAFE_componentWillMount() # 这个已经被废弃了不要使用了render() # 组件渲染【虽然是中间执行的，但是习惯把代码放在最后，大众的习惯!!!!!!!!!!!!!!!!!!!!!!!!!!!!】 # render() 方法是类组件中 唯一必需 的方法。 # render()如果shouldComponentUpdate()返回false，则不会被调用。componentDidMount() # 组件已经被渲染到页面中后触发：此时页面中有了真正的 DOM 的元素，可以进行 DOM 相关的操作 # componentDidMount-componentWillUnmount成对出现 # 定时器开启，网络请求，事件监听，Redux 的订阅事件,然后在 componentWillUnmount() 中取消# 二、运行中阶段: # componentWillReceiveProps() # react 16 已经舍弃了shouldComponentUpdate(nextProps, nextState) # 当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发 # componentWillUpdate() # react v16.3 舍弃了getSnapshotBeforeUpdate(prevProps, prevState) # 在最新的渲染输出提交给 DOM 前将会立即调用。 # 组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给 componentDidUpdate()。componentDidUpdate(prevProps, prevState, snapshot) # 组件被更新完成后触发。 # 页面中产生了新的DOM的元素，可以进行DOM操作 # 如果shouldComponentUpdate()返回false，则 componentDidUpdate() 不会被调用。# 三、销毁阶段：componentWillUnmount() #在组件被卸载和销毁之前立刻调用。 组件被销毁时触发。 # 这里我们可以进行一些清理操作，例如 清理定时器，取消 Redux 的订阅事件等等。 # 可以在该方法里处理任何必要的清理工作，例如解绑定时器，取消网络请求，清理任何在 componentDidMount 环节创建的 DOM 元素。# 四、错误处理：static getDerivedStateFromError(error)componentDidCatch(error, info) 三、生命周期完整的，组件实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import React from 'react'import ReactDOM from 'react-dom';// 父组件class Counter extends React.Component &#123; static defaultProps = &#123; // ①①①① 、加载默认属性：设置组件的默认属性，大多数情况下，这是处理需要重置的状态的最佳方法。 name: 'sls', age:23 &#125;; // Counter.defaltProps=&#123;name:'sls'&#125; 或者默认属性是这样写，在 class 类外面写 constructor(props)&#123; super(props);//super(props) 在任何其他语句之前调用。否则，this.props 将在构造函数中未定义，这可能导致错误。 // ②②②② 、加载默认状态：设置组件的初始化状态 this.state = &#123; number: 0, //color: props.color 错误的写法，也不要在这里用 this.setState color: this.props.color //正确的写法 &#125; &#125; static getDerivedStateFromProps(nextProps, prevState)&#123; console.log('33333333333 666666666666 、替代了原来的三个 will 舍弃的周期'); //组件实例化后和接受新属性时将会调用 getDerivedStateFromProps。 // 它应该返回一个对象来更新状态，或者返回 null 来表明新属性 不需要更新任何状态。 // 注意，如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被调用。如果你只想处理变化，你可能想去比较新旧值。 //调用this.setState() 通常不会触发 getDerivedStateFromProps() &#125; componentDidMount() &#123; console.log('5555555555 、父组件挂载完成'); //安装组件（插入树中）后立即调用，此时可以进行开启定时器、向服务器发 送请求 ajax,axios,request 等操作!!!!!!!!!!!!!!!!! //组件已经被渲染到页面中后触发：此时页面中有了真正的 DOM 的元素，可以进行DOM相关的操作 &#125; shouldComponentUpdate(newProps, newState) &#123;//当组件接收到新属性，或者组件的状态发生改变时触发。组件首次渲染时并不会触发 console.log('7777777777777777 、父组件是否需要更新'); if (newState.number&lt;15) return true;//该钩子函数可以接收到两个参数，新的属性和状态，返回true/false来控制组件是否需要更新。 return false //一般我们通过该 周期函数来优化性能： //一个 React 项目需要更新一个小组件时，很可能需要父组件更新自己的状态。 //而一个父组件的重新更新会造成它旗下所有的子组件重新执行 render() 方法，形成新的虚拟 DOM， //再用 diff 算法对新旧虚拟 DOM 进行结构和属性的比较，决定组件是否需要重新渲染 //无疑这样的操作会造成很多的性能浪费，所以我们开发者可以根据项目的业务逻辑，在 shouldComponentUpdate() 中加入条件判断， //从而优化性能,不需要更新的时候就不要费力去更细了 //例如 React 中的就提供了一个 PureComponent 的类，当我们的组件继承于它时，组件更新时就会默认先比较新旧属性和状态，从而决定组件是否更新。值得注意的是， PureComponent 进行的是浅比较，所以组件状态或属性改变时，都需要返回一个新的对象或数组 &#125; getSnapshotBeforeUpdate(prevProps, prevState)&#123; console.log('99999999 、在最新的渲染输出提交给 DOM 前将会立即调用。它让你的组件能在当前的值可能要改变前获得它们。这一生命周期返回的任何值将会 作为参数被传递给componentDidUpdate()。 '); if (prevProps.list.length &lt; this.props.list.length) &#123; return this.listRef.current.scrollHeight; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log('10 10 10 10、父组件更新完成');//组件被更新完成后触发。页面中产生了新的 DOM 的元素，可以进行 DOM 操作 //更新发生后立即调用。初始渲染不会调用此方法。 //将此作为在 更新组件 时对 DOM 进行操作的机会。只要您将 当前道具 与 之前的道具 进行比较（例如，如果道具未更改，则可能不需要网络请求），这也是进行网络请求 的好地方。!!!!!!!!!!!!!!!!!!!!!! // Typical usage (don't forget to compare props): if (this.props.userID !== prevProps.userID) &#123; this.fetchData(this.props.userID); &#125; if (snapshot !== null) &#123; this.listRef.current.scrollTop += this.listRef.current.scrollHeight - snapshot; &#125; &#125; componentWillUnmount()&#123; console.log('11 11 11 11、销毁组件，卸载组件'); &#125; componentDidCatch(error, info)&#123; console.log('12 12 12 12 12、渲染发生错误'); &#125; // 其他自定义的方法，事件触发的方法，与周期函数 同级，react 的方法可以使用 箭头函数 handleClick = () =&gt; &#123; this.setState(&#123; number: this.state.number + 1// 这里怎么使用 this.state ？？？？？ 不应该去依赖 this.state 把？？？？ // 看不懂，不是说状态更新是异步的么？？不应该是使用 this.state ， this.props &#125;) // 有运算的应该是给 this.setState 传入一个函数把？不能简单的使用对象吧？？？？应该是下面这样来写吧？？？ this.setState((prevState)=&gt;(&#123; number:prevState.number + 1 )&#125;) &#125; render() &#123; console.log('4444444 888888、render(父组件挂载)'); return ( &lt;div&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &#123;this.state.number&lt;10?&lt;SubCounter number=&#123;this.state.number&#125;/&gt;:null&#125; &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter/&gt;, document.getElementById('root'));Counter.forceUpdate(callback) // 强制渲染，不理会 shouldComponentUpdate()，通常不要使用这个方法，还是在 render 做好措施比较好Counter.defaultProps = &#123;// 默认属性值的设置 color: 'blue'//若未设置 props.color，其将被设置默认为'blue',若props.color设为null，则其值则为null：&#125;;// 子组件class SubCounter extends React.Component &#123; shouldComponentUpdate(newProps, newState) &#123; console.log('10、子组件是否需要更新'); if (newProps.number &lt; 5) return true; return false &#125; componentDidUpdate() &#123; console.log('13、子组件更新完成'); &#125; render() &#123; console.log('12、子组件挂载中'); return ( &lt;p&gt;&#123;this.props.number&#125;&lt;/p&gt; ) &#125;&#125;","tags":[{"name":"react.js 生命周期","slug":"react-js-生命周期","permalink":"https://liuxmoo.com/tags/react-js-生命周期/"}]},{"title":"JQurey-ui--[ui 组件库]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ jqurey.js 框架 }-ui 组件/","text":"一、前言JQurey-UI 是依赖 JQurey.js 做的一个界面组件库，若项目是使用 JQurey.js 做的，可以使用这个组件库。JQurey-ui 英文网JQurey-ui 中文网 二、","tags":[{"name":"Jquery->ajax","slug":"Jquery-ajax","permalink":"https://liuxmoo.com/tags/Jquery-ajax/"}]},{"title":"ajax 小白入门篇、速学篇","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ jqurey.js 框架 }-ajax 前后端交换数据/","text":"一、前言这里的 ajax 不是原生的 ajax ， 是 JQuery 对 原生 ajax 进行的封装之后的一个 ajax。","tags":[{"name":"Jquery->ajax","slug":"Jquery-ajax","permalink":"https://liuxmoo.com/tags/Jquery-ajax/"}]},{"title":"vue--[ref 子组件标识属性]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } ref 子组件标识属性/","text":"一、前言 ref 在父组件 html 引用 子组件的标签中给 子组件 一个特殊的 ref 属性。用来指定子组件。 ref 用于普通元素的时候，例如 ：div，p，等，就等价于类似给这些元素一个 ID 特殊属型，来指定其中的 Node 节点。 二、用于子组件：父组件 访问 子组件实例 或 子元素尽管存在 prop 和事件，prop 父传子，事件 子传父。 有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 特性为这个子组件赋予一个 ID 引用。例如： 2.1 例 一123456789101112131415161718&lt;!-- 父组件 --&gt;&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt;&lt;script&gt; export default &#123; name:'', data()&#123; return&#123; // &#125; &#125;, methods:&#123; getFromChild()&#123; this.$refs.usernameInput.xxxx()// 获取到子组件实例 的某个方法 this.$refs.usernameInput.name// 获取到子组件实例 的某个 数据 &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516&lt;!-- 子组件 --&gt;&lt;script&gt; export default &#123; name: \"baseinput\", data()&#123; return&#123; name:'' &#125; &#125;, methods:&#123; xxxx()&#123; // &#125; &#125; &#125;&lt;/script&gt; 2.2 例 二1234567891011121314&lt;!-- 父组件 --&gt;&lt;div id=\"app\"&gt; &lt;navbar ref=\"navbar\"&gt;&lt;/navbar&gt; &lt;pagefooter ref=\"pagefooter\"&gt;&lt;/pagefooter&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el:'#app', mounted() &#123; console.log(this.$refs.navbar.navs);//[] console.log(this.$refs.pagefooter.footer);//'' &#125;&#125;)&lt;/script&gt; 123456789101112131415161718// 子组件Vue.component('navbar',&#123; template:'#navbar', data:function () &#123; return &#123; navs:[] &#125; &#125;&#125;);Vue.component('pagefooter',&#123; template:'#pagefooter', data:function () &#123; return &#123; footer:'' &#125; &#125;&#125;); 三、用于普通元素：html 原始元素标签1&lt;div ref=\"demo\"&gt;&lt;/div&gt; 123document.querySelector('[ref=demo]');// 获取的是 DOM 节点// 等价于this.$refs.demo","tags":[{"name":"interceptor 请求拦截器","slug":"interceptor-请求拦截器","permalink":"https://liuxmoo.com/tags/interceptor-请求拦截器/"}]},{"title":"interceptor 请求拦截器","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } interceptor 请求拦截器/","text":"一、 interceptor 简介interceptor 即使在发送请求之前做的事情。 二、interceptor 大致框架2.1 配置拦截器1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 2.2 移除拦截器12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 三、interceptor 在 vue 中实例应用3.1 token 本地缓存1234567891011121314151617181920212223242526272829//bigdata 项目中的设置// interceptor/index.js 文件import axios from 'axios'import router from 'router'axios.interceptors.request.use((config) =&gt; &#123; const token = localStorage.getItem('token'); if (token) &#123;// 发送请求之前给 token 再其他的请求中就不需要给 token 了 config.headers.Authorization = `$&#123;token&#125;`;// 在配置好 token 就不需要在每个axios 都写上 headers 了。 &#125; return config;&#125;, (error) =&gt; &#123; console.error('request interceptor: ', error) return Promise.reject(error)&#125;)axios.interceptors.response.use((res) =&gt; &#123; return res;&#125;, (error) =&gt; &#123; console.error('response interceptor: ', error) if (error.response.status) &#123; switch (error) &#123; case 401: router.replace('/login');//页面跳转，router.replace 不会计入 history // 在 .vue 的 js 中用的是 this.$router.replace('/login') &#125; &#125; return Promise.reject(error);&#125;) 3.2 token 在 store 中12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue';import router from 'router'import axios from 'axios';import store from '../store/';// 默认配置，这个默认配置可以卸载 interceptor 中也可以写在 main.js 中 ，// 因为最终 interceptor/index.js 都是在 main.js 全局引入的 import 'interceptors'axios.defaults.baseURL = 'http://www.xxxx.com';axios.defaults.headers.post['Content-Type'] = 'application/json';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;// 在这里写默认的，或者是在 interceptors 中写export const request = (config) =&gt; &#123; return axios(config);&#125;;// http request 拦截器axios.interceptors.request.use((config) =&gt; &#123; if(store.state.token) &#123; // 判断是否存在token，如果存在的话，则每个http header都加上token config.headers.Authorization = `$&#123;store.state.token&#125;`; // token保存在store中 &#125; return config; &#125;,(err) =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器axios.interceptors.response.use((response) =&gt; &#123; return response; &#125;,(error) =&gt; &#123; if(error.response) &#123; switch (error.response.status) &#123; case 401: router.replace(&#123; path: '/login', query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;); &#125; &#125; return Promise.reject(error.response.data);// (error.response.data 还是 error 自己做。 &#125;); 四、 axios 的全部配置项具体参考 axios 文章。可以在 main.js 中设置全局配置 这里是一些举例 12345678910111213141516//设置请求baseURLaxios.defaults.baseURL = '/api'//设置默认请求头axios.defaults.headers = &#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;// 发送请求前处理request的数据axios.defaults.transformRequest = [function (data) &#123; let newData = '' for (let k in data) &#123; newData += encodeURIComponent(k) + '=' + encodeURIComponent(data[k]) + '&amp;' &#125; return newData &#125;]// 带cookie请求axios.defaults.withCredentials = true","tags":[{"name":"interceptor 请求拦截器","slug":"interceptor-请求拦截器","permalink":"https://liuxmoo.com/tags/interceptor-请求拦截器/"}]},{"title":"eCharts-ui 与 v-charts【1】- 图表组件库","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } ui 组件库 ECharts-ui 与 v-charts/","text":"一、图表组件库在使用 echarts 生成图表时，经常需要做繁琐的数据类型转化、修改复杂的配置项，v-charts 的出现正是为了解决这个痛点。基于 Vue2.0 和 echarts 封装的 v-charts 图表组件，只需要统一提供一种对前后端都友好的数据格式设置简单的配置项，便可轻松生成常见的图表。 eCharts 是基础v-charts 是基于 Vue2.0 和 echarts 封装，更方便我们使用于 vue 项目中。 eCharts 官网文档v-charts 官网文档 二、安装2.1 echarts 安装引入12$ npm install echarts --save# npm 的方法还需要导入 导入 2.2 v-charts 的安装引入（vue 项目就直接使用这个吧!!!!!!!!!!!!!!!!!!!!）2.2.1 安装1$ npm i v-charts echarts -S 2.2.2 完全导入1234567891011// main.js 完全导入import Vue from 'vue'import VCharts from 'v-charts'import App from './App.vue'Vue.use(VCharts)new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 2.2.3 按需导入12345678# v-charts/lib 文件夹下 有的每种图表组件，都单独打包好了|- lib/ |- line.common.js -------------- 折线图 |- bar.common.js --------------- 条形图 |- histogram.common.js --------- 柱状图 |- pie.common.js --------------- 饼图 |- ring.common.js -------------- 环图 |- funnel.common.js ------------ 漏斗图 1234567891011// v-charts/lib 文件夹下 有的每种图表组件，都单独打包好了 使用的时候，我们只需要单独的引入就 okimport Vue from 'vue'import VeLine from 'v-charts/lib/line.common'// 例如现在需要使用 line 图表import App from './App.vue'Vue.component(VeLine.name, VeLine)new Vue(&#123; el: '#app', render: h =&gt; h(App)&#125;) 2.4 安装过程的坑坑1 12345678910λ cnpm install iveiw --save× Install fail! Error: GET https://registry.npm.taobao.org/iveiw response 404 statusError: GET https://registry.npm.taobao.org/iveiw response 404 status at get (C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npminstall\\lib\\get.js:57:17) at get.next (&lt;anonymous&gt;) at onFulfilled (C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\co\\index.js:65:19) at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7)npminstall version: 3.10.0npminstall args: C:\\Program Files\\nodejs\\node.exe C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npminstall\\bin\\install.js --fix-bug-versions --china --userconfig=C:\\Users\\Administrator\\.cnpmrc --disturl=https://npm.taobao.org/mirrors/node --registry=https://registry.npm.taobao.org iveiw --save 填坑 坑2 12345678910111213141516171819λ npm install iview --savenpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-json-stable-stringifynpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-deep-equalnpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\pinkie-promise\\node_modules\\pinkienpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modulesnpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\pinkie-promise\\node_modulesnpm WARN request-promise-core@1.1.1 requires a peer of request@^2.34 but none is installed. You must install peer dependencies yourself.npm WARN request-promise-native@1.0.5 requires a peer of request@^2.34 but none is installed. You must install peer dependencies yourself.npm ERR! path F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-json-stable-stringifynpm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access 'F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-json-stable-stringify'npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-21T07_18_57_459Z-debug.log 填坑","tags":[{"name":"v-charts 图标库","slug":"v-charts-图标库","permalink":"https://liuxmoo.com/tags/v-charts-图标库/"}]},{"title":"element-ui【1】- 小白入门篇【记录一些使用的注意之处 & 自己经常犯的错】","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } ui 组件库 element-ui/","text":"前言","tags":[]},{"title":"vue--[ v-model && computed]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } v-model && computed/","text":"一、前言在使用到 v-model 与 computed 的时候可能会遇到这个错误。 提示错误，Computed property &quot;XXXXXX&quot; was assigned to but it has no setter. 二、错误原因computed 属性选项中，默认的都是 return ，也就是 get() 函数。在处理 data 中的数据使用没有问题。但是在处理 v-model 的数据就会出现问题，v-model 的数据是用户输入的，如果直接用 get() 是获取不到真值的，做不到双向绑定。 在 data 获取的数据，他们就是 setter 了。而 v-model 的数据需要在 computed 中添加 setter。只有return的话，是无法实现双向数据绑定的，要先将用户输入的数据 setter 进来。 1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;Slider v-model=\"newConfidence\" show-input :min='0' :max='100' :tip-format=\"confidenceFormat\" &gt;&lt;/Slider&gt; &lt;div&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; data: () =&gt; (&#123; confidence: 0.6, num:10 &#125;), computed: &#123; newConfidence: &#123; set(value) &#123; this.confidence = value/100; &#125;, get() &#123; return this.confidence * 100; &#125; &#125;, newNum()&#123; return this.num + '岁' &#125; &#125;&lt;/script&gt;","tags":[]},{"title":"[在 vuei 中使用 less 或者 scss]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-less-scss 在 vue 中使用/","text":"一、前言使用 vue-cli 搭建项目有内置的 webpack 方案，但是没有使用 scss 与 less。 但是 vue 提供了初始化的 webpack 模板，其中使用了vue-loader。vue-loader 默认只支持 sass,要是想要使用scss，必须安装 node-sass 和sass-loader，并修改相关 webpack 配置。具体操作如下： 其实 vue-cli3 已经不需要这么麻烦了，学会了 vue-cli3 的话就不需要做下面的工作了。反而是 crate-react-app 2.0 版本也是，已经不需要麻烦的配置了。如何查看自己的项目中 脚手架的版本，就是看 package.json 文件中字段&quot;react-scripts&quot;: &quot;2.1.2&quot; 这个就是 crate-react-app 的版本。如果版本是 1.0 的，那么可以直接更改为 2.0 的版本，然后 npm install 就可以得到新的版本了。 1NOTE: Create React App 2 supports TypeScript, Sass, CSS Modules and more without ejecting: `https://reactjs.org/blog/2018/10/01/create-react-app-v2.html` 二、vue 中安装 less 或者 sass2.1 vue 使用 less12$ npm install less less-loader --save-dev # 或者安装 less ( -D 就是 -dev 的缩写)$ npm i less less-loader -D # 这样缩写 12345//webpack.base.conf.js 的 module.rules 中加入如下规则？？？？？？？？？？？？这个需要修改么？ &#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\", &#125; 12&lt;style scoped lang=\"less\"&gt;&lt;/style&gt; 2.2 vue 使用 scss1$ npm install node-sass sass-loader --save-dev # 安装 sass（npm 太慢的话就用 cnpm，当然 pnpm 其他都是可以的，有的话就 ok） 12345//webpack.base.conf.js 的 module.rules 中加入如下规则 ，？？？？？？？？？？？？这个需要修改么？ &#123; test: /\\.scss$/, loaders: [\"style\", \"css\", \"sass\"] &#125;, 12345&lt;!-- 在 .vue 文件使用 scss --&gt;&lt;style scoped lang=\"scss\"&gt; @import \"overview\"; /* 导入overview.scss */&lt;/style&gt;","tags":[]},{"title":"vue 中的 mixins 使用","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-mixins 混合/","text":"一、前言混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。 vue.js 框架 mixins 混入地址 二、用途为组件定义可复用的方法，可以在 mixin 对象里定义组件的任何属性，在组件使用 mixin 时，mixin 中的属性会添加到组件属性中。 三、使用 mixins3.1 组件内 mixins12345//mixin.js//pageexport default &#123; let cache = null // 确保进入和离开是一个page&#125;","tags":[]},{"title":"react.js 中使用 interceptor 请求拦截器","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ - 【react.js 框架 】- interceptor 请求拦截器/","text":"一、 interceptor 简介interceptor 即使在发送请求之前做的事情。 下面还是 vue.js 的写法，react.js 的写法后面再用。 二、interceptor 大致框架2.1 配置拦截器1234567891011121314151617// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 2.2 移除拦截器12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 三、interceptor 在 vue 中实例应用3.1 token 本地缓存1234567891011121314151617181920212223242526272829//bigdata 项目中的设置// interceptor/index.js 文件import axios from 'axios'import router from 'router'axios.interceptors.request.use((config) =&gt; &#123; const token = localStorage.getItem('token'); if (token) &#123;// 发送请求之前给 token 再其他的请求中就不需要给 token 了 config.headers.Authorization = `$&#123;token&#125;`;// 在配置好 token 就不需要在每个axios 都写上 headers 了。 &#125; return config;&#125;, (error) =&gt; &#123; console.error('request interceptor: ', error) return Promise.reject(error)&#125;)axios.interceptors.response.use((res) =&gt; &#123; return res;&#125;, (error) =&gt; &#123; console.error('response interceptor: ', error) if (error.response.status) &#123; switch (error) &#123; case 401: router.replace('/login');//页面跳转，router.replace 不会计入 history // 在 .vue 的 js 中用的是 this.$router.replace('/login') &#125; &#125; return Promise.reject(error);&#125;) 3.2 token 在 store 中12345678910111213141516171819202122232425262728293031323334353637383940414243import Vue from 'vue';import router from 'router'import axios from 'axios';import store from '../store/';// 默认配置，这个默认配置可以卸载 interceptor 中也可以写在 main.js 中 ，// 因为最终 interceptor/index.js 都是在 main.js 全局引入的 import 'interceptors'axios.defaults.baseURL = 'http://www.xxxx.com';axios.defaults.headers.post['Content-Type'] = 'application/json';axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;// 在这里写默认的，或者是在 interceptors 中写export const request = (config) =&gt; &#123; return axios(config);&#125;;// http request 拦截器axios.interceptors.request.use((config) =&gt; &#123; if(store.state.token) &#123; // 判断是否存在token，如果存在的话，则每个http header都加上token config.headers.Authorization = `$&#123;store.state.token&#125;`; // token保存在store中 &#125; return config; &#125;,(err) =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器axios.interceptors.response.use((response) =&gt; &#123; return response; &#125;,(error) =&gt; &#123; if(error.response) &#123; switch (error.response.status) &#123; case 401: router.replace(&#123; path: '/login', query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;); &#125; &#125; return Promise.reject(error.response.data);// (error.response.data 还是 error 自己做。 &#125;); 四、 axios 的全部配置项具体参考 axios 文章。可以在 main.js 中设置全局配置 这里是一些举例 12345678910111213141516//设置请求baseURLaxios.defaults.baseURL = '/api'//设置默认请求头axios.defaults.headers = &#123;\"Content-Type\": \"application/x-www-form-urlencoded\"&#125;// 发送请求前处理request的数据axios.defaults.transformRequest = [function (data) &#123; let newData = '' for (let k in data) &#123; newData += encodeURIComponent(k) + '=' + encodeURIComponent(data[k]) + '&amp;' &#125; return newData &#125;]// 带cookie请求axios.defaults.withCredentials = true","tags":[]},{"title":"vue.js--[爬坑集合]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-爬坑/","text":"一、前言使用过程中遇到的各种错误，自己不小心犯的错。 二、爬坑2.1 快速定位错误的 html 段落1234567891011[Vue warn]: Invalid prop: type check failed for prop \"value\". Expected Array, String, got Number.found in---&gt; &lt;Collapse&gt; # 这里箭头就是错误的 html 段落，只要去这里面去找对应的错误就好了 &lt;Organization&gt; at src/pages/organization/organization.vue &lt;Content&gt; &lt;Layout&gt;... (1 recursive calls) &lt;Admin&gt; at src/group/admin.vue &lt;App&gt; at src/App.vue &lt;Root&gt; Error in mounted hook: &quot;TypeError: this.initInfo is not a function&quot;1234Error in mounted hook: \"TypeError: XXXXX is not a function\"# 遇到这个问题一定是函数没有定义，# 看下是不是函数名错误了# 要不就是使用了混合组件但是没有导入，没有注册 mixin ？？？？ 2.1 改变数据类型的坑如下是希望将输入的数据保存在本地，刷新之后数据依然存在。也即是类似做个 todolist 项目的时候，遇到 push 数据不成功的情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243//以下代码为需要展示不部分，其他无关的代码省略&lt;script&gt;export default &#123; name: 'Home', // 这里是组件名称，给 template 中的 class 没有关系，原名为 HelloWorld data () &#123; retrun &#123; ..., todolist:[]//这里一定要写[]，是数组就写数组，不能写 null 其他类型的数据， &#125; &#125;, watch: &#123; // 此处为观察 todolist，一旦发生变化然后执行里面的函数 todolist: &#123; handler: function (newval, oldVal) &#123; var vm = this window.localStorage.setItem('todolist', JSON.stringify(vm.todolist)) //一旦数组数据有所改变，立即执行todolist的保存 &#125;, deep: true &#125; &#125;, mounted () &#123; //获取本次保存的数据放置到数组中 tosolidt 中 this.todolist = JSON.parse(window.localStorage.getItem('todolist')) &#125;, methods: &#123; addtodolist () &#123; //新建一个变量 newtododata，push 到表格数据数组 todolist 中， //避免表格数据与输入框双向绑定 var newtododata = &#123; input: this.newtodo.input, datestart: this.newtodo.datestart, timestart: this.newtodo.timestart, dateend: this.newtodo.datesend, timeend: this.newtodo.timeend, isFinish: this.newtodo.isFinish &#125; this.todolist.push(newtododata) this.$Message.info('添加成功') &#125; &#125;&#125;&lt;/script&gt; 如上代码一执行，就会发现如下错误。 1234567891011121314151617181920212223[Vue warn]: Error in callback for watcher \"data\": \"TypeError: Cannot read property 'forEach' of null\"found in---&gt; &lt;Table&gt; &lt;Content&gt; &lt;Layout&gt; &lt;Home&gt; at src\\components\\home.vue &lt;App&gt; at src\\App.vue &lt;Root&gt;vue.esm.js?efeb:1741 TypeError: Cannot read property 'forEach' of null at VueComponent.makeObjData (iview.js?377a:22344) at VueComponent.handler (iview.js?377a:22495)[Vue warn]: Error in event handler for \"on-ok\": \"TypeError: Cannot read property 'push' of null\"found in---&gt; &lt;Modal&gt; &lt;Content&gt; &lt;Layout&gt; &lt;Home&gt; at src\\components\\home.vue &lt;App&gt; at src\\App.vue &lt;Root&gt;TypeError: Cannot read property 'push' of null at VueComponent.addtodolist (home.vue?250d:226) at VueComponent.invoker (vue.esm.js?efeb:2027) 检查代码发现逻辑没有错误。错在数据类型出错了。在mounted周期中，没有考虑’todolist’为空的情况，一开始todolist为空，保存到本地的将是undefined，但是实际上，我们的todolist应该是数组的。 12345678910//mounted () &#123; //获取本次保存的数据放置到数组中 tosolist 中// this.todolist = JSON.parse(window.localStorage.getItem('todolist'))//&#125;,//更新如下，保证为空的时候为'[]'，那么保存的将会是[]这个字符串，重新获取的也会是[]空数组了，//不会是其他的数据类型mounted () &#123; //获取本次保存的数据放置到数组中 tosolist 中 this.todolist = JSON.parse(window.localStorage.getItem('todolist' || '[]'))&#125;, 因此，我们在做变量赋值的时候一定要注意不要改变数据类型。 2.2 项目目录不能有大写字母1name can no longer contain capital letters. 2.3 v-for 指令中的参数顺序要正确v-for=&quot;(value,key,index) in items&quot; 三个参数的话，第一个是 value ，第二个是 key ，第三个是 index 两个参数的话，第一个是 value ，第二个是 index 错误的话写 :key=”index” 的话是错误的。","tags":[]},{"title":"react.js--[mixins 混合组件 与 hoc 高阶组件]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ - 【react.js 框架 】- mixins 混合组件 与 hoc 高阶组件/","text":"一、前言二、mixins 与 hocmixins 与 hoc 比较文章 mixins与 vue.js 中的 mixins 一个道理。 react 中使用 mixins hoc","tags":[]},{"title":"react.js--[ui 组件库]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】- Design ui 组件库/","text":"一、简介蚂蚁金服 ant.design 二、各个组件使用的注意问题2.1 输入框的 onchange ？？？？？2.2 输入框的清空问题？？？？","tags":[]},{"title":"react.js----[React Router Redux 状态管理器]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-React Router Redux 状态管理器/","text":"一、简介React Router v4 中已经包含了 Redux 状态管理器，只需要下载 React Router v4 就可使用状态管理器了。 4.x 中采用了单代码仓库模型架构，所以里面包含了若干个相互独立的包，如下所示： react-router React Router 核心 这个是不需要重新安装了的。 react-router-dom 用于 DOM 绑定的 React Router react-router-native 用于 React Native 的 React Router react-router-redux React Router 和 Redux 的集成!!!!!!!!！！！！！！！！！不需要再重新的安装了的。 react-router-config 用于配置静态路由 12345# $ npm install -S react-router # npm 安装法# $ yarn add react-router # yarn 安装法# 以前是上面的方法安装的，但是 v4 版本之后就升级了，是安装 react-router-dom ，因为 react-router 不需要显示的安装了$ npm install --save react-router-dom # 这样安装时候也已经包含了 react-router # 也包含了 redux 状态管理器了 二、React Router v4 官网react router v4 与 redux 配合使用 十五、BUG15.11Module not found: Can't resolve 'react-redux' in 'F:\\qianduan_dir\\00program\\react.js\\test\\src\\app' 没有找到 ‘react-redux’ ，注意虽然说 React Router v4 已经集合了 redux ，但是它还是需要安装一下 ‘react-redux’，就像是虽然说 create-react-app 2.0 已经包含了，scss，less，postcss，这些 CSS 预处理器，但是还是需要安装才能使用的。 要安装 react-redux 的，并且还要安装它依赖的 redux ，不然还会是报错的。warning &quot; &gt; react-redux@6.0.0&quot; has unmet peer dependency &quot;redux@^2.0.0 || ^3.0.0 || ^4.0.0-0&quot;. 1234# npm 安装$ npm install --save redux react-redux# yarn 安装$ yarn add redux react-redux","tags":[]},{"title":"redux 与 mbox 状态管理器","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-redeux mobx 状态管理器/","text":"一、简介当我们的页面很复杂的时候就需要使用到状态管理器。 二、redeux 与 mobx现在 react 中主要使用的就是这 2 种管理器。 二者区别","tags":[]},{"title":"react.js--[网络请求 axios,jquery-ajax，浏览器内置的 window.fetch]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-axios 网络请求/","text":"一、前言react.js 中前后端数据请求交换，可以使用 axios，jquery-ajax，浏览器内置的 window.fetch 中的认可一种的。 二、axios去看 vue 中的就好了。 三、jquery-ajax去看 jquery 中的就好了。 四、浏览器内置的 window.fetch内置的没有用过，不用了。 五、示例：在 react.js 中实际使用5.1 fetch1234567// 请求反馈的数据&#123; items: [ &#123; id: 1, name: 'Apples', price: '$2' &#125;, &#123; id: 2, name: 'Peaches', price: '$5' &#125; ]&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: null, isLoaded: false, items: [] &#125;; &#125; componentDidMount() &#123; fetch(\"https://api.example.com/items\")// 这里用的就是内置的 fetch 方法。 .then(res =&gt; res.json()) .then( (result) =&gt; &#123; this.setState(&#123; isLoaded: true, items: result.items &#125;); &#125;, // Note: it's important to handle errors here // instead of a catch() block so that we don't swallow // exceptions from actual bugs in components. (error) =&gt; &#123; this.setState(&#123; isLoaded: true, error &#125;); &#125; ) &#125; render() &#123; const &#123; error, isLoaded, items &#125; = this.state;// 结构赋值 if (error) &#123; return &lt;div&gt;Error: &#123;error.message&#125;&lt;/div&gt;; &#125; else if (!isLoaded) &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125; else &#123; return ( &lt;ul&gt; &#123;items.map(item =&gt; ( &lt;li key=&#123;item.name&#125;&gt; &#123;item.name&#125; &#123;item.price&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; ); &#125; &#125;&#125; 5.2 ajax12345678910111213141516171819202122232425class Posts extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; posts: [] &#125; &#125; componentDidMount() &#123; this.serverRequest = axios.get('/api') .then(posts =&gt; &#123; this.setState(&#123; posts &#125;) &#125;) &#125; componentWillUnmount() &#123; this.serverRequest.abort()// 现在这个周期函数已经被取消了啊 &#125; render() &#123; return &lt;PostList posts=&#123;this.state.posts&#125; /&gt; &#125;&#125;","tags":[]},{"title":"taro.js 多终端框架(京东)","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-taro.js 框架 /","text":"一、前言Taro:京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative; taro.js:多端统一开发框架，支持用 React 的开发方式编写一次代码，生成能运行在微信小程序/百度智能小程序/支付宝小程序、H5、React Native 等的应用。 GitHub官方中文文档 Taro 是一套遵循 React 语法规范的 多端开发 解决方案。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、RN 等）运行的代码。不需要针对不同的终端去书写多套代码。 二、","tags":[]},{"title":"react.js--[传值]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-组件传值/","text":"一、前言","tags":[{"name":"react.js 组件传值","slug":"react-js-组件传值","permalink":"https://liuxmoo.com/tags/react-js-组件传值/"}]},{"title":"数据类型不符合","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑮ -  bug 集合 -vue 中遇到的 bug/","text":"一、前言在开发过程中总是会遇到各种各样的错误，有很多的工具给我们快速的去发现错误。 Chrome 开发者工具，就是每个浏览器都会有的 F12(或者其他快捷键) vue-devtools 工具 二、import 的问题12345678910111213// 没有路径表示 node modules// 加个./表示当前目录// main.jsimport Vue from 'vue' // 从 node modules 导入import App from './App.vue' // 从 当前目录下的 app.vue 文件中导入import router from './router'// 从 当前目录下的 router 文件中导入import store from './store' // 从 当前目录下的 store 文件中导入import iView from 'iview' //从 node modules 导入iview-uiimport 'iview/dist/styles/iview.css' //导入iview.cssimport axios from 'axios'import &#123; Message&#125; from 'iview' //从 node modules 导入 Message 二、JS2.1 数据为 undefined [Vue warn]: Error in mounted hook: “TypeError: Cannot read property ‘fileList’ of undefined” 数据 undefined、或者类型不符合要求 12345678910111213141516171819202122232425[Vue warn]: Error in mounted hook: \"TypeError: Cannot read property 'fileList' of undefined\"# 在 mounted 钩子函数的时候出错(已经告诉我们是在哪里出错了！！！！！！！！！！缩小范围)found in---&gt; &lt;Addproduct&gt; at src/views/Addproduct/Addproduct.vue # 在 Addproduct.vue 组件发证错误 &lt;Content&gt; &lt;Layout&gt;... (2 recursive calls) &lt;Home&gt; at src/views/Home/Home.vue &lt;App&gt; at src/App.vue &lt;Root&gt;warn @ vue.runtime.esm.js?2b0e:619logError @ vue.runtime.esm.js?2b0e:1883。。。。。。vue.runtime.esm.js?2b0e:1887 TypeError: Cannot read property 'fileList' of undefined at VueComponent.mounted (Addproduct.vue?f3da:246) # mounted 钩子（出错的位置） # 有的会在这里支出出错的 methods 中的函数名的，注意看就容易到 bug ！！！！！！！！！！！！！！ at invokeWithErrorHandling (vue.runtime.esm.js?2b0e:1854) at callHook (vue.runtime.esm.js?2b0e:4190) at Object.insert (vue.runtime.esm.js?2b0e:3132) at invokeInsertHook (vue.runtime.esm.js?2b0e:6307) at VueComponent.patch [as __patch__] (vue.runtime.esm.js?2b0e:6526) at VueComponent.Vue._update (vue.runtime.esm.js?2b0e:3919) at VueComponent.updateComponent (vue.runtime.esm.js?2b0e:4037) at Watcher.get (vue.runtime.esm.js?2b0e:4440) at Watcher.run (vue.runtime.esm.js?2b0e:4515) 2.2 参数不符，语法错误（不一定是 JS 中的函数参数错误，也要看看 html 代码）123456789 ERROR Failed to compile with 1 errors 16:01:53 error in ./src/views/Product/Product.vue?vue&amp;type=template&amp;id=40cdf8e5&amp;scoped=true&amp; # 在 Product.vue 页面错误Syntax Error: SyntaxError: Argument name clash (1:827) # 错误原因：语法错误：参数名称冲突 @ ./src/views/Product/Product.vue?vue&amp;type=template&amp;id=40cdf8e5&amp;scoped=true&amp; 1:0-402 1:0-402 @ ./src/views/Product/Product.vue @ ./src/router.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://192.168.2.100:8080/sockjs-node (webpack)/hot/dev-server.js ./src/main.js 123456&lt;template slot-scope=\"&#123; row,row&#125;\" slot=\"name\"&gt; &lt;!-- 一直在找 JS 不知道是哪里错了，原来是在 template 写错了！！！！！！ --&gt; &lt;div v-if=\"(row.images)[0]\" class=\"table-img\"&gt; &lt;img :src=\"(row.images)[0].url\" width=\"100\" height=\"100\"&gt; &lt;div @click=\"changeText('name',row)\"&gt;&#123;&#123;row.name&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 2.3 localstorage 保存的是 JSON 字符串localstorage 保存的是 JSON 字符串，我们 JS 中数组或者是对象，这些数据是不能保存到本地的。 例如使用在登录页面。 123//localStorage.setItem(\"token\", `Code $&#123;res.data.token&#125;`); // 注意如果我们的localStorage.setItem(\"sessionToken\",JSON.stringify(res.data))// 考虑 token 时效就需要同时获取 返回的 token 过期时间this.$router.push(\"/product\"); 三、网络 webSoket3.1 IP 网络问题 GET http://192.168.2.100:8080/sockjs-node/info?t=1551497641166 net::ERR_CONNECTION_TIMED_OUT123[WDS] Disconnected! # WDS 已断开连接！ （WDS 就是 webSoket 的意思）GET http://192.168.2.100:8080/sockjs-node/info?t=1551497596005 net::ERR_CONNECTION_TIMED_OUT# 连接超时 原因： 这是一个常见的互联网错误。1.发生此 DNS 错误是因为访问或浏览该网站时，Internet IP 地址被防火墙或驱动程序阻止。但有时这种 DNS 错误可能由几种原因引起，但都是采取一个解决方案。2.而在 vue 开发中，很大原因是因为网络环境改变了。 场景： 123456789# 2019.03.01 晚上 yarn serve App running at: - Local: http://localhost:8080/ - Network: http://192.168.2.100:8080/# 项目运行的 ip 是 http://192.168.2.100:8080/# 然后一直不停止运行# 2019.03.02 早上打开代码编辑，就会出现这个错误了，# GET http://192.168.2.100:8080/sockjs-node/info?t=1551497596005 net::ERR_CONNECTION_TIMED_OUT# 链接超时，因为我们现在不在 http://192.168.2.100:8080 这个环境下。 解决： 1.重新运行项目，将旧的运行停止掉，重新 yarn serve App running at: Local: http://localhost:8080/ Network: unavailable 这里就会得到新的 IP ，如果没有新的，可能是因为是公司网络，禁止的问题，权限验证的问题。2.如果不是 vue 的网络环境，就是 webpack 的配置问题，其他问题？？就要 清除浏览器历史记录和缓存，或者是其他的操作来解决问题。 Google Chrome 浏览器清除历史记录和缓存：1.这里是全部网站：转到“自定义和控制”（Chrome 浏览器右上角） – &gt;然后单击“设置” – &gt;单击下面的“显示高级设置”按钮 – &gt;然后到“隐私”部分 – &gt;点击“清除浏览数据”按钮 – &gt;检查新弹出窗口中的所有框2.单个网站的清除：打开 审查，之后地址栏前面的圆圈右键就可以直接清除并且重载当前页面。 延伸学习： WDS 即 Wireless Distribution System，是无线网络部署延展系统的简称，指用多个无线网络相互联结的方式构成一个整体的无线网络。简单地说，WDS就是利用两个(或以上)无线宽带路由器/AP通过相互连接的方式将无线信号向更深远的范围延伸。利用WDS技术，AP之间可以舍弃传统的有线网络进行互联，每个AP可以作主设备、中继设备和远端设备。 而在 vue 中 WDS 指的是 webpack-dev-server ，学习 webpack-dev-server 原理分析与 HMR 实现。支持无刷新更新数据，也就是实现了我们更新代码，浏览器端就可以立即看到代码的效果改变了，热重载。 webpack-dev-server 在我们的 entry 中添加的 hot 模块内容（热重载 模块）,更多资料可以学习此篇文章:webpack-dev-server 原理分析与 HMR 实现. 当客户端接受到服务器端发送的 ok 和 warning 信息的时候，同时支持HMR的情况下就会要求检查更新，同时发送过来的还有服务器端本次编译的 hash 值。我们继续深入一步，看看服务器什么时候发送 ’ok’ 和 ’warning’ 消息：也就是每次 compiler的 ’done’ 钩子函数被调用的时候就会要求客户端去检查模块更新，进而完成 HMR 基本功能！ 简单的说就是，我们在配置好的框架下，修改代码，保存文件，触发监视和热加载，浏览器更新。 四、iview 的错误4.1 message 通知 在 main.js 的使用!!!!!!!!!!!!!!!!123456//在 .vue 文件中使用是this.$Notice.open(config)this.$Notice.info(config)this.$Notice.success(config)this.$Notice.warning(config)this.$Notice.error(config) 但是在 main.js 中就不是这样使用的了， 123456789101112131415161718192021222324252627282930313233343536373839404142import Vue from 'vue'import App from './App.vue'import router from './router'import store from './store'import &#123; Message&#125; from 'iview' // Message 一定要以 ES6 这样的方式来引入，不能去掉花括号，不然就错了import iView from 'iview'import 'iview/dist/styles/iview.css'import axios from 'axios'Vue.config.productionTip = falseVue.use(iView); //全局使用iview//。。。。。。。省略一串代码，具体可以去看 axios 拦截器// 响应拦截axios.interceptors.response.use((res) =&gt; &#123; return res;&#125;, (error) =&gt; &#123; console.error('response interceptor: ', error) var status = error.response.status if (status) &#123; switch (status) &#123; case 401: Message.error(\"登录 token 过期，请重新登录\") // 但是在这里不要用 this，因为它就不是 vue 实例 // 并且该文件是直接引入 import router from './router' ，当然可以直接的就使用 router 了！！！！！！！！！！！！！！！！！1 router.push('/login'); &#125; &#125; return Promise.reject(error);&#125;)new Vue(&#123; router,// 因为这里的注册，在 .vue 文件才可以使用 this.$router.push store, render: h =&gt; h(App)&#125;).$mount('#app') 特别严重的错误，因为 Message.error(“登录 token 过期，请重新登录”) 这一句代码的不正确，导致路由不能实现跳转登录页面！！！！！这里是 iview-ui，那个 element-ui 也是一样的道理，差不多的方法来解决这个 main.js 使用 Message 通知的问题！！！！！！！！！！ 4.2 router 在 main.js 的使用123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue'import App from './App.vue'import router from './router' // 这里导入 router，那么再本页面使用的就是 router 了啦。import store from './store'import &#123; Message&#125; from 'iview'import iView from 'iview'import 'iview/dist/styles/iview.css'import axios from 'axios'Vue.config.productionTip = falseVue.use(iView);//。。。。。。。省略一串代码，具体可以去看 axios 拦截器// 响应拦截axios.interceptors.response.use((res) =&gt; &#123; return res;&#125;, (error) =&gt; &#123; console.error('response interceptor: ', error) var status = error.response.status if (status) &#123; switch (status) &#123; case 401: Message.error(\"登录 token 过期，请重新登录\") router.push('/login'); //页面跳转，router.replace 不会计入 history // 在 .vue 的 js 中用的是 this.$router.replace('/login') // 但是在这里不要用 this，因为它就不是 vue 实例 // 并且该文件是直接引入 import router from './router' ，当然可以直接的就使用 router 了！！！！！！！！！！！！！！！！！1 &#125; &#125; return Promise.reject(error);&#125;)//。。。。。。。省略一串代码","tags":[]},{"title":"react-native.js--手机端框架-入门教程","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑥ -【react-native.js 框架 】-react-native.js 框架/","text":"一、前言react native.js 是 react.js 的升级版本。它是做 app 用的，也兼容 pc 端，但是应该还是不要深入这个吧？把 react.js 学习一下好。 react native 中文官网","tags":[]},{"title":"vue.js--事件 以及 vue 中的所有修饰符学习","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-事件/","text":"一、前言二、事件触发2.1 v-on 事件绑定指令官网地址： v-on 就是监听事件，可以用v-on指令监听DOM事件来触发一些javascript代码。语法：v-on:click=&quot;函数变量&quot;用@简写的语法：@click=&quot;函数变量&quot;键盘回车事件v-on:keyup.enter=&quot;函数&quot; 2.2 事件触发-不传参12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-text=\"massage\"&gt;&lt;/p&gt; &lt;button v-on:click=\"add\"&gt;点击massage自增&lt;/button&gt; &lt;button @click=\"subtract\"&gt;点击massage自减&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; massage: 60, &#125;, methods: &#123; add: function () &#123; this.massage++; &#125;, subtract: function () &#123; this.massage--; &#125; &#125; &#125;) &lt;/script&gt; 效果展示： 2.3 事件触发-传参1234567891011121314&lt;div id=\"app\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;)&lt;/script&gt; 2.4 特殊变量 $event12345678910111213&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt;&lt;script&gt; // ... methods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125; &#125;&lt;/script&gt; 三、事件修饰3.1 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop.prevent.capture.self.once.passive 12345678910111213141516171819202122&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 阻止单击事件继续传播 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 修饰符可以串联 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 只有修饰符 --&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;!-- 尤其能够提升移动端的性能。 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 3.2 按键修饰符3.2.1 keycode（keyCode 的事件用法已经被废弃了并可能不会被最新的浏览器支持。）keycode 是数字代码，（例如，enter 键的 keycode 是 13 ）但是要记住这里数字是很困难的，这时候我们就会有别名的存在。 1&lt;input v-on:keyup.13=\"submit\"&gt; &lt;!--这个是 keycode 的方法，但是现在不要用了，已经被废弃了的。 --&gt; 3.2.2 keycode 别名(为了在必要的情况下支持旧浏览器，Vue 提供了绝大多数常用的按键码的别名：)123456789101112@keyup.enter # 回车键@keyup.tab # tab 键@keyup.delete # 捕获“删除”和“退格”键)@keyup.esc # 退出@keyup.space # 空格键@keyup.up # 向上@keyup.down # 向下@keyup.left # 后退@keyup.right # 前进@keyup.arrow-right@keyup.media-play-pause # 暂停@keyup.v # V 字母键 12345678&lt;!-- 下面的 3 行代码是等效的（前提是没有全局配置别名的时候） --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; &lt;!--这个是 keycode 的方法，但是现在不要用了，已经被废弃了的。 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;input @keyup.enter=\"submit\"&gt;&lt;input type=\"text\" @keyup.media-play-pause=\"method\"&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.right=\"handleSubmit\" /&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.arrow-right=\"handleSubmit\" /&gt; 3.3 系统修饰键.ctrl.alt.shift.meta 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17 123456789101112131415161718&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt;&lt;!-- .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 --&gt;&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=\"onClick\"&gt;A&lt;/button&gt; 3.4 鼠标按钮修饰符.left.right.middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 1&lt;button @click.right=\"shout(1)\"&gt;ok&lt;/button&gt; 四、拓展vue 中的所有修饰符的学习RR","tags":[]},{"title":"JavaScript 数据结构与算法【1】--[入门版]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑬ -数据结构与算法-JS-入门/","text":"一、 前言学习数据结构与算法是每一个前端与后端设计人员必需的。学会数据结构将会拓展我们的思维，让我们拥有有效的解决业务需求的能力。 名称是 数据结构与算法 那么我们需要学习的就是一些 数据结构 以及 算法 二、 JavaScript 以及 ES6关于 JavaScript 的基本知识 以及 ES6语法的学习。网址： 三、 数据结构3.1 数组 Array数组是编程语言的内建类型，通常效率很高，可以满足不同需求的数据存储。 3.1.1 数组的标准定义数组的标准定义：一个存储元素的 线性集合，元素可以通过 索引 任意存储数据。索引通常是数字，用来计算元素之间的存储位置的偏移量。 JavaScript 中的数组与其他语言不同， JavaScript 中的数组是一种特殊的对象 ，用来表示偏移量的 索引 是该对象的 属性。索引可能是整数，但是这些 数字索引在内部被转换为字符串类型 ，因为 JavaScript 对象中的属性必须是字符串 。 由于 JavaScript 中的数组只是一种特殊的对象，所以效率上不如其他的语言中的数组高。JavaScript 中的数组，严格来说应该被称为对象，是 JavaScript 中的特殊对象，在内部被归类为数组。数组的长度可以任意的增长，超出其创建时指定的长度。length 属性指的是当前数组中元素的个数。 由于 Array 在 JavaScript 中被当作对象，因此它有许多属性和方法可以在编程时使用。 3.1.2 数组的创建 [] new Array()1234567var arr=[] // 通过操作符[]来创建var arr=[1,2,3,4,5] // 通过操作符创建并且初始化元素var arr=new Array() // 通过构造函数创建var arr=new Array(1,2,3,4,5) // 通过构造函数创建并且初始化元素var arr=new Array(137) // 通过构造函数创建并且初始化长度 （只传入一个参数就作为数组的长度）// 使用操作符 [] 来初始化更为高效 3.1.3 数组的属性 Array.lengthlength 是 Array 的实例属性。返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。 3.1.4 数组的属性 Array.prototype表示 Array 构造函数的原型，并允许您向所有Array对象添加新的属性和方法。Array.prototype 本身也是一个 Array ， Array.isArray(Array.prototype); // true 1234567891011/* 如果JavaScript本身不提供 first() 方法， 添加一个返回数组的第一个元素的新方法。*/if(!Array.prototype.first) &#123; Array.prototype.first = function() &#123; console.log(`如果JavaScript本身不提供 first() 方法，添加一个返回数组的第一个元素的新方法。`); return this[0]; &#125;&#125; 3.1.5 Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。 12345console.log(Array.from('foo'));// expected output: Array [\"f\", \"o\", \"o\"]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6] 3.1.6 Array.isArray() 方法用于确定传递的值是否是一个 Array。当检测Array实例时, Array.isArray 优于 instanceof,因为Array.isArray能检测iframes. 123456//方法的创建if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125; 12345678910111213141516Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(\"foobar\"); // falseArray.isArray([]); // trueArray.isArray([1]); // trueArray.isArray(new Array());// trueArray.isArray(Array.prototype);// true Array.prototype 也是一个数组。它的 length 为 0Array.isArray(); // falseArray.isArray(&#123;&#125;); // falseArray.isArray(null); // falseArray.isArray(undefined); // falseArray.isArray(17); // falseArray.isArray('Array'); // falseArray.isArray(true); // falseArray.isArray(false); // falseArray.isArray(&#123; __proto__: Array.prototype &#125;); // false 3.1.3 字符串与数组之间的转化 str.split() Array.toString() Array.json()123456789101112var sentance = 'I am what i am !'var arr=sentance.split(' ') // 以字符串中的某个字符来切分字符串，返回一个数组var str=arr.toString() //不需要传参，得到字符串是数组中每项以逗号连接var str2=arr.json() //如果没有传参，得到字符串是数组中每项以逗号连接var str3=arr.json('') //传入参数作为连接符号var str4=arr.json(' ') //传入参数作为连接符号// arr=['I','am','what','i','am','!']// str='I,am,what,i,am,!'// str2='I,am,what,i,am,!'// str3='Iamwhatiam!'// str4='I am what i am !' 3.1.4 查找元素 indexOf() 与 lastIndexOf()1234var arr=['xiaomi','liu','liuxiaomi','liuliuliu','liu']arr.indexOf('liu') // 1 从前往后查找第一个arr.lastIndexOf('liu') // 4 从后往前查找第一个arr.indexOf('mei') // -1 找不到的话就返回 -1 3.1.5 已知数组得到新数组 Array.contact(array,item1,item2…) splice(index,n,item1,item2…)Array.contact(array,item1,item2…) 12345678var arr = [\"Mike\", \"Clayton\", \"Terrill\", \"Danny\", \"Jennifer\"]var arr2 = [\"Raymond\", \"Cynthia\", \"Bryan\"]var newArr = arr.concat(arr2)console.log(arr) //\"Mike,Clayton,Terrill,Danny,Jennifer\" 就是原数组不会被改变console.log(newArr) //\"Mike,Clayton,Terrill,Danny,Jennifer,Raymond,Cynthia,Bryan\" 得到的新数组var newArr2 =arr.concat('xiaomi',2) //可以连接数组用可以直接连接项console.log(newArr2) //Mike,Clayton,Terrill,Danny,Jennifer,xiaomi,2 splice(index,n,item1,item2…) 原数组会被改变 123456789101112131415var arr = [\"Mike\", \"Clayton\", \"Terrill\", \"Danny\", \"Jennifer\"]var newArr = arr.slice(1)var newArr2 = arr.splice(1) // 表示从索引为 1 删除到最后一个console.log(arr) // Mike 原数组被改变了console.log(newArr2) // Clayton,Terrill,Danny,Jennifer 得到的新数组（为被删除的项组成）var newArr3 = newArr2.splice(1,1,'xiaomi','zihua') //console.log(newArr2) // Clayton,xiaomi,zihua,Danny,Jennifer 第二项被删除了然后加入两项console.log(newArr3) // Terrill 得到的新数组是被删除的项组成的//该函数方法与有 3 以上 个参数，开始索引 删除的长度/元素个数 后面的是添加的项 arr.splice(start); // [start, end] 只有一个参数表示，从该下标删除到后面一个arr.slice(begin); // [start, count] 只有 2 个参数，表示从 start 处 删除 count 个元素arr.slice(begin, end); // [start,count,item1,item2...] 表示从 start 处 删除 count 个元素，并且插入元素 item1,item2... slice(start，end) 原数组不会改变，只是获取数组切片 12345678var arr = [\"Mike\", \"Clayton\", \"Terrill\", \"Danny\", \"Jennifer\"]console.log(arr) // Mike,Clayton,Terrill,Danny,Jennifer 就是原数组不会被改变console.log(newArr) // Clayton,Terrill,Danny,Jennifer 得到的新数组//该函数方法与有两个参数，开始索引与结束索引arr.slice(); // [0, end] 没有参数表示获取数组的全部元素arr.slice(begin); // [start, end] 只有一个参数，参数表示开始索引 取到最后一项，包括最后一项arr.slice(begin, end); // [start, end) 两个参数，表示开始索引 取到最后一项，但是不包括最后一项，为半闭区间 3.2 列表3.2.1 列表的定义列表是一组有序的数据。每个列表中的数据项称为元素。在 JavaScript 中，列表中的元素可以是任意数据类型。列表中可以保存多少元素并没有事先限定，实际使用时元素的数量受到程序内存的限制。 3.2.2 列表的应用场景待办事项列表、购物清单、十佳榜单、最后十名榜单等 3.2.3 列表的属性与方法3.2.3 列表的创建3.3 栈3.3.1 栈的定义3.3.2 栈的应用场景3.3.3 栈的属性与方法3.3.3 栈的创建3.4 队列3.4.1 队列的定义3.4.2 队列的应用场景3.4.3 队列的属性与方法3.4.3 队列的创建3.5 链表3.5.1 链表的定义3.5.2 链表的应用场景3.5.3 链表的属性与方法3.5.3 链表的创建3.6 字典3.6.1 字典的定义3.6.2 字典的应用场景3.6.3 字典的属性与方法3.6.3 字典的创建3.7 散列3.7.1 散列的定义3.7.2 散列的应用场景3.7.3 散列的属性与方法3.7.3 散列的创建3.8 集合 Set3.8.1 集合的定义3.8.2 集合的应用场景3.8.3 集合的属性与方法3.8.3 集合的创建3.9 树3.9.1 树的定义 、二叉查找树的定义树的定义树由一组以边连接的节点组成。公司的组织结构图就是一个树的例子。树是一种非线性的数据结构，以分层的方式存储数据。树被用来 存储具有层级关系的数据，比如 文件系统中的文件；树还被用来存储 有序列表。 根节点：一棵树最上面的节点称为根节点 父节点：如果一个节点下面连接多个节点，那么该节点称为父节点 子节点：父节点下面的节点称为子节点，一个节点可以有 0 个、1 个或多个子节点。 叶子节点：没有任何子节点的节点称为叶子节点。 路径：从一个节点到另一个节点的这一组边称为路径 边：两点之间连线为边，（边构成路径） 树的遍历：在图中用虚线表示。以某种特定顺序访问树中所有的节点称为树的遍历。 层次：树可以分为几个层次，根节点是第 0 层，它的子节点是第 1 层，子节点的子节点是第 2 层，以此类推。 宽度：（二叉查找树中）具有最多结点数的层中包含的结点数。 深度：我们定义树的层数就是树的深度，数有多少层，深度就是多少 左子树：根节点的左子节点以及延伸的子节点 右子树：根节点的右子节点以及延伸的子节点 左节点：（二叉查找树中）一个父节点的左边子节点 右节点：（二叉查找树中）一个父节点的右边子节点 树中任何一层的节点可以都看做是子树的根，该子树包含根节点的子节点，子节点的子节点等 键：每个节点都有一个与之相关的值，该值有时被称为键。 二叉查找树的定义 （英语：Binary Search Tree）二叉树是一种特殊的树，它的子节点个数不超过两个,左节点比父节点小，右节点比父节点大.二叉树非常适合于范围查找， 查找树的定义非常简单.，还有一个特性就是’中序遍历’可以让结点有序。可以写出高效的程序在树中插入、查找和删除数据。二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。 3.9.2 树的属性与方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166//二叉树节点类 BSTNodefunction BSTNode(data,left, right) &#123; this.data = data; //保存数据 this.count = 1 //保存数据出现的次数，记录相同数据出现的次数(这个属性需要的话就写，不需要的话不写，初始化为 1 ) this.left = left; //保存左节点链接 this.right = right; //保存右节点链接 this.show = function show() &#123; //显示保存在节点中的数据。 return this.data; &#125;&#125;// BST 二叉查找树function BST() &#123; this.rootNode = null //将 BST 类的根节点定义为 null 空节点 this.insert = function insert(data) &#123; // 插入数据 let newNode = new Node(data, null, null) //传参 data 构造待插入节点 if (this.rootNode == null) &#123; this.rootNode = newNode // 如果根节点为空，插入的节点赋值给根节点 &#125; else &#123; let currentNode = this.rootNode // 定义当前节点为根节点 开始循环遍历树 let parentNode //一定要弄个中间变量 while (true) &#123; parentNode = currentNode //将当前节点保存为父节点 if (data &lt; currentNode.data) &#123; currentNode = currentNode.left if (currentNode == null) &#123; //如果当前左节点为 空节点 那就让将插入的新节点赋值给父节点的左子节点 parentNode.left = newNode break &#125; &#125; else &#123; currentNode = currentNode.right if (currentNode == null) &#123; parentNode.right = newNode break &#125; &#125; &#125; &#125; &#125; // 前后中 就是看根节点的顺序了，左一直在右的前面就对了！！！！ // 中序：那么就是根节点在中间 也就是 左-根-右 this.inOder = function inOder(node) &#123; if (!(node == null)) &#123; arguments.callee(node.left) putstr(node.show() + ' ') //后续其他的功能只要在这里更新这个语句就好了 arguments.callee(node.right) &#125; &#125; // 前序/先序：那么就是根节点在先/前 也就是 根-左-右 this.prevOder = function prevOder(node) &#123; if (!(node == null)) &#123; putstr(node.show() + ' ') //后续其他的功能只要在这里更新这个语句就好了 arguments.callee(node.left) arguments.callee(node.right) &#125; &#125; // 后序：那么就是根节点在后 也就是 左-右-根 this.postOder = function postOder(node) &#123; if (!(node == null)) &#123; arguments.callee(node.left) arguments.callee(node.right) putstr(node.show() + ' ') //后续其他的功能只要在这里更新这个语句就好了 &#125; &#125; //最大值一定是在 右节点的最后一个 this.getMax = function getMax() &#123; let currentNode = this.rootNode while (currentNode.right != null) &#123; currentNode = currentNode.right &#125; return currentNode.data //返回当前节点的数据 &#125; //最小值一定是在 左节点的最后一个 this.getMin = function getMin() &#123; let currentNode = this.rootNode while (currentNode.left != null) &#123; currentNode = currentNode.left &#125; return currentNode.data &#125; //查找给定值，返回它的节点，若不存在返回 null this.findData = function findData(data) &#123; let currentNode = this.rootNode while (currentNode != null) &#123; if (data = currentNode.data) &#123; return currentNode //相等，返回当前节点，结束循环 &#125; else if (data &gt; currentNode.data) &#123; currentNode = currentNode.right // 赋值右节点 进入下一个循环 &#125; else &#123; currentNode = currentNode.left // 赋值左节点 进入下一个循环 &#125; &#125; return null //上面的循环没有找到值，没有 return 没有找到值就会执行到这条语句返回一个 null &#125; this.removeNode = function removeNode(data) &#123; // 这个不知道怎么做，书上的是错误的，？？？？？？？？？？？？？？ &#125; this.removeData = function removeData() &#123; // 这个不知道怎么做，书上的是错误的，？？？？？？？？？？？？？？？ &#125; //用于更新节点中的 count ,并返回修改之后的 节点 this.update = function update(data) &#123; let dataNode = this.findData(data) dataNode.count++ return dataNode &#125; // 递归方法：求数结构中节点的个数 ,最初传入的参数为根节点 this.getNodeCount = function getNodeCount(node) &#123; if (node == null) &#123; return 0 &#125; //根节点不为空，返回 左子树递归 + 右子树递归 + 根节点 //递归到叶子节点之后就是 0 + 0 + 1,啦 return arguments.callee(node.left) + arguments.callee(node.right) + 1 &#125; // 遍历方法：可以用遍历方法来计算节点数么 // 需要传入一个 a=&#123;count:0&#125; 变量，传进来的不能只是 count=0 // 值传递不会改变原值，引用传递可以改变原值，这样原来的 count 属性才会被改变，这个方法比上面的递归麻烦多了！！！/* this.getNodeCount = function getNodeCount(node, a) &#123; if (!(node == null)) &#123; arguments.callee(node.left, a) a.count = a.count + 1 arguments.callee(node.right, a) &#125; &#125; */ // 递归方法：求数结构中边的个数 this.getSideCount = function getSideCount(node) &#123; if (node == null) &#123; return 0 &#125; // 中间变量 t var t =0 if(node.left !=null) t++ // 左子节点存在那么 边 +1 if(node.right !=null) t++ // 右子节点存在那么 边 +1 // 最后返回的是 左子树边 + 右子树边 + 该节点的边 t return arguments.callee(node.left) + arguments.callee(node.right) + t &#125;&#125;// 调用 二叉树类 处理数据var bst1 = new BST()bst1.insert(23)bst1.insert(45)bst1.insert(16)bst1.insert(37)bst1.insert(3)bst1.insert(99)bst1.insert(22)bst1.inOder(bst1.rootNode)//bst1.prevOder(bst1.rootNode)//console.log(bst1.getNodeCount(bst1.rootNode)) //7 直接调用的是递归函数/* var a = &#123;count: 0&#125; //这个方法看出来是没有直接递归的好用的bst1.getNodeCount(bst1.rootNode, a)console.log(a.count) //7 */ 3.9.2.1 求二叉树第K层的节点个数递归解法：（1）如果二叉树为空或者k&lt;1返回0（2）如果二叉树不为空并且k==1，返回1（3）如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和参考代码如下： 123456789int GetNodeNumKthLevel(BinaryTreeNode * pRoot, int k)&#123; if(pRoot == NULL || k &lt; 1) return 0; if(k == 1) return 1; int numLeft = GetNodeNumKthLevel(pRoot-&gt;m_pLeft, k-1); // 左子树中k-1层的节点个数 int numRight = GetNodeNumKthLevel(pRoot-&gt;m_pRight, k-1); // 右子树中k-1层的节点个数 return (numLeft + numRight); 3.9.2.2 求二叉树中叶子节点的个数递归解法：（1）如果二叉树为空，返回0（2）如果二叉树不为空且左右子树为空，返回1（3）如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数参考代码如下： 12345678910int GetLeafNodeNum(BinaryTreeNode * pRoot)&#123; if(pRoot == NULL) return 0; if(pRoot-&gt;m_pLeft == NULL &amp;&amp; pRoot-&gt;m_pRight == NULL) return 1; int numLeft = GetLeafNodeNum(pRoot-&gt;m_pLeft); // 左子树中叶节点的个数 int numRight = GetLeafNodeNum(pRoot-&gt;m_pRight); // 右子树中叶节点的个数 return (numLeft + numRight);&#125; https://blog.csdn.net/luckyxiaoqiang/article/details/7518888#topic6 3.9.3 树的应用场景3.9.3.1 二叉查找树：查找速度的应用/树的查找是很快的后台给的 tree 数据怎么渲染到 tree 组件里？一般来说后端是不会给这个复杂的结构数据的，只会给简单的，数组，对象数组，这些简单的数据结构类型数据。有时候还是会存在复杂的数据结构的。 3.9.3.2 二叉查找树：（计数）记录考试成绩的分布BST 二叉查找树：记录一组数据集中数据出现的次数：例如记录考试成绩的分布 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176function Node(data, left, right) &#123; this.data = data; //保存数据 this.count = 1 //保存数据出现的次数，记录相同数据出现的次数 this.left = left; //保存左节点链接 this.right = right; //保存右节点链接 this.show = function show() &#123; //显示保存在节点中的数据。 return this.data; &#125;&#125;// BST 二叉查找树function BST() &#123; this.rootNode = null //将 BST 类的根节点定义为 null 空节点 this.insert = function insert(data) &#123; // 插入数据 let newNode = new Node(data, null, null) //传参 data 构造待插入节点 if (this.rootNode == null) &#123; this.rootNode = newNode // 如果根节点为空，插入的节点赋值给根节点 &#125; else &#123; let currentNode = this.rootNode // 定义当前节点为根节点 开始循环遍历树 let parentNode //一定要弄个中间变量 while (true) &#123; parentNode = currentNode //将当前节点保存为父节点 if (data &lt; currentNode.data) &#123; currentNode = currentNode.left if (currentNode == null) &#123; //如果当前左节点为 空节点 那就让将插入的新节点赋值给父节点的左子节点 parentNode.left = newNode break &#125; &#125; else &#123; currentNode = currentNode.right if (currentNode == null) &#123; parentNode.right = newNode break &#125; &#125; &#125; &#125; &#125; // 前后中 就是看根节点的顺序了，左一直在右的前面就对了！！！！ // 中序：那么就是根节点在中间 也就是 左-根-右 this.inOder = function inOder(node) &#123; if (!(node == null)) &#123; arguments.callee(node.left) putstr(node.show() + ' ') //后续其他的功能只要在这里更新这个语句就好了 arguments.callee(node.right) &#125; &#125; // 前序/先序：那么就是根节点在先/前 也就是 根-左-右 this.prevOder = function prevOder(node) &#123; if (!(node == null)) &#123; putstr(node.show() + ' ') //后续其他的功能只要在这里更新这个语句就好了 arguments.callee(node.left) arguments.callee(node.right) &#125; &#125; // 后序：那么就是根节点在后 也就是 左-右-根 this.postOder = function postOder(node) &#123; if (!(node == null)) &#123; arguments.callee(node.left) arguments.callee(node.right) putstr(node.show() + ' ') //后续其他的功能只要在这里更新这个语句就好了 &#125; &#125; //最大值一定是在 右节点的最后一个 this.getMax = function getMax() &#123; let currentNode = this.rootNode while (currentNode.right != null) &#123; currentNode = currentNode.right &#125; return currentNode.data //返回当前节点的数据 &#125; //最小值一定是在 左节点的最后一个 this.getMin = function getMin() &#123; let currentNode = this.rootNode while (currentNode.left != null) &#123; currentNode = currentNode.left &#125; return currentNode.data &#125; //查找给定值，返回它的节点，若不存在返回 null this.findData = function findData(data) &#123; let currentNode = this.rootNode while (currentNode != null) &#123; if (data == currentNode.data) &#123; return currentNode //相等，返回当前节点，结束循环 &#125; else if (data &gt; currentNode.data) &#123; currentNode = currentNode.right // 赋值右节点 进入下一个循环 &#125; else &#123; currentNode = currentNode.left // 赋值左节点 进入下一个循环 &#125; &#125; return null //上面的循环没有找到值，没有 return 没有找到值就会执行到这条语句返回一个 null &#125; /* this.removeNode = function removeNode(data) &#123; if (this.findData(data) != null) &#123; &#125; &#125; this.removeData = function removeData() &#123; &#125; */ //用于更新节点中的 count ,并返回修改之后的 节点 this.update = function update(data) &#123; let dataNode = this.findData(data) dataNode.count++ return dataNode &#125; // 递归方法：求数结构中节点的个数 ,最初传入的参数为根节点 this.getNodeCount = function getNodeCount(node) &#123; if (node == null) &#123; return 0 &#125; //根节点不为空，返回 左子树递归 + 右子树递归 + 根节点 //递归到叶子节点之后就是 0 + 0 + 1,啦 return arguments.callee(node.left) + arguments.callee(node.right) + 1 &#125; // 遍历方法：可以用遍历方法来计算节点数么 // 需要传入一个 a=&#123;count:0&#125; 变量，传进来的不能只是 count=0 // 值传递不会改变原值，引用传递可以改变原值，这样原来的 count 属性才会被改变，这个方法很麻烦，不要用这个方法/* this.getNodeCount = function getNodeCount(node, a) &#123; if (!(node == null)) &#123; arguments.callee(node.left, a) a.count = a.count + 1 arguments.callee(node.right, a) &#125; &#125; */ // 递归方法：求数结构中边的个数 this.getSideCount = function getSideCount(node) &#123; if (node == null) &#123; return 0 &#125; // 中间变量 t var t = 0 if (node.left != null) t++ // 左子节点存在那么 边 +1 if (node.right != null) t++ // 右子节点存在那么 边 +1 // 最后返回的是 左子树边 + 右子树边 + 该节点的边 t return arguments.callee(node.left) + arguments.callee(node.right) + t &#125;&#125;var grades = [88, 90, 100, 90, 99, 81, 90, 56, 34, 66, 77, 55, 77, 88, 55, 44, 22, 66, 99, 78, 98, 90, 56, 34, 23, 53, 64, 47, 87]var gradesBST = new BST()// 将分数数组加入到 BST 中，如果已经存在就更新节点 ，不存在就插入节点for (let grade of grades) &#123; if (gradesBST.findData(grade) == null) &#123; gradesBST.insert(grade) &#125; else &#123; gradesBST.update(grade) &#125;&#125;//输出显示当前拥有的分数:调用任意一个遍历来输出gradesBST.inOder(gradesBST.rootNode) //怎么只是输出 88 跟节点呢？// 键盘输入分数检验分数出现的次数var cont = 'yes'while (cont == 'yes') &#123; putstr('\\n please enter a grade:') //提示键盘输入分数 let grade = parseInt(readline()) //读取键盘输入的数据转化为 整数复制给 grade if (gradesBST.findData(grade) == null) &#123; console.log('No occurrences of ' + grade) &#125; else &#123; console.log('Occurrences of ' + grade + ':' + gradesBST.findData(grade).count) &#125;&#125; 3.9.3.3 二叉查找树：（计数）记录一段文本中各个单词出现的次数BST 二叉查找树：记录一组数据集中数据出现的次数：例如一段文本中各个词出现的次数 3.10 图3.10.1 图的定义图由 边的集合 及 顶点的集合 组成。图是一种复杂的 非线性结构。而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。图G由两个集合V(顶点Vertex)和E(边Edge)组成，定义为G=(V，E) 例如：地图 每两个城镇都由某种道路相连。地图，就是一种图，上面的每个 城镇可以看作一个 顶点，连接城镇的 道路便是边。 顶点：v1 和 v2 分别是图中的两个顶点， 边：顶点对(v1,v2) 表示边。简单就是两点之间的连线是边 权重：顶点也有权重，也称为成本。 有向图：顶点对是有序的，如果一个图的顶点对是有序的，则可以称之为有向图，有向图表明了顶点的流向 流向：在对有向图中的顶点对排序后，便可以在两个顶点之间绘制一个箭头。有向图表明了顶点的流向。 无向图：如果图是无序的，则称之为无序图，或无向图当然也就没有 流向了。 路径：一个顶点到另一个顶点经过的边集合。图中的一系列顶点构成路径, 路径长度，是指一条路径上经过的边的数量，用路径中第一个顶点到最后一个顶点之间边的数量表示 回路/环：指一条路径的起点和终点为同一个顶点。由指向自身的顶点组成的路径称, 环的长度为0 图: 图由边的集合及顶点的集合组成 圈: 是至少有一条边的路径，且路径的第一个顶点和最后一个顶点相同 简单圈: 无论是有向图还是 无向图，只要是没有重复边或重复顶点的圈 平凡圈: 除了第一个和最后一个顶点以外（区别于环），路径的其他顶点有重复的圈 如果两个顶点之间有路径，那么这两个顶点就是强连通的，反之亦然。如果有向图的所有 的顶点都是强连通的，那么这个有向图也是强连通的 3.10.2 图的应用场景用图对现实中的系统建模比如对交通流量建模，顶点可以表示街道的十字路口，边表示街道。加权的边可以表示限速或者车道的数量。建模人员可以用这个系统来判断最佳路线及最有可能堵车的街道。 任何运输系统都可以用图来建模。比如，航空公司可以用图来为其飞行系统建模。将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。加权的边可以看作从一个机场到另一个机场的航班成本，或两个机场之间的距离，这取决与建模的对象是什么。 包含局域网和广域网（如互联网）在内的计算机网络，同样经常用图来建模。 另一个可以用图来建模的实现系统是消费市场，顶点可以用来表示供应商和消费者。 3.10.3 图的属性与方法3.10.3 图的创建四、 算法4.1 图算法见第 3.10 节 4.2 排序算法4.2.1 简单排序4.2.1.1 冒泡排序（简单排序）冒泡排序原理：数组中有 n 个数，比较每相邻两个数，如果前者大于后者，就把两个数交换位置；第一轮就可以选出一个最大的数放在最后面；下一轮不需要比较它了第二轮第二大的数字就会在倒数第二个位置;下一轮也不需要比较它了………也就是说那么经过 n-1（数组的 length - 1） 轮，就可以完成所有数的排序。 外层用来递增排序轮次（总需要比较 n-1 轮），内层循环用来比较替换位置，将本轮最大的数字放到最后 1234567891011121314151617181920212223242526272829303132333435363738// 冒泡排序function bubbleSort(arr) &#123; let n = arr.length for (let i = 0; i &lt; n - 1; i++) &#123; // 内层循环用来比较：每轮比较之后最后一个数字肯定是最大的数 // 每轮循环都不需要比较最后一项，因此 j &lt; (n - 1 - i) ，每轮少比较后面 i 个元素 for (let j = 0; j &lt; (n - 1 - i); j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; //swap(arr, j, j+1) 这里可以在外面写一个交换位置函数 let t = arr[j] arr[j] = arr[j+1] arr[j+1] = t &#125; &#125; console.log(arr.toString()); // 将每轮的结果输出，需要观察的时候写上这句代码 &#125;&#125;var nums = [10, 8, 3, 2, 2, 4, 9, 5, 4, 3]bubbleSort(nums)/* 结果λ js eg-chapter12.1.js8,3,2,2,4,9,5,4,3,103,2,2,4,8,5,4,3,9,102,2,3,4,5,4,3,8,9,102,2,3,4,4,3,5,8,9,102,2,3,4,3,4,5,8,9,102,2,3,3,4,4,5,8,9,102,2,3,3,4,4,5,8,9,102,2,3,3,4,4,5,8,9,102,2,3,3,4,4,5,8,9,10*/// 数组元素交换函数function swap(arr, index1, index2) &#123; let t = arr[index1] arr[index1] = arr[index2] arr[index2] = t&#125; 4.2.1.2 选择排序（简单排序）选择排序原理：数组中有 n 个数，选择数组中最小值放到前面第一轮就可以选出一个最小的数放在最第 0 索引；下一轮不需要管他了第二轮第二小的数字就会在第 1 索引;下一轮也不需要比较它了………也就是说那么经过 n-1（数组的 length - 1） 轮，就可以完成所有数的排序。 找到数组最小的元素，将它和数组红第一个元素交换位置，接下来，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，往复如此，直到将整个数组排序。基本点就是不断地选择剩余元素之中的最小者。 123456789101112131415161718192021222324252627282930313233343536373839function swap(arr, index1, index2) &#123; let t = arr[index1] arr[index1] = arr[index2] arr[index2] = t&#125;// 选择排序function selectSort(arr) &#123; let n = arr.length // 循环比较 n-1 次就可以完成排序，外层用来递增排序轮次，也就是找到第 i 位置处应该放的 对应轮次最小值 for (let i = 0; i &lt; n - 1; i++) &#123; // 内层循环用来比较：每轮比较之后最前面一个数字肯定是最小的数 // 每轮循环都不需要比较前面的项，因此 j &lt; (n - 1 - i) let min = i // 内循环求最小值 赋值给索引 i 位置，先假设 i 位置就是最小值 for (let j = i + 1; j &lt; n; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j &#125; &#125; swap(arr, i, min) // 将上面的最小值与 本轮索引 i 位置交换 console.log(arr.toString()); // 将每轮的结果输出，需要观察的时候写上这句代码 &#125;&#125;var nums = [10, 8, 3, 2, 2, 4, 9, 5, 4, 3]selectSort(nums)/* 结果λ js eg-chapter12.2.js2,8,3,10,2,4,9,5,4,32,2,3,10,8,4,9,5,4,32,2,3,10,8,4,9,5,4,32,2,3,3,8,4,9,5,4,102,2,3,3,4,8,9,5,4,102,2,3,3,4,4,9,5,8,102,2,3,3,4,4,5,9,8,102,2,3,3,4,4,5,8,9,102,2,3,3,4,4,5,8,9,10 */ 4.2.1.3 插入排序/简单插入排序（简单排序）插入排序原理：数组中有 n 个数，将无序数列中的元素插入到有序数列的对应位置，插入前通过比大小的方式找到其在有序数列中的对应位置。第一轮索引 0 元素是有序的，带插入的元素为 索引 1 的元素， 将索引 1 元素值与前面已经排序好的 索引 0 元素比较，是否移动 索引 0 元素, 将待插入元素 索引 1 元素 插入到适当的位置第二轮索引 0,1 元素是有序的，带插入的元素为 索引 2 的元素， 将索引 2 元素值与前面已经排序好的 索引 0,1 元素比较是否移动，将待插入元素 索引 2 元素 插入到适当的位置第三轮索引 0,1,2 元素是有序的，带插入的元素为 索引 3 的元素， 将索引 3 元素值与前面已经排序好的 索引 0,1,2 元素比较是否移动，将待插入元素 索引 3 元素 插入到适当的位置………也就是说那么经过 n-1（数组的 length - 1） 轮，就可以完成所有数的排序。 外层循环是控制循环轮次，获取待插入的元素，内层循环做元素的移动，找到合适的插入位置。然后再外层循环将待插入的元素插入到适合的位置。 12345678910111213141516171819202122232425262728293031323334353637// 插入排序function insertSort(arr) &#123; let n = arr.length // 循环比较 n-1 次就可以完成排序，外层用来递增排序轮次 // 第 1 轮：第 0 索引元素是一个有序的数列，第 1 个以后的是无序的序列， // 第 2 轮：第 0-1 索引元素是一个有序的数列，第 2 个以后的是无序的序列， for (let i = 1; i &lt; n; i++) &#123; let t = arr[i] var j = i - 1 //已经排好序的最后一个索引 while (j &gt;= 0 &amp;&amp; arr[j] &gt; t) &#123; arr[j + 1] = arr[j] // 元素往后移动 arr[j] 往后移动到 arr[j + 1] 位置上 j-- // 内层循环用来比较：移动元素，找到适合的位置 j+1 ，注意不是 j // 当 arr[j] &gt; t 不满足的时候结束内循环的，那么带插入的就应该是在 arr[j+1] // 带插入的元素,要用中间变量 t 保存下来，因为内层循环会改变它的值 //（大的元素往后移动，数组元素被改变了,带插入元素还用 arr[i] 可能就不正确了） // 每轮循环比较的是 前面已经排序好的，也就是 arr[0]~arr[i-1] &#125; arr[j + 1] = t console.log(arr.toString()); // 将每轮的结果输出，需要观察的时候写上这句代码 &#125;&#125;var nums = [10, 8, 3, 2, 2, 4, 9, 5, 4, 3]insertSort(nums)/* 结果λ js eg-chapter12.3.js8,10,3,2,2,4,9,5,4,33,8,10,2,2,4,9,5,4,32,3,8,10,2,4,9,5,4,32,2,3,8,10,4,9,5,4,32,2,3,4,8,10,9,5,4,32,2,3,4,8,9,10,5,4,32,2,3,4,5,8,9,10,4,32,2,3,4,4,5,8,9,10,32,2,3,3,4,4,5,8,9,10 */ 4.2.1.4 三种简单排序的比较时间复杂度：排序用时 ， 空间复杂度：内存的占用 排序方法 平均时间 最好时间 最坏时间 稳定性 空间复杂度 冒泡排序 O(n²) O(n) O(n²) 稳定 O(1) 选择排序 O(n²) O(n²) O(n²) 不稳定 O(1) 直接插入排序 O(n²) O(n) O(n²) 稳定 O(1) O(n)这样的标志叫做渐近时间复杂度,是个近似值.各种渐近时间复杂度由小到大的顺序如下 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 一般时间复杂度到了2^n(指数阶)及更大的时间复杂度,这样的算法我们基本上不会用了,太不实用了.比如递归实现的汉诺塔问题算法就是O(2^n). 平方阶(n^2)的算法是勉强能用,而nlogn及更小的时间复杂度算法那就是非常高效的算法 ,4.2.4 节就是高效的排序方法学习 冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为O(1),因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引) 快速排序空间复杂度为logn(因为递归调用了) ,归并排序空间复杂是O(n),需要一个大小为n的临时数组. 基数排序的空间复杂是O(n),桶排序的空间复杂度不确定 4.2.2 高级排序4.2.1.1 几种高级排序的比较 排序方法 平均时间 最好时间 最坏时间 稳定性 空间复杂度 桶排序 O(n) O(n) O(n) 不稳定 不确定 基数排序 O(n) O(n) O(n) 稳定 O(n) 归并排序 O(nlogn) O(nlogn) O(nlogn) 稳定 O(n) 快速排序 O(nlogn) O(nlogn) O(n^2) 不稳定 O(logn) 堆排序 O(nlogn) O(nlogn) O(nlogn) 不稳定 O(1) 希尔排序 O(n^1.25) 不稳定 O(1) 所有排序算法中最快的应该是桶排序(很多人误以为是快速排序,实际上不是.不过实际应用中快速排序用的多)但桶排序一般用的不多,因为有几个比较大的缺陷. 1.待排序的元素不能是负数,小数. 2.空间复杂度不确定,要看待排序元素中最大值是多少. 所需要的辅助数组大小即为最大元素的值. 4.2.2.2 希尔排序/缩小增量排序（高级排序-简单插入排序的升级）希尔排序是把记录按下标的一定 增量/间隔 gap 分组，对每组使用 直接插入排序算法/简单插入排序 进行排序；随着 增量/间隔 gap 逐渐减少，每组包含的元素越来越多，当增量减至1时，整个文数组元素恰被分成一组，算法便终止，得到了正确的排序。希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序/简单插入排序，待整个序列中的记录基本有序时，再对全体记录进行依次直接插入排序/简单插入排序。 希尔排序是也加缩小增量排序，它基于简单插入排序做了改善。简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动，简化了代码的执行，减少代码执行时间。 增量一般可以获取数组长度的一半，也就是 希尔增量：gap=length/2 ，缩小增量 gap=gap/2 ，实际上它不是最优的。后面我们使用动态间隔。 将有n个元素的数组分成n/2份，第1个数据与第n/2+1个数据属于同一份。。。 使用类似插入排序的方法，将同一份的数据排序 然后，再变为n/4份，同样的操作再次排序 不断重复上述3个步骤之后，最后分成n份数据，再通过一次插入排序就完成了全部的排序。 12345678910111213141516171819202122232425262728293031323334353637383940// 希尔增量/间隔 gap=length/2// 希尔函数，插入函数的升级版，用增量来给数组元素分组成多个组 使用直接插入算法排序，不断的减小增量来不断排序知道增量为1function shellSort(arr) &#123; let n = arr.length let gap = Math.floor(n / 2) //希尔增量 while (gap &gt;= 1) &#123; // 外层循环控制 gap增量 for (let i = gap; i &lt; n; i++) &#123; // 控制 每轮-每组 元素的待插入元素，arr[i] let t = arr[i] let j = i - gap while (j &gt;= 0 &amp;&amp; arr[j] &gt; t) &#123; // 元素比较移动 arr[j + gap] = arr[j] j -= gap &#125; // 插入元素 arr[j + gap] = t &#125; console.log(arr.toString()) gap = Math.floor(gap / 2) &#125;&#125;/* console.log(3 / 2) //1.5 console.log(Math.floor(3 / 2)) //1 Math.floor() 向下取整， go、Java 等语言中是自动取整的。JS中 3/2 是小数，需要取整！！！*/var nums = [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]var start = new Date().getTime();shellSort(nums)var stop = new Date().getTime();var elapsed = stop - start;print(\"shellSort \" + elapsed + \" ms\"); // 10~50ms// 对于小数组 100 位数排序来说用三大简单的排序！！只需要几毫秒，高级排序是给大数据数组用的/* λ js eg-chapter12.5.js3,5,1,6,0,8,9,4,7,20,2,1,4,3,5,7,6,9,80,1,2,3,4,5,6,7,8,9 */ 123456789101112131415161718192021222324252627282930313233343536373839// 动态增量// 希尔函数，插入函数的升级版，用增量来给数组元素分组成多个组 使用直接插入算法排序，不断的减小增量来不断排序知道增量为1function shellSort(arr) &#123; let n = arr.length let gap = 1 while (gap &lt; n / 3) &#123; gap = gap * 3 + 1 //循环动态定义增量-间隔序列：那为什么是3？？？有的是5？？？这里又是怎么取的？？ &#125; while (gap &gt;= 1) &#123; // 外层循环控制 gap增量 for (let i = gap; i &lt; n; i++) &#123; // 控制 每轮-每组 元素的待插入元素，arr[i] let t = arr[i] let j = i - gap while (j &gt;= 0 &amp;&amp; arr[j] &gt; t) &#123; // 元素比较移动 arr[j + gap] = arr[j] j -= gap &#125; // 插入元素 arr[j + gap] = t &#125; console.log(arr.toString()) gap = Math.floor(gap / 3) &#125;&#125;var nums = [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]var start = new Date().getTime();shellSort(nums)var stop = new Date().getTime();var elapsed = stop - start;print(\"shellSort \" + elapsed + \" ms\"); // 10~40ms/*λ js eg-chapter12.6.js2,0,1,4,6,3,5,7,8,90,1,2,3,4,5,6,7,8,9shellSort 14 ms */ 4.2.2.3 快速排序/划分交换排序（高级排序-冒泡排序的升级）快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直到所有数据都是有序的。 但是注意不要重新创建两个子数组来存贮数据，这样就不是 in-place 方法了！！！ 快速排序是一个“交换类”的排序，以军训排队为例，教官说：“第一个同学出列，其他人以他为中心，比他矮的全排到他的左边，比他高的全排他右边。”这就是一趟快速排序。可以看出，一趟快速排序是以一个“枢轴”为中心，将序列分成两部分，枢轴的一边全是比它小（或者小于等于）的，另一边全是比他大（或者大于等于）的。 快速排序的实现：①从数列中挑出一个元素，称为 “基准”（pivot）（通常以第一个元素作为基准），②重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。具体步骤：先 从左 i=0 往右找比基准大的元素 与 从右 j=length-1 往左找比基准小的数字 交换位置，当 i=j 时，停止比较，基准元素就放在这个索引位置。注意一定是先右往左比较，再左往右比较，就是 j 先移动一步，然后 i 再移动一步③递归的去调用 1-2 步骤 直到 length&lt;=1 这个子序列就是正确的排列的，最终得到的数字元素就是正确的排序的。 123456789101112131415161718192021222324252627282930 // 下面是第一趟排序的实现过程原始序列： 49 38 65 97 76 13 27 49 i j（ i 和 j 开始时分别指向头，尾元素） 进行第一趟快速排序，以第一个数 49 作为枢纽（通常都选第一个元素作为枢纽），整个过程是一个交替扫描和交换的过程。 ①使用 j，从序列最右端开始向前扫描，直到遇到比枢轴 49 小的数 27 ， j 停在这里。 49 38 65 97 76 13 27 49 i j ②使用 i，交换扫描方向，从前向后扫描，直到遇到比较枢轴 49 大的数 65 ，i 停在这里。 49 38 65 97 76 13 27 49 i j ③将当前 i 与 j 位置的元素互换 49 38 27 97 76 13 65 49 i j ④使用 j，交换扫描方向，从后向前扫描，直到遇到比枢轴 49 小的数 13 ， j 停在这里。 49 38 27 97 76 13 65 49 i j ⑥使用 i，交换扫描方向，从前向后扫描，直到遇到比 49 大的数 97 ， i 停在这里。 49 38 27 97 76 13 65 49 i j ⑦将当前 i 与 j 位置的元素互换 49 38 27 13 76 13 65 49 i j ⑧使用 j，交换扫描方向，直到遇到比 49 小的数，当扫描到 i 与 j 相遇时，说明扫描过程结束了。 27 38 13 76 97 65 49 ij ⑨此时 i 等于 j 的这个位置就是枢轴 49 的最终位置，将 49 放入这个位置，第一趟快速排序结束。 27 38 13 49 76 97 65 49 ij // 如果是这样找到 大值小值相遇 那么就不需要做他们两的交换了 123456789101112131415161718192021222324252627282930 // 再如下面是第一趟排序的实现过程原始序列： 3 9 9 2 8 7 0 i j（ i 和 j 开始时分别指向头，尾元素） 进行第一趟快速排序，以第一个数 3 作为枢纽（通常都选第一个元素作为枢纽），整个过程是一个交替扫描和交换的过程。 ①使用 j，从序列最右端开始向前扫描，直到遇到比枢轴 3 小的数 0 ， j 停在这里。 3 9 9 2 8 7 0 i j ②使用 i，交换扫描方向，从前向后扫描，直到遇到比较枢轴 3 大的数 9 ，i 停在这里。 3 9 9 2 8 7 0 i j ③将当前 i 与 j 位置的元素互换 3 0 9 2 8 7 9 i j ④使用 j，交换扫描方向，从后向前扫描，直到遇到比枢轴 3 小的数 2 ， j 停在这里。 3 0 9 2 8 7 9 i j ⑥使用 i，交换扫描方向，从前向后扫描，直到遇到比 3 大的数9 ， i 停在这里。 3 0 9 2 8 7 9 i j ⑦将当前 i 与 j 位置的元素互换 3 0 2 9 8 7 9 i j ⑧使用 j，交换扫描方向，j 往左移动遇到 i 了，此时扫描结束， 3 0 2 9 8 7 9 ij ⑨基数 3 与当前 ij位置交换，结束本轮交换。 2 0 3 9 8 7 9 本轮基数 3 到了最终排序的正确位置上了，下一轮将是 2 0 与 9 8 7 9 的递归扫描 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 快速排序-冒泡排序的升级版// left 为左端起始索引， right 为右端索引 ，// left 为子串第一个索引，right 为子串最后一个索引// 原始调用 left=0 right=n-1 也就是数组的 第 0 与 n-1 索引位置function quickSort(arr, left, right) &#123; if (left &gt;= right) return //递归出口 let t = arr[left] //保存基数 var i = left // 递归需要使用 left 与 right ，因此不能改变他们的值，循环使用的值 要创建新的变量来使用 //quickSort(left, i - 1) // left 为最初传进来的值 ,这里的left不能被改变 var j = right while (i != j) &#123; // i==j 的时候就是每轮的扫描结束，不比较了 // 从右往左找 &lt; 基数的元素，得到它当前的 j 值 while (arr[j] &gt;= t &amp;&amp; j &gt; i) &#123; j-- &#125; // 从左往右找 &gt; 基数的元素，得到它当前的 i 值 while (arr[i] &lt;= t &amp;&amp; j &gt; i) &#123; i++ &#125; // 如果 arr[i] 与arr[j] 是同一个元素就没有必要做交换了，特别是当元素是很大的数据的话，交换需要成本 // 比如 6 1 2 5 4 3 9 7 10 8 最后的 ij 是在3 相遇的，没有必要交换他们的位置的 // 如果 3 是很大的对象元素，那么交换的成本是高的。i != j 或 i&lt;j if (i &lt; j) &#123; let t1 = arr[j] arr[j] = arr[i] arr[i] = t1 &#125; &#125; //将基数与当前的 ij 位置交换 arr[left] = arr[i] arr[i] = t //0 9 i=6 console.log(arr) quickSort(arr,left, i - 1) // left 为最初传进来的值 ,不要忘记 传arr quickSort(arr,i + 1, right) // right 为最初传进来的值 ,不要忘记 传arr &#125;var nums = [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]var start = new Date().getTime();quickSort(nums, 0, nums.length - 1)var stop = new Date().getTime();var elapsed = stop - start;print(\"quickSort \" + elapsed + \" ms\"); // 10~40ms/*λ js eg-chapter12.6.js2,0,1,4,6,3,5,7,8,90,1,2,3,4,5,6,7,8,9shellSort 14 ms */ 4.2.2.4 堆排序（高级排序）4.2.2.5 归并排序（高级排序）归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并操作的工作原理如下：第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置重复步骤3直到某一指针超出序列尾将另一序列剩下的所有元素直接复制到合并序列尾 4.2.2.6 基数排序（高级排序）4.2.2.7 桶排序（高级排序）4.3 检索算法4.3.1 顺序查找顺序查找/线性查找：适用于元素随机排列的列表；从列表的第一个元素开始对列表元素逐个进行判断，直到找到了想要的结果，或者直到列表结尾也没有找到。称为顺序查找。在执行查找时可能会访问到数据结构里的所有元素。 顺序查找的实现 ：只要从列表的第一个元素开始循环，然后逐个与要查找的数据进行比较。如果匹配到了，则结束查找。如果到了列表的结尾也没有匹配到，那么这个数据就不存在于这个列表中。 123456789101112131415161718192021222324252627282930313233// 顺序查找，就是从头开始查，可能会查到尾巴function seqSearch(arr, data) &#123; let n = arr.length for (let i = 0; i &lt; n; i++) &#123; if (arr[i] == data) &#123; return i // return true &#125; &#125; return -1 // return false // return null // 使用 -1 比较好，返回相同的数据类型，在被调用的时候好做判断&#125;function getMin(arr) &#123; let n = arr.length let min = arr[0] for (let i = 0; i &lt; n; i++) &#123; if (arr[i] &lt; min) &#123; min = arr[i] &#125; &#125; return min&#125;function getMin(arr) &#123; let n = arr.length let max = arr[0] for (let i = 0; i &lt; n; i++) &#123; if (arr[i] &gt; min) &#123; max = arr[i] &#125; &#125; return max&#125; 如果需要找的数据在数组的开头那么很容易找到，如果恰好是在后面难么就很难找了。我们可以根据数据被查询的频率来改变数据在数组中的位置。比如，如果你是一个图书馆管理员，并且你在一天内会被问到好几次同一本参考书，那么你将会把这本书放在触手可及的地方。经过多次查找之后，查找最频繁的元素会从原来的位置移动到数据集的起始位置。这就是一个数据自组织的例子：数据的位置并非由程序员在程序执行之前就组织好，而是在程序运行过程中由程序自动组织的。 由于对数据的查找遵循“80-20 原则”，因此将你的数据转化为自组织的形式是很有意义的。“80-20 原则”是指对某一数据集执行的 80% 的查找操作都是对其中 20% 的数据元素进行查找。自组织的方式最终会把这 20% 的数据置于数据集的起始位置，这样便可以通过一个简单的顺序查找快速找到它们。类似这种“80-20 原则”的概率分布被称为帕累托（Pareto）分布，它是由帕累托（VilfredoPareto）在 19 世纪末期研究收入和财富的分布时发现的。更多关于数据集的概率分布可以参考高纳德（Donald Knuth）编写的《计算机程序设计艺术，卷 3：排序与查找》。 当数据位于数据集的前，20% 元素之外时，该数据才需要被重新移动到数据集的起始位置。 根据上面的原则，我们就可以将顺序查找元素更新如下， 1234567891011121314151617181920function swap(arr, index1, index2) &#123; let t = arr[index1] arr[index1] = arr[index2] arr[index2] = t&#125;function seqSearch(arr) &#123; let n = arr.length for (let i = 0; i &lt; n; i++) &#123; if (arr[i] == data) &#123; if ( i &gt; (arr.length * 0.2)) &#123; swap(arr, i, 0) // 将查询的 i 位置 跟 i-1 位置交换掉 // 当数据位于数据集的前，20% 元素之外时，该数据才需要被重新移动到数据集的起始位置。 &#125; return i &#125; &#125; return -1&#125; 4.3.2 二分查找/折半搜索/二分搜索二分查找：适用于元素已排序的列表。二分查找效率更高，但是你必须在进行查找之前花费额外的时间将列表中的元素排序。 二分查找算法，这个算法只对有序的数据集有效。如果你要查找的数据是有序的，二分查找算法比顺序查找算法更高效。 二分查找实现：元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/ 二分查找 left 左限 ，right 右限function binarySearch(arr, data) &#123; let left = 0 let right = arr.length - 1 while (left &lt;= right) &#123; //let mid = Math.floor((left + right) / 2) 这样直接 (left + right) / 2 可以回溢出 // 计算机位 64 位，有一位是符号位，那么 left 与 right 最大的情况是 2^63 + 2^63， // 他们的结果，计算机无法保存。因为转化为如下，加法转化为减法运算 // (left + right) / 2 等价于 left + (right - left) / 2 let mid = Math.floor(left + (right - left) / 2) if (arr[mid] == data) &#123; return mid &#125; else if (arr[mid] &gt; data) &#123; right = mid - 1 &#125; else &#123; left = mid + 1 &#125; &#125; return -1 //没有找到&#125;// 如果是递归：最初传入 left=0 ，right=length-1，//能用循环就不要用递归，递归可能会写得麻烦,像这个二分查找的实现，递归就比循环要难思考了function binarySearch1(arr, data, left, right) &#123; if (left &gt; right) &#123; return -1 &#125; let mid = Math.floor(left + (right - left) / 2) if (arr[mid] == data) &#123; return mid &#125; else if (arr[mid] &gt; data) &#123; return binarySearch1(arr, data, left, mid - 1) &#125; else &#123; return binarySearch1(arr, data, mid + 1, right) &#125;&#125;var nums = []for (let i = 0; i &lt; 99; i++) &#123; nums[i] = i + 1&#125;console.log(binarySearch(nums, 82)) //81console.log(binarySearch(nums, 1000)) //-1console.log(binarySearch1(nums, 82, 0, 99)) //81console.log(binarySearch1(nums, 1000, 0, 99)) //-1 统计某个数据的重复次数如果这个数组是有序的，而且已经使用了二分查找了，那么我们可以像下面这样来查找。（如果是没有排序好的数组，数据又是很大的话，我们是可以用 字典 来做的，键值对比这些要好很多的，只是 字典 需要新内存） 1234567891011121314151617181920212223242526272829303132// 对于排序好的数组//var nums = [1,3,3,3] 这个数组找 3 返回的是 1 对于查找的数据，它返回它的索引， 我们需要统计它的重复次数，// 用二分查找找到一个索引， 往右遍历得到右边的重复个数，往左遍历得到左边的重复个数，// 那么最终得到的就是该数据的重复次数了function count(arr, data) &#123; let count = 0 let index = binarySearch(arr, data) if (index != -1) &#123; // data 在数据中存在，返回下标 count++ for (let i = index - 1; i &gt;= 0; i--) &#123; if (arr[i] == data) &#123; count++ &#125; else &#123; break // 不等的话，左边就不会有重复的数据了，跳出循环 &#125; &#125; let n = arr.length for (let i = index + 1; i &lt; n; i++) &#123; if (arr[i] == data) &#123; count++ &#125; else &#123; break // 不等的话，左边就不会有重复的数据了，跳出循环 &#125; &#125; &#125; return count&#125;var nums = [11, 23, 34, 34, 34, 34, 34, 56, 78, 99]console.log(count(nums, 34)) //5 4.4 高级算法4.4.1 动态规划递归：是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。（出现一样的小问题会不断的重复求解，浪费时间,效率不高）动态规划：通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。（相同的子问题只会求解一边，然后将结果存储在数组中，下次调用即可） 动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 使用递归去解决问题虽然简洁，但效率不高。包括 JavaScript 在内的众多语言，不能高效地将递归代码解释为机器代码，尽管写出来的程序简洁，但是执行效率低下。但这并不是说使用递归是件坏事，本质上说，只是那些指令式编程语言和面向对象的编程语言对递归的实现不够完善，因为它们没有将递归作为高级编程的特性。 许多使用递归去解决的编程问题，可以重写为使用动态规划的技巧去解决。动态规划方案通常会使用一个数组来建立一张表，用于存放被分解成众多子问题的解。 4.4.1.1 斐波那契数列1234567891011// 简单递归算法//0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … 该序列是由前两项数值相加而成的。function fib(n) &#123; if (n &lt; 2) &#123; return n &#125; else &#123; return fib(n-1) + fib(n-2) &#125;&#125;console.log(fb(10)); // 55 从上面的递归树，我们看到很多函数（也就是子问题），被求解了很多遍，可以看出这个函数的效率是非常低的，该算法的运算时间是指数级增长的。我们可以通过保存已经算出的子问题的解来避免重复计算：以将子函数的解存储下来，存储到一个 解的数组中，下次同样的子问题值需要访问数组元素即可得到解，不需要再次求解。这就是动态规划.那么上面的斐波那契数列递归函数，我们可以更新如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344//0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, … 该序列是由前两项数值相加而成的。// 递归函数function fib(n) &#123; if (n &lt; 2) &#123; return n &#125; else &#123; return fib(n - 1) + fib(n - 2) &#125;&#125;//动态规划，用数组存贮数据 空间换时间，创建数组需要空间，但是时间大大的缩短了function dynamicFib(n) &#123; let arr = [] // 用来存储 f(0), f(1), f(2), f(3),也恶就是这里值的结果 arr[0] = 0 arr[1] = 1 if (n &lt; 2) &#123; return n // 如果要求的很小就没有必要保存了，直接就是返回 n 就好了 &#125; else &#123; // 如果需要求的 n 比较大，那么就像将这里结果放到数组中 for (let i = 2; i &lt;= n; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2] &#125; return arr[n] &#125;&#125;var start = new Date().getTime()fib(40)var end = new Date().getTime()var time = end - startconsole.log(time + 'ms')start = new Date().getTime()dynamicFib(1000)end = new Date().getTime()time = end - startconsole.log(time + 'ms')/* 结果λ js eg-chapter14.1.js4383ms1ms *///可以看出，用递归函数需要几千毫秒，动态规划使用数组来存贮的话就仅仅是 1ms 的事情 4.4.1.2 寻找最长公共子串寻找两个字符串中最长的公共子串。 4.4.1.3 背包问题（动态规划）4.4.2 贪心算法贪心算法是一种以寻找“优质解”为手段从而达成整体解决方案的算法。这些优质的解决方案称为局部最优解，将有希望得到正确的最终解决方案，也称为全局最优解。“贪心”这个术语来自于这些算法无论如何总是选择当前的最优解这个事实。通常，贪心算法会用于那些看起来近乎无法找到完整解决方案的问题，然而，出于时间和空间的考虑，次优解也是可以接受的。 动态规划：基于递归方案实现的。对许多问题来说，采用动态规划的方式去处理有点大材小用，往往一个简单的算法就够了。那就是贪心算法。 贪心算法就是一种比较简单的算法。贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响。使用贪心算法通常表明，实现者希望做出的这一系列局部“最优”选择能够带来最终的整体“最优”选择。如果是这样的话，该算法将会产生一个最优解，否则，则会得到一个次优。然而，对很多问题来说，寻找最优解很麻烦，这么做不值得，所以使用贪心算法就足够了 4.4.2.1 找零问题123// 美分： 1美分，10美分，25美分，50美分// 在所有面额都可用且数量不限的情况下，这种方案总能找到最优解。// 如果某种面额不可用，比如 5 美分，则会得到一个次优解。 4.4.2.2 背包问题（贪心算法）","tags":[]},{"title":"HTTP--[状态码]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑨-【HTTP】-HTTP 状态码/","text":"一、前言状态码小数详解 1.1 5 种数字开头的状态码123456# 状态码 类别 原因短语# 1.. informational(临时响应状态码) 服务器收到请求，需要请求者继续执行操作，正在处理请求 （继续处理）# 2.. success（成功状态码） 请求正常处理完毕，操作被成功接收并处理 (成功)# 3.. Redirction（重定向） 需要进一步的操作以完成请求 （继续处理-重定向）# 4.. Client（客户端错误） 客户端错误，请求包含语法错误或无法完成请求 (前端错误/后端错误)# 5.. Server Error（服务端错误） 服务器错误，服务器在处理请求的过程中发生了错误 (后端错误) 三、 1 开头状态码 【临时响应-需要继续操作】1xx 代表服务器已经收到请求，需要请求者继续执行操作处理。 这个状态码的分类意味着一个临时的响应，仅有状态行和可选的头部信息组成，并且有一个空行结尾。因为 HTTP/1.0 并没有定义任何 1xx 相关的状态码，所以服务器应该发出一个1xx 的响应给一个 HTTP/1.0 的客户端除非在实验条件下。 100 继续12# 100 Continue 继续。# 客户端应继续其请求，需要请求者继续执行操作 101 切换协议12# 101 Switching Protocols（成功状态码）切换协议。# 服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议 这意味着请求者要求服务器切换协议并且服务器也确认将会那么做。 102 处理中1# 102 服务在处理请求中 作为一个 WebDAV 的请求可能包含多个子请求包括文件操作等，这将可能花费很长时间去完成操作。这个状态码意味着服务器已经收到了请求，并且正在处理中，所以当前暂无响应。这样将避免客户端因为超时而认为当前请求丢失。 四、 2 开头状态码【成功状态码-请求成功】2XX 成功 这一类状态码意味着请求的行为已经被客户端收到、理解接受而且被成功地处理。请求正常处理完毕，操作被成功接收并处理 200 成功1# 200 OK 请求成功。一般用于 GET 与 POST 请求 成功 HTTP 请求的标准响应状态码。不过实际的响应取决于请求者所使用的方法。如果在一个 GET 的请求中，响应将会包含对应资源的实体。而在一个 POST 请求中，响应将会包含一个实体的描述或者是请求行为的结果。 201 已创建1# 201 Created 已创建。成功请求并创建了新的资源. 请求已经被满足，并且一个新的资源将会被创建。 202 接受1# 202 Accepted 已接受.已经接受请求但未处理完成 请求已经被接受并被处理，但是处理还没有完成。请求可能最终不会采取行动，因为在执行过程中可能会被打断。 203 非权威的信息/非授权信息12# 203 Non-Authoritative Information 非授权信息# 请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本 服务器成功处理请求，但是返回信息可能来自其它源。 204 无内容1# 204 No Content 无内容,服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 服务器成功处理请求，但是没有返回任何内容。通常被用来被作为成功删除的请求的响应。 205 重置内容12# 205 Reset Content 重置内容# 服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 服务器成功处理请求，但是没有返回任何内容。和 204 不同的是，响应需要请求者重置文档视图。修改内容请求的返回？？ 206 部分内容1# 206 Partial Content 部分内容.服务器成功处理了部分 GET 请求 服务器只返回了一部分资源因为客户端发送了一系列的请求头。这些请求头被像 wget 的工具去恢复已经被中断的下载，或者将下载分成多个同步的流。 207 多状态 [新增]1# 207 多状态 紧跟消息体后面的是 xml 消息并且包含了多个单独的响应状态码，响应的数量取决于子请求的个数。 208 已经报告 [新增]1# 208 已经报告 一个 DAV 的绑定成员被前一个请求枚举，并且没有被再一次包括。 226 IM Used1# 226 IM Used 服务器已经满足了请求所要的资源，并且响应是一个或者多个实例操作应用于当前实例的结果。 五、 3 开头状态码 【重定向状态码-跳转】3xx 跳转 Redirction（请求被重定向） 需要进一步的操作以完成请求 需要客户端采取进一步的操作才能完成请求。 通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 location 域中指明。 这一类状态码意味着客户端必须执行额外的动作去完成请求。大部分这些状态码被用于 url 重定向。只有当第二请求方法是 GET 或者是 HEAD 的情况下，用户代理可能会执行额外的动作在没有用户交互的情况下。一个用户代理不能自动地重定向请求超过 5 次，因为这样的重定向经常意味着一个死循环。 300 多重选择12# 300 Multiple Choices =&gt;多种选择# 请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 意味着对于这个资源有多个选项需要客户端注意。例如，可以用来展示不同格式的视频，使用不同的扩展名列出文件，或者消除文字的歧义。 301 永久移动12# 301 Moved Permanently =&gt;永久移动，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。# 今后任何新的请求都应使用新的URI代替 当前以及未来的所有请求应该被定位到指定的 url 上去。【永久移动】请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会 自动将请求者转到新位置 场景：当站点迁移，域名变更、网站改版时，建议使用 301 返回码，除了能减少网站改版带来的流量损失，还能通过此代码通知 Baiduspider 某个网页或网站已被永久移动到新位置，从而将权重和排名尽快转移到目标页面。 IIS 服务器解决方案：（Internet Information Server，互联网信息服务） 打开 internet 信息服务管理器，在欲重定向的网页或目录上按右键，选择“重定向到URL”，在“重定向到”输入框中输入要跳转到的目标网页的 URL地址，选中“资源的永久重定向”(切记)，最后点击“应用”。 Apache服务器解决方案： 在 Apache 中，只需要找到 .htaccess 文件，通过对它的设置，即可实现 301 设置。找到redirectpermanent/old-url.htmlhttp://new-url.com,修改这句即可。 302 发现/临时移动1234# 302 Found =&gt; 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI# 解析：（临时移动）服务器目前正从不同位置的网页响应请求，但 **请求者应继续使用原有 URL 来进行以后的请求**。# 此代码与响应 GET 和 HEA 请求的 301 代码类似，会 **自动将请求者转到不同的位置**。 这是工业实践和标准相矛盾的例子。HTTP/1.0 规范需要客户端执行一个临时的跳转(原始的描述短语是”临时移动”)，但是流行的浏览器使用 303 查看其它的功能去实现 302.因此，HTTP/1.1 添加了状态码 303 和 307 去分辨这两个操作。然而，一些 web 程序和框架使用 302 状态码就好像它是 303 一样。 使用环境及影响：302 代码一般默认为临时跳转，仅用于暂时跳转至新的临时性的 URL 或网址。 一般来说 Baiduspider 仍会继续抓取原有位置将其编入索引。因经常被用于域名网址劫持等黑帽作弊，很多站长觉得百度对 302 并不友好，若是永久移动某个页面或者网站不建议使用该代码。 解决方案：若是永久移动某个页面， IIS 服务器只需跟设置 301 步骤一样，最后一项记得选择”该资源将永久跳转“， Apache 服务器则在 htaccess 文件中进行 Rewrite 重写即可；一般在批量设置 URL 重定向规则时要用到正则表达式。 303 查看其它1# 303 See Other =&gt; 查看其它地址。 与301类似。使用 GET 和 POST 请求查看 当前请求的响应能够在其它的 URI 地址上使用 GET 方法发现。当接收到一个 POST 响应的请求，则应该假设服务器已经收到数据而且跳转应该发出一个单独的 GET 消息。 304 未修改12# 304 Not Modified =&gt; 未修改。 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。# 客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 意味着资源没有被修改因为请求头指定的版本跟本地保存的版本并未修改或没有匹配。这说明没有必要重新传输资源，因为客户端仍然有一个以前下载的副本。 305 使用代理（自从HTTP/1.1）1# 305 Use Proxy =&gt; 使用代理。 所请求的资源必须通过代理访问 请求的资源只能通过代理才能访问，并且访问的地址由响应提供。很多 HTTP 客户端（像火狐和 IE ）因为安全问题，不能正确地处理该响应。 306 切换代理 (这个状态码已经被废弃)12# 306 Unused xxxxx =&gt; 已经被废弃的HTTP状态码# 不再使用。原意是随后的请求应该使用指定的代理 307 临时跳转（自从HTTP/1.1）1# 307 Temporary Redirect =&gt; 临时重定向。与302类似。使用GET请求重定向 今后任何新的请求都应使用新的URI代替 在这种情况下，当前请求应该被另一个 URI 地址重新发送，然而未来的请求仍然应该使用原始的 URI 地址。和 302 不同的是历史实现，请求方法不允许改变当重新发送原始请求。例如，一个 POST 请求应该被另一个 POST 请求重新发送。 308 永久转移 [新增]1# 308 永久转移 这个请求和以后的请求都应该被另一个 URI 地址重新发送。307、308 和 302、301 有相同的表现，但是不允许 HTTP 方法改变。例如，请求表单到一个永久转移的资源将会继续顺利地执行。 六、 4 开头状态码【客户端错误】4XX 客户端错误 Client（请求错误-客户端错误） 客户端错误，请求包含语法错误或无法完成请求 (前端错误/后端错误) 客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 4XX类别的状态码是为了预防客户端出现错误的情况。除了响应请求头的情况，服务器应该包括错误情形解释的实体无论是临时的还是永久的条件。这些状态码可以和任何请求方法匹配。用户代理应该展示可以被包括的实体给用户。 登录的请求过程1、客户端/前端 发送请求 到 后端服务器2、后端服务器 认证 前端填写的信息（账户，密码等等） authorized 账户密码通过认证3、认证通过了后端会返回 token 或者 cookie 或者 session 给前端（前端通过 localstorage 等方法保存 token）4、其他的接口是需要 登录时保存下的 token 等信息来通过请求， 带上 token 或者 cookie 或者 session id 后端服务器就知道你是谁了，然后后端会看你有没有权限访问某个东西这里做的就是授权 400 错误请求（请求头错误）服务器因为一些事情感知到客户端的错误而不继续处理请求（例如不正确的请求语法，无效的请求消息框架，以及虚假的请求路由） 12# 400 Bad Request =&gt; 客户端请求的语法错误，服务器无法理解# 表示请求报文中存在语法错误，需修改请求的内容后再次发送请求。就是请求头，请求内容错了，就是 data 错啦 状态码使用场景：一般出现这个状态码分为两种情况： 1、bad request 意思是 “错误的请求”.语义有误，当前请求无法被服务器理解。表示请求报文中存在语法错误，需修改请求的内容后再次发送请求是由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。 在 ajax 请求后台数据时比较常见 ① 前端提交数据的 字段名称 或者是 字段类型 和 后台的实体类 不一致，导致无法封装； ② 前端提交的到后台的数据应该是 json 字符串类型，而前端没有将对象转化为字符串类型； 2、invalid hostname 意思是 “不存在的域名”。访问的页面域名不存在或者请求错误。 前端找出错的原因/解决问题 定位到目标请求代码 1、对照字段名称，类型保证一致性 2、使用 stringify 将前端传递的对象转化为字符串：data: JSON.stringify(param); 当然这个在 ajax，与 axios 都封装了 3、在确定域名或 URL 没有输错的前提下，首先可以 Ping（指的是检查网络连通，就是在命令行检查 的一个命令） 一下域名，看看是否解析到服务器或空间所在的 IP，如果是，可以去空间的管理面板看有没有绑定域名，如果有，那有可能是空间提供商的问题了，找空间提供商解决即可！ 4、http 请求参数中含有 &amp; 或者空格,则必须 URL 编码 . 解决：URLEncoder.encode(url, &quot;UTF-8&quot;) 对 url 进行 UTF-8 编码，将空格去除 5、GET 请求时,参数含有中文,也需要 URL 编码。解决：URLEncoder.encode(url, &quot;UTF-8&quot;) 对 url 进行 UTF-8 编码，将空格去除 6、请求的内容 data 错误 401 未认证，认证不通过（账户密码错误）~~~~~~重点，重点，重点，重点，重点~~~~~~和 403 未认证有区别，401 未认证 和 403 未授权/禁止访问 是两回事 和 403 禁止相似，但是明确用于需要授权的、失败的或者是不支持的。响应必须包括适用于请求资源的 WWW-认证头字段。查看基本访问认证和数字访问认证。对于 401,我们可以用一句话描述它:那就是 HTTP 401 错误 - 未授权： (Unauthorized) (绝大多数情况下是这样的），简单的来说: 就是你的 Web 服务器认为，客户端发送的 HTTP 数据流是正确的，但进入网址 (URL) 资源 ， 需要用户身份验证 ， 而相关信息 尚未被提供, 或 已提供但没有通过授权测试。这就是通常所知的“ HTTP 基本验证 ”。而需客户端提供的验证请求在 HTTP 协议中被定义为 WWW – 验证标头字段 (WWW-Authenticate header field) 。 1234567891011# 401 Unauthenticatied =&gt; 请求要求用户的身份认证 【看下可能是账户，密码错误，或者是网络错误，等等，再或者就是写代码就没有带上要求的 token 等通行证】# 401.1 =&gt; Logon failed -登陆失败【用户名或密码无效】导致【登录失败】。# 401.2 =&gt; Logon failed due to server configuration-基于服务器配置的登陆失败【服务器配置导致】登录失败。# 401.3 =&gt; Unauthorized due to ACL on resource-资源访问控制列表返回未授权# 资源访问控制列表返回未授权,由于 ACL 对资源的限制而未获得授权。表示存在 NTFS 权限问题。# 即使您对试图访问的文件具备相应的权限，也可能发生此错误。# 例如，如果 IUSR 帐户无权访问 C:WinntSystem32Inetsrv 目录，您会看到这个错误。# 401.4 =&gt; Authorization failed by filter -服务器 filter 返回未授权。筛选器授权失败。服务器 filter 返回未授权。# 401.5 =&gt; Authorization failed by ISAPI/CGI application-服务器 ISAPI/CGI 返回未授权# ISAPI/CGI 应用程序授权失败。服务器 ISAPI/CGI 返回未授权# 401.7 =&gt; 由 Web 服务器上的 URL 验证策略拒绝访问。这个错误代码为 IIS 6.0 所专用。 状态码使用场景： 请求用户的 token 这个接口的时候 前端找出错误原因： ① 因为 request 中没有包含 Authorization header，服务器会返回一个 401 Unauthozied 给客户端，并且在 Response 的 header “www-authentivate”中添加信息。当客户端把用户名密码用 Base64 加密后编码，放在 Authorization header 中发送给服务器，那么就会认证成功了。 ② 如果是开放的服务器资源, 需要考虑的是是否有防御性的安全策略;请求头没有带上 token,带上的 token 是否正确，是否过期页面需刷新，重新登录 ③ 外链，跨域是否设置 cookie 携带 为 withCredentials: true，需要进行跨域请求的资源（api），当服务端检测到是 OPTONS 请求时候统统放行，给出HTTP.OK(200)的状态和必要的响应头，哪怕它是不带身份信息的 ③ 优先考虑是否是需要验证,也就是是否需要授权账号和密码信息。 ④ 网络错误啊，等等 402 需要付款1# 402 Payment Required =&gt; 保留。将来使用 为以后保留使用。原意是该状态码可被用于一些数字货币或者是微支付，但是目前还没有普及，所以这些代码不经常被使用。YouYube使用这个状态如果某个IP地址发出了过多的请求，并要求用户输入验证码。 403 禁止访问/未授权/没有权限查看（不给访问了）这个请求是一个有效的请求，但是服务器拒绝响应它。和 401 未认证有区别，401 未认证 和 403 是两回事 12345678910111213141516171819202122232425262728293031323334# 403 Forbidden =&gt; 服务器理解请求客户端的请求，但是拒绝执行此请求# 403.1 【执行访问被禁止】。可能原因：您没有足够的执行许可。# 例如，如果试图访问的 ASP 页所在的目录权限设为“无”，或者，# 试图执行的 CGI 脚本所在的目录权限为“只允许脚本”，将出现此错误消息。# 若要修改执行权限，请在 Microsoft 管理控制台 (MMC) 中右击目录，然后依次单击“属性”和“目录”选项卡，# 确保为试图访问的内容设置适当的执行权限。# 您没有将试图执行的文件类型的脚本映射设置为识别所使用的谓词（例如，GET 或 POST）。# 若要验证这一点，请在 Microsoft 管理控制台中右键单击目录，依次单击“属性”、“目录”选项卡和“配置”，# 然后验证相应文件类型的脚本映射是否设置为允许所使用的谓词。# 403.2 【读访问被禁止】。验证是否已将 IIS 设置为允许对目录进行读访问。# 另外，如果您正在使用默认文件，请验证该文件是否存在。# 403.3 【写访问被禁止】。验证 IIS 权限和 NTFS 权限是否已设置以便向该目录授予写访问权。# 403.4 【要求 SSL】。禁用要求安全通道选项，或使用 HTTPS 代替 HTTP 来访问该页面。# 403.5 【要求 SSL 128】。禁用要求 128 位加密选项，或使用支持 128 位加密的浏览器以查看该页面。# 403.6 【IP 地址被拒绝】。您已经将服务器配置为拒绝访问您当前的 IP 地址。# 403.7 【要求客户端证书】。您已经将服务器配置为要求提供证书进行客户端身份验证，但是您没有安装有效的客户端证书。# 403.8 【站点访问被拒绝】。您已经为用来访问服务器的域设置了域名限制。# 403.9 【用户数过多】。与该服务器连接的用户数量超过了您设置的连接限制。# 注意：Microsoft Windows 2000 Professional 和 Windows XP Professional # 自动设置了在 IIS 上最多 10 个连接的限制。您无法更改此限制。# 403.10 【配置无效。】# 403.11 【密码更改。】# 403.12 【拒绝访问映射表。】您要访问的页要求提供客户端证书。但是，映射到该客户端证书的用户 ID 已经拒绝访问该文件。# 403.13 【客户端证书被吊销。】# 403.14 【拒绝目录列表。】# 403.15 【超出客户端访问许可。】# 403.16 【客户端证书不受信任或无效。】# 403.17 【客户端证书已过期或尚未生效。】# 403.18 【在当前的应用程序池中不能执行所请求的 URL。】这个错误代码为 IIS 6.0 所专用。# 403.19 【不能为这个应用程序池中的客户端执行 CGI。】这个错误代码为 IIS 6.0 所专用。# 403.20 【Passport 登录失败。】这个错误代码为 IIS 6.0 所专用。# 403.21 - 拒绝源访问。# 403.22 - 无限深度被拒绝。# 403.502 - 来自同一客户端IP的请求过多; 达到动态IP限制限制。 状态码的使用场景：一般出现这个状态码可以简单理解为 没有访问权限，通常需要对服务器上的文件或目录进行权限设置时使用；若在 Baiduspider 尝试抓取你网站上的有效网页时显示此状态代码，则可能是你的服务器或主机拒绝 Baiduspider 对其进行访问，如果长期返回403，搜索引擎会认为该 URL 是失效链接，将会对其进行删除，为此对搜索引擎并不友好。 错误：前几天偶然看到了这个报错403，是当时我们链接地址是 `https://www.ceshi.com;` 但是却被谁谁谁配置成了 `http://www.ceshi.com;` 最后就会导致 403 的报错。解决办法：就是将http改成https。这个错误应该是 403.4。403.4 错误是由于要求 SSL 而造成的，您必须在要查看的网页的地址中使用 &quot;https&quot;。 seo解决方案：解决服务器 403 问题要分情况而定， ① 若是因为 DNS 解析错误，或者因为连接用户过多，服务器繁忙导致，则可通过重建 dns 缓存来解决； ② 若是文件夹安全属性设置错误导致，则要修改文件夹安全属性； ③ 确实有某些页面不希望被搜索引擎收录的，建议通过写进 robots 规则文件来屏蔽蜘蛛收录即可。 前端找出错误 1、你的 IP 被列入黑名单。 2、你在一定时间内过多地访问此网站（一般是用采集程序），被防火墙拒绝访问了。 3、网站域名解析到了空间，但空间未绑定此域名。 4、你的网页脚本文件在当前目录下没有执行权限。 5、在不允许写/创建文件的目录中执行了创建/写文件操作。 6、以 http 方式访问需要 ssl 连接的网址。 7、浏览器不支持 SSL 128 时访问 SSL 128 的连接。 8、在身份验证的过程中输入了错误的密码。 9、DNS 解析错误，手动更改 DNS 服务器地址。 10、连接的用户过多，可以过后再试。 11、服务器繁忙，同一IP地址发送请求过多，遭到服务器智能屏蔽。 12、是不是 token 等已经过时，重新的登录 前端解决 403 错误的方法 ① 重建 dns 缓存：对于一些常规的 403 forbidden 错误，首先要尝试的就是重建 dns 缓存，在运行中输入 cmd，然后输入 ipconfig /flushdns 即可。如果不行的话，就需要在 hosts 文件里把主页解析一下了。同时，查看是否在网站虚拟目录中添加默认文档，一般默认文档为：index.html；index.asp；index.php；index.jsp；default.htm；default.asp 等 ② 修改文件夹安全属性：用以下命令修改文件夹安全属性 chcon -R -t httpd_user_content_t public_html/`ls -Z -d public_html/` `# 显示文件／目录的安全语境－Z, --context` `Display security context so it fits on most displays. Displays only mode, user, group, security context and file name.-d, --directory` `list directory entries instead of contents, and do not dereference symbolic links` `chcon -R -t httpd_user_content_t public_html/` `# 修改文件／目录的安全语境-R, --recursive` `change files and directories recursively-t, --type` `set type TYPE in the target security context` ④ 关于 apache 导致的 403 forbidden 错误，需设置 Apache 的配置文件。打开 apache 的配置文件 httpd.conf，找到这段代码： `OptionsFollowSymLinks` `AllowOverrideNone` `Orderdeny,allow` `Denyfromall` 有时候由于配置了 php 后，这里的 “Denyfromall” 已经拒绝了一切连接。把该行改成 “allowfromall”，修改后的代码如下，问题解决。 `OptionsFollowSymLinks` `AllowOverrideNone` `Orderdeny,allow` `Allowfromall` 之所以会出现错误，是因为大多数的国外主机在配置 Apache 的时候启用了 mod_security，也就是开启了安全检查，如果提交的信息中包含select,%,bin 等关键字，Apache 就会禁止，并给出 403，404，500 等错误。 ⑤ 关于 HawkHost 空间出现 403 Forbidden 错误需设置 htaccess 文件。有的时候在共享服务器上安装了 Modsecurity，当网址包含有 “%” 号等其它敏感字符时，也会被 Modsecurity 阻止。解决方法是 在 .htaccess 文件里添加如下代码： `SecFilterEngineOff` `SecFilterScanPOSTOff` 直接放在网站的根目录或者程序运行的目录下。 ⑥ 关于 WordPress 导致的 403 Forbidden 错误解决方法对于一些使用 WordPress 管理程序搭建的博客来说，就需要修改 .htaccess 文件，在后面添加上如下内容即可，其实就是 disable mod_security `SecFilterEngine Off` `SecFilterScanPOST Off` 另外dedecms的可能还需要再加一条，以让默认访问的是index.html文件的DirectoryIndex index.html。 修改.htaccess文件，将文件上传之后，再重新打开之前出现403 Forbidden的URL就没有再出现错误，直接可以打开了。 401 与 403 的区别authentication [ɔ,θɛntɪ’keʃən] 认证authorization [,ɔθərɪ’zeʃən] 授权 401 认证 (authentication) 和 403 授权 (authorization) 的区别 认证：你要登机，你需要出示你的 passport 和 ticket，passport 是为了证明你张三确实是你张三，这就是 authentication； 你要登陆论坛，输入用户名张三，密码 1234，密码正确，证明你张三确实是张三，这就是 authentication授权：而机票是为了证明你张三确实买了票可以上飞机，这就是 authorization。 再一 check 用户张三是个版主，所以有权限加精删别人帖，这就是 authorization。 404 找不到【前端错误 url 路径错了/或者后端错误 接口错了，实际接口与文档提供的不同】服务器无法找到请求的页面或资源。请求资源无法被找到但是可能以后会再次有效。客户端以后发出的请求也是被允许的。网页不存在 12345678# 404 Not Found =&gt; 服务器无法根据客户端的请求找到资源（网页），服务器无法找到请求的页面或资源【前端错误/后端错误】# 通过此代码，网站设计人员可设置 \"您所请求的资源无法找到\" 的个性页面# 404.0 =&gt; 没有找到文件或目录。# 404.1 =&gt; 无法通过请求的端口访问网站。此错误消息表明，试图访问的网站的 IP 地址不接受来自此请求所用端口的请求。# 404.2 =&gt; Web 服务扩展锁定策略阻止本请求。在 IIS 6.0 中，表示 Web 服务扩展列表中已经阻止了该请求。# 404.3 =&gt; MIME 映射策略阻止了此请求。 如果存在下列情况，将出现此问题：# 未配置请求的文件扩展名的处理程序映射。# 没有为网站或应用程序配置相应的 MIME 类型。 状态码使用场景： （前端路径设置错误，后端路径错误）例如，如果请求是针对服务器上不存在的网页进行的，那么服务器通常要返回此代码。 Baiduspider 通常会认为该网页已经失效，从而在搜索结果中进行删除，并且短期内 spider 再次发现这条 URL 也不会抓取。 这里不得不提的一点，很多站长想自定义 404 页面，需要做到确保 spider 访问时返回状态码为 404，若因为 404 页面跳转时设置不当，返回了200 状态码，则容易被搜索引擎认为网站上出现了大量重复页面，从而造成降权。 seo 解决方案： 对于存在的网页内容由于路径改变而导致访问不了时，应该使用 301 永久重定向跳转到新的地址，让服务器返回 301 状态码，这对搜索引擎是最友好的；若某个页面内容确实已经被删除，或者过期失效，则应该制作一个友好的 404 文件页面，同时确保该页面返回的是 404 状态码。 前端找原因： ① 是不是接口没有写对，使用 postman 这些工具看下接口对不对，前端接口写错了，还是后端写文档错了？ ② 资源的路径是不是正确，前端是不是设置路由的时候写错了地址错误（拼写不正确，字母大小写错误） ③ 资源 url 更换了？一般会给出 301 来重定向的，不排除可能后端忘记了地址错误（拼写不正确，字母大小写错误） ③ web.xml 文件中的两个 &lt;servlet-name&gt; 不一致 ③ web 应用程序部署结构没有遵守 servlet 规范 ③ 工程没有部署 ④ favicon.ico 设置的问题。所以如果您的站点目录中没有favicon.ico，那么浏览器请求您的站点时，就会产生一个404错误。解决方法也很简单，做一个favicon.ico，放到网站的根目录，就搞定了。 ⑤ robots.txt 文件问题。搜索引擎使用程序自动遍历整个站点来索引页面。我们通常把这类程序叫做 web robots(或者 Web Wanderers, Crawlers, or Spiders)。我们可以通过 /robots.txt 文件来指示 web robots 的动作（包含但不限于禁止 web robot 访问某些内容）。这个叫做”The Robots Exclusion Protocol“。 简单地说，它的工作方式大致如下： 1：web robot欲访问一个站点上的内容 2：web robot首先访问站点根目录的robots.txt文件 3：web robot分析robots.txt中的指令 4：web robot根据指令去访问站点内容 由此可见，搜索引擎的爬虫访问站点前，首先访问的是 robots.txt 文件。如果您的站点上没有这个文件，那么就会产生 404 错误。 解决：放置一个 robots.txt 文件到 public_html 目录下。 最简单的 robots.txt 文件包含两条规则（如何创建手工 robot.txt 文件可以参考[资料](http://www.robotstxt.org/),[维基百科](https://en.wikipedia.org/wiki/Robots_exclusion_standard),[其他](https://support.google.com/webmasters/answer/6062608?hl=en&amp;visit_id=636845177087323170-815856678&amp;rd=1)。） * User-agent: 指示以下的规则应用到哪种 robot * Disallow: 您想屏蔽的 URL 405 方法不允许请求由不支持该方法的资源发出。例如，使用 GET 方法在一个需要数据通过 POST 展现的表单或者是使用 PUT 在一个只读的资源中。 1# 405 Method Not Allowed =&gt; 客户端请求中的方法被禁止 状态码使用场景： seo 解决方案： 前端找原因： OPTIONS( 选项 ) ，GET( 获取 ) ，HEAD( 头 ) ，POST( 投寄 ) ，PUT( 放置 ) 各个方法不要搞错 ① axios 等等交互 config 配置 method 方法名称写错了，例如，后端使用的是 post 请求，前端做的时候却使用的是 put 请求 ② 方法的参数类型与标准不一致？ ③ 方法异常，返回值类型与标准不一致（一般是前端的问题，解决是 post 要写成 get ？？？反正就是请求方法不对，但是为啥说 post 改为 get 看不懂看不懂） ④ controller 中忘记写 @requestMapping(&quot;/XXX&quot;) 了？？？这个又是什么？？ ⑤ @DeleteMapping(&quot;/XXX&quot;) ⑥ service 方法名称写错，service 方法参数类型与标准不一致，service 方法异常、返回值类型与标准不一致 ⑦ 看下 content-type 是不是没有设置正确 406 不可接受的被请求的资源只能用于生成内容而不会接收发送请求中的头。 1# 406 Not Acceptable =&gt; 服务器无法根据客户端请求的内容特性完成请求 前端找原因 例如：正常为 Accept:*/*异常为：`Accept:text/html,application/xhtml+xml,application/xml` ① Accept 字段，请求内容错误导致。可能是代码前端代码中本来就是错的 ② 前端代码奔本来没有写错。原始请求头部的 Accept 字段是对的，但是在经过 CDN 节点的时候被 CDN 篡改了，可以查看链接 ③ 搜索引擎爬虫，非正常用户导致的问题。当然这个是属于已经上线的网站来说的，刚开发的就是前端工程师自己写错了！对开发人员来说，当站点（上线网站）遇到大量的 406 错误的时候，不用太担心，好好查下日志，它很有可能是搜索引擎的爬虫导致的。 别人的搜索引擎在为我们的页面的时候，请求头设置 Accept 与后端服务所接受的 Accept 字段不同，从而导致大量的 406 错误 407 需要代理认证12# 407 Proxy Authentication Required =&gt; 请求要求代理的身份认证# 与 401 类似，但请求者应当使用代理进行授权 客户端必须首先使用代理认证自己。 408 请求超时1# 408 Request Time-out =&gt; 服务器等待客户端发送的请求时间过长，超时 服务器超时等待请求。根据 HTTP 规范:”客户端在服务器等待期间没有发出任何请求”。客户端可能会在未来的某个时候重复请求而不做任何修改。 使用环境及影响： 客户端没有在服务器预备等待的时间内完成一个请求的发送时返回此代码； 若 Baiduspider 在对网站进行访问时，长期返回此代码，则搜索引擎会认为该网站空间访问速度不稳定，从而影响排名；解决方案： 检查 Web 服务器的工作量，看是由于访问量激增导致，还是客户端系统的工作量导致，如果两者都不是，建议检查服务器网络或者更换更好的空间服务商。 409 冲突 Conflict1# 409 Conflict =&gt; 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突 意味着请求不能被处理因为存在冲突，例如多个更新的情况下存在修改冲突。 410 遗失的 Gone12# 410 Gone =&gt; 客户端请求的资源已经不存在# 410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置 当前状态意味着被请求的资源不再有效并且以后也不会再次生效。一般用于一个资源被有意地删除或者资源需要被清除。一旦接收 410 状态码，客户端将不应该再次请求该资源。例如搜素引擎应该从它们的下表中移除资源。大部分用例并不需要客户端和搜索引擎清空资源，而是使用 404 找不到来代替。 使用环境及影响： 这个状态码的使用跟 404 有点类似，当一个文件从服务器上被永久地移除（而非转移到其它位置）时，可以使用 410 状态码，告诉搜索引擎删除已经收录的链接，避免搜索引擎再次访问时出现死链。解决方案： 当服务器出现该状态码时，需要检查该资源是否确定被永久移除，若网址还是有效的，那就表示 Web 服务器的设置有一些错误，需要进行相应的设置。若是被转移，则应使用 301 代码指定该资源的新位置。 411 长度要求 Length Required1# 411 Length Required =&gt; 服务器无法处理客户端发送的不带 Content-Length 的请求信息 请求没有指定内容的长度，但是请求的资源需要指定。 412 前置条件失败1# 412 Precondition Failed =&gt; 客户端请求信息的先决条件错误 服务器不满足请求者所请求的预置条件 413 响应实体太大123# 413 Request Entity Too Large =&gt; 由于请求的实体过大，服务器无法处理，因此拒绝请求。# 为防止客户端的连续请求，服务器可能会关闭连接。# 如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息 请求超过服务器所能处理和允许的最大值。 414 请求-URI太长1# 414 Request-URI Too Large =&gt; 请求的 URI 过长（ URI 通常为网址），服务器无法处理 被提供的 URI 对服务器的处理来说太长。经常出现在太多被编码的数据被作为查询字符串的 GET 请求的结果，因此需要被转换为 POST 请求。 415 不被支持的媒体类型1# 415 Unsupported Media Type =&gt; 服务器无法处理请求附带的媒体格式 请求实体的媒体类型不被服务器或者资源支持。例如，客户端上传一个 image/svg+xml 的图片，但是服务器需要图片使用不同的格式。 416 请求范围不能满足1# 416 Requested range not satisfiable =&gt; 客户端请求的范围无效 客户端要求文件的部分（字节服务），但是服务器不能提供那部分的内容。例如，如果客户端要求的部分超过文件的底端。 417 期望失败1# 417 Expectation Failed =&gt; 服务器无法满足 Expect 的请求头信息 服务器期望请求头字段的要求。 418 我是一个茶壶1# 418 这个代码是在 1998 年作为传统的 IETF April Fools’ jokes 被定义的在 RFC2324，超文本咖啡罐控制协议，但是并没有被实际的 HTTP 服务器实现。RFC 指定了这个代码应该是由茶罐返回给速溶咖啡。 419 认证超时1# 419 认证超时 并不是 HTTP 标注的一部分，419 认证超时表示以前的有效证明已经失效了。同时也被用于 401 未认证的替代选择为了从其它被拒绝访问的已认证客户端中指定服务器的资源。 420 方法失效不是 HTTP 的标准，但是被 Spring 定义在 HTTP 状态类中当方法失时使用。这个状态码已经不推荐在 Spring 中使用。 420 提高你的耐心也不是HTTP标准的一部分，但是被版本1的Twitter搜索和趋势APi返回当客户端的速率被限制的时候。其它的服务提供商可能会使用429太多的请求响应码来代替。 421 误导请求请求被直接定向到不能产生响应的服务器上（例如因为一个连接的复用）。 422 不可处理的实体（WebDAV）请求符合要求但是不能接受错误由于语法错误。 423 锁定的资源访问被锁定。 424 失败的依赖请求由于上一个请求的失败而失败。 426 需要升级客户端应该切换不同的协议例如 TLS/1.0 在指定的升级的头字段里。 428 需要前置条件 [新增]12345678# Precondition Required (要求先决条件)# 先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。# 一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，# 那么客户端只在响应中的 ETag 改变后才会重新接收回应。# 先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，# 这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。# 当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，# 这个方法为服务器提供一种有效的方法来阻止 'lost update' 问题。 原始服务器需要有条件的请求。当客户端GET一个资源的状态的时候，同时又PUT回给服务器，与此同时第三方修改状态到服务器上的时候，为了避免丢失更新的问题发生将会导致冲突。 429 过多请求 [新增]12345# 429 Too Many Requests (太多请求)# 当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。# 在此之前，有一些类似的状态码，例如 '509 Bandwidth Limit Exceeded'. Twitter 使用 420 （这不是HTTP定义的状态码）# 如果你希望限制客户端对服务的请求数，可使用 429 状态码，# 同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。 用户已经发送了太多的请求在指定的时间里。用于限制速率。 431 请求头部字段太大 [新增]12# 431 Request Header Fields Too Large (请求头字段太大)# 某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。 服务器由于一个单独的请求头部字段或者是全部的字段太大而不愿意处理请求。 440 登陆超时（微软）一个微软的扩展，意味着你的会话已经超时。 444 无响应被使用在 Nginx 的日志中表明服务器没有返回信息给客户端并且关闭了连接（在威慑恶意软件的时候比较有用）。 449 重试（微软）一个微软的扩展。请求应该在执行适当的动作之后被重试。 450 被 Windows 家长控制阻塞（微软）一个微软的扩展。这个错误是当Windows家长控制打开并且阻塞指定网页的访问的时候被指定。 451 由于法律原因而无效（因特网草稿）被定义在因特网草稿“一个新的 HTTP 状态码用于法律限制的资源”。被用于当资源的访问由于法律原因被禁止的时候。例如检查制度或者是政府强制要求禁止访问。一个例子是 1953 年 dystopian 的小说 Fahrenheit 451 就是一个非法的资源。 451 重定向（微软）被用在 Exchange ActiveSync 中如果一个更有效的服务器能够被使用或者是服务器不能访问用户的邮箱。客户端会假定重新执行 HTTP 自动发现协议去寻找更适合的服务器。 494 请求头太大（Nginx）Nginx 内置代码和 431 类似，但是是被更早地引入在版本 0.9.4（在 2011 年 1 月 21 日） 495 证书错误（Nginx）Nginx 内置的代码，当使用 SSL 客户端证书的时候错误会出现为了在日志错误中区分它和 4XX 和一个错误页面的重定向。。 496 没有证书（Nginx）Nginx 内置的代码，当客户端不能提供证书在日志中分辨 4XX 和一个错误页面的重定向。 497 HTTP到HTTPS（Nginx）Nginx 内置的代码，被用于原始的 HTTP 的请求发送给 HTTPS 端口去分辨 4XX 在日志中和一个错误页面的重定向。 498 令牌超时或失效（Esri）由 ArcGIS for Server 返回。这个代码意味着令牌的超时或者是失效。 499 客户端关闭请求（Nginx）被用在 Nginx 日志去表明一个连接已经被客户端关闭当服务器仍然正在处理它的请求，是的服务器无法返货状态码。 499 需要令牌（Esri）由 ArcGIS for Server 返回。意味着需要一个令牌（如果没有令牌被提交）。 七、 5 开头状态码【服务器错误】5XX 服务器错误 服务器似乎不能满足有效的请求 以数字 5 开头的响应状态码意味着服务器已经意识到遇到了一个错误或者是无法发送请求。除了响应 HEAD 请求的时候，服务器应该包含一个保存错误情形解释的实体，并且标识这个情况是暂时的还是永久的。同样地，用户代理也应该展示任何被包含的实体给用户。这些响应码适用于任何请求方法。 Server Error（服务端错误） 服务器错误，服务器在处理请求的过程中发生了错误 (后端错误) 服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 500 服务器内部错误一个普通的错误信息，当一个意外的情况出现并且没有其它明确的消息是合适的。（服务器内部错误）服务器遇到错误，无法完成请求。 123456789101112# 500 Internal Server Error =&gt; 服务器内部错误，无法完成请求# 500.12 应用程序正忙于在 Web 服务器上重新启动。# 这表示您在 IIS 重新启动应用程序的过程中试图加载 ASP 页。# 刷新页面后，此消息即会消失。如果刷新页面后，此消息再次出现，可能是防病毒软件正在扫描 Global.asa 文件。# 500.13 Web 服务器太忙。# 500.15 不允许直接请求 Global.asa。# 500.16 UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。# 500.18 无法打开 URL 授权存储库。这个错误代码为 IIS 6.0 所专用。# 500.19 此文件的数据在元数据库中配置不正确。# 如果 XML 元数据库在您尝试访问的内容类型中包含无效的配置信息，您就会收到此错误。# 要解决此问题，请删除或更正无效的配置。此问题通常表示 ScriptMap 元数据库键中存在问题。# 500.100 内部 ASP 错误。 如果试图加载的 ASP 页中含有错误代码，将出现此错 使用环境及影响： 页面代码出错时返回的状态。一般来说当访问的网站或者页面 ASP 或者 PHP 等出现代码错误，如语法错误、数据库连接错误等，而恰好服务器环境关闭了出错信息的输出提示，则出现 500 错误反馈。网站若返回大量 500 错误，不仅对用户体验不友好，也会影响搜索引擎对该页面的评分从而影响排名。 seo 解决方案： 首先检查下网页的源代码，看下是否存在不规范的语法错拼、代码缺少等导致页面验证失败，或者数据库连接语句出错等问题。若没有，则检查下服务器是否正常响应，是否安装了服务器不支持的组件等，必要的话可以重启下服务器。 前端找错误原因 ① 500 报错一般是前端的问题，但也不能排除是前端出错了，例如后台报出序列化错误，就可能是前端没有设置content-Type = application/json,或者其他的类型，反正看下 content-type 是不是没有设置正确 ② 查看前端代码是不是有代码逻辑的问题，根据提示找 bug ③ 常见的错误位置：NullpointException，根据库中提取数据没有提取到，但是却赋值给另一个对象传入了空值/注入了对象，出现空值 null，没有获取到对象而出现异常 ④ servlet 类没有继承 HttpServlet 或实现 servlet 接口web.xml 文件中的 `&lt;servlet-class&gt;` 写错 service 方法中代码运行时抛出异常 ⑤ 主要错误是服务器内部错误，程序上的错误为多的，用户权限的问题导致，或者是数据库连接出现了错误 501 没有实现、请求格式错误服务既不能识别请求方法，也缺少满足请求的能力。一般会在将来可用(例如一个新的 web-service 接口特性) 1# 501 Not Implemented =&gt; 服务器不支持请求的功能，无法完成请求 前端找错误原因： ① 一般是后端的错误，但是前端也是可能的，看下 axios 等等交互配置 type：”post/get” 是否出错，或者是 form 表单中 method：”post/get” 是否书写错误。 ② 是服务器还是不具有请求功能的，而且是没有实施的，可以用来 HttpWebRequest 指定一个 UserAgent 来试试的，可以换电脑来测试一下，可以换不同类型浏览器测试 502 错误的网关服务器作为一个网关或者代理，从上游的服务器中接收到无效的响应。502（错误网关）服务器作为网关或代理，从上游服务器收到了无效的响应。 123# 502 Bad Gateway =&gt; 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求# 502.1 CGI 应用程序超时。# 502.2 CGI 应用程序出错。 使用环境及影响： 该代码一般由于网关错误而造成的（不一定是自身的 web 服务器），当作为网关或代理的服务器与上层内容服务器联络时，收到无效的响应时则返回该代码。 解决方案： 首先在排除是我们浏览器使用了代理前提下，可以尝试清除浏览器缓存，再者检查下网关是否配置正确，或者刷新服务器，尝试重新发送请求。 先清除下缓存或者是在服务器上进行刷新。 503 服务不可用（暂时的状态）服务当前不可用(因为过载或者下线维护)。一般而言，只是一种暂时的状态。（服务不可用）目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。 12# 503 Service Unavailable =&gt; 由于超载或系统维护，服务器暂时的无法处理客户端的请求。# 延时的长度可包含在服务器的 Retry-After 头信息中 使用环境及影响： 网站临时关闭或其他临时情况，如宽带超限、服务器响应不及时等，应该返回此代码。 一般来说 Baiduspider 会认为该网页临时不可访问，不会把这条 URL 直接删除，短期内会再访问。届时如果网页恢复，则正常抓取。这也是 503 和 404 的区别，如果是 404 则通常会从搜索结果中删除，并后续不会再抓取。解决方案： 一般这种情况是由网站服务器关闭或维护造成的，联系服务器管理员或者服务商解决即可！ 后端服务器正在维护或者暂停了，cpu 占用的频率大导致的，等后端处理就 ok 了 504 网关超时服务器作为一个网关或者代理，但是没有从上游服务器收到即时的响应。 1# 504 Gateway Time-out =&gt; 充当网关或代理的服务器，未及时从远端服务器获取请求 504（网关超时）服务器作为网关或代理，未及时从上游服务器接收请求。 使用环境及影响： 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（ URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。解决方案： 这个错误完全是由后端电脑之间 IP 通讯缓慢而产生，可能包括 Web 服务器。为此该问题一般需要站长和互联网服务供应商 (ISP) 及 Web 服务器软件供应商联络，检查在其控制下的不同电脑之间的 IP 数据传输的流通状况来进行解决。 505 HTTP版本不支持服务器不支持在请求中使用的 HTTP 协议。 1# 505 HTTP Version not supported =&gt; 服务器不支持请求的 HTTP 协议的版本，无法完成处理 使用环境： 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。 前端解决方案： 如果出现这个错误，可以通过升级 Web 服务器软件。如果版本 1.x 的请求失败，很可能是因为你的 Web 服务器不是很好地支持 1.x 协议版本，而不是完全不支持。 http 的版本是不受支持的，升级浏览器，一般现在的电脑安装的浏览器不会出现，一般是使用古老的电脑会出现这个问题。 506 变量也是导航对于请求是透明的内容导航导致循环参照。 507 存储不足服务器不能存储需要的内容去完成请求。 508 发现环路服务器发现了一个无限的循环档处理请求的时候。 509 频带宽度超出限制(Apache的扩展)这个状态码没有在任何RFCS中指定。使用方法是未知的。 511 需要网络授权 [新增]客户端需要授权去火的网络的访问权限。一般用于代理交互中被用来进行网络的访问控制。 1234567891011# 511 Network Authentication Required (要求网络认证)# 如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。# 如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。# 这是通过拦截 HTTP 流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。# 使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：# - 如果你在登录 WIFI 前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico'。# 登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。# - 如果客户端使用 HTTP 请求来查找文档（可能是 JSON ），网络将会响应一个登录页，# 这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。# 因此 511 状态码的提出就是为了解决这个问题。# 如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。 520 未知错误这个状态码也没有被指定在任何RFC中，并且只会被一些服务器返回，例如微软的Azure和CloudFlare服务器:”520错误本质上是一个捕获全部的响应当原始服务器返回一些未知的或者一些不能被忍受或者被解释的(协议违反或者空响应)”。 598 网络读取超时异常(未知)（微软）这个状态码也没有在任何 RFC 中指定，但是被用在微软的 HTTP 代理中去标注一个网络读取超时在一个客户端之前的代理的后面。 599 网络连接超时异常(未知)（微软）这个状态码也没有在任何RFC中指定，但是被用在微软的 HTTP 代理中去标注一个网络连接超时在一个客户端之前的代理的后面。","tags":[]},{"title":"vue.js--[小白入门篇]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-入门/","text":"一、前言在前面已经学习了 jQurey.js 这个框架，既然有这样一个框架方便我们使用，肯定会有更加方便的框架给我们使用，那就是 vue.js 了。Jquery 专注于dom操作，步骤一般为：获取 dom 元素–&gt; 跟 dom 元素赋值+加事件–&gt;插入 dom 元素。 其中 dom 元素赋值和加事件又需要获取 dom 元素和给dom元素赋值，代码量会很大。 Vue 专注于数据：用户只需要关注 dom 元素值对应绑定的数据，每次 dom 需要修改只需要去修改数据就可以了。vue.js 背后做了大量的工作，我们可以简单的实现 html 与 js 之间的数据绑定，达到前后端数据的便捷绑定。 vue 优势在于去 dom 操作和双线数据绑定。 由于 Vue 帮我们省略了dom 操作，加上双向数据绑定，Vue 的代码量减少很多，代码变得比较简洁，逻辑更加清晰。 由于多个 dom 事件可能会同时修改一个元素的值， Vue 只需要关注元素对应绑定的数据就可以了，这使得 Vue 在逻辑上会更加清晰 二、vue.js 的安装2.1 Vue Devtools 调试工具在安装 vue.js 之前，推荐在浏览器上安装 Vue Devtools。它允许你在一个更友好的界面中审查和调试 Vue 应用。让开发者方便调试代码。 2.2 独立版本引入官网下载文件放置在项目目录下。如下引入 vue.js，这样 Vue 会被注册为一个全局变量 12&lt;script src=\"../vue.js\"&gt;&lt;/script&gt;//注意开发使用开发版本 vue.js，生产上线用 vue.min.js 版本 2.3 CDN引入[CDN链接]]。如下引入 vue.js，这样 Vue 会被注册为一个全局变量 12&lt;script src=\"https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.js\"&gt;&lt;/script&gt;//注意开发使用开发版本 vue.js，生产上线用 vue.min.js 版本 三、vue.js 的 vue 属性选项：数据绑定, DOM，JS 交互原理 MVVM : model view view model model:指数据 view:页面(页面上面输入数据会影响model) 3.1 原始的 html/js/css 写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!-- 这里是没有使用 vue-cli 的写法,原始的 html/css 写法--&gt;&lt;head&gt;&lt;style&gt;/* css... */&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; number &#125;&#125; &lt;!-- 数据绑定 “Mustache” 语法 (双大括号) --&gt; &lt;/div&gt; &lt;script&gt; var appvm = new Vue(&#123; el: '#app', //①el选项/属性：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。 //只在由 new 创建的实例中遵守，这里是用new Vue创建的 data: &#123; //②data选项/属性：与html中的数据绑定，实现双向绑定 nunber:18 &#125;, watch: &#123;//监听数据的变化 number: function (newnumber , oldnumber) &#123; &#125; &#125; created: function () &#123; &#125;, computed: &#123; //计算属性 reversedMessage: function () &#123; &#125;, &#125;, methods: &#123; //方法 reverseMessage: function () &#123; &#125; &#125;, beforeCreate: function () &#123; console.log('1-beforeCreate 初始化之后'); &#125;, created: function () &#123; console.log('2-created 创建完成'); &#125;, beforeMount: function () &#123; console.log('3-beforeMount 挂载之前'); &#125;, mounted: function () &#123; console.log('4-mounted 被挂载之后'); &#125;, beforeUpdate: function () &#123; console.log('5-beforeUpdate 数据更新前'); &#125;, updated: function () &#123; console.log('6-updated 被更新后'); &#125;, activated: function () &#123; console.log('7-activated'); &#125;, deactivated: function () &#123; console.log('8-deactivated'); &#125;, beforeDestroy: function () &#123; console.log('9-beforeDestroy 销毁之前'); &#125;, destroyed: function () &#123; console.log('9-destroyed 销毁之后'); &#125;, errorCaptured: function () &#123; console.log('11-errorCaptured 发生错误'); &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 3.2 vue-cli脚手架框架中.vue的写法1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 这里是/vue文件 --&gt;&lt;tempalate&gt; &lt;!-- html --&gt; &lt;div class=\"home\"&gt; &#123;&#123; number &#125;&#125; &lt;!-- 数据绑定 “Mustache” 语法 (双大括号) --&gt; &lt;/div&gt;&lt;/tempalate&gt;&lt;script&gt;//这里是使用了 vue-cli 脚手架建立框架之后的写法,因为 .vue 文件都是导出给 js 文件使用的export default &#123; //做成导出件 name: 'Home', // 这里是组件的名称 data () &#123; return &#123; number: 18 &#125; &#125;, watch: &#123;//监听数据的变化 number: function (newnumber , oldnumber) &#123; &#125; &#125;, created() &#123; &#125;, computed: &#123; //计算属性 reversedMessage: function () &#123; &#125; &#125;, methods: &#123; //方法 reverseMessage() &#123; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;/* css */&lt;/style&gt; 四、vue 的指令学习（ html 指令/template）vue 指令是用于 template，也即是 html 编辑的时候使用的。 4.1 v-text、v-html 数据双向绑定 ①可以说这个是后面两个的简写，这个不是指令 ②v-text 纯文本的双向绑定，这个是指令，vue 中指令都是在前面有v- ③v-html 带 html 元素/标签 的 DOM 文本绑定，这个是指令，vue 中指令都是在前面有v- 可以说这个是后面两个的简写，这是 vue 中常用的数据绑定。如此双向绑定之后，DOM 中显示会出现，在 new Vue 的 data 中获取到数据之后 替代掉{massage}}显示真正要展示的文本。简单的说{massage}}是写在标签内容区。而vue指令是写在html的开标签中的。v-text 是纯文本的绑定，会将 data 中的数据照搬过来，即使里面存在元素标签不会转化为 DOM 元素。v-html 是 html 元素/标签 的 DOM 文本绑定，如果 data 中有的数据是带标签的，绑定之后会解析为 html 标签元素.12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p v-text=\"msg\"&gt;&lt;/p&gt; &lt;p v-html=\"msg\"&gt;&lt;/p&gt; &lt;p&gt;&#123;&#123; number + 1 &#125;&#125;简单的可以这样用&lt;/p&gt; &lt;p&gt;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; text.split( '').reverse().join( '') &#125;&#125;不建议在这里这样用，应该在 script 的方法里面处理&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var appvm = new Vue(&#123; el: '#app', data: &#123; name:'xiaomi', msg:'&lt;span style=\"color:red\"&gt;hello!&lt;/span&gt;', nunber:18, ok: true, text: 'danger', &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 效果展示： 注意：值得注意的是使用 v-html 需要小心，跟 js 使用 innerHtml 一样，注入带元素的标签是非常危险的。在生产环境中动态渲染 HTML 是非常危险的，因为容易导致 XSS 攻击。所以只能在可信的内容上使用 v-html，永远不要在用户提交和可操作的网页上使用。 ？？？比如说？？？ XSS 攻击全称跨站脚本攻击，是为不和层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，故将跨站脚本攻击缩写为 XSS，XSS 是一种在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到提供给其它用户使用的页面中。 4.2 v-if v-else 条件渲染指令根据 v-if 绑定的数据的真假来选择渲染对象、方式、css 样式等等。 1234567891011121314&lt;div id=\"app\"&gt; &lt;div v-if=\"loginStatue\" style=\"background: yellow;\"&gt;您好！&lt;/div&gt; &lt;div v-else style=\"background: gray;\"&gt;请登录&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; loginStatue: true //这里使得 v-if=\"loginStatue\" 绑定的 loginStatue 为真。 //将会选择v-if所在的语句显示，v-else语句将不会得到渲染出来 &#125; &#125;)&lt;/script&gt; 效果展示： 将 true 更改为 false 得到下面的效果图。当然了实际应用中我们不是手动的来修改这个数据为 false 的，而是根据 methods 选项中的方法来触发数据的修改。 4.2.1 v-if v-else-if v-else 多重语句，更多的语句进行条件渲染。12345678910111213141516&lt;!-- 注意：这几个绑定一定要紧跟着，不然没有效果的。中间不能插入其他的不绑定的语句 --&gt;&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;!-- 不能在这些地方添加其他没有绑定if的元素 --&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;!-- 不能在这些地方添加其他没有绑定if的元素 --&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;!-- 不能在这些地方添加其他没有绑定if的元素 --&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 4.2.2 key 管理复用元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换。 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder.简单的说他们很懒惰别人有的他们也需要使用的话就直接用别人的，自己需要更新的部分才会更新。 key的作用 这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可： 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; 现在，每次切换时，输入框都将被重新渲染。注意：&lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性。 4.3 v-show 切换元素的CSS属性 display1234567891011121314&lt;div id=\"app\"&gt; &lt;div v-if=\"loginStatue\" style=\"background: yellow;\"&gt;您好！&lt;/div&gt; &lt;div v-else style=\"background: gray;\"&gt;请登录&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; loginStatue: true //这里使得v-if=\"loginStatue\"绑定的loginStatue为真。 //将会选择v-if所在的语句显示，v-else语句将不会得到渲染出来 &#125; &#125;)&lt;/script&gt; 效果展示： 将true更改为false得到下面的效果图。当然了实际应用中我们不是手动的来修改这个数据为false的，而是根据methods选项中的方法来触发数据的修改。注意设置为false的话，浏览器就么有内容了，但是在审查中这个DOM还是存在的，只是多了一个display:none,设置为不可见。DOM已经加载，只是CSS控制没有显示出来。 v-if v-else 与v-show 的区别 v-if v-else 判断是否加载对应的html内容，判断是否加载，可以减轻服务器的压力，在需要时加载。 v-show 判断是是否对文本进行隐藏或显示，相当display的效果，调整css dispaly属性，可以使客户端操作更加流畅 v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 4.4 v-for 模板循环指令当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。 4.4.1 循环数组 v-for 指令循环渲染一组 data 的数组。要哪个 html 标签循环，v-for 就写在那个上边。v-for 指令需要以 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。因为是形式，所以我们可以相应的写，text in texts 等等这样的来做循环数据渲染 html 模板写法 text 表示的是体现在 html 里面的文本，texts 指的是所有里面的 text 文本的数组集合. 可以循环的参数：①item ②索引index 123456789101112131415&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;li v-for=\"item in items\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; var itemsArr = [10, 20, 30, 40, 50, 60] var vm = new Vue(&#123; el: '#app', data: &#123; items: itemsArr &#125; &#125;) &lt;/script&gt; 效果展示： 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt; &lt;!-- 当然不只是是在list列表中循环，在其他元素上也是可以循环的。 --&gt; &lt;p v-for=\"(student,index) in sortStudents\"&gt; &#123;&#123;index+1&#125;&#125;、名字:&#123;&#123;student.name&#125;&#125; &lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;年龄: &#123;&#123;student.age&#125;&#125;,资产:&#123;&#123;student.money&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm1 = new Vue(&#123; el: '#app', data: &#123; students: [&#123; name: 'xiaomi', age: 18, money: 100000000 &#125;, &#123; name: 'xiaomizhou', age: 100, money: 450000000 &#125;, &#123; name: 'liuliu', age: 50, money: 2300000000 &#125;, &#123; name: 'meimeimei', age: 30, money: 224000000 &#125;] &#125; &#125;)&lt;/script&gt; 效果展示： 4.4.2 循环对象可以循环的参数：①item ②索引index③键值key 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;)&lt;/script&gt; 效果：注意：每次的结果可能不一致，因为对象是无序的！！！0.firstName:John1.lastName:Doe2.age:30 需要注意的是！！！！！！！！！！！！！！！ v-for=&quot;(value, key, index) in object&quot; 如果有两个参数，第一个参数是 value ，第二个参数是 index 如果有两个参数，第一个参数是 value ，第二个参数是 key ，第三个是 index 参数的顺序不能有错，如果错误的话，循环是会出错，key 绑定的值大多数情况是会报错的。 4.4.3 key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值. 1234567&lt;!-- 如果数组中的项存在 id，那么 key 可以直接绑定 id ，没有 id 的话通常用绑定的是 index --&gt;&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt;&lt;div v-for=\"(item,index) in items\" :key=\"index\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。 4.5 v-on 事件绑定指令官网地址： v-on 就是监听事件，可以用v-on指令监听DOM事件来触发一些javascript代码。语法：v-on:click=&quot;函数变量&quot;用@简写的语法：@click=&quot;函数变量&quot;键盘回车事件v-on:keyup.enter=&quot;???&quot; 4.5.1 v-on事件绑定：方法名12345678910111213141516171819202122&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-text=\"massage\"&gt;&lt;/p&gt; &lt;button v-on:click=\"add\"&gt;点击massage自增&lt;/button&gt; &lt;button @click=\"subtract\"&gt;点击massage自减&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; massage: 60, &#125;, methods: &#123; add: function () &#123; this.massage++; &#125;, subtract: function () &#123; this.massage--; &#125; &#125; &#125;) &lt;/script&gt; 效果展示： 4.5.2 v-on事件绑定：方法传参1234567891011121314&lt;div id=\"app\"&gt; &lt;button v-on:click=\"say('hi')\"&gt;Say hi&lt;/button&gt; &lt;button v-on:click=\"say('what')\"&gt;Say what&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', methods: &#123; say: function (message) &#123; alert(message) &#125; &#125;&#125;)&lt;/script&gt; 4.5.2 特殊变量 $event1234567891011&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit&lt;/button&gt;// ...methods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 4.5.3 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop.prevent.capture.self.once.passive 12345678910111213141516171819202122&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 阻止单击事件继续传播 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt; &lt;!-- 修饰符可以串联 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 只有修饰符 --&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;!-- 尤其能够提升移动端的性能。 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 4.5.4 按键修饰符4.5.4.1 keycodekeycode 是数字代码，（例如，enter 键的 keycode 是 13 ）但是要记住这里数字是很困难的，这时候我们就会有别名的存在 4.5.4.2 keycode 别名123456789101112.enter # 回车键.tab # tab 键.delete # 捕获“删除”和“退格”键).esc # 退出.space # 空格键.up # 向上.down # 向下.left # 后退.right # 前进.arrow-right.media-play-pause # 暂停.v # V 字母键 1234567&lt;!-- 下面的 3 行代码是等效的（前提是没有全局配置别名的时候） --&gt;&lt;input v-on:keyup.13=\"submit\"&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;input @keyup.enter=\"submit\"&gt;&lt;input type=\"text\" @keyup.media-play-pause=\"method\"&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.right=\"handleSubmit\" /&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.arrow-right=\"handleSubmit\" /&gt; 4.5.4.3 全局配置别名 Vue.config.keyCodes如果提供的别名不能满足我们的要求，可以自行配置 123456789Vue.config.keyCodes = &#123; v: 86, c: 87, x: 88, f1: 112, //mediaPlayPause: 179,// 这样是错误的 camelCase 不可用 \"media-play-pause\": 179,// 取而代之的是 kebab-case 且用双引号括起来 up: [38, 87]&#125; 4.5.5 系统修饰键 ctrl alt shift meta对于不同的键盘, 这四个系统修饰键对应各有不同 mac 系统键盘, meta 键对应 command 键 windows 系统,meta 键中对应 ⊞ 键 123456&lt;!-- ctrl+v 都被按下时候出发的事件，可能会有其他的按键也按下了--&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.ctrl.v=\"handle\"/&gt;&lt;!-- exact 翻译：精确 当且仅当 同时按下 ctrl+v 时候触发的事件--&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.ctrl.v.exact=\"handle\"/&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.ctrl.c=\"handle\"/&gt;&lt;input type=\"text\" placeholder=\"请输入电话号码\" v-model=\"phone\" @keyup.ctrl.x=\"handle\"/&gt; 4.6 v-model 表单绑定指令 就是说用户输入的文本与html显示文本的绑定是通过v-model来实现的，把两者都与vue构造函数的data里对应的属性值绑定起来就ok了。v-model绑定的是表单输入的数据。它负责监听用户的输入事件以更新数据 4.6.1 v-model指令的修饰符，三个修饰符都是可选择的，可以同时存在 的，不分先后的 .lazy：取代 input 监听 change 事件.用法：v-model.lazy=&quot;&quot;, 作用：lazy就是懒惰的意思， 所以这个属性的作用很好理解，就是让双向数据的改变变懒惰，不实时 用了这个修饰之后，我们在输入框输入文字，p标签里面的文本不跟着改变， 直到我们把光标移除输入框，p标签里面的文本才改变。 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步： .number：输入字符串转为数字。 用法：v-model.number=&quot;&quot;, 作用：自动的将字符串隐式转化为数字 问题：（如果原值的转换结果为 NaN 则返回原值即字符串） .trim：输入去掉首尾空格。 用法：v-model.trim=&quot;&quot;, 作用：自动的将输入的文本消息中的空格修剪掉，也就是删除掉 4.6.2 ① [单行文本框、多行文本框]-使用v-model数据绑定123&lt;p&gt;&#123;&#123;massage&#125;&#125;&lt;/p&gt;&lt;input type=&quot;text&quot; v-model=&quot;massage&quot; /&gt;这里就实现了最简单的数据双向绑定，input 里面 v-model 值改变，p 标签内的值也就跟着改变了，这个改变时实时的，就是立即改变的 1234567891011121314151617181920&lt;div&gt; &lt;p v-text=\"massage\"&gt;&lt;/p&gt; &lt;input v-model=\"massage\" type=\"text\" placeholder=\"请输入数字\" /&gt;v-model &lt;hr/&gt; &lt;input v-model.lazy=\"massage\" type=\"text\" placeholder=\"请输入数字\" /&gt;v-model.lazy &lt;hr/&gt; &lt;input v-model.number=\"massage\" type=\"text\" placeholder=\"请输入数字\" /&gt;v-model.number &lt;hr/&gt; &lt;input v-model.trim=\"massage\" type=\"text\" placeholder=\"请输入数字\" /&gt;v-model.trim &lt;hr/&gt; &lt;textarea name=\"ee\" id=\"ee\" cols=\"30\" rows=\"10\" v-model.number.trim=\"massage\"&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; massage: 60 &#125; &#125;)&lt;/script&gt; 效果展示： 4.6.3 ② [单选框]–使用v-model数据绑定1234567891011121314151617&lt;div&gt; &lt;label for=\"female\"&gt;女&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"female\" value=\"female\" v-model=\"sex\" /&gt; &lt;label for=\"man\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"man\" value=\"man\" v-model=\"sex\" /&gt; &lt;br/&gt; &lt;span&gt;勾选的是为:&#123;&#123;sex&#125;&#125;&lt;/span&gt; &lt;hr/&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; sex: 'female' &#125; &#125;)&lt;/script&gt; 效果展示： 注意的问题：v-model 会忽略所有表单元素的 value、checked、selected ,特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。简单来说，他们的初始值不像是 html 那样在 html 标签里面设置的。在这里他们是根据 data 中的值决定的，即使在标签中有，它们还是会根据 data中 的值来决定的。 4.6.3 ③ [多选框]–使用v-model 数据绑定12345678910111213141516171819202122232425262728&lt;div&gt; &lt;p&gt;多选框使用v-model数据绑定&lt;/p&gt; &lt;p&gt;单个复选框，绑定到布尔值 &lt;/p&gt; &lt;label for=\"checkbox\" v-text=\"datachecbox\"&gt;&lt;/label&gt; &lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"datachecbox\" /&gt; &lt;br/&gt; &lt;p&gt; 多个复选框，绑定到同一个数组： &lt;/p&gt; &lt;label for=\"car1\"&gt;宝马&lt;/label&gt; &lt;input type=\"checkbox\" name=\"car1\" id=\"car1\" value=\"宝马\" v-model=\"cars\" /&gt; &lt;label for=\"car2\"&gt;奔驰&lt;/label&gt; &lt;input type=\"checkbox\" name=\"car2\" id=\"car2\" value=\"奔驰\" v-model=\"cars\" /&gt; &lt;label for=\"car3\"&gt;兰博基尼&lt;/label&gt; &lt;input type=\"checkbox\" name=\"car3\" id=\"car3\" value=\"兰博基尼\" v-model=\"cars\" /&gt; &lt;br/&gt; &lt;span&gt;勾选的是为&#123;&#123;cars&#125;&#125;&lt;/span&gt; &lt;hr/&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; datachecbox: true, cars: ['奔驰', '宝马', '兰博基尼'] &#125; &#125;)&lt;/script&gt; 效果展示： 4.6.3 ④ [多选框]–使用v-model 数据绑定123456789101112131415161718192021222324252627282930&lt;div id=\"div\"&gt; &lt;h2&gt;下拉框使用v-model&lt;/h2&gt; &lt;p&gt;单选下拉框，绑定到一个值&lt;/p&gt; &lt;select name=\"\" id=\"\" v-model=\"area\"&gt; &lt;option value=\"\" disabled=\"disabled\"&gt;请选择&lt;/option&gt; &lt;option value=\"广西\"&gt;广西&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;option value=\"广东\"&gt;广东&lt;/option&gt; &lt;/select&gt; &lt;span&gt;选择的是&#123;&#123;area&#125;&#125;&lt;/span&gt; &lt;p&gt;多选下拉框,绑定到数组&lt;/p&gt; &lt;select name=\"\" id=\"\" v-model=\"area1\" multiple&gt; &lt;option value=\"\" disabled=\"disabled\"&gt;请选择&lt;/option&gt; &lt;option value=\"广西\"&gt;广西&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;option value=\"广东\"&gt;广东&lt;/option&gt; &lt;/select&gt; &lt;span&gt;选择的是&#123;&#123;area1&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#div', data: &#123; area: '广东', //单选下拉框的初始值 area1: ['上海','广西'] //多选下拉框的初始值 &#125; &#125;)&lt;/script&gt; 效果展示： 4.7 v-bind 绑定[标签属性]指令 ！！！重点12语法举例： v-bind:src=&quot;???&quot;简写： :src=&quot;???&quot; 就是以冒号替代 4.7.1 与标签的属性绑定（包括 class）这里是简单的与属性绑定， 属性值写在 js 中赋值给一个 vue 构造函数的 data 属性，data 属性写在 html 中。简单来说，就是绑定的值必须在 vue 中的 data 属性中进行声明。我们绑定的只是属性名 1234567891011121314151617181920212223242526272829303132&lt;style&gt;.red&#123;color:red;&#125;.blue&#123;color:blue;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;img v-bind:src=\"imgSrc\" /&gt; &lt;a v-bind:href=\"aHref\"&gt;兔子&lt;/a&gt; &lt;p v-bind:class=\"classA\"&gt;v-bind 与 class 属性直接简单的绑定，&lt;/p&gt; &lt;p v-bind:title=\"message\"&gt;鼠标悬停几秒钟查看此处动态绑定的提示信息！&lt;/p&gt; &lt;p title=\"mei\"&gt;xiaomi xiaomixiaomi！&lt;/p&gt; &lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#div', data: &#123; imgSrc:'../.png', aHref:'http://...', classA:'red', message: '页面加载于 ' + new Date().toLocaleString(), id: 18 &#125; &#125;)&lt;/script&gt;&lt;!-- 可以在 js 中去动态的修改 img 图片的 src，链接 a 中的 href，class 中的属性上面的代码等价于原始的 html&lt;div id=\"app\"&gt; &lt;img src=\"../.png\" /&gt; &lt;a href=\"http://...\"&gt;兔子&lt;/a&gt; &lt;p class=\"red\"&gt;&lt;/p&gt;&lt;/div&gt; --&gt; 4.7.2 class 绑定升华①class：值/数组绑定 12345678910111213141516171819202122&lt;style&gt;.active &#123;color: greenyellow;&#125;.px30 &#123;font-size: 30px;&#125;.border1px &#123;border: 1px blue solid;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;p v-bind:class=\"classNameA\"&gt;4.7.1节的简单绑定&lt;/p&gt; &lt;p v-bind:class=\"[classNameA]\"&gt;v-bind 与class 属性值接简单的绑定，只有一项的数组&lt;/p&gt; &lt;p v-bind:class=\"[classNameA,classNameB]\"&gt;简单绑定多个 class 名&lt;/p&gt; &lt;p class=\"border1px\" :class=\"[classNameB]\"&gt;v-bind:class 指令也可以与普通的 class 属性存。&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; classNameA: 'active', classNameB: 'px30' &#125; &#125;)&lt;/script&gt; ②class：对象绑定 1234567891011121314151617181920&lt;style&gt;.active &#123;color: greenyellow;&#125;.px30 &#123;font-size: 30px;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;p v-bind:class=\"&#123;active:isActive&#125;\"&gt;js控制isActive&lt;/p&gt; 判断active,isPx30这个属性值是否需要 &lt;p v-bind:class=\"&#123;active:isActive,px30:isPx30&#125;\"&gt;js控制isActive/isPx30&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; isActive: true, isPx30: true &#125; &#125;)&lt;/script&gt; ③class：三元表达式绑定 12345678910111213141516171819&lt;style&gt;.active &#123;color: greenyellow;&#125;.danger &#123;color: red;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;p v-bind:class=\"isActive?classNameA:classNameB\"&gt;三元&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; isActive: true, classNameA: 'active', classNameB: 'danger' &#125; &#125;)&lt;/script&gt; ④数组，三元表达式，对象 混合使用 12345678910111213141516171819202122&lt;style&gt;.active &#123;color: greenyellow;&#125;.danger &#123;color: red;&#125;.px30 &#123;font-size: 30px;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;p v-bind:class=\"[isActive?classNameA:classNameB,classNameC]\"&gt; 三元表达式与数组混合使用&lt;/p&gt; &lt;p v-bind:class=\"[&#123;active:isActive&#125;,classNameA]\"&gt; 对象与数组混合使用&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; isActive: false, classNameA: 'active', classNameB: 'danger', classNameC: 'px30' &#125; &#125;)&lt;/script&gt; *⑤class：computed属性值 绑定 1234567891011121314151617181920&lt;style&gt;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"classObject\"&gt;xiaomi&lt;/div&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; data: &#123; error: null &#125;, computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125; &#125; &#125;) 4.7.3 style绑定①style：值/数组绑定 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;p style=\"color: red;font-size: 30px;\"&gt; 这里是内联style原样式&lt;/p&gt; &lt;p v-bind:style=\"[colorStyle,fontSizestyle]\"&gt;vue绑定&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; colorStyle: &#123; color: 'yellow' &#125;, fontSizestyle: &#123; fontSize: '30px' //注意这里css中的font-size：变成fontSize &#125; &#125; &#125;)&lt;/script&gt; v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： ②style：对象绑定 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;p v-bind:style=\"&#123;color:colorValue,'font-size':sizeValue&#125;\"&gt;使用vue，&lt;/p&gt; &lt;p v-bind:style=\"&#123;color:colorValue,fontSize:fontSize+'px'&#125;\"&gt;使用vue，&lt;/p&gt; &lt;p v-bind:style=\"styleObject\"&gt;使用vue，&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; colorValue: 'blue', sizeValue: '30px', fontSize: '30', styleObject: &#123; color: 'red', fontSize: '30px' &#125; &#125; &#125;)&lt;/script&gt; 4.8 v-pre 预定义格式绑定 v-pre不需要表达式跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。在模板中跳过 vue 的编译，直接输出原始值。就是在标签中加入 v-pre 就不会输出 vue 中的 data 值了。 1234567891011&lt;div v-pre id=\"app\"&gt;&#123;&#123;massge&#125;&#125;&lt;!-- 会直接在网页中输出&#123;&#123;massage&#125;&#125; 这样的一个文本，不会是其他的信息。即使在 vue 的 data 中有定义 --&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#div', data: &#123; massge: 'hello' &#125; &#125;)&lt;/script&gt; 效果展示： 4.9 v-cloak 渲染好后展示指令 v-cloak不需要表达式用法：放置一些渲染比较麻烦的列表啊，表格啊，还没有渲染完成就显示，可能会出错啊，不好看啊，用户体验不好。这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。在 vue 渲染完指定的整个 DOM 后才进行显示。它必须和 CSS 样式一起使用。 12345678910111213141516171819&lt;style&gt;[v-cloak] &#123; display: none; &#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;p v-cloak&gt; &#123;&#123;massge&#125;&#125; &lt;/p&gt;&lt;!-- &#123;&#123;massge&#125;&#125;不会先显示，直到编译结束。避免用户网络不好加载不出 data 中的值，而直接显示&#123;&#123;massge&#125;&#125; --&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#div', data: &#123; massge: 'hello' &#125; &#125;)&lt;/script&gt; 效果展示：这个不好展示效果，方正就是表格类数据复杂的，用 v-cloak 避免不好的用户体验 4.10 v-once 仅渲染一次指令 v-once不需要表达式只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。可以说是data中的初始值，在外面再更新值，绑定 v-once 的插值不会改变 12345678910111213&lt;div id=\"app\"&gt; &lt;div v-once&gt;&#123;&#123;massage&#125;&#125;这里只会一直是 xiaomi&lt;/div&gt; &lt;div&gt;&#123;&#123;massage&#125;&#125;这里会根据 input 输入框的输入而变化&lt;/div&gt; &lt;input type=\"text\" v-model=\"massage\" /&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; massage: 'xiaomi', &#125; &#125;)&lt;/script&gt; 五、[选项/属性] &amp;&amp; [实例方法/属性] 逐个解析5.1 el 与 vm.$el限制：只在由 new 创建的实例中遵守，因此在 vue-cli 脚手架中只会在 main.js 中出现，其他的 .vue 文件都是导出件，export default {} 创建的，没有 el， 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。 5.2 data 与 vm.$data123456789101112131415161718192021&lt;!-- 这里是没有使用 vue-cli 的写法,原始的 html/css 写法--&gt;&lt;head&gt;&lt;style&gt;/* css... */&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; number &#125;&#125; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; //②data选项/属性：与html中的数据绑定，实现双向绑定 nunber:18 &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 5.3 props 与：vm.$props5.4 propsData5.5 computedcomputed 的作用主要是在给我们给用户展现之前对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号…… js 对原始数据有保护机制，不能修改原始数据的，但是我们确实有对原始数据进行改在的需求，那么就使用到这computed选项来改造数据,这个操作不会污染原数据。有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。 5.5.1 ①格式化输出结果:把结果重新用新的方式熟输出展现给用户：给数据添加其他东西123456789101112131415161718192021&lt;!-- 非vue-cli框架 --&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;good&#125;&#125;:&#123;&#123;newprice&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; good: '笔', price: 100 &#125;, computed: &#123; newprice: function () &#123; return this.price = '$' + this.price; &#125;, reverseNewsItems: function () &#123; return this.newsItems.reverse(); &#125; &#125; &#125;) &lt;/script&gt; 5.5.2 ②格式化输出结果:用计算属性反转数组：给数据倒过来输出经常用在我们得到一些数组类型的数据时，我们经常需要按照一定的顺序来排序输出展现，那么就要用 computed 来重新 倒序输出 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=\"app\"&gt; &lt;ol&gt; &lt;li v-for=\"item in reverseNewsItems\"&gt;&#123;&#123;item.title&#125;&#125;&#123;&#123;item.date&#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script&gt; var dataObject = &#123; good: '笔', price: 100, newsItems: [&#123; title: '香港或就“装甲车被扣”事件追责 起诉涉事运输公司', date: '2017/3/10' &#125;, &#123; title: '日本第二大准航母服役 外媒：针对中国潜艇', date: '2017/3/12' &#125;, &#123; title: '中国北方将有明显雨雪降温天气 南方阴雨持续', date: '2017/3/13' &#125;, &#123; title: '起底“最短命副市长”：不到40天落马，全家被查', date: '2017/3/23' &#125;, ] &#125;; new Vue(&#123; el: '#app', data: dataObject, computed: &#123; reverseNewsItems: function () &#123; return this.newsItems.reverse(); &#125; &#125; &#125;) &lt;/script&gt; 效果： 1.起底“最短命副市长”：不到40天落马，全家被查2017/3/232.中国北方将有明显雨雪降温天气 南方阴雨持续2017/3/133.日本第二大准航母服役 外媒：针对中国潜艇2017/3/124.香港或就“装甲车被扣”事件追责 起诉涉事运输公司2017/3/10 5.5.3 computed 的默认 getter 函数，与 setter 函数计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;firstName&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;fullName&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') //split 根据字符串中的某个字符拆分字符串变成数组 this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125; /* fullName: function (oldVal, newVal) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; */ &#125; &#125;) vm.fullName = 'John Doe' /* 没有set的话，上面这行代码是无效的，无法设置 。有set之后，vm.fullName = 'John Doe'这句有效。setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。*/&lt;/script&gt; 5.5.4 computed 与 v-modell 使用!!!!!!!!!!!!!!上面的都是从 data 获取的数据，但是 v-model 是用户输入的数据，如果是只是简单的使用上面的办法，是没有办法做到双向绑定的。 会提示错误，Computed property &quot;XXXXXX&quot; was assigned to but it has no setter. 1234567891011121314151617181920212223242526&lt;Slider v-model=\"newConfidence\" show-input :min='0' :max='100' :tip-format=\"confidenceFormat\"&gt;&lt;/Slider&gt;&lt;script&gt; data: () =&gt; (&#123; showMetadataModal: false, loading: false, robot_fre: 110, refresh_fre: 10, confidence: 0.6 &#125;), computed: &#123; newConfidence: &#123; set(value) &#123; this.confidence = value/100; &#125;, get() &#123; return this.confidence * 100; &#125; &#125; &#125;,&lt;/script&gt; 5.6 methods经常用在发生事件的时候触发方法。要在方法里面编辑一个方法。 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;button @click=\"add(2)\"&gt;&lt;/button&gt;. &lt;input type=\"button\" value=\"add\" v-on:click=\"add()\" /&gt; &lt;input type=\"button\" value=\"addnumber\" v-on:click=\"addnumber(2,$event)\" /&gt; &lt;btn v-on:click.native=\"add\"&gt;&lt;/btn&gt; &lt;btn v-on:click.native=\"addnumber(2)\"&gt;&lt;/btn&gt; &lt;/div&gt;&lt;script&gt; var btncomponent = &#123; template: `&lt;button&gt;组件add&lt;/button&gt;` &#125; var vmapp = new Vue(&#123; el: '#app', data: &#123; num: 18 &#125;, components: &#123; 'btn': btncomponent &#125;, methods: &#123; add: function () &#123; this.num++; &#125;, addnumber: function (number, event) &#123; if (number != \"\") &#123; this.num += number; &#125; else &#123; this.num++; &#125; console.log(event); &#125; &#125; &#125;)&lt;/script&gt; 5.6.1 methods中的$event参数传递的$event参数都是关于你点击鼠标的一些事件和属性。我们先看看传递的方法。这个是做比较高级交互性的时候用的，一般来说简单的后台什么的，用不到这玩意, 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //以下是打印event出来的数据,//看看event到底是个怎样的对象。你会发现，它包含了大部分鼠标事件的属性。MouseEvent &#123;isTrusted: true, screenX: 123, screenY: 264, clientX: 123, clientY: 171, &#125;&lt;!-- altKey : false bubbles : true button : 0 buttons : 0 cancelBubble : false cancelable : true clientX : 95 clientY : 179 composed: true ctrlKey : false currentTarget : null defaultPrevented : false detail : 1 eventPhase : 0 fromElement : null isTrusted: true layerX : 95 layerY : 179 metaKey : false movementX : 0 movementY : 0 offsetX : 42 offsetY : 16 pageX : 95 pageY :179 path : (6) [input, div#app, body, html, document, Window] relatedTarget : null returnValue : true screenX : 95 screenY: 272 shiftKey : false sourceCapabilities : InputDeviceCapabilities &#123;firesTouchEvents: false&#125; srcElement : input target :input timeStamp : 2550.3000000026077 toElement : input type : \"click\" view : Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close:ƒ, frames: Window, …&#125; which : 1 x : 95 y : 179 __proto__ : MouseEvent --&gt; 5.6.2 native 给组件绑定构造器里的原生事件在实际开发中经常需要把某个按钮封装成组件，然后反复使用。如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的 .native 修饰器了。当你给一个vue组件绑定事件时候，要加上 native 如果是普通的 html元素！就不需要 native 就是把组件变回原生 DOM 的一种方式 自定义标签直接添加方法是不成功的，需要加上 .native，才可能在自定义标签上绑定事件。 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;data&#125;&#125;&lt;/p&gt; &lt;button @click=\"plus\"&gt;add&lt;/button&gt; &lt;!-- &lt;btn @click=\"plus\"&gt;这里不会成功&lt;/btn&gt; --&gt; &lt;btn @click.native=\"plus\"&gt;btn是自定义标签直接绑定事件是无效的，用.native&lt;/btn&gt;&lt;/div&gt;&lt;script&gt; var vmapp3 = new Vue(&#123; el: '#app', data: &#123; data: 20 &#125;, components: &#123; 'btn': &#123; template: `&lt;button&gt;组件ADD&lt;/button&gt;` &#125; &#125;, methods: &#123; plus: function () &#123; this.data++; &#125;, plusnumber: function (number) &#123; if (number != \"\") &#123; this.data += number; &#125; else &#123; this.data++; &#125; &#125; &#125; &#125;)&lt;/script&gt; 5.6.3 作用域外部调用构造器里的方法这种不经常使用如果你出现了这种情况，说明你的代码组织不够好 12345678910111213141516&lt;!-- &lt;button onclick=\"app.add(4)\" &gt;外部调用构造器里的方法&lt;/button&gt; --&gt;&lt;div id=\"app9\"&gt;&#123;&#123;date&#125;&#125; &lt;hr/&gt;&#123;&#123;now&#125;&#125;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app9', data: &#123; date: Date &#125;, computed: &#123; now: function () &#123; return Date.now() &#125; &#125; &#125;)&lt;/script&gt; 5.6.4 computed 与 Methods 的区别 数据处理 computed 计算属性是对 data 中的数据进行格式化，简单的处理后输出，不会改变数据。 getter 作用。 Methods 方法是做一些方法来改变数据。通常是按钮绑定事件来触发方法。 缓存 ①computed 计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 ②methods 每当触发重新渲染时，调用方法将总会再次执行函数。 ③简单的就是说 data 中的数据更新了 computed 才会重新求值。method 方式是只要调用一次就执行一次。 ④假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter 如果你不希望有缓存，请用方法来替代。 5.7 watch 与 vm.$watchwatch 侦听器(监听数据的变化)。数据一旦发生变化将会触发 watch 中相应的函数。来看一个简单的数据变化监控的例子。例如天气预报的穿衣指数，它主要是根据温度来进行提示的 假设：温度大于 26 度时，我们建议穿T恤短袖，温度小于 26 度大于 0 度时，我们建议穿夹克长裙，温度小于 0 度时我们建议穿棉衣羽绒服。 5.7.1 选项 watch：1234567891011121314151617181920212223242526272829&lt;div id=\"app\"&gt; &lt;p&gt;温度：&#123;&#123;temp&#125;&#125;℃&lt;/p&gt; &lt;p&gt;穿搭建议：&#123;&#123;tips&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"up\"&gt;tempUp&lt;/button&gt; &lt;button @click=\"down\"&gt;tempDown&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var tiparr = ['夹克长裙', 'T恤短袖', '棉衣羽绒'] var vmapp = new Vue(&#123; el: '#app', data: &#123; temp: 14, tips: '夹克长裙' &#125;, methods: &#123; up: function () &#123; this.temp++; &#125;, down: function () &#123; this.temp--; &#125; &#125;, watch: &#123; temp: function (newVal, oldVal) &#123; this.tips = (newVal &gt; 26) ? tiparr[1] : ((newVal &lt; 0) ? tiparr[2] : tiparr[0]) &#125; &#125; &#125;) &lt;/script&gt; 5.7.2 实例方法 vm.$watch有些时候我们会用实例属性的形式来写 watch 监控。也就是把我们 watch 写在构造器的外部，这样的好处就是降低我们程序的耦合度，使程序变的灵活。 123456789101112131415161718192021222324252627&lt;div id=\"app\"&gt; &lt;p&gt;温度：&#123;&#123;temp&#125;&#125;℃&lt;/p&gt; &lt;p&gt;穿搭建议：&#123;&#123;tips&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"up\"&gt;tempUp&lt;/button&gt; &lt;button @click=\"down\"&gt;tempDown&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var tiparr = ['夹克长裙', 'T恤短袖', '棉衣羽绒'] var vm = new Vue(&#123; el: '#app', data: &#123; temp: 14, tips: '夹克长裙' &#125;, methods: &#123; up: function () &#123; this.temp++; &#125;, down: function () &#123; this.temp--; &#125; &#125; &#125;) vm.$watch('temp', function (newVal, oldVal) &#123; this.tips = (newVal &gt; 26) ? tiparr[1] : ((newVal &lt; 0) ? tiparr[2] : tiparr[0]) &#125;) &lt;/script&gt; 5.7.3 watch 与computed区别Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch 特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性computed,而不是命令式的 watch 回调. 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。如下例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;div id=\"watch-example\"&gt; &lt;p&gt; 请提问: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt; &lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: '你还没有输入问题，我无法作答' &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = '我在等您停止输入' this.debouncedGetAnswer() &#125; &#125;, created: function () &#123; // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, methods: &#123; getAnswer: function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = '提问通常应该带上问号？。 ;-)笑脸' return &#125; this.answer = '我正在思考' var vm = this //这句是干嘛？？？为了解耦？ axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = '错误，无法连接' + error &#125;) &#125; &#125; &#125;) &lt;/script&gt; //在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)， //限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。 //这些都是计算属性无法做到的。 5.8 template一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。 如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 &lt;script type=&quot;x-template&quot;&gt; 包含模板。 出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。 如果 Vue 选项中包含渲染函数 render，该模板将被忽略。 5.9 render渲染函数5.10 renderError渲染函数render 函数遭遇错误时，提供另外一种渲染输出 5.11 生命周期/钩子函数选项vue 的生命周期函数/钩子函数，我们可以利用这些函数在 vue 的每个阶段都进行操作数据或者改变内容 5.11.1 beforeCreate类型：Function详细：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 5.11.2 created类型：Function详细：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 5.11.3 beforeMount类型：Function详细：在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。 5.11.4 mounted类型：Function详细：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted： 1234567mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125;//该钩子在服务器端渲染期间不被调用。 5.11.5 beforeUpdate类型：Function详细：数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 5.11.6 updatedFunction详细：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated： 1234567updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125;//该钩子在服务器端渲染期间不被调用。 5.11.7 activated类型：Function详细：keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。参考：构建组件 - keep-alive 动态组件 - keep-alive 5.11.8 deactivated类型：Function详细：keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。参考：构建组件 - keep-alive 动态组件 - keep-alive 5.11.9 beforeDestroy类型：Function详细：实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。 5.11.10 destroyed类型：Function详细：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 5.11.110 errorCaptured类型：(err: Error, vm: Component, info: string) =&gt; ?boolean详细：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。 此钩子可以返回 false 以阻止该错误继续向上传播。你可以在此钩子中修改组件的状态。因此在模板或渲染函数中设置其它内容的短路条件非常重要，它可以防止当一个错误被捕获时该组件进入一个无限的渲染循环。错误传播规则默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子， 则它们将会被相同的错误逐个唤起。如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。 本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的errorCaptured 钩子和全局的 config.errorHandler。 vue.js 官网 教程部分学习 十五、教程 细节注意点15.1 创建新实例 new Vue({})经常会使用 vm (ViewModel 的缩写) 这个变量名表示 Vue 实例。 123var vm = new Vue(&#123; // 使用 Vue 函数创建一个 vue 实例，并且 赋值给 vm 这个变量&#125;) 15.2 MVVM 响应式视图层与逻辑层通过数据绑定来相关联。 只用 vue 实例中 data 选项中的数据 会存在 MVVM 模式，如果 data 中没有的属性，只是使用 vm.name=&#39;name&#39;，这样来添加属性的话，这个 name 属性是不存在 MVVM 模式的。 Object.freeze() 冻结属性，让他不会被改变，不存在 MVVM1234&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"foo = 'baz'\"&gt;Change it&lt;/button&gt;&lt;!-- 这里的 `foo` 不会更新！ --&gt;&lt;/div&gt; 12345678910var obj = &#123; foo: 'bar'&#125;Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;) 生命周期 钩子函数/??????????????????????????不要在选项属性或回调上使用箭头函数 会导致 this 指定不到 vue 实例1234created: () =&gt; console.log(this.a)Uncaught TypeError: Cannot read property of undefinedvm.$watch('a', newValue =&gt; this.myMethod())Uncaught TypeError: this.myMethod is not a function","tags":[]},{"title":"vue 中使用 UEditor 富文本编辑器","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-vue 中使用 UEditor 富文本编辑器/","text":"一、前言vue 富文本编辑器的使用 UEditor 百度研发团队 太垃圾了，用不了，全是错，百度现在还关闭 issue 了，说是弄新的版本，现在根据网上的方法，都用不了这个东西，算了吧，太垃圾了，下面的方法是错的，用了搞不来 二、百度 UEditor 插件安装2.1 下载 引入 下载 下载地址：UEditor,一般都选择使用 JSP 版本，下载下来。 PHP： PHP 语言JSP: JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。ASP： ASP是动态服务器页面(Active Server Page)的英文缩写。 是微软公司开发的代替CGI脚本程序的一种应用，它可以与数据库和其它程序进行交互，是一种简单、方便的编程工具。 UTF-8： 比较国际化， UTF－8 编码用以解决国际上字符的一种多字节编码，它对英文使用 8 位（即一个字节），中文使用 24 位（三个字节）来编码。对于英文字符较多的网站则用 UTF－8 节省空间。 UTF8编码的优点: 优点1： 外国人的英文IE上也能显示中文，无需下载IE的中文语言支持包。 香港台湾无需安装简体中文支持就能正常观看utf8编码的网页,网页上文字不会出现乱码。 优点2： 对于英文字符较多的网站则用UTF－8节省空间。 （对于英文比较多的论坛 ，使用GBK则每个字符占用2个字节，而使用UTF－8英文却只占一个字节。）GBK： 版本与 UTF-8 版本功能是一样的．只不过编码方式不同。 GBK 的文字编码是双字节来表示的，即不论中、英文字符均使用双字节来表示，只不过为区分中文，将其最高位都定成 1。选择：（但是我们 vue 使用的都是 utf-8 吧） 如果主要是做简体,网站访问者多数是国内,就用 gbk 如果你计划做繁体和英文的,网站访问者多是国外,就用 uf8 discuz 论坛一般都推荐使用 GBK 版本,因为：如果中文比较多,则 UTF-8 编码比 gbk 编码的占用更多的空间 .discuz 的 utf-8 版本的风格模板比较少. 引入 将下载好的文件包放在工程目录中，就放在 src 目录下吧，比如自定义的一个 assets 文件夹下。或者是 static 文件夹 main.js 引入 或者 index.html 引入 12345//index.html &lt;script type=\"text/javascript\" src=\"/static/js/ueditor/ueditor.config.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/js/ueditor/ueditor.all.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/js/ueditor/lang/zh-cn/zh-cn.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/static/js/ueditor/ueditor.parse.min.js\"&gt;&lt;/script&gt; 123456789101112 //main.jsimport'../static/Ueditor/ueditor.config.js'import'../static/Ueditor/ueditor.all.min.js'import'../static/Ueditor/lang/zh-cn/zh-cn.js'import'../static/Ueditor/ueditor.parse.min.js'// 根据自己的路径改变import'./assets/ueditor/ueditor.config.js'import'./assets/ueditor/ueditor.all.min.js'import'./assets/ueditor/lang/zh-cn/zh-cn.js'import'./assets/ueditor/ueditor.parse.min.js' 2.2 修改配置 修改 ueditor/ueditor.config.js 里的务器统一请求接口路径 12345678910111213141516171819202122232425262728(function () &#123; /** * 编辑器资源文件根路径。它所表示的含义是：以编辑器实例化页面为当前路径，指向编辑器资源文件（即 dialog 等文件夹）的路径。 * 鉴于很多同学在使用编辑器的时候出现的种种路径问题，此处强烈建议大家使用\"相对于网站根目录的相对路径\"进行配置。 * \"相对于网站根目录的相对路径\"也就是以斜杠开头的形如 \"/myProject/ueditor/\" 这样的路径。 * 如果站点中有多个不在同一层级的页面需要实例化编辑器，且引用了同一 UEditor 的时候，此处的 URL 可能不适用于每个页面的编辑器。 * 因此，UEditor 提供了针对不同页面的编辑器可单独配置的根路径，具体来说，在需要实例化编辑器的页面最顶部写上如下代码即可。 * 当然，需要令此处的 URL 等于对应的配置。 * window.UEDITOR_HOME_URL = \"/xxxx/xxxx/\"; */ //！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！在这里定义 window.UEDITOR_HOME_URL window.UEDITOR_HOME_URL = \"/static/js/ueditor/\" // 就是 放进来的 文件路径，假设是 src/static/js/ueditor/ ！！！！！！！（加上这个代码句子） var URL = window.UEDITOR_HOME_URL || getUEBasePath(); /** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */ window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL // 服务器统一请求接口路径 , serverUrl: URL + \"jsp/controller.jsp\" //这里是你配置的上传内容的 url ；不需要可以删除；如果有上传图片的功能就不能删除啊！！！！ // 这里是 配置 ueditor 的图片 以及 文件 的后台上传接口 // 下面省略一堆代码.......... 如果在设置 serverUrl 的时候错误， 1Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them... 这个问题是因为项目中的使用的 babel 默认添加了 use strict 造成，可参考 https://segmentfault.com/q/1010000007415253，选择其中的方法来解决 或者在webpack.base.conf.js 添加 loaders: [{ test: /.js$/, exclude: /(node_modules|bower_components)/, loader: ‘babel’, query: { presets: [‘es2015’] }}] 或者就 注释 serverUrl 字段（如果不注释还会报上传文件地址错误的问题），不要了啊！！ 三、百度 UEditor 组件化使用3.1 components 组件化在 components 中新建 Ue.vue 文件 贴入这个代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- components/Ue.vue --&gt;&lt;template&gt; &lt;script :id=id type=\"text/plain\"&gt;&lt;/script&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'UE', data() &#123; return &#123; editor: null &#125; &#125;, props: &#123; content: &#123; type: String, default:'' &#125;, config: &#123; type: Object, &#125;, id: &#123; type: String &#125; &#125;, mounted() &#123; const _this = this; _this.editor = UE.getEditor(_this.id, _this.config); // 初始化UE _this.editor.addListener(\"ready\", function () &#123; _this.editor.setContent(_this.content); // 确保UE加载完成后，放入内容。 &#125;); &#125;, methods: &#123; getContent() &#123; // 获取内容方法 return this.editor.getContentTxt();; &#125; &#125;, destroyed() &#123; this.editor.destroy(); &#125;, &#125;&lt;/script&gt; 3.2 在 页面或者其他组件使用 Ueditor 组件123456789&lt;template&gt; &lt;ueditor :content=content1 :config=config :id=\"ue1\"&gt;&lt;/ueditor&gt; //使用&lt;/template&gt;&lt;script&gt; import ueditor from '../components/Ue/Ue.vue' //路径还是按照自己的路径来 export default &#123; &#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=\"content-wrapper\"&gt; &lt;div class=\"content\"&gt; &lt;div class=\"info\"&gt;UE编辑器示例&lt;br&gt;需要使用编辑器时，调用UE公共组件即可。可设置填充内容content，配置信息config(宽度和高度等)，可调用组件中获取内容的方法。支持页面内多次调用。 &lt;/div&gt; &lt;button @click=\"getUEContent()\"&gt;获取内容&lt;/button&gt; &lt;ueditor :content=content1 :config=config1 :id=\"ue1\"&gt;&lt;/ueditor&gt; &lt;!-- 使用组件 --&gt; &lt;ueditor :content=content2 :config=config2 :id=\"ue2\"&gt;&lt;/ueditor&gt; &lt;!-- 使用组件 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ueditor from '../components/Ue/Ue.vue' //路径还是按照自己的路径来 export default &#123; components: &#123; ueditor &#125;, data() &#123; return &#123; content1: '这里是UE测试1',// content2: '这里是UE测试2', config1: &#123; initialFrameWidth: 1600, initialFrameHeight: 350, wordCount: false, &#125;, config2: &#123; autoHeight: false, wordCount: false, &#125;, ue1: \"ue1\", // 不同编辑器必须不同的id ue2: \"ue2\" &#125; &#125;, methods: &#123; getUEContent() &#123; // 获取 ueditor 值 let content1 = UE.getEditor(this.ue1).getContent(); let content2 = UE.getEditor(this.ue2).getContent(); console.log(content1) console.log(content2) &#125; &#125; &#125;;&lt;/script&gt; 四、API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//1. 实例化编辑器到 id 为 container 的 dom 容器上：var ue = UE.getEditor('container');//2. 设置编辑器内容： ue.setContent('&lt;p&gt;hello!&lt;/p&gt;');//3. 追加编辑器内容： ue.setContent('&lt;p&gt;new text&lt;/p&gt;', true);//4. 获取编辑器html内容： var html = ue.getContent();//5. 获取纯文本内容： ue.getContentTxt();//6. 获取保留格式的文本内容： ue.getPlainTxt();//7. 判断编辑器是否有内容： ue.hasContents();//8. 让编辑器获得焦点： ue.focus();//9. 让编辑器失去焦点 ue.blur();//10. 判断编辑器是否获得焦点： ue.isFocus();//11. 设置当前编辑区域不可编辑： ue.setDisabled();//12. 设置当前编辑区域可以编辑： ue.setEnabled();//13. 隐藏编辑器： ue.setHide();//14. 显示编辑器： ue.setShow();//15. 清空内容： ue.execCommand('cleardoc');//16. 读取草稿箱： ue.execCommand('drafts');//17. 清空草稿箱： ue.execCommand('clearlocaldata'); 五、bug2.1 UE is not defined2.21* ../components/Ue/Ue.vue in ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/Addproduct/Addproduct.vue?vue&amp;type=script&amp;lang=js&amp; 问题： 在 Addproduct.vue 文件中引用的 config.js 文件找不到。解决： 确认 config.js 文件的相对路径是否正确，可以解决此问题 123# 类似不是 这个 ueditor 的问题./config.js in ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/view/HelloWorld.vue?vue&amp;type=script&amp;lang=js&amp;# 这个错误一般是指在 HelloWorld.vue 文件中引用的 config.js 文件找不到。确认 config.js 文件的相对路径是否正确，可以解决此问题","tags":[]},{"title":"markdown 的技巧","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】markdown 的技巧/","text":"一、前言markdown 是我们经常需要使用的，一些排版技巧。 二、Markdown 图片排版2.1 图片链接地址Markdown写博文时，插入图片不能直接从本地上传，需要挂图片的链接地址才可以。一定是上传到网络上面的照片。 问题：如果照片不显示，看下是不是自己的写法不正确，还有就是自己所在的网络不好，加载不来网络上的照片。 2.2 单张图片直接使用 div 的 align 属性使得图片对其方式按照希望的这样。通过更改align属性可以修改图片左对齐、居中或者右对齐； 123&lt;div align=\"center\"&gt;&lt;img src=\"http://liuxmoo.foryung.com/2222.jpg\" height=\"300px\" alt=\"图片说明\" &gt;&lt;/div&gt; 123&lt;div align=\"left\"&gt;&lt;img src=\"http://liuxmoo.foryung.com/2222.jpg\" height=\"300px\" alt=\"图片说明\" &gt;&lt;/div&gt; 123&lt;div align=\"right\"&gt;&lt;img src=\"http://liuxmoo.foryung.com/2222.jpg\" height=\"300px\" alt=\"图片说明\" &gt;&lt;/div&gt; 如果使用的是 markdown 的方法来插入图片的话，注意 div 要与 markdown 的语法要有一行的空行，不然会得到的是文本，没法显示图片的。 123456# 下面的代码中是空行&lt;div align=\"right\"&gt;![头像](http://liuxmoo.foryung.com/%E4%B8%80%E5%AF%B8%E7%85%A7.jpg)&lt;/div&gt; 2.3 多张张图片并排显示通过调整两张图片的高度和宽度可以将两张图片并排显示，同样修改align属性可以改变两张图片的对齐方式； 问题：两张图片在markdown中已经并排显示了，但提交到网站后确实没有并排显示。注意要把这些 img 标签 markdown 的语法，空行也还是必须的。 https://mazhuang.org/2017/09/01/markdown-odd-skills/关于 Markdown 的一些奇技淫巧 但是导出pdf 之后，图片位置就不对了啊!!!!!!!!!!!!!!!!!!!!! 使用插件来直接导出就是正确的了，那个 typora 是又问题的。Markdown pdf，直接在文档区域右键就可以导出来了 三、文字排版2.1 文字颜色 使用 html 标签 1&lt;div style=\"color:red;\"&gt;11&lt;/div&gt; 11 如果要求不高的话直接使用 反引号就好了 1这里是 `重点` 的东西 这里是 重点 的东西","tags":[]},{"title":"阿里矢量图-在各个框架，组件，web端，移动端，小程序中的用法","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】-阿里矢量图用法集合/","text":"一、前言为了方便我们开发者使用，网上会有很多的字体图标库，方便我们直接调用 阿里矢量图，提供了大量免费的图标，也提供了使用方法，但是在各个组件库中，各种场合其实使用时有所不一样的。本文就是列举出来在各种场合应该如何使用。 阿里矢量图：网址 三、jquery.js 使用阿里图标3.1.1 结合 jquery-ui四、vue.js 使用阿里图标阿里图标：地址阿里图标使用方法：官方使用教程， 4.1 Unicode Font class 兼容性良好，支持 ie8+，及所有现代浏览器。相比于 unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 unicode 引用，就是修改 icon-xxx 这些。不过因为本质上还是使用的字体，所以多色图标还是不支持的。 1234567# ① 第一步：拷贝项目下面生成的 fontclass 代码：# vue-cli2 项目框架中引入使用：在 src 目录下的 index.html 文件中 link 标签引入# vue-cli3 项目框架中引入使用：在 public 目录下的 index.html 文件中 link 标签引入# ② 第二步：挑选相应图标并获取类名，应用于页面：# &lt;i class=\"iconfont icon-xxx\"&gt;&lt;/i&gt; 这里是在 html 中直接使用的 , 修改 icon-xxx 来改成需要的图标。# 在 UI 框架中，有的时候我们不能直接在 template 中直接的使用 &lt;i class=\"iconfont icon-xxx\"&gt;&lt;/i&gt; Symbol 这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个svg的集合，与上面两种相比具有如下特点： 支持多色图标了，不再受单色限制。通过一些技巧，支持像字体那样，通过 font-size,color 来调整样式。兼容性较差，支持 ie9+,及现代浏览器。浏览器渲染 svg 的性能一般，还不如 png。 1234567891011121314151617181920# ① 第一步：拷贝项目下面生成的 symbol 代码：：# vue-cli2 项目框架中引入使用：在 src 目录下的 index.html 文件中 script 标签引入# vue-cli3 项目框架中引入使用：在 public 目录下的 index.html 文件中 script 标签引入# ② 第二步：第二步：加入通用css代码（引入一次就行）：# vue-cli2 项目框架中引入使用：在 src 目录下的 index.html 文件# vue-cli3 项目框架中引入使用：在 public 目录下的 index.html 文件中# &lt;style type=\"text/css\"&gt;# .icon &#123;# width: 1em; height: 1em;# vertical-align: -0.15em;# fill: currentColor;# overflow: hidden;# &#125;# &lt;/style&gt;# ③ 第三步：挑选相应图标并获取类名，应用于页面：# &lt;svg class=\"icon\" aria-hidden=\"true\"&gt;# &lt;use xlink:href=\"#icon-xxx\"&gt;&lt;/use&gt;# &lt;/svg&gt;# 在 UI 框架中，有的时候我们不能直接在 template 中直接的使用 &lt;i class=\"iconfont icon-xxx\"&gt;&lt;/i&gt; 3.2.1 vue &amp;&amp; element-ui 使用 阿里矢量图3.2.2 vue &amp;&amp; iview-ui 使用 阿里矢量图五、小程序使用阿里妈妈图标3.3 微信小程序icon单个使用 不建议使用下载的方法 ①选择需要使用的图片 ②调色/下载 png ③项目根目录中新建一个 src/images 文件夹，可以直接是 images 文件夹，自己喜好习惯 此种方式适合用在图标引用特别少，以后也不需要特别维护的场景。比如设计师用来做 demo 原型。前端临时做个活动页。当然如果你只是为了下载图标做 PPT,也是极好的。 但是项目一旦需要到不少的图标的话，就不要使用这种方式使用，阿里官方也是不推荐使用这种方式的。 注意一个问题： ①图片文件夹创建/图片放置正确方式 不能直接将图片拉到开发工具中，目前还不支持。 不能直接将下载好的图片的文件夹直接粘贴到项目中，也不支持，无法识别到文件 只能是在开发工具中建好文件夹，然后本地打开文件夹，将复制好的图片粘贴在文件夹下才对 ②图片文件夹的目录，一定不能放置在 pages 文件夹中 他会给你创建一个 images 页面的。然后 app.json 中的 pages 路径也会多出来一个 images 页面， &quot;pages/images&quot;这是不正确的，模拟器都无法正确运行 垃圾问题 项目会自动创建 images.json，images.wxml，images.wxss，images.js 文件！！！！！！ 3.3.1 微信小程序 &amp;&amp; wepy-ui 使用 阿里矢量图unicode 引用方法：注意修改为自己项目的链接与对应的代码 网址网址 123456789101112131415161718192021222324252627# 阿里图标项目中 生成如下代码#①：拷贝项目下面生成的 font-face 每次链接都是不一样呀的，每次重新生@font-face &#123; font-family: 'iconfont'; /* project id 922431 */ src: url('//at.alicdn.com/t/font_922431_rf7ztse40wc.eot'); src: url('//at.alicdn.com/t/font_922431_rf7ztse40wc.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_922431_rf7ztse40wc.woff') format('woff'), url('//at.alicdn.com/t/font_922431_rf7ztse40wc.ttf') format('truetype'), url('//at.alicdn.com/t/font_922431_rf7ztse40wc.svg#iconfont') format('svg');&#125;# ②第二步：定义使用 iconfont 的样式，这个可以不需要改变.iconfont &#123; font-size: 16px; font-style: normal; font-family: 'iconfont' !important; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;&#125;# ③：在页面使用之前，先把这个文件，引入到全局 app.wpy 中 （这是小程序中特有的）# 具体的链接地址根据自己的项目而定&lt;style lang=\"less\" src=\"./assets/styles/iconfont.less\"&gt;&lt;/style&gt;# ④：在页面使用：具体的 图标修改 代码 `&amp;#xe625;` 这个代码当然是在 阿里图标 Unicode 的状态下的。&lt;i class=\"iconfont\" style=\"font-size:30px\"&gt;&amp;#xe625;&lt;/i&gt; 注意：这时候开发者工具看到的是 口，不要慌张，重新运行一下就好了。 wepy build --watch，注意一定是在命令行去运行一下，在开发者工具编译时无效的。 12345λ wepy build --watch[16:36:41] [编译] 入口: src\\app.wpy[16:36:49] [写入] JSON: dist\\app.json[WARNING] 找不到编译器：wepy-compiler-sass。[Error] 未发现相关 sass 编译器配置，请检查wepy.config.js文件。 解决：如果编辑的是 scss 那么就要在 webpack.config.js 中配置 scss 的转译。 12VM884:2 Failed to load font http://1701630871.debug.open.wei ... flings-regular.woff : the server responded with a status of 404 (HTTP/1.1 404 Not Found)From server 127.0.0.1 这个是什么意思？为什么开发者工具开始提示这个，然后谷歌了一下，再去开发者工具没干什么，它自己又好了。 更多关于 阿里图标的坑 重新添加了图标，不要忘记重新生成新的代码，置换新的代码。 @font-face 的链接是更新的。 3.3.2 微信小程序 &amp;&amp; mpvue 使用 阿里矢量图2.2 在线链接使用方法","tags":[]},{"title":"【postman】-[小白入门篇、速学篇、全面详解]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑨-【HTTP】-postman㉕/","text":"一、前言","tags":[]},{"title":"【npm & yarn 】-安装工具的工具","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑩ - 【命令-工具】node包管理器==npm && yarn  && cnpm && pnpm/","text":"一、前言yarn 中文文档 没有翻墙的话用不了 npm，只能用，那用淘宝镜像拉下包，或者pnpm有的时候有可能网络问题也会导致 npm 包安装有问题 二、npm123#查看安装模块$ npm list --depth=0npm # 查看本文件夹/本项目$ npm list --depth=0 -global #查看 全局 三、yarn 但是 qq 群里有人说这个不靠谱？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？3.1 yarn 的安装123456789101112npm install -g yarn``[WZ](https://yarnpkg.com/zh-Hans/docs/install#mac-stable)### 3.2 yarn 的使用（比 npm 快）```BASH# 下面三个是等效的，下载别人项目，都是这样还原依赖包$ npm install$ yarn install$ pnpm install 123456# yarn 的命令$ yarn add # 为当前正在开发的包新增一个依赖包$ yarn init # 初始化包$ yarn install # 安装 package.json 文件里定义的所有依赖包$ yarn publish # 发布一个包到包管理器；$ yarn remove # 从当前包里移除一个未使用的包。 12345678$ npm install taco --save-dev# 等价于$ yarn add taco --dev$ npm install taco --global# 等价于$ yarn global add taco 四、cnpm 淘宝镜像安装淘宝镜像，但是很多时候总是出现包安装不完全的现象，还是不了吧！ 五、pnpm 缓存安装优先使用缓存包来安装，这样会比 npm 快很多。","tags":[]},{"title":"JXL 之 JS 语法拓展","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】JSL 之 JS 语法拓展/","text":"一、什么是 JSX？1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 上面这种看起来可能有些奇怪的标签语法 既不是字符串也 不是 HTML。 它是JSX，一种 JavaScript 的语法扩展。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。 React.js 以及 vue.js 这两个框架都是使用 JSX 来描述用户界面。JSX 用来声明 React.js 以及 vue.js 当中的元素。使用 render 宣传出来的。 本文学习 JSX 都是按照 react 来解说， vue.js 都是一样的。 二、 JSX 学习使用2.1 在 JSX 中使用表达式可以任意地在 JSX 当中使用 JavaScript 表达式，在 JSX 当中的表达式要包含在大括号里。 12// 没有表达式的情况，不必加上括号，还是加上括号比较好吧！！，句子多的话也是加的就不要为难自己了。const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; 1234567891011121314function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;// 使用了表达式 要加上括号才行，并且要给表达式加上一对 花括号!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;); 2.2 JSX 本身其实也是一种表达式在编译之后呢，JSX 其实会被转化为普通的 JavaScript 对象。这也就意味着，你其实 可以在 if 或者 for 语句里使用 JSX，将它赋值给变量，当作参数传入，作为返回值都可以： 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;// 这里怎么就不加括号呢？？？？？？？？？？？？？？？？？？？？？？？？？？？？ &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; 2.3 JSX 属性可以使用 引号来定义以 字符串为值的 属性： tabIndex=”0” 1const element = &lt;div tabIndex=\"0\"&gt;&lt;/div&gt;; 也可以使用 大括号来定义以 JavaScript 表达式为值的属性： src={user.avatarUrl} 1234const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;//注意这里的 src 使用了花括号就不要在外面再使用过 引号了!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!// 如果加上引号的话，JSX 会将引号当中的内容识别为 字符串 而不是 表达式。const element = &lt;img src=&#123;user.avatarUrl&#125;/&gt;; // 如果是半闭标签 2.4 JSX 嵌套1234567// 这里怎么又用括号了？？？多个句子的话就用括号？？？？const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); 2.5 属性的 camelCase 小驼峰命名!!!!!!!!!!!!!!!!!!!!!!!!!!!!重点，在 vue.js 或者 react.js 都会涉及到这个问题。因为 JSX 的特性 更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。 例如，class 变成了 className，而 tabindex 则对应着 tabIndex。 2.6 JSX 防注入攻击!!!!!!!!!!!!!!!!!!!!!!!!!!!! input 输入框就适合使用这个拓展语言来写。123const title = response.potentiallyMaliciousInput;// 直接使用是安全的：可以放心地在 JSX 当中使用用户输入： input 输入框const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击. 2.7 JSX 代表 ObjectsBabel 转译器会把 JSX 转换成一个名为 React.createElement() 的方法调用。 12345678910111213141516// JSX 写法const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// 等价于//React.createElement() 的方法 调用的写法const element = React.createElement( 'h1',// 参数 1，元素，或者是函数返回，或者是组件 &#123; className: 'greeting'// 参数 2 一些属性值 &#125;, 'Hello, world!'// 参数3 文本/子组件/子元素); 12345678910//React.createElement() 这个方法首先会进行一些避免 bug 的检查，之后会返回一个类似下面例子的对象：// 注意: 以下示例是简化过的（不代表在 React 源码中是这样）就是说，下面的代码是用来理解的，写代码的时候不要这样写!!!!!!!!!!!!!!!!!!!const element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world' &#125;&#125;;//这样的对象被称为 “React 元素”。它代表所有你在屏幕上看到的东西。React 通过读取这些对象来构建 DOM 并保持数据内容一致。 三、JSX 元素的渲染 ReactDOM.render()与浏览器的 DOM 元素不同，React 当中的元素 事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。元素是 html 原始标签/元素 ，组件是我们自定义的（虽然也是按照元素标签一样使用的，但是他们不是元素）。初学者要知道区分二者。 3.1 ReactDOM.render() 将元素渲染到 DOM 中12&lt;!-- 这个节点即将用来给 ReactDOM 天界内容，称之为 “根” DOM 节点。 React 开发应用时一般只会定义一个根节点。 --&gt;&lt;div id=\"root\"&gt;&lt;/div&gt; 123const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;//要将 React 元素渲染到根 DOM 节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上：ReactDOM.render(element, document.getElementById('root')); 3.2 更新元素渲染：有状态组件 实现 DOM 更新方式(在 react 中去学习。)React 元素都是 immutable 不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。 根据我们 现阶段了解的有关 React 知识，更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法： 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById('root'));&#125;setInterval(tick, 1000);//这个示例通过 setInterval() 方法，每秒钟调用一次 ReactDOM.render().//在实际生产开发中，大多数React应用只会调用一次 ReactDOM.render()// 因此这个方式是行不通的，而是使用：有状态组件 实现 DOM 更新方式!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1 3.3 React 只会更新必要的部分React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。 即便我们每秒都创建了一个描述整个 UI 树的新元素，React DOM 也只会更新渲染文本节点中发生变化的内容。 根据我们以往的经验，将界面视为一个个特定时刻的固定内容（就像一帧一帧的动画），而不是随时处于变化之中（而不是处于变化中的一整段动画），将会有利于我们理清开发思路，减少各种 bug。","tags":[]},{"title":"去除 webstorm 编辑器代码的波浪线 & 下划线警示/提示","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑩ -【命令-工具】编辑器== 编辑器/","text":"一、前言WebStorm 是 jetbrains 公司旗下一款 JavaScript 开发工具。目前已经被广大中国 JS 开发者誉为 “Web前端开发神器”、“最强大的 HTML5 编辑器”、“最智能的 JavaScript IDE” 等。与 IntelliJ IDEA 同源，继承了IntelliJ IDEA 强大的 JS 部分的功能。 二、jetbrains 系列产品主题 jetbrains 公司为自家的编辑器软件提供了很多主题，用户可以根据自己的喜欢选择设置自己喜好的主题。官网Color Themes 三、 主题Color Themes导致代码波浪线下划线编辑一个 js 文件，发现全篇都是波浪线与下划线，看得眼睛都要晕了。必须要取消掉这些乱七八糟的线。 步骤：点击文件→设置→主题→通用→无用的警示→取消标记→应用steps：file→settings→Color Scheme→Weak Warning→Error stripe mark &amp;&amp; Effects→Apply 最终可以取消掉那些难看的波浪下与下划线。etbrains 公司旗下其他的编辑软件也会遇到同样的问题，也是用一样的办法来解决的。eg：怎么去除 idea 即 IntelliJ IDEA 中代码的波浪线(警告线) 3.2 重复代码提醒为了减少一定量的重复代码，提醒开发人员注意，但是如果有时几行代码的重复没必要扔到一个统一的地方处理，这是总是提醒，干扰视线。这里根据个人习惯，还是关闭这个功能比较好。在 setting 里面 搜索 inspections _ General _ Duplicated Code 取消勾选.提交之后就可以了.","tags":[]},{"title":"git 使用教程-常用的操作","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑩ -【命令-工具】github- 初始化项目/","text":"一、前言gitHub 视频教程 二、本地新项目上传 gitHub本地创建的项目，要放在仓库的步骤。 2.1 本地与 gitHub 建立联系1234567# gitHub 上面创建仓库， 获取仓库地址# 命令行进入本地仓库目录$ git init #初始化一个本地仓库$ git remote add origin &lt;远程仓库地址&gt; # 添加一个远程仓库地址给本地仓库 # origin 为默认远程仓库$ git remote show # 查看远程仓库 （查看是否添加成功）$ git remote show origin # 查看 origin 远程仓库详情（查看是否添加成功） 2.2 本地的文件更新再上传 gitHub1234$ git add . # 添加当前目录下的所有文件以及文件夹(把文件添加到本地仓库)$ git commit -m \"xx\" # 确认添加到本地(把文件添加到本地仓库)$ git push # 把确认好的文件添加到远程 默认的 master 分支# $ git push origin master 上面一条是这里的简写 origin master 为默认分支 1234567$ git push --set-upstream origin master #本次仓库首次提交# $ git push 第一次提交直接推可能是不成功的，要先建立联系。# --set-upstream 的意思是 设置上游为 origin 的 master 分支$ git push --set-upstream origin master --force #强推# 注意：这个强推，会将线上的东西覆盖，不能随意使用。# 特别是合作的项目，不能把别人 push 的东西默认的覆盖！！！# 强推之后就没有 readme.md 了，要自己添加上去。（本地添加好操作） 四、获取线上项目 下拉更新本地代码 并且重新上传4.1 获取新代码获取线上的项目，我们不需要像上传本地新项目到 git 上面了，不需要初始化项目了。 12# 进入到本地的文件夹（希望把即将下载的项目放置在哪里）$ git clone &lt;远程仓库地址&gt; # 这样本地就会有一个与 git 上面的仓库了 12345# 每天项目第一步就是先 pull 下载到最新的版本$ git pull # 更新别的开发者上传的部分# 用户名输入# 密码输入（输入不可见）$ code . # 使用 vscode 打开项目（当然也可以用编辑器的方法去打开） 4.2 上传自己更新的代码123456$ git add . # 添加当前目录下的所有文件以及文件夹(把文件添加到本地仓库)$ git commit -m \"xx\" # 确认添加到本地(把文件添加到本地仓库)$ git push # 把确认好的文件添加到远程 默认的 master 分支# $ git push origin master 上面一条是这里的简写 origin master 为默认分支# 如果线上有新的版本，git push 是不成功的，需要先 git pull 拉新的下来再git push，不然就会把别人写的代码覆盖了 更加合理的流程应该是这样的，不要直接 git add . 这样是上传这个项目， 1234567891011$ git status # 查看目前的修改情况，结果如下#On branch master#Your branch is up to date with 'origin/master'.#Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed) # 添加改动# (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) # 撤销改动# modified: src/pages/formulaManagement/formulaManagement.vue$ git add src/pages/formulaManagement/formulaManagement.vue # 添加自己id修改文件$ git commit -m \"xx\" # 确认添加到本地(把文件添加到本地仓库)$ git pull # 选拉下别人的修改，注意这里，否则会把别人的工作给干没了的$ git push # 把确认好的文件添加到远程 默认的 master 分支 4.4 撤销改动123$ git status# 没有 commit 但是忘记自己修改的部分，需要回退$ git checkout src/group/admin.vue # 没有 commit 需要回退的话就用 可以用 checkout 回退 12345# 已经 commit 掉，需要回退到之前的 commit的状态$ git log # 查找 commit 记录，获取自己 commit 后面的字符串# commit 260f0661eae5b4a1c4f56223700db1b0ab18e1e1$ q # 退出 git log 查找，不行就 ctrl + c，或者是 esc$ git reset 260f0661eae5b4a1c4f56223700db1b0ab18e1e1 # 后退到之前的 commit 状态 4.4 查看自己改动文件内容对比123456$ git status # 查看自己修改了哪些文件# modified: src/pages/analysis/analysis.vue# modified: src/pages/formManagement/formManagement.vue$ git diff src/pages/formManagement/formManagement.vue # 查看该文件改动部分# 一直回车回车 到 end 就是所有的改动部分$ q # 退出查看 4.3 拉取线上版本覆盖本地版本123# 拉取线上的版本，完全覆盖本地版本$ git fetch --all$ git reset --hard origin/master # origin/master 是当前master分支 可根据需要的分支修改该值 十、git 上面 issue回复：markdown 使用issue 兼容了 markdown ，完全可以使用 markdown 的语法。 10.1 代码块模板例如，我们需要放置一段 js 代码，如下，我们就是使用这样的格式将 js 代码包起来就好了，其他的格式代码都是一样的道理。 1// js 代码 10.2 单选框，多选框1234567// 如下使用这个模板做到复选框功能，注意 [] 内需要空格符- [ ] Be awesome- [ ] Prepare dinner - [ ] Research recipe - [ ] Buy ingredients - [ ] Cook recipe- [ ] Sleep 在 issue 生成的回复中就可以勾选了，并且勾选之后对应的 markdown 代码也会被改变。 十一、文章编辑技巧11.1 锚点12这是第 4 章中写的标签&lt;p id=&quot;id4&quot;&gt;&lt;/p&gt; 12在需要锚点的地方写的代码具体学习见第四章:&lt;a href=&quot;#id4&quot; target=&quot;_self&quot;&gt;HTTP 报文首部&lt;/a&gt; 十五、 本章问 git 上 README.md 文件的使用说明书写样例下面的 bash 的格式没有写完整（为了本文的格式） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# hete_web&gt; A Vue.js project## Before Build``bash# install pnpm（本项目使用pnpm作为包管理工具）sudo npm install -g pnpm``## Build Setup`` bash# install dependenciespnpm install# serve with hot reload at localhost:8080pnpm run dev# build for production with minificationpnpm run build# build for production and view the bundle analyzer reportpnpm run build --report``## 协作须知``bash# 使用UI库：iViewhttps://www.iviewui.com/# 项目结构group 目录下分 visitor 和 adminassets 存放公共资源，如公共 css、js 库components 存放公用组件pages 存放页面，下分 visitor 和 adminstore 使用 vuex# 路由结构&quot;/&quot; 下为用户界面，对应 group/visitor&quot;/admin/&quot; 下为管理员界面，对应 group/admin``For a detailed explanation on how things work, check out the [guide](http://vuejs-templates.github.io/webpack/) and [docs for vue-loader](http://vuejs.github.io/vue-loader).","tags":[]},{"title":"vue 项目生产环境部署【1】--[网站部署:远程步骤/本地部署]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑪ - 网站部署】==/","text":"一、前言所谓部署，就是让开发出的产品能够在某一环境中运行起来。这个过程中会将源代码生成可运行的软件包，然后将软件包放到要部署的环境中，通过一些配置使得这个软件包在目标环境上也能够正常工作。 这个环境根据具体情况而定，可以是一个公司买的实体服务器，可以是类似 AWS 提供的云平台服务，也可以是本地环境，所以相应地部署就分为 远程部署 和 本地部署。一般来说，我们提到的部署都是远程部署，因为毕竟是要真正地投入使用嘛，如果只是学习就可以本地部署啦。 部署要做的工作大致分为三步： 将源代码生成可运行的软件包，例如 jar 包或 war 包等； 将可运行的软件包放到目标环境上； 配置目标环境使得软件包能够运行起来； 二、命令行学习更多命令行学习：菜鸟网址 2.1 登录远程服务器12$ ssh 用户名@服务器IP地址 //例如 ssh liuxmoo@254.88.88.88 //以 liuxmoo 用户的身份登录到 IP 地址为 254.88.88.88 服务器上。 2.2 删除文件12$ rm 文件名 //删除文件$ rm -r 文件夹名 //删除文件夹 2.3 创建文件夹1$ mkdir 文件夹名 //新建文件夹 2.4 查看当前路径1$ pwd //查看当前文件夹路径 2.5 退出远程登录1$ exit 退出远程登录 2.6 文件复制到远程 &amp;&amp; 本地复制文件1234$ scp 文件名 用户名@服务器IP地址:远程服务器路径 //例如 scp t.vue liuxmoo@254.88.88.88:/home/yahaa/xm/m //将本地的文件 t.vue 复制到远程服务器 /home/yahaa/xm/m 的文件夹下$ scp -r 文件夹名 用户名@服务器IP地址:远程服务器路径 复制文件/文件夹 12$ cp 文件名 目标文件/目标文件夹$ cp -r 文件夹名 目标文件夹 2.7 修改/移动 文件修改文件名 123$ mv 原文件夹名/文件名 目标文件夹名/目标文件名//如果目标文件夹已经存在，这个操作是将 原文件/原文件夹 移动到目标文件夹中 三、 远程部署（一般说的部署就是这个部署）3.1 命令行中部署服务端123456789101112131415$ ssh 用户名@服务器IP地址 # 登录服务器$ mkdir 目录名 # 创建该网站的在服务器上的目录 例如mkdir xmblog$ exit # 退出远程服务器# 本地操作①编译生成代码 （见 3.2 节）# 本地操作②编写网站运行的配置文件（见 3.2 节）$ scp -r public 用户名@服务器IP地址:/home/用户名/目录名 # 例如 liuxmoo@154.88.88.88:/home/liuxmoo/xmblog$ scp xxxx.conf 用户名@服务器IP地址:/home/用户名/目录名$ ssh 用户名@服务器IP地址 # 登录服务器$ cd /home/用户名/目录名 # 例如 /home/liuxmoo/xmblog$ sudo cp xxxx.conf /etc/nginx/conf.d # 把配置文件移动到 nginx web 服务器指定 /etc/nginx/conf.d 配置文件目录$ sudo nginx -s reload # 重启 nginx web 服务器# 操作③登录（阿里云，腾讯云，等等）已购买的账户给域名做解析 （见 3.3 节） 3.2 本地电脑中操作 本地操作①编译生成代码 例如 vue 项目中 build 生成 dist hexo 博客中的 public 文件夹 本地操作②编写网站运行的配置文件 1$ code liuxmoo.conf # 命令行创建一个 liuxmoo.conf 文件，并且用 vs code 工具打开， 12345678910111213141516# 下面以 nginx 为例，配置 xxxx.conf文件server &#123; listen 80; server_name blog.liuxmoo.com; # blog.liuxmoo.com 为自己的服务名 client_max_body_size 5120m; client_body_buffer_size 512K; client_header_buffer_size 4k; large_client_header_buffers 4 8k; root /home/yahaa/xmblog/public;# /home/yahaa/xmblog/public 为上传到服务器上的编译文件 index index.html; location / &#123; try_files $uri $uri/ /index.html =404; &#125;&#125; 3.3 登录服务器去部署操作③登录（阿里云，腾讯云，等等）已购买的账户给域名做解析 //阿里云：阿里云] 四、本地部署（模拟远程部署，）4.1 下载/解压服务器软件下面以 nginx 为例 nginx：网址 4.2 编译生成文件例如 vue 项目中 build 生成 dist hexo 博客中的 public 文件夹 4.3 修改配置文件打开解压的 nginx 文件，进入到 conf 文件夹，找到 nginx.conf 文件，用编辑器打开它。 12345678910111213141516171819202122232425#...省略其他内容# 以下为 http 中的 server 内容 server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\dist; # 4.2中编译生成文件夹的路径 index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;#...省略其他内容 4.4 启动服务器123$ cd 解压的 nginx 文件中 nginx.exe 的路径$ nginx.exe -c conf/nginx.conf //使用 nginx.exe 应用程序 打开指定配置文件 conf/nginx.conf 运行 // -c 为指定的意思","tags":[]},{"title":"JQurey 实战项目--[选课系统]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑫ -项目实战-选课系统/","text":"## 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Teacher&#123; constructor()&#123; this.courses=[] &#125; openCourse(course)&#123; this.courses.push(course); &#125; closeCourse(course)&#123; for(let c of this.courses)&#123; if(course.id===c.id)&#123; this.courses.remove(course) &#125; &#125; &#125; &#125;class Course&#123; constructor(id,name,startTime,addr)&#123; this.id=id this.name=name this.startTime=startTime this.addr=addr this.students=[] this.teachers=[] &#125;&#125;class Student&#123; constructor()&#123; this.courses=[] &#125; selectCourse(course)&#123; if(course.teachers)&#123; this.courses.push(course) &#125; &#125; cancleCourse(course)&#123; for(let c of this.courses)&#123; if(course.id===c.id)&#123; this.courses.remove(course) &#125; &#125; &#125;&#125;","tags":[]},{"title":"git 命令行全解-详解","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑩ -【命令-工具】github- 团队合作/","text":"一、前言gitHub 视频教程 二、git 原理图解（本地 + 远程）2.1 git 原理图解（本地 + 远程） 本地存在 3 个区域 工作区：就是我们的编辑区域 git add 命令可以将我们的工作保存至 缓存区 缓存区：我们代码的暂时的保存区域 git commit 命令可以将我们的缓存区内容提交到 本地仓库 本地仓库：本地代码管理区域 git push 命令可以将我们本地仓库的 commit 推送到 远程仓库 2.2 本地仓库-远程分支 origin/master（本地） 1234$ git checkout o/master$ git commit# Git 变成了分离 HEAD 状态，当添加新的提交时 o/master 也不会更新。# 这是因为 o/master 只有在远程仓库中相应的分支更新了以后才会更新。？？？？所以呢要怎么做？ 二、基础 git 命令（本地 + 远程） 1、 git add 2、 git reset 与 3、git revert 4、 git commit 5、 git branch 6、 git checkout 7、 git log 8、 git status 9、 git diff 10、git clone 11、git remote 12、git fetch 13、git merge 14、git rebase 15、git pull 16、git push 17、git cherry-pick 18、git tag 与 19、 git describe 2.1 git add 添加文件改动（添加到缓存区）123$ git add . # 添加所有的变动到缓存区（多人合作的话，一般不要这样用，先看 用 git status 看遍变动情况）$ git add xxx.vue # 添加本地的 xxx.vue 文件 到缓存区$ git add xxx.vue vvv.css # 添加本地的 xxx.vue 与 vvv.css 文件 到缓存区 2.2 git reset 与 git revert 撤销更改2.2.1 git reset（撤销提交或者是添加）123456789$ git reset HEAD &lt;file&gt; # 如果文件在 本地分支，就把它拿到 缓存区 # 如果文件在 缓存区 ，就把它拿到 工作区$ git reset &lt;file&gt; # 这里是简写# 注意这个与 git checkout 的区别# git reset &lt;file&gt;不会改动文件内容（虽然撤销了，但是只是移动了区域，没有去改变我们做的变动）# git checkout &lt;file&gt; 会改动文件内容（撤销了我们的变动，移动了区域，就是拿本地分支上的 HEAD 来覆盖本地的所有变动# 在我们不需要我们 该文件的操作的时候，可以这样来覆盖） git reset 重置/回退（这个对于多人合作的话是无效的，不要用，不要用，不要用） 12$ git reset HEAD~1 # 撤销一个 commit$ git reset HEAD^ git reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。 在 reset 后， 被回退的的变更还在，但是处于未加入暂存区状态。 但是。虽然在本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！为了撤销更改并分享给别人，我们需要使用 git revert。 撤销变更 git reset 与 git revert 和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。 撤销变更的方法很多。主要有两种方法用来撤销变更 —— 一是 git reset，还有就是 git revert。我们就学习这 2 种办法就好了。 2.2.2 git revert 撤销,还原/延伸（用这个，用这个，用这个，用这个，用这个，用这个，用这个，用这个）123456$ git revert HEAD# 假如我们需要撤销的是 C2 ,在我们要撤销的提交记录后面居然多了一个新提交！# 这是因为新提交记录 C2' 引入了更改 —— 这些更改刚好是用来撤销 C2 这个提交的。# 也就是说 C2' 的状态与 C1 是相同的。# revert 之后就可以把我们的更改推送到远程仓库与别人分享啦。 2.4 git commit 提交修改（提交到本地分支）12345# commit 的相关命令$ git commit # 提交修改（一次 commit 相当于一个 git 版本，注意这里不是 app 的版本）# 不建议直接上面的提交操作，要带上适当的注释$ git commit -m \"提交修改的注释\" # 提交修改，注意带上注释，不然后期维护起来不明所以!!!!!!!! 2.5 git branch 创建分支比如说一个项目很大，通常会按照功能来做各个分支，最后再合并 123456789101112# branch 的相关命令# 如何查看当前分支（一般带有 * 号的就是当前分支/或者在 gitKargen 上面 √ 号就是当前的分支）$ git branch # 列举所有的分支（带有 * 号的就是当前分支）$ git branch branch-name # 创建分支，名字为 branch-name，注意分支名称有大小写的区分!！！！！$ git checkout branch-name # 切换到 branch-name 分支# 上面两条命令的简写$ git checkout -b branch-name # 创建并且切换到 branch-name 分支，也就是上 2 个的简写$ git checkout -m branch-name branch-name1# 将 branch-name 分支名称更换为 branch-name1 2.6 git checkout 切换分支/移动 HEAD/撤销修改123456789101112# 先来学习切换分支$ git checkout branch-name # 切换到 branch-name 分支$ git checkout master # 切换到 master 分支# 移动 HEAD 到高级操作再学习# 撤销修改# 注意这个与 git reset 的区别# git reset &lt;file&gt;不会改动文件内容（虽然撤销了，但是只是移动了区域，没有去改变我们做的变动）# git checkout &lt;file&gt; 会改动文件内容（撤销了我们的变动，移动了区域，就是拿本地分支上的 HEAD 来覆盖本地的所有变动# 在我们不需要我们 该文件的操作的时候，可以这样来覆盖） 2.7 git log 查看 commit 记录这里的记录包含了当前分支的所有 commit 记录，自己的 commit 还有团队其他开发者的 commit 记录，都可以查看，commit 记录只会显示出来几条最近的记录，可以通过 enter 键来查看其他的记录。 12345678910$ git log # 查看当前分支的 commit 记录$ enter # 查看更多 commit 记录# commit 257a3c34040e8a666cc93ab168f42d8bfd12be42 # commit 的 哈希值# Merge: 3dc859c 433d46a ## Author: xiaomizhou66 &lt;39998745+xiaomizhou66@users.noreply.github.com&gt; # 操作者# Date: Sun Jan 27 17:26:38 2019 +0800 # 操作时间# Merge pull request #12 from xiaomizhou66/xx # 操作测试请求# 修改文件测试 git 使用 # commit 的注解$ q # 退出查看 1234567891011121314151617181920212223242526272829# 举例liuxm@me ~/work/vue/freegit/code/freeui (develop)λ git logcommit 3a600520cb2974a6e0b859e3ecc67dc9359d7734 (HEAD -&gt; develop, zihua/develop, origin/develop, origin/HEAD)Merge: 257a3c3 015a860Author: xiaomizhou66 &lt;39998745+xiaomizhou66@users.noreply.github.com&gt;Date: Sun Jan 27 17:27:11 2019 +0800 Merge pull request #11 from xiaomizhou66/update-readme 修改 readme 文档commit 257a3c34040e8a666cc93ab168f42d8bfd12be42Merge: 3dc859c 433d46aAuthor: xiaomizhou66 &lt;39998745+xiaomizhou66@users.noreply.github.com&gt;Date: Sun Jan 27 17:26:38 2019 +0800 Merge pull request #12 from xiaomizhou66/xx 修改文件测试 git 使用commit 433d46ad8586b1087ca4b4326dc9b620cbf0b524 (origin/xx, xx)Author: luixmoo &lt;liuxmoo@gmail.com&gt;Date: Sun Jan 27 17:22:36 2019 +0800 修改文件测试 git 使用commit 3dc859c3c48e59393d8b8efefe09337bef12a9b1Author: yzihua &lt;yuanzihua0@gmail.com&gt;Date: Sun Jan 27 17:21:31 2019 +0800: 2.8 git status 查看本地 3 个工作区域的变动情况1234567$ git status #查看变动情况# 没有颜色的是 本地分支的变动# 绿色字体是 缓存区的变动# 红色字体是 工作区的变动# 本地分支的变动# fix conflicts 解决冲突（手动改动文件中去解决冲突，或者 gitKargen 软件中去修改冲突） 1234567891011121314151617181920liuxm@me ~/work/vue/freegit/code/freeui (update-readme|REBASE 1/1)λ git statusrebase in progress; onto 0053607 # 本地分支的变动~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~You are currently rebasing branch 'update-readme' on '0053607'. (fix conflicts and then run \"git rebase --continue\") # 解决然后再次合并 (use \"git rebase --skip\" to skip this patch) # 忽略合并 (use \"git rebase --abort\" to check out the original branch) #Changes to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) # 将 &lt;file&gt; 文件从 分支 移动到 缓存区 deleted: REAME.md # 缓存区的变动~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # 这里是缓存区的变动，字体会是 绿色 的Unmerged paths: (use \"git reset HEAD &lt;file&gt;...\" to unstage) (use \"git add &lt;file&gt;...\" to mark resolution) # 将 &lt;file&gt; 文件从 缓存区 移动到 工作区 both modified: README.md # 工作区的变动~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ # 这里是工作区的变动，字体会是 红色 的 2.9 git diff 查看文件的具体变动内容（将改动的内容在命令行展示）1234$ git diff &lt;file&gt; #查看文件的具体变动内容（将改动的内容在命令行展示）# 它会将 本地分支的 HEAD 中的文件内容 与 工作区的文件内容做比较（增删改查都会展示）# 缓存区的文件我们没有办法去比较，如果想要比较，只能从 缓存区移动到工作区去比较 2.10 git clone 克隆线上仓库到本地12345678$ git clone &lt;仓库地址&gt; # 克隆线上的仓库到本地# 当然如果网络不好的时候我们可使用下载的防方式，不过还是算了吧# 当你用 git clone 某个仓库时，Git 已经帮你把远程仓库的名称设置为 origin 了# origin 仓库上的分支也会是 origin/master 也就是 本地的 远程分支# 由于远程分支的特性导致其拥有一些特殊属性。远程分支反映了远程仓库(在你上次和它通信时)的状态。# 这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.# 远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git 这么做是出于不能直接在这些分支上进行操作的原因# 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。 远程仓库却有一系列强大的特性： ① 首先也是最重要的的点, 远程仓库是一个强大的备份。本地仓库也有恢复文件到指定版本的能力, 但所有的信息都是保存在本地的。有了远程仓库以后，即使丢失了本地所有数据, 你仍可以通过远程仓库拿回你丢失的数据。 ② 还有就是, 远程 让代码社交化了! 既然你的项目被托管到别的地方了, 你的朋友可以更容易地为你的项目做贡献(或者拉取最新的变更) 现在用网站来对远程仓库进行可视化操作变得越发流行了(像 Github 或 Phabricator), 但远程仓库永远是这些工具的顶梁柱, 因此理解其概念非常的重要!git clone 命令在真实的环境下的作用是在本地创建一个远程仓库的拷贝（比如从 github.com） 2.11 git remote 查看远程分支情况12345678$ git remote #列出远程仓库，origin，company 假设远程有两个仓库# origin# company$ git remote show company # 展示 company 仓库的信息# 远程分支情况# 本地分支情况# 本地缓存区情况# 本地工作区情况 1234# 一般的工作是公司有自己的仓库，开发者 folk 公司的仓库（有了自己的 origin 仓库）$ git clone &lt;folk 的仓库地址&gt; # 克隆自己的仓库到本地 默认就是 origin 仓库# 克隆了自己的仓库之后，就可以使用 git remote add 添加公司的仓库$ git remote add company &lt;公司的仓库地址&gt; # 添加公司的仓库 名字是自己取名的，这里就是 company 2.12 git fetch 从远程仓库获取数据下图中看到当我们从远程仓库获取数据时, 远程分支也会更新以反映最新的远程仓库。在上一了我们已经提及过这一点了。 12345678910111213# 在上面的图片中，我们可以看到，远程仓库中有 C2,C3 两个commit （就是项目合作中其他人的提交）$ git fetch # 从 默认 origin 远程仓库下载本地仓库中缺失的提交记录 ，更新远程分支 origin/master$ git fetch company # 从 company 远程仓库下载本地仓库中缺失的提交记录 ，更新远程分支 origin/master# 之后就可以获取到别人的 commit 了。# git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。# 远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式# git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上（缓存区）的文件。# 许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。# 它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。# 我们在后面的课程中将会讲解能完成该操作的命令，所以, git fetch 的理解为单纯的下载操作。# 后面使用 合并 merge 或者是 rebase 是将 本地的 master 分支的 commit 记录（base 根基）替换为 origin/master 的根基# 这样 远程与 本地的就合并在一起了，得到了线上的，本地的自己的修改也不会被改变 123456# 其实我们有很多方法来解决这个问题# 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。$ git cherry-pick origin/master$ git rebase origin/master$ git merge origin/master# 等等....... 2.13 git merge在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。” 相当于自动生成一个 commit 记录，然后把两个分支指向这里来，这个 commit 不是开发人员 commit 的。而是命令自定形成的。 123456789# 假设本地有两个分支 master 分支与 bugFix 分支liuxm@me ~/work/vue/freegit/code/freeui (master)$ git merge bugFix # 把 bugFix 分支里的工作合并到 master 分支上。这样 master 分支就拥有了 两个 分支的 commit 记录$ git checkout bugFixliuxm@me ~/work/vue/freegit/code/freeui (bugFix)$ git merge master # 将 bugFix 分支上的 commit 合并到 master 分支，因为 master 继承自 bugFix，Git 什么都不用做，# 只是简单地把 bugFix 移动到 master 所指向的那个提交记录。# rebase 与 merge 的区别就是，merge 会产生一个特殊的 commit 记录，而 rebase 只是将一个分支的 commit 记录复制到另外一个分支上去 2.14 git rebase (合并提交记录，整理提交记录)Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。base 是根基的意思，其实就是类似于将一个 仓库的分支 commit 记录，复制出来，替换别人的 commit 记录。Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。 123456789# 假设本地有两个分支 master 分支与 bugFix 分支liuxm@me ~/work/vue/freegit/code/freeui (bugFix)$ git rebase master # 把 bugFix 分支里的工作直接移到 master 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的$ git checkout masterliuxm@me ~/work/vue/freegit/code/freeui (master)$ git rebase bugFix # 将 master 分支上的 commit 提取给 bugFix 分支，master 分支也得到更新了，由于 bugFix 继承自 master，# 所以 Git 只是简单的把 master 分支的引用向前移动了一下而已。# rebase 与 merge 的区别就是，merge 会产生一个特殊的 commit 记录，而 rebase 只是将一个分支的 commit 记录复制到另外一个分支上去 2.14.1 git fetch 与 git rebase 一般会是这样来操作 √√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√ git fetch：下载最新的代码 git rebase：合并（相当于替换了 历史 commit 不会产生 特殊的 commit 记录，一般使用这个合并方法~~~~~） rebase：提取 commit 记录，是创建 额外的一个分支来放置所有复制合并生成的点 Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。 12345678910# Rebase 的相关命令，这里写的是本地的操作，一般本地不会使用到合并的，但是也不排除需要的时候$ git checkout branch-name # 切换到分支 branch-name$ git rebase master # 分支branch-name 上的提交记录 commit 提取到 master 分支# master 分支就会有 branch-name 分支的提交记录了# branch-name 分支就会变成半透明（是重新在一个新的地 复制出来的新的）$ git checkout branch-name # 切换到分支 master$ git rebase branch-name # 将 master 分支的提交记录 cmmit 提取给 branch-name 分支# 就是要把 branch-name 分支的提交记录给到 master ，也要把 master 的分支也给到 branch-name 分支 2.15 git pull 获取远程更新 并且 合并到本地分支 master（本地仓库就与远程仓库同步）Git 远程仓库相当的操作实际可以归纳为两点： ① 向远程仓库传输数据 git push ② 从远程仓库获取数据 git pull既然我们能与远程仓库同步，那么就可以分享任何能被 Git 管理的更新（因此可以分享代码、文件、想法、情书等等）。 但是上面也说了，使用 10.3 办法只是 单纯的类似为 下载的意思，并没有 本地的 master 分支，也不会修改你磁盘上的文件，本地的仓库并没有与远程仓库同步。实际上，由于 先抓取更新再 合并到本地分支 这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们要讲的 git pull。 12345$ git fetch # 获取远程的 commit 更新 到 本地 master$ git merge o/master # 合并从 o/master 获取到的 commit 到 master 上，在本例中远程仓库名为 origin# 上面 2 个命令的简写/缩写$ git pull # 抓取 commit 更细并且 合并同步到本地 2.15.1 操作练习 git pull自造命令 git fakeTeamwork，这个不是学习重点，这里只是为了展示他人远程 commit “假如”同事、朋友、合作伙伴更新了远程仓库，有可能是某个特定的分支，或是几个提交记录。我们使用 自造命令 git fakeTeamwork。git fakeTeamwork 默认操作就是在【远程仓库的 master 分支】上做一次提交 123# 提交 commit 到远程$ git fakeTeamwork # 如果没有分支名称 默认是 远程仓库的 master 分支 commit$ git fakeTeamwork foo 3 # 在远程仓库 的 foo 分支 commit 3 条记录 123456789101112# ① 克隆他人项目$ git clone # 将远程代码克隆到本地# ② 协同工作每个人修改代码# 假设远程 master 有别人 commit 的记录，本地自己也有一个 commit 记录 的操作$ git fakeTeamwork # 在远程提交 commit （项目合作就是他人 commit 了内容），是提交在远程仓库的 master 分支$ git commit # 在本地自己也提交了 commit ，是提交在本地仓库的 master 分支# 这样本地就会有一个 origin/master 本地远程分支， 一个本地 master 分支，此时的 commit 是提到 master 上的# ③ 获取远程 commit，并且合并更新本地代码， origin/master 分支，master 分支 合并，并且也含有 远程的 commit$ git pull# 这里就不要用 git fetch + git merge..... 慢慢的操作了 git pull（git fetch 与 git merge）一般不会直接这样使用的，可能会导致不可预想的问题 xxxx git pull 是 git fetch 与 git merge 的简写 git fetch：下载最新的代码 git merge：合并（会有一个 特殊的 commit 记录，一般不会用这个!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!） merge：做的是合并分支 是在两个分支合并生成一个特殊的 commit 记录来交汇 123456789101112131415# Merge 的相关命令，这里写的是本地的操作，一般本地不会使用到合并的，但是也不排除需要的时候# 以下命令假设当前分支为主干/主分支 master$ git merge branch-name # 将分支 branch-name 合并到 master 主干# 合并两个分支时会产生一个特殊的提交记录，在 Git 中它有两个父节点。# 其实就是合并的愿意啊，合并就是为了“我要把这两个父节点本身及它们所有的祖先都包含进来。”# 此时 master 指向了一个拥有两个父节点的提交记录。这个特殊的提交记录。# 此时 只有 master 分支拥有所有的 commit$ git checkout branch-name # 切换到分支 branch-name$ git merge master # 将主干 master 合并到 branch-name 分支上# 此时也是会产生一个特殊的记录的......省略不说# 如果只有这两个分支的话，此时 master 主干，branch-name 分支都拥有了所有的修改# 当然如果还存在其他的分支的话，他们有自己的提交修改的话，# master 就没有包含所有的修改了，branch-name 更加不会 2.16 git pushgit push 负责将你的变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 git push 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！ 你可以将 git push 想象成发布你成果的命令。它有许多应用技巧，稍后我们会了解到，但是咱们还是先从基础的开始吧…… 注意 —— git push 不带任何参数时的行为与 Git 的一个名为 push.default 的配置有关。它的默认值取决于你正使用的 Git 的版本，但是在教程中我们使用的是 upstream。 这没什么太大的影响，但是在你的项目中进行推送之前，最好检查一下这个配置。 2.17 git cherry-pick (用于整理提交记录)“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”。移动提交记录：自由修改提交树（整理提交记录）（赋值，没有生成新的交汇点，也没有生成新的额外的分支!!!!!!!!!!!!!!!!!!!!!!!!） cherry-pick 需要知道哈希值啊，不然就是一大串的相对引用，很麻烦的 如果你想将一些提交复制到 当前所在的位置（HEAD） 下面的话， Cherry-pick 是最直接的方式了.因为它特别简单。注意前面的 rebase 是合并，并不是复制，我们要做的复制其中的一些 commit 而已。需要注意的是后面的 commit 才能放在 HEAD 的后面，HEAD 前面的 commit 是没有办法 放在 HEAD 后面的 1234567$ git cherry-pick XXX1 XXX3 # 将 XXX 分支 XXX1·XXX3 之间的 commit 复制到当前分支 HEAD 后面# 需要注意的是这些 XXX1 XXX3 一定是当前 HEAD 后面 commit 提交的$ git cherry-pick XXX1 BBB3 # 将 XXX 分支的 XXX1 BBB 的 BBB3 中的# commit 复制到当前分支 HEAD 后面# 当然了， XXX1 XXX3 XXX1 BBB3 是一些哈希值呢，# 我们需要知道所需要的提交记录（并且还知道这些提交记录的哈希值）时，使用 cherry-pick 才是简单的# XXX1 BBB3 一定是 HEAD 后面的 commit 的 2.18 git tag 与 git describe 标签/标记/标识-描述标签原因通过前面 第三、四 章的内容很容易发现：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。问题有没有什么可以永远指向某个提交记录的标识呢，① 比如软件发布新的大版本，或者是 ② 修正一些重要的 Bug 或是 ③ 增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？ 解决Git 的 tag 就是干这个用的，它们可以（在某种程度上， 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。 作用标签在代码库中起着“锚点”的作用 2.18.1 git tag 做标志/标签123$ git tag V1.0.0 C1 # 将这个标签命名为 V1.0.0，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。$ git tag V1.0.0 # 如果没有指定 commit 那么将忽视 HEAD 指向的 commit$ git checkout V1.0.0 # 分离切换到 V1.0.0 这个 commit 2.19.2 git describe 用来描述离你最近的锚点（也就是标签）Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。 1234567# 语法# $ git describe &lt;ref&gt; 语法如此，输出如此 &lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;# &lt;ref&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。# tag 表示的是离 ref 最近的标签，# numCommits 是表示这个 ref 与 tag 相差有多少个提交记录，# hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。# 当 ref 提交记录上有某个标签时，则只输出标签名称 例如 123$ git tag v1 C3$ git describe master # 输出 v1_2_gC2$ git describe side # v2_1_gC4 三、 公司工作的实际操作看上面的很多操作，没有实际的项目，我们是不知道怎么去使用这些命令的，而且很多时候，由于公司权限的设置，有的操作我们是没有权限去执行的，对应的命令对于我们也就是没有用处了。下面来学一下公司的流程图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# - 一般公司创建了自己的私有仓库（公司远程仓库）# - 然后需要开发者去 folk 仓库（自己的远程仓库 默认名为 origin）# 然后 git clone &lt;自己仓库地址&gt; 下载到本地，本地还是那样的，拥有 3 个区域（一个本地仓库，一个本地缓存区，一个本地工作区）# - git remote add company &lt;公司仓库地址&gt; （给自己的远程添加一个仓库 命名为 company）# 上面的操作就完成了基本的工作，可以开始开发了# 一、每天的第一个工作就是获取线上的最新代码# 路劲liuxm@me ~/work/vue/freegit/code/freeui (master) # 进入本地仓库，切换到主分支，# 如果默认名就是 master 的话，如果是其他的比如说是 develop 就换切换 develop# 这假设是 主分支是 develop 分支liuxm@me ~/work/vue/freegit (develop)$ git fetch company # 下载公司远程的最新代码（包含了其他开发者的 commit 记录）（注意要给 git fetch 加上后面的参数，不认就会默认是 origin 的了）$ git rebase company/develop # 将下载到的代码 与 本地代码合并（base 理解为 根基的意思，其实就是将 company 的 commit 记录[根基]替换给本地的 develop 主分支）# 这里不要直接使用 git pull（git fetch 与 git merge 的简写），可能会出现冲突代码被覆盖的情况，小心谨慎工作被丢失# git pull --rebase（git fetch 与 git rebase 的简写）# 二、开发 aa 功能，创建分支来开发（通常一个分支是一个功能）liuxm@me ~/work/vue/freegit/code/freeui (develop)$ git checkout -b cc # 创建并且切换到 cc 分支（假设我们的分支名称本来是要 aa-ui 的）liuxm@me ~/work/vue/freegit/code/freeui (cc)$ git checkout -m cc aa-ui # 修改分支名称liuxm@me ~/work/vue/freegit/code/freeui (aa-ui)# 一顿开发操作 dhdjwwnkwai 只会就开始推送自己的代码了$ git status # 不是必须的，但是这样做可以让自己查看当前的情况（避免一些不必要的错误）$ git add . # git add 具体的看是添加所有还是单个文件来添加 （添加到 缓存区）$ git commit -m \"工作注解\" # 将缓存区的内容添加到本地仓库分支（aa-ui 当前分支）（注解不要少，为了后续的工作，一眼便知道是干了什么）$ git push origin # 默认的将 本地分支推送给远程 origin 仓库，也就是自己的仓库# 到 github 上面的去提交 pr，（将自己仓库的代码 提交到 公司 company 仓库去）# 提交 pr 时候可能会发现代码冲突，无法提交 pr 就需要修改代码解决冲突再重新提交 pr 了# 三、开发 bb 功能# 提价的 pr 是需要他人去看代码，然后合并到公司的仓库。（别人有可能会没有来得及做这个工作，但是我们需要开始其他功能更多操作了）# 假如已经得到合并了# 重复 一 的工作，下来公司仓库的最新代码，并合并，然后重复 二 的工作（记住新分支），然后又是不断的提交新代码，下拉新代码# 假如别人还没有合并我们提价提交的 pr# 如果要开发的 bb 功能与 aa 功能完全没有关系的，不会去使用到里面的东西，那么也是很简单，# 重复 一 的工作，下来公司仓库的最新代码，并合并，然后重复 二 的工作（记住新分支），然后又是不断的提交新代码，下拉新代码# 这个时候就不要去动 aa 功能的文件了，不然会导致各种复杂的冲突，# 如果要开发的 bb 功能是与 aa 功能有关的，我们只能在原来的 aa 分支上去写代码（其实也就是有关系的功能代码就写再一个分支就好了）# 重复 一 的工作，下来公司仓库的最新代码，并合并（下载别人的新代码还是必须的），# 然后重复 二 的工作（就不要新的分支了，不然前面的 pr 又没有合并，一定会弄得很乱的），然后又是不断的提交新代码，下拉新代码# 上面这个复杂的操作，其实就是说赶紧的让别人帮忙看下 pr 帮忙尽快的合并我们的代码就完事了。 四、 代码冲突解决偏离的提交历史（就是代码提交重从冲突, 远程代码 与本地代码不匹配!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!） fetch、rebase/merge 和 push 组成的工作流很普遍，就是我们的团队合作的工作，每天不断的下拉新代码，编辑代码，上传推送自己的新代码。 代码的下拉与推送基本操作我们知道了，但是在实际工作中并不是那么简单的，一个项目可能是多人合作的，这样一来，大家下拉推送代码不免就会有冲突，这个冲突才是我们需要去解决的问题。比较专业的意思有就是 远程库提交历史的偏离。 git push 的时候发生了冲突 提交 pr 的时候发生了冲突 git rebase 的时候发生冲突 git pull 的时候发生冲突 5.1 git push 推送代码发生了冲突假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是，天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。（别人有改动了，还改动了我在改的文件）。这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？git 会拒绝你的 push 请求，不执行任何的操作，而是提示你代码冲突了，需要先合并代码。因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制要求我们先合并远程最新的代码，然后才能 推送我们的工作新代码。 如何解决很简单，你需要做的就是 使你的工作基于最新的远程分支。有许多方法做到这一点呢，不过最直接的方法就是通过 rebase 调整你的工作。咱们继续，看看怎么 rebase！ 123456789101112131415161718192021# 方法 1liuxm@me ~/work/vue/freegit/code/freeui (origin/master) # 命令行后面的就是当前所在的分支$ git fetch # 下载远程仓库的 commit 记录（最新代码）（用 git fetch 更新了本地仓库中的远程分支 origin/master）$ git rebase origin/master # 将我们的工作移动到最新的提交记录下（其实就是将远程的 commit 记录（根基）复制替换本地的 commit 记录（根基））# 简写 git pull 就是 fetch 和 merge 的简写，# 类似的 git pull --rebase 就是 fetch 和 rebase 的简写！# 上面的两句可以改写为下面的简写$ git pull --rebase origin/master # 将我们的工作 rebase 到 远程分支 的最新提交记录$ git push # 将本地 commit 推向远程，向远程仓库推送我们的工作，前面已经 add 过了，也 commit 过了就不要再次重复执行了# 方法 2# git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。# 这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。$ git fetch # 用 git fetch 更新了本地仓库中的远程分支 origin/master$ git merge origin/master # 合并 origin/master 远程分支上的新变更 到 master 本地分支（为了包含远程仓库的变更）$ git push # 将本地 commit 推向远程 5.2 提交 pr 的时候发生了冲突1234567891011121314151617181920212223liuxm@me ~/work/vue/freegit/code/freeui (bb-ui) # 假设我们现在开发好了 bb-ui 分支$ git add .$ git commit -m \"开发 bb 功能\"$ git push origin# 上面的 push 的时候没有发生错误，但是提交 pr 的时候却告诉我们发生了冲突。# 提交 pr 提示了错误，此时我们的 pr 没有提交成功的~~~~~~~~~~记住修改好冲突之后还要去 提交 pr 的# 既然提示了代码冲突，肯定我们修改的代码，别人也有更新，并且合并到公司仓库去了# 那么我们首先需要做的就是去下载别人的新代码$ git checkout develop # 切换到主分支（下载代码，都要去主分支的）liuxm@me ~/work/vue/freegit/code/freeui (develop)$ git fetch company$ git rebase company/develop # 将 company 仓库的仓库的根基 赋值替换给本地 develop 主分支$ git checkout bb-uiliuxm@me ~/work/vue/freegit/code/freeui (bb-ui)$ git rebase develop # 将 develop 分支的根基赋值替换给 bb-ui 分支# $ git am --show-current-patch 提示了错误的地方在哪里了，这个时候我们就要去解决冲突了（其实也就是下面 5.3 的时候时候发生的错误了）# 手动修改错误$ git add README.md # 将修改的 README.md 文件移到缓存区$ git rebase --continue # 继续合并（替换根基）$ git push origin # 将新修改的文件推送到远程仓库（但是通常这样 push 不成功了的,错误在下面一段说到）$ git push -f # 将新修改的文件 强行推送到 远程仓库 origin（因位这个 origin 是自己别人也不会用到，使用 -f 没有关系的，别人的项目不要使用这个！！！！！！） 5.3 git rebase 发生了冲突123456789101112131415161718192021222324liuxm@me ~/work/vue/freegit/code/freeui (bb-ui)λ git rebase develop # rebase 然后就发生了下面的错误# First, rewinding head to replay your work on top of it...# Applying: 修改 readme 文档# Using index info to reconstruct a base tree...# M code/freeui/README.md# Falling back to patching base and 3-way merge...# Removing code/freeui/REAME.md# Auto-merging code/freeui/README.md# CONFLICT (content): Merge conflict in code/freeui/README.md# ____________________________也就是 code/freeui/ 下的 README.md 文件发生了冲突（本地的与先生的不一致了）# error: Failed to merge in the changes.# hint: Use 'git am --show-current-patch' to see the failed patch# ____________________________可以使用 git am --show-current-patch 命令去查看错误的路径（或者编辑器提示了）# Patch failed at 0001 修改 readme 文档# Resolve all conflicts manually, mark them as resolved with# ____________________________手动的去解决冲突，有冲突的文档会在编辑器提示的（或者上面的命令去找到冲突的地方）# \"git add/rm &lt;conflicted_files&gt;\", then run \"git rebase --continue\". # ____________________________可以 git add/rm &lt;conflicted_files&gt; 然后 git rebase --continue 继续合并# You can instead skip this commit: run \"git rebase --skip\".# ____________________________或者 可以 git rebase --skip 合并，并且跳过这个 commit 不要了# To abort and get back to the state before \"git rebase\", run \"git rebase --abort\".# ____________________________再或者 可以 git rebase --abort 回到 git rebase 之前的状态# 提示冲突 ONFLICT (content): Merge conflict in code/freeui/README.md 1234567891011121314# 上面的就是 rebase 冲突的一个表现$ git am --show-current-patch # 找到冲突的文件，位置# 编辑器其实也会提示冲突的地方的，GitKaren 工具也会提示错误的地方的# 手动的解决掉这个冲突# 111111111111111111111111111# $ git add/rm &lt;conflicted_files&gt; # 这是什么鬼操作？？？ 将冲突文件修改好之后，重新提交至缓存区$ git add README.md # 将修改的 README.md 文件移到缓存区$ git rebase --continue # 继续合并（替换根基）$ git push origin # 将新修改的文件推送到远程仓库（但是通常这样 push 不成功了的,错误在下面一段说到）$ git push -f # 将新修改的文件 强行推送到 远程仓库 origin（因位这个 origin 是自己别人也不会用到，使用 -f 没有关系的，别人的项目不要使用这个！！！！！！）$ git rebase --skip # 继续合并，跳过这个 commit 222222222222222222222222222222222222$ git rebase --abort # 不合并了，回到 git rebase 之前的状态 3333333333333333333333333 1234567$ git push origin ! [rejected] bb-ui -&gt; bb-ui (non-fast-forward)error: failed to push some refs to 'git@github.com:xiaomizhou66/freegit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 五、高级操作（本地）：介绍 Git 的超棒特性（在提交树上移动）5.1 HEAD 是什么？HEAD 是一个对当前检出记录的 符号引用 —— 也就是 指向 你 正在其基础上进行工作的 commit 提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。 12$ cat .git/HEAD # 查看 HEAD 指向$ git symbolic-ref HEAD # 如果 HEAD 指向的是一个引用。这样查看它的指向 5.2 分离 HEAD分离的目的就是要移动 HEAD，后面我们可以直接使用相当引用来移动 HEAD ，就不需要分离 HEAD 了，太麻烦了。 123456# 分离之前# HEAD -&gt; master -&gt; C1# HEAD 指向 master， master 指向 C1$ git checkout C1# HEAD -&gt; C1 现在就变成了这样， HEAD 直接指向 commit 记录 5.3 移动 HEAD移动 HEAD 的方法有 2 中， 一个是通过 commit 记录的哈希值来操作 二个就是通多相对引用 ^ ~ 来移动 HEAD 5.3.1 哈希值 移动通过哈希值指定提交记录。每个提交记录的哈希值显示在代表提交记录的圆圈中。哈希值就是通过哈希函数来计算的唯一值。 通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值。并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 fed2da64c0efc5293610bdd892f82a58e8cbc5d8。舌头都快打结了吧…比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入 fed2 而不是上面的一长串字符。 12$ git log # 查询 commit 记录，获取到目标 commit 的哈希值 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`$ git checkout fed2 # 移动到 fed2 这个 commit，并且分离出 HEAD 5.3.2 相对引用 ^ 与 ~如果我们使用的是哈希值的话，就要麻烦了，一大串的字符，即使我们可以使用简写，在使用 git log 查询的试试也是一大串的字符串，命令行看起来也都不好看了，因此我们通常使用相对引用来操作。 12345678# ^ 用 ~ 两种相对引用# HEAD^ 表示 HEAD 所在分支 上面 1 个commit# HEAD~ 表示 HEAD 所在分支 上面 1 个commit# HEAD~1 表示 HEAD 所在分支 上面 1 个commit# HEAD~2 表示 HEAD 所在分支 上面 回退 2 个commit# 其实 ^ 后面也是可以添加 数字，但是与 ~后面的数字一样，~ 后面的数字 指定的是 commit 的回退条数# ^ 后面的数字 指定的 第 几个 分支 1234567891011121314151617181920# ① 返回几个 commit 记录$ git checkout ^ # 将 HEAD 向上移动 1 个提交记录$ git checkout HEAD^ # 将 HEAD 使用 HEAD^ 向上移动 1 个点。$ git checkout ~ # 将 HEAD向上移动 1 个提交记录$ git checkout ~1 # 将 HEAD向上移动 1 个提交记录$ git checkout ~3 # 将 HEAD向上移动 3 个提交记录$ git checkout HEAD~2 # 将HEAD 使用 HEAD~2 向上移动 2 次。# ② 返回到分支上的几个 commit 记录# (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。$ git checkout master^ # 将 HEAD 切换到 master 的父节点 中的 第一个父节点 commit 记录$ git checkout master^^ # 将 HEAD 切换到 master 的父节点 中的 第二个父节点 commit 记录# ③ 返回那个父分支# 操作符 ~num 用来指定向上返回几代，也就是返回几个 commit 记录，而这里的 ^num 就不一样了。# 操作符 ^num 用来指定合并提交记录的某个父提交。如果是 merge 合并提交有两个父提交，所以遇到这样的节点时该选择哪条路径就不是很清晰了。# Git 默认选择合并提交的 “第一个” [是哪个？？？？？] 父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。 1234567$ git checkout HEAD~ # 在 当前 所在的分支上 回退 1 个commit# $ git checkout HEAD^ # 在 第 1 个分支上 回退 1 个commit，$ git checkout HEAD^2 # 在 第 2 个分支上 回退 1 个commit，$ git checkout HEAD~2 # 在 当前 所在的分支上 回退 2 个commit# 这些相对操作其实可以链式操作，上面的 3 个操作 等价如下$ git checkout HEAD~^2~2 5.3 移动分支（强制操作 -f）（就是省略掉切换分支的操作）使用相对引用，强行移动分支。我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。更直接的说其实就是强行移动非当前分支，不需要切换分支的意思。不需要再切换分支再去移动 HEAD 12345liuxm@me ~/work/vue/freegit/code/freeui (bugFix) # 当前在 bugFix 分支上，但是我们想要移动 master 分支$ git branch -f master HEAD~3 # 将 master 分支强制指向 HEAD 的第 3 级父提交。$ git branch -f branch-name HEAD # 将 branch-name 分支强制指向 HEAD 提交。 3.1.3 综合操作，综合操作，综合操作!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!123456789101112131415# ① HEAD# HEAD 是一个对当前检出记录的符号引用，也就是是说就像是 ￥ 一样，HEAD 只是一个符号表示# HEAD 通常情况下是指向分支名的（如 master），通常也是最后一个 commit 提交记录的位置# ② 分离 HEAD# 上面也说到了，HEAD 通常情况下是指向分支名的（如 master），但是我们需要的不只是这个分支名称# 我们需要的是将当前位置也就是 HEAD 指向的是 某个/目标 commit 提交，从而才可以进一步操作# 不是说知道是 master 分支就好了，而是要移动到具体的 commit 提交记录上面。$ git log # 可以【查询/获取】commit 提交记录的哈希值# 假设查询到目标提交记录的哈希值为 `fed2da64c0efc5293610bdd892f82a58e8cbc5d8`$ git checkout fed2da64c0efc5293610bdd892f82a58e8cbc5d8 # 【分离】 HEAD 到目标 提交记录!!!!!!!$ git checkout fed # 哈希值的简写，因为 git 的作用我们可以这样简写其中的字符就可以知道是对应的提交# 即使我们可以使用哈希值来分离移动到我们目标的 commit 记录上，但是操作有点麻烦。# 我们可以使用 相对引用来分离移动，具体查阅 3.1.2 5.3 综合实际应用（整理移动提交记录）5.3.1 只提取其中 1 条 commit 记录（跳过 debug console.log prinf 语句的 commit）场景：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些 调试命令 如 console.log 并向控制台打印了一些信息。这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！最后就差把 bugFix 分支里的工作合并回 master 分支了。你可以选择通过 fast-forward 快速合并到 master 分支上，但这样的话 master 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……实际我们只要让 Git 复制解决问题的那一个提交记录就可以了 假设目前的提交树是这样的， 12345678# 在 bugFix 分支上的 C1 C3 是做为调试使用的，C4 才是我们调试好的 commit 也才是我们需要的# 现在 HEAD 再 bugFix 分支上$ git rebase -i HEAD~3$ git merge master # 好像 master 没有自己的 commit 的话这句不需要做？$ git checkout master$ git merge bugFix# 这里是用的是 cherry-pick 方法来做 3.3.2 修改历史 commit （代码内容 或者是 commit 时候的注释）（这个方法可能有问题！！！！！！！！）之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。 假设目前的提交树是这样的， 12345678# git 使用 amend 选项提供了最后一次 commit 的反悔。但是对于历史提交呢 已经 pushed 的，就必须使用 rebase 了# 也就是说如果我们只是需要直接 git commit --amend ，但是操作的是之前的操作，那么就要先将 需要修改的变成 最后一个 commit 就好了$ git rebase -i HEAD~2 # 将 HEAD~2 后面的 commit 提取出来 ,先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前$ git commit --amend # 使用 --amend 这个参数可以修改最后一次 commit 的内容，包括提交的 注释内容 都是可以的(进行一些小修改)$ git rebase -i HEAD~2 # 将 HEAD~2 后面的 commit 提取出来 ,还原顺序$ git branch -f master HEAD # 将 master 分支强制的合并到 HEAD（把 master 移到修改的最尾部，结合起来） 当然完成这个任务的方法不止上面提到的一种（当然用 cherry-pick 也是可以的啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。 最后有必要说明一下目标状态中的那几个 ‘ ，我们把这个提交移动了两次，每移动一次会产生一个 ‘ ；而 C2 上多出来的那个是我们在使用了 amend 参数提交时产生的，所以最终结果就是这样了。 3.3.3 修改历史 commit （代码内容 或者是 commit 时候的注释）上面的使用 rebase 排序的方法是可以的，但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。这个小节我们使用 git cherry-pick 来操作。cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题 ？？？？？什么鬼意思，没有看懂） 假设目前的提交树是这样的， 12345678# 此时直接使用 git cherry-pick C2 会出错，就是因为`cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上# （只要不是 HEAD 上游的提交就没问题） C2 属于 HEAD 上游 是不行的`# 所以 cherry-pick 只能是复制别人的分支的 commit 么？$ git checkout master # 切换到 master 分支$ git cherry-pick C2 # 将 C2 复制到 master 分支上$ git commit --amend # 提交一些修改$ git cherry-pick C3 # 将 C3 复制到 master 分支上 5.1 合并分支/ 使用 rebase ??????????????? 怎么做呀，好难啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊 将所有的分支 commit 全都复制合并到 master 上。 1# 直接 $ git cherry-pick C3 是错误的，C3 并不是 HEAD 后面出现的。 交互式（就是会跳出一个窗口来选择操作 类似 UI）（这个有 UI 界面效果的，好操作多了呀） 如果你不清楚你想要的提交记录的哈希值呢? 我们可以利用交互式的 rebase ，可以从一系列的提交记录中找到想要的记录, 这就是最好的方法。 12345678910$ git rebase --interactive HEAD~4$ git rebase -i HEAD~4 # 简写 --interactive# 最后得到的也是一个复制的 commit 记录# 指的是从 HEAD~4 后面的 commit 记录都抽取出来操作，注意的是与选择不同，这里的是意思的从 HEAD~4 的后面开始挑选出来进行操作# ① 调整提交记录的顺序（通过鼠标拖放来完成）# ② 删除你不想要的提交（通过切换 pick 的状态来完成，关闭就意味着你不想要这个提交记录）# 如果有不需要复制的 commit 点击 omit 取消即可，pick 是选择，就是需要赋值# ③ 合并提交。简而言之，它允许你把多个提交记录合并成一个。就是上面 第 2 章学习的 rebase 内容。# 三种操作，然后就可以得到一个 复制的 指向 HEAD~4 的复制提交树 5.2 两个父节点 使用相对引用1git checkout HEAD^1~2 5.3 纠缠不清的分支六、高级远程（远程）：关于 origin 和它的周边 —— Git 远程仓库高级操作6.1 推送主分支在 大型项目 中开发人员通常会在 从 master 上分出来的 特性分支上工作，工作完成后只做一次集成。这跟前面课程的描述很相像（把 side 分支推送到远程仓库），不过本节我们会深入一些. 但是有些开发人员只在 master 上做 push、pull —— 这样的话 master 总是最新的，始终与远程分支 (o/master) 保持一致。 将特性分支集成到 master 上 推送并更新远程分支 题目：① 这里共有三个特性分支 —— side1 side2 和 side3。② 我需要将这三分支按顺序推送到远程仓库③ 因为远程仓库已经被更新过了，所以我们还要把那些工作合并过来 11.2 合并远程仓库11.3 远程追踪11.4 git push 的参数11.5 git fetch 的参数11.5 git pull 的参数git pull 到头来就是 fetch 后跟 merge 的缩写。你可以理解为用同样的参数执行 git fetch，然后再 merge 你所抓取到的提交记录。 12345678910111213$ git pull origin foo# 相当于：$ git fetch origin foo$ git merge o/foo$ git pull origin bar~1:bugFix# 相当于$ git fetch origin bar~1:bugFix$ git merge bugFix# git pull 实际上就是 fetch + merge 的缩写,# git pull 唯一关注的是提交最终合并到哪里（也就是为 git fetch 所提供的 destination 参数） 11.7 没有 source 的 source","tags":[]},{"title":"【圈数字】-与编程无关的圈数字输出①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/㊿ - 其他---带圈数字输出/","text":"一、前言与变成无关，纯粹记录一些其他问题。 1 2 3 4 5 6 7 8 9 10 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿","tags":[]},{"title":"【Foxmail】-添加 163.com 网易邮箱账号不成功 POP,MAP","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/㊿ 其他---Foxmail邮箱使用/","text":"一、前言与编程无关，纯粹记录一些其他问题。 二、Foxmail 添加163邮箱错误直接新建邮箱登录出错，手动设置添加服务器地址端口还是错误。而且提示也不搭调，说是账号或者密码错误，不然。这是因为有没有开启 POP,MAP 服务。 具体步骤：登录163邮箱→设置页面设置→POP3/SMTP/IMAP→勾选设置→授权码设置→Foxmail新建账号→输入邮箱地址与授权码。 设置页面设置→POP3/SMTP/IMAP 勾选设置→授权码设置 勾选设置→授权码设置 勾选设置→授权码设置 输入邮箱地址与授权码 其他第三方客户端也是一样的道理，不只是 foxmai。Foxmail 比较简单，界面清洁，用户友好（可以设置收件人备注） 三、Foxmail 添加 gmail 邮箱方法，需要科学上网才能使用的，","tags":[]},{"title":"谷歌浏览器使用技巧","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/㊿ 其他---谷歌浏览器使用技巧/","text":"一、前言用 Chrome 浏览器，学会好用功能，游刃有余，提升工作效率、节省大量时间。谷歌的 Chrome 浏览器功能尤其强大：它隐藏了不少快捷方式、扩展功能和可能性。 二、快捷键功能/新功能2.1 浏览器打开一个新的标签页而不离开现有的页面，这样就不会打断目前的工作！！！！这个确实是很有用，比如博客点击文章的时候就会覆盖原来的文章,很不乐意这样的现象。 Windows ctrl + 鼠标单机链接 Mac os Cmd + 鼠标单机链接 这一操作将在你使用 Chrome 的大部分情况下发挥作用，包括历史页面和后退按钮下拉历史列表 2.2 浏览器打开一个新的窗口打开一个新的标签页而不离开现有的页面 Windows Shift + 鼠标单机链接 Mac os Shift + 鼠标单机链接 这一操作将在你使用 Chrome 的大部分情况下发挥作用，包括历史页面和后退按钮下拉历史列表 2.3 向下滚动一个完整的页面长度 Windows 空格键 + ↓ Mac os 空格键 + ↓ 2.4 向上滚动一个完整的页面长度 Windows 空格键 + Shift Mac os 空格键 + Shift 2.5 打开刚关闭的页面 Windows Ctrl + Shift + T Mac os Cmd + Shift + T 多次使用会依次打开之前关闭的页面 还有一个办法就是左上角的回退按钮，点击它并长按鼠标，你将会看到一个弹出的历史栏，在你的当前标签查看最近历史记录。就可以再次打开了。 2.6 快速收藏当前打开的所有页面-到-文件夹Ctrl+Shift+D 2.7 快速打开收藏夹的所有收藏右键-&gt;打开所有新窗口 2.8 快速搜索 划词-&gt; 右键-&gt; 选择谷歌搜索 划词-&gt; 拖拽-&gt; 扔进搜索框 2.9 如果谷歌浏览器变得很奇怪如果你发现 Chrome变得非常奇怪，请记住这个命令:Chrome://restart。把它输入到 Chrome 的地址栏中，你的浏览器就会重新启动并在瞬间恢复所有的标签和窗口。你永远不会想到这一功能什么时候会派上用场。？？？没有看懂这个是什么鬼。 三、一些新功能使用3.1 在谷歌浏览器给自己一个备忘录空白页1data:text/html;charset=utf-8, &lt;title&gt;Scratchpad&lt;/title&gt;&lt;style&gt;body &#123;padding: 5%; font-size: 1.5em; font-family: Arial; &#125;\"&gt;&lt;/style&gt;&lt;link rel=\"shortcut icon\" href=\"https://ssl.gstatic.com/docs/documents/images/kix-favicon6.ico\"/&gt;&lt;body OnLoad='document.body.focus();' contenteditable spellcheck=\"true\" &gt; 将上面一串代码拉到地址栏，enter 回车就可以得到一个空白页面。保存在收藏栏就可以了~~~~ 这里其实就是一个编辑器： 支持对文本的格式设置 windows：Ctrl +B为设置粗体，Ctrl+I 为设置斜体，Ctrl+U 为设置下划线）， Mac： Cmd +B为设置粗体，cmd+I 为设置斜体，Cmd+U为设置下划线 甚至还附带一个内置的拼写检查功能。 保存windows：Ctrl +S Mac： cmd +S ？？？？？？？？？？？？？？？？？？？？不行啊，没有办法保存！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 3.2 去除格式的复制粘贴（这个应该不算是谷歌浏览器的功能）ctrl + c 复制ctrl + v 粘贴ctrl + shift + v 去格式粘贴","tags":[]},{"title":"谷歌浏览器清除缓存-清除当前页面的缓存-清除当前网站缓存","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/㊿ 其他---谷歌浏览器清除缓存问题/","text":"一、前言谷歌浏览器清除缓存的问题，这个文章其实与编程有关系的。 二、已经部署好的网站，修改的内容不生效这里是部署上线的网站，已经有了自己的样式，js，等等缓存信息。 后面修改了它的 css 样式，本地修改好的了。但是推送到远程，发现线上的样式怎么样都不修改。一时间以为是自己的 css 写错了，或者是 hexo 主题没有做好，，，，，，其实是因为 线上缓存的关系，我们更新的 css 文件没有得到更新，需要我们手动的去更新才会更新。 下面是更新缓存的方方法 2.1 更多工具-&gt;清除缓存（这是最容易想到的方法）但是这个方法会清除浏览器中所有的网站的缓存，我们并不想要这样做，我们只是想更新当前的网站。 2.2 清除当前页面的缓存（右键刷新按钮）！！！！！！！！！！！！！！！！！！！！！！！！！！！！！先打开开发者工具，右键刷新网页按钮，就可以看清除缓存的选项，这里就是清除当前页面的缓存。注意一定要先打开开发者工具，然后右键刷新按钮才会有这 3 个下拉选项，不然是没有的","tags":[]},{"title":"async 异步编程进阶","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-ES7-async 异步编程进阶/","text":"一、前言异步编程对 JavaScript 语言太重要。JavaScript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。 单线程：就相当于一个人干所有的事情，小事都是大事。多线程：相当于很多人去干一件事情，就大事化小了。 但是很多时候，我们一个语句的执行需要依赖另外一个语句的结果，那么就需要去处理异步操作。 二、异步操作 回调函数 事件监听 new proxy({}) Promise 对象 Generator 函数 async….await（应该算是 ES7 的内容） 2.1 异步？同步：等待上一个的结果，下一个才能执行异步：不需要等待上一个的结果，下面的语句也执行了 所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 2.1 回调函数（太难了）回调函数，就是 B 函数作为 A 函数的参数，在 A 函数中调用。 123456789101112131415161718function A(b, c) &#123; b(c) console.log('AAAAAAAAA')&#125;function B(c) &#123; c() console.log('我是回调函数B，作为别的函数的参数')&#125;function C() &#123; console.log('我是回调函数C，作为别的函数的参数')&#125;A(B,C)// 我是回调函数C，作为别的函数的参数// 我是回调函数B，作为别的函数的参数// AAAAAAAAA 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//付款的简易流程，先找人，再找订单，最后支付。其中找人、找订单和支付都是异步逻辑。function pay() &#123; getUserByDB(function (err, user) &#123; if (err) &#123; console.error('出错了'); return false; &#125; if (user) &#123; getOrderByDB(function (err, order) &#123; if (err) &#123; console.error('出错了'); return false; &#125; if (order) &#123; toPayByDB(function (err) &#123; if (err) &#123; console.error('出错了'); return false; &#125; console.log('支付成功'); &#125;); &#125; else &#123; createOrderByDB(function (err, order) &#123; if (err) &#123; console.error('出错了'); return false; &#125; toPayByDB(function (err) &#123; if (err) &#123; console.error('出错了'); return false; &#125; console.log('支付成功'); &#125;); &#125;); &#125; &#125;); &#125; else &#123; createUserByDB(function (err, user) &#123; if (err) &#123; console.error('出错了'); return false; &#125; getOrderByDB(function (err, order) &#123; if (err) &#123; console.error('出错了'); return false; &#125; if (order) &#123; toPayByDB(function (err) &#123; if (err) &#123; console.error('出错了'); return false; &#125; console.log('支付成功'); &#125;); &#125; else &#123; createOrderByDB(function (err, order) &#123; if (err) &#123; console.error('出错了'); return false; &#125; toPayByDB(function (err) &#123; if (err) &#123; console.error('出错了'); return false; &#125; console.log('支付成功'); &#125;); &#125;); &#125; &#125;); &#125;); &#125; &#125;);&#125;pay(); 2.2 new proxy({})2.3 promise 对象 new Promise({})Promise 内部具备三种状态（pending 进行中,fulfilled 已成功,rejected 已失败） 缺点： 首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。 其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。 第三，当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） 12345678910111213141516171819// Promise 对象是一个构造函数，用来生成 Promise 实例，对象// 这里的 resolve, reject 是两个函数参数，由 JavaScript 引擎提供，不用自己部署。const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then((res)=&gt;&#123; //resolved&#125;,(err)=&gt;&#123; //rejected 这个函数参数是可选的&#125;).catch((err)=&gt;&#123; //&#125;) 12345678910111213141516171819202122// 这里假设所有异步操作的返回都是符合 Promise 规范的。不符合怎么办// 实际场景中，比如 mongoose 是可以配置的，异步回调也可以自己去封装function pay() &#123; return getUserByDB() .then(function (user) &#123; if (user) return user; return createUserByDB(); &#125;) .then(getOrderByDB) .then(function (order) &#123; if (order) return order; return createOrderByDB(); &#125;) .then(toPayByDB) .catch(function (err) &#123; console.error(err); &#125;);&#125;pay().then(function (order) &#123; console.log('付款成功了');&#125;); 2.4 Generator 函数 *…yield…123456789101112131415161718192021function B() &#123; // 协程B可以是字符串、同步函数、异步函数、对象、数组 // 这里用函数更能说明问题 console.log('222222222') return '协程 B 交还了执行权';&#125;function * A() &#123; console.log('111111111');//next() let A2 = yield B(); console.log('333333333');// return A2;&#125;let it = A();//这是 generator 的调用方法，用来实例化一个变量console.log(it.next())//1111111 222222 &#123; value: '协程 B 交还了执行权', done: false &#125;console.log(it.next())//3333333 &#123; value: undefined, done: true &#125;// 变量的 it.next() 执行了变量 it 的第一步，与异步的 B ，返回&#123; value: '协程 B 交还了执行权', done: false &#125;// 此时 A 是没有执行完的// 再次 it.next() 执行了变量 it 的第二部，返回 &#123; value: undefined, done: true &#125;// 此时 A 已经执行完了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function * Pay() &#123; // 这四个变量是为了更好的说明这个过程 // 其实只需user 和 order 两个变量就能解决问题 let oldUser = null; let newUser = null; let oldOrder = null; let newOrder = null; try &#123; let oldUser = yield getUserByDB(); if (!oldUser) &#123; newUser = yield createUserByDB(); &#125; let oldOrder = yield getOrderByDB(); if (!oldOrder) &#123; newOrder = yield createOrderByDB(); &#125; const result = yield toPayByDB(); return result; &#125; catch (error) &#123; console.error('支付失败'); &#125;&#125;const pay = Pay();pay.next().value.then(function (user) &#123; // 执行getUserByDB()，得到user，并停止 // user不存在，next()不传值，则oldUser被赋值为undefined，然后执行createUserByDB()，得到user，并停止 if (!user) return pay.next().value; return user; // 如果user存在，直接返回&#125;).then(function (user) &#123; // 这个next(user)就有点复杂了。 // 如果代码在执行了getUserByDB()后停止的，则next(user)就是把user赋值给oldUser // 如果代码在执行了createUserByDB()后停止的，则next(user)就是user赋值给newUser // 然后执行getOrderByDB()，得到order，并停止 return pay.next(user).value.then(function (order) &#123; // order不存在，next()不传值，则oldOrder被赋值为undefined，然后执行createOrderByDB()，得到order，并停止 if (!order) return pay.next().value; return order; // 如果order存在，直接返回 &#125;);&#125;).then(function (order) &#123; // 这个next(order)同样。 // 如果代码在执行了getOrderByDB()后停止的，则next(order)就是把order赋值给oldOrder // 如果代码在执行了createOrderByDB()后停止的，则next(order)就是order赋值给newOrder // 然后执行toPayByDB()，并停止。 return pay.next(order).value; // done的值为false&#125;).then(function () &#123; // next(),将undefined赋值给result，并返回result pay.next(); // 此时done的值为true&#125;); 2.5 async….awaitasync/await 就像自然界遵循着进化论一样，从最初的回调一步一步的演化而来，达到异步编程的最高境界，就是根本不用关心它是不是异步。 123456789101112131415function sleep(s) &#123; setTimeout(() =&gt; &#123; console.log('希望我会先执行') &#125;, s * 1000)&#125;async function testAsync() &#123; sleep(3); console.log('我会后面执行')&#125;testAsync();//我在后面执行//希望我会先执行// 上面的结果并不是我们需要的 12345678910111213141516function sleep(s) &#123; setTimeout(() =&gt; &#123; console.log('希望我会先执行') &#125;, s * 1000)&#125;// 异步函数async function testAsync() &#123; const data = await sleep(3); console.log('我会后面执行')&#125;testAsync();// async....await...异步编程,就是等待 await 后面跟着的函数先执行完之后，下面的语句才会执行// 希望我会先执行// 我会后面执行 1234567891011121314151617181920//wepy 框架小程序的 代码// 页面加载onLaunch() &#123; this.testAsync();//调用 testAsync 函数 wepy.showShareMenu(&#123; withShareTicket: true &#125;);&#125;sleep(s) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('promise resolved'); &#125;, s * 1000); &#125;);&#125;// 异步函数async testAsync() &#123; const data = await this.sleep(3); console.log(data);//保证上面的 sleep(3) 会先执行，才会执行这里的语句&#125;","tags":[]},{"title":"ES6【1】--[ECMAScript 6 入门]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-ES6-基础入门/","text":"一、前言全面介绍 ECMAScript 6 新引入的语法特性。 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 阮一峰的教程说的太多了，太细，不适合入门，入门就看这篇文章就好了。 二、var let const123456// for 中使用 let 来声明是极好的for(let i=0;i&lt;n;i++)&#123; //&#125;// 块级作用域 三、解构赋值解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。 3.1 数组解构赋值12345678910111213141516171819// 数组解构赋值---顺序赋值let [a,b,c] = [1,2,3];//得到 a=1 b=2 c=3let [a,[b,c],d] = [1,[2,3],4];//得到 a=1 b=2 c=3 d=4let [a,,c] = [1,2,3];//得到 a=1 c=3let [a,b] = [1];//得到 a=1 b=undefinedlet [a,b=1] = [1,undefined];//得到 a=1 b=1let [a,b=1] = [1,null];//得到 a=1 b=null//可以用值交换,交换变量的值let x = 1;let y = 2;[x, y] = [y, x];//从函数返回多个值，函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example(); 3.2 对象解构赋值123456789101112//字符串解构赋值-顺序赋值（类似数组）let &#123;a,b,c,d&#125; = 'xiaomi'// a='x' b='i' c='a' d='o'// 返回多个值， 返回一个对象，函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。function example() &#123;return &#123; foo: 1, bar: 2&#125;;&#125;let &#123; foo, bar &#125; = example(); 1234567891011121314151617181920212223//对象的解构赋值---同名赋值let &#123;name,age&#125; = &#123; name: 'xiaomi', age: 18&#125;console.log(name);//xiaomiconsole.log(age);//18// 如果先声明了变量，再解构赋值，要给语句添加括号 ()，不然会报错let res = &#123; name: 'xiaomi',//假设这里是后端给的数据 age: 18&#125;;let name;//这里先声明了let age;(&#123;//这里解构赋值要给 () name, age&#125; = res)console.log(name); //xiaomiconsole.log(age); //18 3.3 数组对象赋值对象部分同名解构赋值，数组部分顺序赋值，对象的解构赋值可以用很多次。 1234567891011// 这样 p 不是变量，不能赋值的let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 123456789101112// 这样 p 也会被赋值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\"p // [\"Hello\", &#123;y: \"World\"&#125;] 1234567891011121314// 更加复杂的解构赋值，对象的解构赋值可以用很多次。！！！！！！！！！！！！！！！！！const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 12345678910// 实际应用~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//提取 JSON 数据，快速提取从后端获取来的数据let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123;id,status,data:number&#125; = jsonData;//这里 data 只是一个模量，不需要解构赋值console.log(id, status, number);// 42, \"OK\", [867, 5309] 3.4 函数参数的解构赋值12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 12345678910111213// 实际应用~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// 指定参数的默认值，就避免了在函数体内部再写 var foo = config.foo || 'default foo'; 这样的语句。jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 1234567891011121314151617// 实际应用~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~let json = &#123; name:'xiaomi', age:18&#125;function fun(&#123;name,age=18&#125;)&#123;//这样传参就不需要 .属性了，简单了很多 console.log(a,b);&#125;fun(json);let arr = ['xiaomi',18,'female'];function fun(a,b,c)&#123; console.log(a,b,c);&#125;fun(...arr);//拓展运算符传参也简答了 3.5 set/map 的遍历1234567891011121314151617181920var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 3.6 输入模块的指定方法123const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\");// 导入react组件import &#123;ReactComponent&#125; from './xxxComponent.jsx'; 四、扩展运算符 和 rest 运算符（都是 4 个点）4.1 扩展运算符它们可以很好的为我们解决参数和对象数组未知情况下的编程，让我们的代码更健壮和简洁。 123456789//可以给一个函数传入不同个数的参数function AA(...arg)&#123; arg[0]//1 arg[1]//2 arg[2]//3 arg[3]//undefined&#125;AA(1,2,3);AA('xiaomi',18);// arg[0]=xiaomi arg[1]=18 123456789101112131415161718// 解决数组的引用问题（浅拷贝）let arr = ['xiaomi', 18]let arr1 = [...arr]arr1.push('female');console.log(arr); //[ 'xiaomi', 18 ]console.log(arr1); //[ 'xiaomi', 18, 'female' ] 达到了深拷贝的效果// 解决对象引用问题（浅拷贝）let obj = &#123; name: 'XIAOMI', age: 18&#125;let obj1 = &#123; ...obj&#125;obj1.name = 'mei'console.log(obj);//&#123; name: 'XIAOMI', age: 18 &#125; obj 不受 obj1 的影响了，达到了深拷贝的效果console.log(obj1);//&#123; name: 'mei', age: 18 &#125; 4.2 rest 运算符1234567//可以给一个函数传入不同个数的参数, 后面的是剩余参数function AA(name, ...arg) &#123; console.log(arg[0]) //18 console.log(arg[1]) //19 console.log(arg[2]) //undefined&#125;AA('xiaomi', 18, 19); 五、字符串模版123456let name = 'xiaomi'let age = 18let str = name + ' is ' + age + ' year old!'// ES5 字符串拼接，注意空格需要放在冒号里面，不然单词就链接在一起了let str1 = `$&#123;name&#125; is $&#123;age&#125; year old！`// ES6 字符串模本，`` 反引号中所有的数据，包括空格都是直接的结果console.log(str);//xiaomi is 18 year old!console.log(str1);//xiaomi is 18 year old! 12345678// 字符串模本写 html 代码片段let name = 'xiaomi'let str = `&lt;h1&gt;标题&lt;/h1&gt; &lt;div&gt; &lt;span&gt;$&#123;name&#125;&lt;/span&gt; &lt;span&gt;333&lt;/span&gt; &lt;/div&gt;`;document.write(str); 1234//字符串模板做计算let a=1;let b=2;let result=`$&#123;a+b&#125;`;//3 12345678let name = 'xiaomi'let res = name.indexOf('ao')//2let res1 = name.includes('ao') //trueconsole.log(name.startsWith('ao'))//falseconsole.log(name.startsWith('x'))//trueconsole.log(name.endsWith('i'))//true'*'.repeat(10)// ********** 六、ES6 数字操作12let binary = 0B010101;//21 二进制： 数字0 + 字母b（不区分大小写）let o = 0o666;//438 八进制： 数字0 + 字母o（不区分大小写） 123456789101112131415161718// 是否无线let a= 11/4;console.log(Number.isFinite(a));//trueconsole.log(Number.isFinite('jspang'));//falseconsole.log(Number.isFinite(NaN));//falseconsole.log(Number.isFinite(undefined));//false//是否为 NaNNumber.isNaN(NaN)//true//是否为整数let a=123.1;console.log(Number.isInteger(a)); //false//整数转换let a='9.18';console.log(Number.parseInt(a));console.log(Number.parseFloat(a)); 十一、Symbol11.1 用 Symbol 构建对象的 Key，并调用和赋值。1234567let s = Symbol();let obj=&#123; [s]:'xiaomi'&#125;console.log(obj[s]);//xiaomiobj[s]='web';console.log(obj[s]);//web 11.2 Symbol 对象元素的保护作用在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用 Symbol 进行保护。 123456789let obj=&#123;name:'xiaomi',sex:'female'&#125;;let age=Symbol();obj[age]=18;for (let item in obj)&#123; console.log(obj[item]); //xiaomi //female&#125;console.log(obj);//&#123; name: 'xiaomi', sex: 'female', [Symbol()]: 18 &#125; 十二、set/map 为 JS 内置的 数据结构12.1 set (它类似于数组，但是成员的值都是唯一的，没有重复的值。)1234let s = new Set();//声明空值const set = new Set([1, 2, 3, 4, 4]);console.log(set)//Set &#123; 1, 2, 3, 4 &#125; 1234567891011121314151617181920// add(value)： 添加某个值， 返回 Set 结构本身。// delete(value)：删除某个值， 返回一个布尔值，表示删除是否成功。// has(value)： 返回一个布尔值，表示该值是否为Set的成员。// clear()： 清除所有成员， 没有返回值。//size 属性 获取长度值let s = new Set();s.add('xiaomi')console.log(a.size)//1console.log(s)//Set &#123; 'xiaomi' &#125;s.add(18)console.log(s)//Set &#123; 'xiaomi', 18 &#125;console.log(s.delete(18))//trueconsole.log(s)//Set &#123; 'xiaomi' &#125;console.log(s.has(18))//falseconsole.log(s)//Set &#123; 'xiaomi' &#125;s.clear()console.log(s)//Set &#123;&#125; 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] 12.2 map123456let map=new Map();//声明空值const map = new Map([ ['F', 'no'], ['T', 'yes'],]); 1234567891011121314151617181920// set(value)： 添加某个键值对， 返回 map 结构本身。// get(value)： 用 key 获取 value 值// delete(value)：删除某个键值对， 返回一个布尔值，表示删除是否成功。// has(value)： 返回一个布尔值，表示该值是否为Set的成员。// clear()： 清除所有成员， 没有返回值。//size 属性 获取长度值let m = new Map();m.set('name', 'xiaomi') //key valuem.size //1console.log(m); //Map &#123; 'name' =&gt; 'xiaomi' &#125;m.set('age', 18)console.log(m); //Map &#123; 'name' =&gt; 'xiaomi', 'age' =&gt; 18 &#125;console.log(m.get('age')) //18 用 key 键来获取 value 值console.log(m.delete('age')) //trueconsole.log(m) //Map &#123; 'name' =&gt; 'xiaomi' &#125;console.log(m.has('name'))//true 用 key 键来判断m.clear() 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\" 十三、new Proxy({})本文省略 十五、Promise 对象本文省略 二十、class 与 它的继承12345678910111213141516171819202122232425262728293031class Myclass &#123; constructor(x, y, c = 1) &#123; //在类的参数传递中我们用constructor( )进行传参。传递参数后可以直接使用 this.xxx 进行调用。 this.x = x; this.y = y; this.c = c; this.toString = this.toString.bind(this)//这样来解决 this 的指向问题最简单 &#125; // prop 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 // 问题这个不需要绑定 this 了么？？？ get prop() &#123; return this.c = this.c * 10; &#125; set prop(value) &#123; this.c = value; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var mm = new Myclass(2, 3);console.log(mm.toString()) // (2, 3)mm.prop = 5console.log(mm.prop) //50//类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。// 就是说将它解构赋值给了别人就变成单独的了，这样来使用方法， this 的指向就会被改变了","tags":[]},{"title":"TypeScript--[入门","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-TypeScript- 语言/","text":"一、前言TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 Microsoft 开发，代码开源于 GitHub 上。TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。 英文文档中文文档阮一峰教程 typescript 的简称是 TS, 下文将以 TS 称之。 二、TS 特点 增加了代码的可读性和可维护性 类型系统实际上是最好的文档，大部分的函数看看 类型的定义 就可以知道如何使用了 可以在编译阶段就 发现大部分错误，这总比在运行时候出错好 增强了 编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等 非常包容 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可 即使不显式的定义类型，也能够自动做出类型推论 可以定义从简单到复杂的几乎一切类型 即使 TypeScript 编译报错，也可以生成 JavaScript 文件 兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取 TypeScript 拥有活跃的社区 大部分第三方库都有提供给 TypeScript 的类型定义文件 Google 开发的 Angular2 就是使用 TypeScript 编写的 TypeScript 拥抱了 ES6 规范，也支持部分 ESNext 草案的规范 TypeScript 的缺点 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 集成到构建流程需要一些工作量 可能和一些库结合的不是很完美 根据自己团队和项目的情况判断是否需要使用 TypeScript。 三、安装 TypeScript123# npm 安装$ npm install -g typescript# 会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了 四、理解 TypeScript.ts 我们约定使用 TypeScript 编写的文件以 .ts 为后缀，.tsxTypeScript 编写 React 时，以 .tsx 为后缀！！！！react 中是 xxx.tsx 文件 TypeScript 是 JavaScript 的一个超集，是需要编辑器的支持，我们才能在编辑器编辑 ts 类型的文件。因为它是微软的，所以编辑器 Visual Studio Code 也是微软的，17 版的 vscode 内置了 TypeScript。其他的编辑器根据自己的需求去获取 TypeScript 支持。 4.1 TypeScript 文件最终还是编译为 js 文件12345678// 创建 greeter.ts 文件function greeter(person: string) &#123; return \"Hello, \" + person;&#125;let user = \"Jane User\";document.body.innerHTML = greeter(user); 123# 使用 tsc 命令来编译 ts 文件$ tsc greeter.ts# 在当前目录文件夹下，将产生一个 greeter.js 文件 4.2 类型注解 定义的变量，传入的参数，函数返回值的，类型: 冒号前候有无空格均可（但是貌似后面给个空格会比较好看把，习惯） 说白了，类型注解就是让我们方便知道定义的变量，传入的参数，函数返回值的，类型。让编译器帮助我们判断对错。 TypeScript 里的类型注解是一种轻量级的为函数 或 变量 添加约束的方式。 冒号前候有无空格都行。 1234567function greeter(person: string) &#123;// 我们希望传进来的参数 person 是字符串，如果不是字符串将会报错 return \"Hello, \" + person;&#125;let user = [0, 1, 2];document.body.innerHTML = greeter(user); 1greeter.ts(7,26): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 4.2.1 类型不对，但是依然会被编译上面的 ts 文件，虽然穿进去的参数类型是不对的，但是它依然会编译得到一个 js 文件。只是会在编译的时候命令行报错。 4.2.2 避免类型错误依然编译问题如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。这个知识点看文章后续。 4.3 类型断言（）有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。说白了，就是说我们知道这个值是什么类型的，我们直接告诉编译器。通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 2 中办发来做类型断言，两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。 4.3.1 类型断言 尖括号 语法12let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 4.3.2 类型断言 as 语法12let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 4.4 类型推论 没有定义类型，编译器会根据赋值来推断类型TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 1234567//以下代码虽然没有指定类型，但是会在编译的时候报错：let myFavoriteNumber = 'seven';// 第一次赋值是一个字符串，后面就不能赋值为其他的类型了。//除非是后面的给了一个类型是 any 那就随你去修改变量的类型。myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.// 它等价于let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 五、ts 基础学习JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。 一样的，ts 只是 js 的超级，它跟 js 一样的。 5.1 基础类型5.1.1 布尔值类型在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 JavaScript 中，Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。 12345678910let isDone: boolean = false;//变量注解 布尔值类型let createdByNewBoolean: boolean = new Boolean(1);//error// index.ts(1,5): error TS2322: Type 'Boolean' is not assignable to type 'boolean'.// 使用构造函数 Boolean 创造的对象不是布尔值//事实上 new Boolean() 返回的是一个 Boolean 对象：let createdByNewBoolean: Boolean = new Boolean(1);//ok//直接调用 Boolean 也可以返回一个 boolean 类型：let createdByBoolean: boolean = Boolean(1);//ok 5.1.2 数值类型123456let decLiteral: number = 6;//变量注解 数值类型let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;//十 进制let octalLiteral: number = 0o744;// ES6 中的八进制表示法let notANumber: number = NaN;let infinityNumber: number = Infinity; 123456789//编译后var decLiteral = 6;var hexLiteral = 0xf00d;var binaryLiteral = 10;// ES6 中的二进制表示法var octalLiteral = 484;// ES6 中的八进制表示法var notANumber = NaN;var infinityNumber = Infinity;//0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。 5.1.3 字符串类型12345678910let name: string = \"bob\";//变量注解 字符串类型，单双引号都可以，还有字符串模板 `` 都可以的name = \"smith\";let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`;//等价于，注意到上面是两个换行，下面这里字符串拼接就是 \\n\\nlet sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" + \"I'll be \" + (age + 1) + \" years old next month.\"; 5.1.4 数组类型5.1.4.1 普通数组12let list: number[] = [1, 2, 3];let list: Array&lt;number&gt; = [1, 2, 3]; 5.1.4.5 元组 就是元素类型不同/多元化 的 数组123456789let x: [string, number]; // 定义一个元组类型x = ['hello', 10]; // 给它初始化，成功能x = [10, 'hello']; // 初始化不成功，VScode 编辑器会把有错误的数据标明红色底纹!!!!!!!!!!!!!!!特别好!!!!!!!!!!!!!!!!!!!!console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'//当访问一个越界的元素，会使用联合类型替代：只能是联合定义的时候给的类型，其他的类型不可以。x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 5.1.4.6 枚举 enumenum 类型是对 JavaScript 标准数据类型的一个补充。 像 C# 等其它语言一样，使用 枚举类型 可以为 一组数值 赋予友好的名字。 12345678910111213141516enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green;//默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;//全部都采用手动赋值enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green;//枚举类型提供的一个便利是你可以由枚举的值得到它的名字。//例如，我们知道数值为 2 ，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 5.1.5 Any 任意不指定类型有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量： 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; // ok, definitely a boolean 在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object 有相似的作用，就像它在其它语言中那样。 但是 Object 类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // ok, ifItExists might exist at runtimenotSure.toFixed(); // ok, toFixed exists (but the compiler doesn't check)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. 123//你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：let list: any[] = [1, true, \"free\"];list[1] = 100; 123456//如果是一个普通类型，在赋值过程中改变类型是不被允许的：let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7;//ok 12345678910//在任意值上访问任何属性都是允许的：let anyThing: any = 'hello';console.log(anyThing.myName);console.log(anyThing.myName.firstName);//也允许调用任何方法：let anyThing: any = 'Tom';anyThing.setName('Jerry');anyThing.setName('Jerry').sayHello();anyThing.myName.setFirstName('Cat');//可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 123456789101112// 未声明类型的变量// 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：let something;something = 'seven';something = 7;something.setName('Tom');//等价于let something: any;something = 'seven';something = 7;something.setName('Tom'); 5.1.6 空值 void 像是与any类型相反,表示没有任何类型JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数： 123function alertName(): void &#123; alert('My name is Tom');&#125; 12let unusable: void = undefined;// 虽然没有错误，但是声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null 5.1.7 Null 和 Undefined1234//在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：//undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。let u: undefined = undefined;let n: null = null; 12345678910111213//与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：// 非严格模式let num: number = undefined;// 这样不会报错，但是严格模式来说就错误了，而且也推荐使用严格模式let u: undefined;// 这样也不会报错，但是严格模式来说就错误了，而且也推荐使用严格模式let num: number = u;// 这样也不会报错，但是严格模式来说就错误了，而且也推荐使用严格模式//在严格模式来说，上面这样写是错误的。//null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。//也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefinedlet u: void;let num: number = u;// error， void 类型的变量不能赋值给 number 类型的变量：// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 5.1.8 Never 那些永不存在的值的类型never 类型是那些 总是会抛出异常或 根本就不会有返回值的函数表达式或 箭头函数表达式的返回值类型; 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。 never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; 5.1.9 Object 非原始类型object 表示非原始类型，也就是除 number，string，boolean，symbol，null 或 undefined 之外的类型。使用 object 类型，就可以更好的表示像 Object.create 这样的 API 123456789declare function create(o: object | null): void;// 参数类型为 对象 或者 null ，没有返回值create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Error","tags":[{"name":"递归函数","slug":"递归函数","permalink":"https://liuxmoo.com/tags/递归函数/"}]},{"title":"JavaScript -- [深拷贝与浅拷贝]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/[Javascript]-js-深拷贝与浅拷贝/","text":"一、前言浅拷贝 引用拷贝，两者是相互影响的。 B 修改会影响 A 的值，反之亦然深拷贝 值的拷贝，拷贝前后的对象没有影响。B 的修改不会影响 A ，反之亦然 有个问题就是，别人都说的是 简单数组，的拷贝不属于深拷贝，链接本文评论区 二、深拷贝 与 浅拷贝的1.浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用2.深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用” 在 JS 这门语言中， array 也是对象，因为数组的拷贝也有深浅拷贝之说。 2.1 为什么要使用深拷贝？我们希望在改变新的 数组（对象）的时候，不改变原数组（对象） 2.2 深拷贝的要求程度？我们在使用深拷贝的时候，一定要弄清楚我们对深拷贝的要求程度：是仅 深拷贝 第一层级的 对象属性 或 数组元素，还是 递归拷贝 所有层级的 对象属性 和 数组元素 ？ 2.3 怎么检验深拷贝成功？改变任意一个新对象/数组中的属性/元素, 都不改变原对象/数组 三、数组拷贝3.1 简单数组[‘’,6，true]，直接遍历深拷贝数组（只拷贝第一级数组元素) 3.1.1 for 循环遍历123456789101112var array = [1, 2, 3, 4];function copy (array) &#123; let newArray = [] for(let item of array) &#123; newArray.push(item); &#125; return newArray;&#125;var copyArray = copy(array);copyArray[0] = 100;console.log(array); // [1, 2, 3, 4]console.log(copyArray); // [100, 2, 3, 4] 3.1.2 slice()12345var array = [1, 2, 3, 4];var copyArray = array.slice();copyArray[0] = 100;console.log(array); // [1, 2, 3, 4]console.log(copyArray); // [100, 2, 3, 4] slice() 方法返回一个从已有的数组中截取一部分元素片段组成的新数组（不改变原来的数组！）用法：array．slice(start,end) start 表示是起始元素的下标， end 表示的是终止元素的下标 当slice()不带任何参数的时候，默认返回一个长度和原数组相同的新数组 3.1.3 concat()12345var array = [1, 2, 3, 4];var copyArray = array.concat();copyArray[0] = 100;console.log(array); // [1, 2, 3, 4]console.log(copyArray); // [100, 2, 3, 4] concat() 方法用于连接两个或多个数组。( 该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。) 用法：array.concat(array1,array2,……,arrayN) 因为我们上面调用concat的时候没有带上参数，所以 var copyArray = array.concat(); 实际上相当于 var copyArray = array.concat([]);也即把返回数组和一个空数组合并后返回 3.2 对象数组[{}] JSON.parse(JSON.stringify(obj1)在 JS 中 数组也是对象，因此可以使用这个办法对于对象数字的深拷贝 123456//deep Clonelet obj = [&#123;a:1,b:2&#125;];let obj2 = JSON.parse(JSON.stringify(obj));obj.a = 4;console.log(JSON.stringify(obj)); // [&#123;a:4,b:2&#125;]console.log(JSON.stringify(obj2)); // [&#123;a:1,b:2&#125;] 将该对象转换为其 JSON 字符串表示形式，然后将其解析回对象。JSON.stringify(obj1) 将 obj1 转化为 JSON 数据，再用 JSON.parse 将 JSON 数据转化为 对象。 缺点 创建了一个临时的、可能很大的字符串，只是为了把它重新放回解析器。 这种方法不能处理循环对象,抛出错误。 诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。 四、对象 Object 实现深拷贝对于一些时候，我们希望得到一个拷贝对象，但是希望二者不要相互影响，那么就会希望是深拷贝。 4.1 简单对象{}4.1.1 for 循环遍历1234567891011121314151617var obj = &#123; name: 'liuxmoo', job: '学生'&#125;function copy (obj) &#123; let newObj = &#123;&#125;; for (let item in obj )&#123; newObj[item] = obj &#125; return newObj;&#125;var copyObj = copy(obj);copyObj.name = 'xiaomi';console.log(obj); // &#123;name: \"liuxmoo\", job: \"学生\"&#125;console.log(copyObj); // &#123;name: \"xiaomi\", job: Object&#125; 4.1.2 ES6 的 Object.assign 或者 Array.from12345678var obj = &#123; name: 'liuxmoo', job: '学生'&#125;var copyObj = Object.assign(&#123;&#125;, obj);copyObj.name = 'xiaomi';console.log(obj); // &#123;name: \"liuxmoo\", job: \"学生\"&#125;console.log(copyObj); // &#123;name: \"xiaomi\", job: Object&#125; Object.assign：用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），并返回合并后的target 用法： Object.assign(target, source1, source2); 所以 copyObj = Object.assign({}, obj); 这段代码将会把obj中的一级属性都拷贝到 ｛｝中，然后将其返回赋给copyObj 4.1.3 ES6 扩展运算符： …12345678var obj = &#123; name: 'liuxmoo', job: '学生'&#125;var copyObj = &#123; ...obj &#125;copyObj.name = 'xiaomi';console.log(obj); // &#123;name: \"liuxmoo\", job: \"学生\"&#125;console.log(copyObj); // &#123;name: \"xiaomi\", job: Object&#125; 扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中 4.2 多层级对象 用多层花括号4.2.1 obj2 = JSON.parse(JSON.stringify(obj1)) 方法 【拷贝所有层级-处理多层级对象】123456//deep Clonelet obj1 = &#123;a: 0, b: &#123;c: 0&#125;&#125;;let obj3 = JSON.parse(JSON.stringify(obj1));obj1.a = 4;obj1.b.c = 4;console.log(JSON.stringify(obj3)); // &#123;a: 0, b: &#123;c: 0&#125;&#125; 将该对象转换为其 JSON 字符串表示形式，然后将其解析回对象。JSON.stringify(obj1) 将 obj1 转化为 JSON 数据，再用 JSON.parse 将 JSON 数据转化为 对象。 缺点 创建了一个临时的、可能很大的字符串，只是为了把它重新放回解析器。 这种方法不能处理循环对象,抛出错误。 诸如 Map, Set, RegExp, Date, ArrayBuffer 和其他内置类型在进行序列化时会丢失。 循环对象无法使用这种办法 12345//构建树状数据结构，其中一个节点引用其父级，而父级又引用其子级。const x = &#123;&#125;;const y = &#123;x&#125;;x.y = y; // Cycle: x.y.x.y.x.y.x.y.x...const copy = JSON.parse(JSON.stringify(x)); // throws! 抛出错误 4.2.2 自行编辑 的递归方法1234567891011121314151617181920var array = [ &#123; number: 1 &#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;];function copy (obj) &#123; var newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== 'object')&#123; return; &#125; for(var i in obj)&#123; newobj[i] = typeof obj[i] === 'object' ? copy(obj[i]) : obj[i]; &#125; return newobj&#125;var copyArray = copy(array)copyArray[0].number = 100;console.log(array); // [&#123;number: 1&#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;]console.log(copyArray); // [&#123;number: 100&#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;] 4.5 Structured Clone 结构化克隆算法 方法4.2.1 MessageChannel调用 postMessage 结构化克隆算法就可以使用。我们可以创建一个 MessageChannel 并发送消息。在接收端，消息包含我们原始数据对象的结构化克隆。 12345678910function structuralClone(obj) &#123; return new Promise(resolve =&gt; &#123; const &#123;port1, port2&#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125;const obj = /* ... */;const clone = await structuralClone(obj); 缺点它是异步的。虽然这并无大碍，但是有时候你需要使用同步的方式来深度拷贝一个对象。 4.2.2 History API12345678910function structuralClone(obj) &#123; const oldState = history.state; history.replaceState(obj, document.title); const copy = history.state; history.replaceState(oldState, document.title); return copy;&#125;const obj = /* ... */;const clone = structuralClone(obj); 使用 history.pushState()写过 SPA，我们可以提供一个状态对象来保存 URL。 事实证明，这个状态对象使用结构化克隆 - 而且是同步的。我们必须小心使用，不要把程序逻辑使用的状态对象搞乱了，所以我们需要在完成克隆之后恢复原始状态。为了防止发生任何意外，请使用 history.replaceState() 而不是 history.pushState()。 缺点 然而，仅仅为了复制一个对象，而使用浏览器的引擎，感觉有点过分。 Safari 浏览器对 replaceState 调用的限制数量为 30 秒内 100 次。 4.2.3 Notification API123456function structuralClone(obj) &#123; return new Notification('', &#123;data: obj, silent: true&#125;).data;&#125;const obj = /* ... */;const clone = structuralClone(obj); 短小，简洁。 缺点 需要浏览器内部的权限机制，所以它是可能是很慢的？？？？？。由于某种原因，Safari 总是返回undefined。 七、性能深拷贝实际上是很消耗性能的。（我们可能只是希望改变新数组里的其中一个元素的时候不影响原数组，但却被迫要把整个原数组都拷贝一遍，这不是一种浪费吗？） 所以，当你的项目里有大量深拷贝需求的时候，性能就可能形成了一个制约的瓶颈了。 7.1 存在大量深拷贝需求的代码——immutable提供的解决方案通过immutable引入的一套API，实现： 1.在改变新的数组（对象）的时候，不改变原数组（对象）2.在大量深拷贝操作中显著地减少性能消耗 12345const &#123; Map &#125; = require('immutable')const map1 = Map(&#123; a: 1, b: 2, c: 3 &#125;)const map2 = map1.set('b', 50)map1.get('b') // 2map2.get('b') // 50","tags":[]},{"title":"react.js--[create-react-app 脚手架]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-create-react-app 脚手架/","text":"一、前言使用脚手架快速搭建项目结构。官网叫做 React App，其实就是 create-react-app，这样过比较好理解。 gitHub 网址，上面有视频教程。 脚手架搭建的项目也是 单页应用。 二、环境准备：应用的安装以下应用如果没有在电脑安装过，那么就要先安装才能在电脑上使用 create-react-app 脚手架创建项目。 2.1全局安装 node.js12345# 安装 node.js，命令行输入 node -v 查看版本来测试是否成功安装① 中文地址：http://nodejs.cn/download/② 英文地址：https://nodejs.org/en/download/③ 历史版本下载地址：https://nodejs.org/dist/④ 全面的详解安装方法：http://www.runoob.com/nodejs/nodejs-install-setup.html 2.2全局安装 npm123# 新版本的 node.js 中已经含有 NPM，如果是新版本不需要再安装 NPM，# 安装NPM， 命令行输入 `npm -v` 查看版本来测试是否成功安装# 全面的详解安装方法：http://www.runoob.com/nodejs/nodejs-npm.html 2.3全局安装 cnpm12$ npm install -g cnpm --registry=https://registry.npm.taobao.org # 安装 cnpm# 安装 CNPM，可以使用 `cnpm-v` 查看版本来测试是否成功安装 2.4 全局安装 pnpm12# install pnpm$ npm install -g pnpm # pnpm 是先使用缓存，要比 npm 要好一点 2.5 升级NPM版本123# 升级 npm 版本，命令行输入$ npm install npm -g ，或者是淘宝镜像$ cnpm install npm -g 2.6 react 安装 （不需要额外安装）官网也没有安装 react ，因为 create-react-app 就包含了 react ，使用脚手架创建项目的时候会自动的安装 react 与 react-dom。 但是下面还是写一下方法 2.6.1 npm 安装方法 npm init [name]123# npm 安装方法$ npm init #这一句需要么？？？$ npm install --save react react-dom # 一般是不是不推荐全局安装 react ？ 2.6.2 yarn 安装方法 yarn add123# Yarn 安装方法yarn init # 这个需要么？？yarn add react react-dom 2.6.3 pnpm/cnpm 安装法2.6.5 cdn 安装方法1234567891011121314151617&lt;!-- CDN 引入 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\" /&gt;&lt;title&gt;Hello React!&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!--react.min.js ======= React 的核心库react-dom.min.js === 提供与 DOM 相关的功能babel.min.js ======= Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平。注意: 在浏览器中使用 Babel 来编译 JSX 效率是非常低的。一般还是不用这种办法了，还要去找 链接 --&gt; 2.7 create-react-app（包括 react 与 react-dom）12$ npm install -g create-react-app# 全局安装 create-react-app 脚手架 2.8 安装 调试工具 debuggingReact Developer Tools : an extension available for Chrome , Firefox , and as a standalone app that allows you to inspect the React component hierarchy in the Chrome Developer Tools React Developer Tools 调试工具 三、初始化项目：react 项目构建完整构建过程3.1 react 框架项目创建!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 完整构建过程# ① 创建应用 应用名称 my-app 最好使用正确的路径 my-app 为自定义名称$ create-react-app my-app # 用这个好了，不要搞其他什么特殊,避免发生错误$ yarn create react-app my-app # 使用 yarn 初始化项目$ npx create-react-app my-app # 使用 npx 初始化项目# ② 进入项目!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!这个很重要，很重要，很重要，很很重要!!!!!!!!!!$ cd my-app# ③ 开启/运行项目，start 之后浏览器就会打开一个窗口，不打开就自己复制链接去打开一个窗口$ npm start # 开始使用，当然 cnpm start，pnpm start，yarn start 都行的$ yarn start # 这里还是使用 yarn 吧，命令行都是使用 yarn 安装的，很快，并且也提示 yarn start# 先 start 之后再来安装下面的东西吧，要保证自己每步写的代码都没有问题，写了很多，才发现一堆的错误，会很头疼的。# ④ 路由# $ npm install --save react-router 这个已经过时，不适用了，现在用的是 4.0 + 版本的$ npm install --save react-router-dom # 4.0 + 版本使用的是 react-router-dom$ yarn add react-router-dom # yarn 安装法# ⑤ 官方动画（看自己是否需要，也可以自己做，或者是网上大神的开源项目使用）$ yarn add react-transition-group # 网址 https://reactcommunity.org/react-transition-group/$ npm install react-transition-group --save #安装动画插件 yarn 的好处就是不需要 --save 了$ yarn add react-motion$ npm install --save react-motion # 安装动画插件 使用 https://github.com/chenglou/react-motion# ⑥ 请求，拦截器$ yarn add axios # 使用 yarn 安装 axios# ⑦ ui 组件库 蚂蚁金服 antd design$ npm install antd --save$ yarn add antd# 实践之后发现使用 npm 好多错误（版本问题啊，等等），还是用 yarn 好了!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 直接用 scss 文件之后， yarn start 会提示安装的。# $ npm install sass-loader node-sass --save-dev # 安装 scss# $ yarn add sass-loader node-sass # yarn 的好处，# create-react-app 2.0 已经默认的是支持 css 预处理器了，但是还是要安装 node-sass，只是不需要配置了。$ yarn add node-sass # 只需要安装 node-sass 不需要 sass-loader ，否则会报出下面的错误# warning Pattern [\"sass-loader@^7.1.0\"] is trying to unpack in the same destination# eject !!!!!!这个会移除我的 webpack 不要轻易使用！！！！！！！！!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 如果 create-react-app 中的 webpack 配置满足不了需求，可以运行这个命令将所有 webpack 配置以及服务移到项目目录中，# 这样修改起来就很灵活了，但是这个命令是不可回退的。$ npm run eject # 会生成一个 config 文件夹，其实相当于 复制 node_module 中的文件夹，不直接修改 node_module 文件夹避免错误$ yarn eject # 用 yarn 来运行，其实 2.0 版本的脚手架不需要这个操作了已经！！！！！！！！！！！！！！！！！！！！！！！！！！# 不要忘记配置 config 文件夹# 打包应用，开发完之后，打包 disc 文件夹部署上线$ pnpm run build$ yarn build# 如果是下载或者克隆别人的项目！不要忘记这个步骤啦，不然报错了还以为浪费时间# 还原依赖$ yarn install # 用 yarn 吧。$ npm install 还可以引人其他的工具库: 阿里图标：内含千万字符实体图标选择使用 Lodash工具库：一套工具库，内部封装了很多字符串、数组、对象等常见数据类型的处理函数，方便我们处理js的各种类型数据 3.2 查看版本 以及其他 命令操作12345678910-V # --version 的缩写-h # --help 的缩写$ create-react-app -V (or --version)# 打印版本信息$ create-react-app --info # 打印当前系统跟react相关的开发环境参数，也就是操作系统、Node版本 et$ create-react-app -h (or --help) # 打印帮助信息$ create-react-app my-app --verbose # 打印本地日志，其实他是 npm 和 yarn 安装外部依赖包可以加的选项，可以打印安装有错时的信息。$ create-react-app my-app --scripts-version # 由于它本身把创建目录初始化步骤和控制命令分离了，用来控制react项目的开发、打包和测试都放在了 react-scripts 里面，所以这里可以单独来配置控制的选项信息。$ create-react-app my-app --use-npm # create-react-app 默认使用 yarn 来安装，运行，# 如果没有使用 yarn，需要指定配置为使用 npm create-react-app 对于开发者还是很友好的，可以自己去定义很多东西，如果你不想这么去折腾，它也提供了标准的 react-scripts 供开发者使用 3.3 搭建完成的项目包含的功能1234567891011121314151617- React, JSX, ES6, TypeScript and Flow syntax support. # 因此就是上面的，不需要下载 react.js 了的。- Language extras beyond ES6 like the object spread operator. # 对象扩展运算符- Autoprefixed CSS, so you don’t need -webkit- or other prefixes. # 自动修复 CSS，不需要 -webkit- 或 其他前缀- A fast interactive unit test runner with built-in support for coverage reporting. # 一个快速交互式单元测试运行器，内置支持覆盖率报告。- A live development server that warns about common mistakes. # 一个实时开发服务器，用于警告常见错误。- A build script to bundle JS, CSS, and images for production, with hashes and sourcemaps. # 用于生成JS，CSS和图像的构建脚本，包含哈希和源图- An offline-first service worker and a web app manifest, meeting all the Progressive Web App criteria. (Note: Using the - service worker is opt-in as of react-scripts@2.0.0 and higher) #- Hassle-free updates for the above tools with a single dependency. # 使用单个依赖项对上述工具进行无忧更新 四、搭建框架中间遇到的问题4.1 npm WARN deprecated circular-json@0.3.3: CircularJSON is in maintenance only, flatted is its successor.12npm WARN deprecated circular-json@0.3.3: CircularJSON is in maintenance only, flatted is its successor.这个 CircularJSON 它其实是 ESlint 的问题， ESlint 的问题 网址，出来十几天的问题，2018-12-21 没有解决曾问题， 4.2 npm install 出错123456789101112λ yarn installyarn install v1.9.4[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...error An unexpected error occurred: \"EPERM: operation not permitted, scandir 'F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\hello-world\\\\node_modules\\\\@types'\". # 安装依赖的时候错误info If you think this is a bug, please open a bug report with the information provided in \"F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\hello-world\\\\yarn-error.log\".info Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command. 123456789101112131415161718192021222324252627282930313233343536373839λ npm installnpm WARN deprecated circular-json@0.3.3: CircularJSON is in maintenance only, flatted is its successor.npm WARN deprecated kleur@2.0.2: Please upgrade to kleur@3 or migrate to 'ansi-colors' if you prefer the old syntax. Visit &lt;https://github.com/lukeed/kleur/releases/tag/v3.0.0\\&gt; for migration path(s).npm WARN rollback Rolling back @types/q@1.5.1 failed (this is probably harmless): EPERM: operation not permitted, lstat 'F:\\qianduan_dir\\00program\\react.js\\hello-world\\node_modules\\@types\\q'npm ERR! path F:\\qianduan_dir\\00program\\react.js\\hello-world\\node_modules\\@typesnpm ERR! code EPERMnpm ERR! errno -4048npm ERR! syscall mkdirnpm ERR! Error: EPERM: operation not permitted, mkdir 'F:\\qianduan_dir\\00program\\react.js\\hello-world\\node_modules\\@types'npm ERR! &#123; Error: EPERM: operation not permitted, mkdir 'F:\\qianduan_dir\\00program\\react.js\\hello-world\\node_modules\\@types'npm ERR! cause:npm ERR! &#123; Error: EPERM: operation not permitted, mkdir 'F:\\qianduan_dir\\00program\\react.js\\hello-world\\node_modules\\@types'npm ERR! errno: -4048,npm ERR! code: 'EPERM',npm ERR! syscall: 'mkdir',npm ERR! path: 'F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\hello-world\\\\node_modules\\\\@types' &#125;,npm ERR! stack: 'Error: EPERM: operation not permitted, mkdir \\'F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\hello-world\\\\node_modules\\\\@types\\'',npm ERR! errno: -4048,npm ERR! code: 'EPERM',npm ERR! syscall: 'mkdir',npm ERR! path: 'F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\hello-world\\\\node_modules\\\\@types',npm ERR! parent: 'hello-world' &#125;npm ERR!npm ERR! The operation was rejected by your operating system.npm ERR! It's possible that the file was already in use (by a text editor or antivirus),npm ERR! or that you lack permissions to access it.npm ERR!npm ERR! If you believe this might be a permissions issue, please double-check thenpm ERR! permissions of the file and its containing directories, or try runningnpm ERR! the command again as root/Administrator (though this is not recommended).npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-12-21T11_11_52_804Z-debug.log 解决： 其实就是 node_modules 下载出错了。大概是安装到一半的话不要停止，即使 ctrl+c 停止，但是node_modules 文件夹已经存在了，再停止重新安装会出错的可能性很大，装了就不要停止，否则就需要先删掉，node_modules ,删除缓存，然后再重新的安装。 网址 123# node_modules 删除这个文件夹$ npm cache verify # 清除缓存$ yarn install # 重新下载依赖 4.3 安装 scss 出错/webpack1234567891011λ yarn add sass-loader node-sassyarn add v1.12.3[1/4] Resolving packages...[2/4] Fetching packages...warning Pattern [\"sass-loader@^7.1.0\"] is trying to unpack in the same destination \"C:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Yarn\\\\Cache\\\\v4\\\\npm-sass-loader-7.1.0-16fd5138cb8b424bf8a759528a1972d72aad069d\\\\node_modules\\\\sass-loader\" as pattern [\"sass-loader@7.1.0\"]. This could result in non-deterministic behavior, skipping. # sass-loader@^7.1.0 试图在同一个地址解压info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...`warning \" &gt; sass-loader@7.1.0\" has unmet peer dependency \"webpack@^3.0.0 || ^4.0.0\".` # 没有找到必须的 webpack 依赖包[4/4] Building fresh packages... 解决：因为之前用过了 yarn eject，不要轻易使用吧！！！！！还是不知道怎么在 react 中使用 scss!!!!!!!!!!!!!!!!!!!!!!!!!!!1yarn eject 会把 webpack 这个打包工具去掉。出现上面的警告，去看创建好的项目中 package.json 文件内容少了好多！！！！！！！ 12345# 版本是自己选择的，不用版本就会下载不指定版本的 webpack$ npm install webpack -g # 不需要安装$ yarn add webpack@4.19.1 -g # 不需要安装# 但是之后没有使用 yarn eject 也出现了这个问题，是因为 vie-cli3 没有包含 webpack 打包器么# vue-cli3 脚手架也会出现这个问题，只是一个警告，因为新的脚手架是对 webpack 进行了封装，一个警告不是错误 error 我们不需要理会的。 问题： cli3 中 对 webpack 进行了封装，CLI 服务,上面的只是警告，不用理会，react 的 create-react-app 2.0 中好像也是这样的问题。 4.4 使用 yarn 安装时候出现的问题123456λ yarn add axiosyarn add v1.12.3warning package-lock.json found. # 发现了 package-lock.json 文件Your project contains lock files generated by tools other than Yarn. # 您的项目包含由 Yarn 以外的工具生成的锁定文件。It is ion inconsistencies caused by unsynchronized lock files. #它是由不同步的 lock 文件引起的不一致To clear this warning, remove package-lock.json. # 要清除此警告，请删除package-lock.json。 其实就是因为之前有使用 npm 然后一会又使用 yarn 导致的问题，就把这个 package-lock.json 删掉就好了，留下一个 yarn.lock 来锁定版本就好。 4.5 yarn eject123456789101112λ yarn ejectyarn run v1.12.3$ react-scripts ejectNOTE: Create React App 2 supports TypeScript, Sass, CSS Modules and more without ejecting: https://reactjs.org/blog/2018/10/01/create-react-app-v2.html? Are you sure you want to eject? This action is permanent. YesThis git repository has untracked files or uncommitted changes:# 提示还有没有提交的修改，就是 git 相关的项目， eject 之前需要上传到 gitpackage.jsonM yarn.lockRemove untracked files, stash or commit any changes, and try again.error Command failed with exit code 1.info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command. 123# commit 一下就好了，或者之前就是将它按照正产 git 项目来 commitgit add .git commit -am \"Save before ejecting\" 4.1 Can’t resolve ‘./assets/logo.svg’1234567λ yarn startyarn run v1.12.3$ node scripts/start.jsFailed to compile../src/app/App.js`Module not found: Can't resolve './assets/logo.svg' in 'F:\\qianduan_dir\\00program\\react.js\\todo\\src\\app'` 这里就是路径错误了，路径一定要修改正确。是 ../assets/logo.svg，一个点表示当前目录下的 assets 目录，肯定是不存在的了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！两个点表示返回到文件夹 assets，这样才是正确的。！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 4.1 没有 cd 进入文件夹!!!!!!!!!!!!!!!!!!!!!!!!!!!!!每次都犯这个错误1234567891011F:\\qianduan_dir\\00program\\react.jsλ yarn add react-router-domyarn add v1.12.3info No lockfile found.[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...warning \"react-router-dom &gt; react-router@4.3.1\" has unmet peer dependency \"react@&gt;=15\".# 这里这样提示，但是却不是它的错误，仔细看下 F:\\qianduan_dir\\00program\\react.js 这个目录都不对。warning \" &gt; react-router-dom@4.3.1\" has unmet peer dependency \"react@&gt;=15\".[4/4] Building fresh packages... 根本不是其他插件的问题，就是因为在这里文件夹不是项目文件夹啊，都没有 package.json 怎么去安装插件!!!!!!!!!!!!!!!!! 4.8 yarn add node-sass123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132F:\\qianduan_dir\\00program\\react.js\\ordering-system (master -&gt; origin)λ yarn add node-sassyarn add v1.12.3[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...[4/4] Building fresh packages...`error F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\node-sass: Command failed.`# 什么鬼错误？不是支持 scss 的么，怎么还错误了？？？？Exit code: 1`Command: node scripts/build.js`#Arguments:Directory: F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\node-sassOutput:Building: C:\\Program Files\\nodejs\\node.exe F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\node-gyp\\bin\\node-gyp.js rebuild --verbose --libsass_ext= --libsass_cflags= --libsass_ldflags= --libsass_library=gyp info it worked if it ends with okgyp verb cli [ 'C:\\\\Program Files\\\\nodejs\\\\node.exe',gyp verb cli 'F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js',gyp verb cli 'rebuild',gyp verb cli '--verbose',gyp verb cli '--libsass_ext=',gyp verb cli '--libsass_cflags=',gyp verb cli '--libsass_ldflags=',gyp verb cli '--libsass_library=' ]gyp info using node-gyp@3.8.0gyp info using node@8.11.3 | win32 | x64gyp verb command rebuild []gyp verb command clean []gyp verb clean removing \"build\" directorygyp verb command configure []gyp verb check python checking for Python executable \"python2\" in the PATHgyp verb `which` failed Error: not found: python2gyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed python2 &#123; Error: not found: python2gyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed stack: 'Error: not found: python2\\n at getNotFoundError (F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:13:12)\\n at F (F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:68:19)\\n at E (F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:80:29)\\n at F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:89:16\\n at F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\isexe\\\\index.js:42:5\\n at F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\isexe\\\\windows.js:36:5\\n at FSReqWrap.oncomplete (fs.js:152:21)',gyp verb `which` failed code: 'ENOENT' &#125;gyp verb check python checking for Python executable \"python\" in the PATHgyp verb `which` failed Error: not found: pythongyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed python &#123; Error: not found: pythongyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed stack: 'Error: not found: python\\n at getNotFoundError (F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:13:12)\\n at F (F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:68:19)\\n at E (F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:80:29)\\n at F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\which\\\\which.js:89:16\\n at F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\isexe\\\\index.js:42:5\\n at F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\isexe\\\\windows.js:36:5\\n at FSReqWrap.oncomplete (fs.js:152:21)',gyp verb `which` failed code: 'ENOENT' &#125;gyp verb could not find \"python\". checking python launchergyp verb could not find \"python\". guessing locationgyp verb ensuring that file exists: C:\\Python27\\python.exegyp ERR! configure errorgyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable.gyp ERR! stack at PythonFinder.failNoPython (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\node-gyp\\lib\\configure.js:484:19)gyp ERR! stack at PythonFinder.&lt;anonymous&gt; (F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\node-gyp\\lib\\configure.js:509:16)gyp ERR! stack at F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\graceful-fs\\polyfills.js:284:29gyp ERR! stack at FSReqWrap.oncomplete (fs.js:152:21)gyp ERR! System Windows_NT 6.1.7601gyp ERR! command \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"F:\\\\qianduan_dir\\\\00program\\\\react.js\\\\ordering-system\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\" \"rebuild\" \"--verbose\" \"--libsass_ext=\" \"--libsass_cflags=\" \"--libsass_ldflags=\" \"--libsass_library=\"gyp ERR! cwd F:\\qianduan_dir\\00program\\react.js\\ordering-system\\node_modules\\node-sassgyp ERR! node -v v8.11.3gyp ERR! node-gyp -v v3.8.0gyp ERR! not okBuild failed with error code: 1info Visit https://yarnpkg.com/en/docs/cli/add for documentation about this command. 五、框架结构详解5.1 没有 eject 的项目结构1234567891011121314151617181920|-- node_modules/ # 依赖包||-- public| |-- favicon.ico # 网站图片标识| |-- index.html # 页面模板：一切的开始都从这里开始，所以这个是代码执行的源头| |-- manifest.json # 指定了开始页面为 index.html。||-- src/ # src 目录下的文件才会被 webpack 打包，所以要把 js、css 文件放在 src 目录下| |-- App.css| |-- App.js| |-- App.test.js| |-- index.css| |-- index.js # 入口文件| |-- logo.svg| |-- serviceWorker.js||-- .gitignore # git 上传需要忽略的文件格式|-- package.json # 项目基本信息|-- README.md # 项目说明|-- yarn.lock # 明确 安装包的具体版本 5.2 eject 之后的项目结构项目结构可以学习这篇文章 1234567891011121314151617181920212223242526272829303132333435363738|-- build/ #存放项目被webpack处理后生成的文件；||-- config/ # webpack 配置文件，存放的是项目的配置文件；| |-- jest/| | |-- cssTransform.js| | |-- fileTransform.js| || |-- env.js| |-- paths.js| |-- webpack.config.js| |-- webpackDevServer.config.js||-- node_modules/ # 依赖包，存放 npm 安装的工具包 或 模块||-- public # 静态资源，该目录下的文件不会被webpack处理，它们会被拷贝到 build/ 文件夹下| |-- favicon.ico # 网站图片标识| |-- index.html # 页面模板：一切的开始都从这里开始，所以这个是代码执行的源头| |-- manifest.json # 指定了开始页面为 index.html。||-- scripts # 运行配置，与项目的构建、打包 或 服务 相关的脚本| |-- build.js #| |-- start.js #| |-- test.js #|# |-- src/ # src 目录下的文件才会被 webpack 打包，所以要把 js、css 文件放在 src 目录下，项目的源代码及资源# | |-- App.css# | |-- App.js# | |-- App.test.js# | |-- index.css# | |-- index.js # 入口文件# | |-- logo.svg# | |-- serviceWorker.js# 实际代码中会去修改这个文件夹下的结构，||-- .gitignore # git 上传需要忽略的文件格式|-- package.json # 项目基本信息|-- README.md # 项目说明|-- yarn.lock # 明确 安装包的具体版本 5.3 public/public 虽然目录可以添加任何资源，如：图片、代码 等等，但是 不建议 把这些资源添加到 public 目录中；public 适合存放 与 webpack 不兼容的库 要引用 public/ 目录下的资源，需要使用一个特殊的变量 PUBLIC_URL 来表示 public 目录；在执行 npm run build 时，PUBLIC_URL 变量会被替换成正确的绝对路径； 12345&lt;!-- 在 HTML中用 %PUBLIC_URL% 引用 PUBLIC_URL 变量，在 JavaScript 中用 process.env.PUBLIC_URL 引用 PUBLIC_URL 变量；示例：在文件 public/index.html 可以这样引用 public/favicon.ico: --&gt;&lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" /&gt; 4.1 public/manifest.json 配置文件123456789101112131415&#123; \"short_name\": \"React App\", \"name\": \"Create React App Sample\", \"icons\": [ &#123; \"src\": \"favicon.ico\", \"sizes\": \"64x64 32x32 24x24 16x16\", \"type\": \"image/x-icon\" &#125; ], \"start_url\": \".\", \"display\": \"standalone\", \"theme_color\": \"#000000\", \"background_color\": \"#ffffff\"&#125; 4.2 public/index.html 入口文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"theme-color\" content=\"#000000\"&gt; &lt;!-- manifest.json provides metadata used when your web app is added to the homescreen on Android. See https://developers.google.com/web/fundamentals/web-app-manifest/ 当你使用 Android 屏幕的时候，这个 manifest.json 文件可以提供元数据，具体参阅上面的网址 --&gt; &lt;link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\"&gt; &lt;!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. 请注意在上面的标记中使用％PUBLIC_URL％。它将在构建期间替换为 `public` 文件夹的 URL。 只能从 HTML 中引用 `public` 文件夹中的文件。 与 “/favicon.ico” 或 “favicon.ico” 不同，“％PUBLIC_URL％/ favicon.ico” 将 与客户端路由和非 root 公共 URL 一起正常工作。 通过运行 `npm run build` 了解如何配置非 root 公共 URL。 --&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; You need to enable JavaScript to run this app. &lt;/noscript&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;!-- This HTML file is a template. 这个是 html 模板文件 If you open it directly in the browser, you will see an empty page. 如果直接用浏览器打开这个文件看到的是空白页面 You can add webfonts, meta tags, or analytics to this file. 可以添加 webfonts, meta tags, or analytics 到这个文件 The build step will place the bundled scripts into the &lt;body&gt; tag. 构建好的内容将会导入 &lt;div id=\"root\"&gt;&lt;/div&gt; 这里面 To begin the development, run `npm start` or `yarn start`. 可以运行 `npm start` or `yarn start` 来运行,pnpm start 也行 To create a production bundle, use `npm run build` or `yarn build`. 使用 `npm run build` or `yarn build` 打包 --&gt; &lt;/body&gt;&lt;/html&gt; 5.4 src/上面这个里是创建时产生的结构，但是我们的 项目页面肯定是不少的，文件多了，都放在一个页面是很难看的。根据自己项目的结构需要调整。webpack 只能编译 src/ 目录下的代码，如果在 src/ 下导入了 src/ 目录之外的文件（除了npm 包），则 webpack 会报错；这样做的目的是为了减少由于路径书写错导而导致的错误；如果一定要导入 src/ 外的 非 npm 包 文件，则可以在 /config/paths.js 文件中的 allowedFilesOutOfSrc 属性 中添加需要包含的 src 外部非 npm 包文件 的路径； 项目结构的核心思想因为代码的相关性主要与业务功能有关，而与文件类型的关系不大，所以，为了便于 编写、查阅、理解 代码，项目结构遵循以下核心宗指（宗指属于思想）： 以业务功能为单位组织项目结构； 以低耦合度为目标划分模块职责和逻辑； 优点： 业务功能模块的相关代码都集中在一块，方便移动和删除； 实现了关注点分离，方便开发、调试、维护、编写、查阅、理解代码； src目录结构 搭建的项目中 src 的目录结构修改如下。src的目录结构将以业务功能划分 12345678910111213141516171819202122src/├── app/ # 存放项目业务代码│ ├── App.css│ ├── App.js # 根组件，路由也在这里写│ └── App.test.js│├──assets/ # 存放项目共用的代码以外的资源，如：图片、图标、视频 等；│ ├── logo.svg│ ├── constant.less # 存放 Less 的常量；如果是 scss 就是 scss 常量│ └── constant.js # 存放 js 的常量；│├── component/ # 组件│ ├──│ └──│├── views/ # 页面│ ├──│ └──│├── index.css # 全局 css 样式├── index.js # webpack 的入口文件；└── serviceWorker.js 4.3 src/index.js 插入 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 中的 JSX 拓展语言代码组件123456789101112import React from 'react';// 导入 react.jsimport ReactDOM from 'react-dom';// 导入 react-domimport './index.css';//导入 index 对应的 css 文件import App from './App';// 导入 app 组件 路径需要响应的修改！！！！！！！！！！！！！！！！！！import * as serviceWorker from './serviceWorker';//导入服务器ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// 将 app 组件渲染到 html 中// If you want your app to work offline and load faster, you can change如果您希望您的应用脱机工作并加载更快，您可以更改// unregister() to register() below. Note this comes with some pitfalls.取消注册（）以注册（）如下。 请注意，这带来了一些陷阱。// Learn more about service workers: http://bit.ly/CRA-PWA了解有关服务工作者的更多信息：http：//bit.ly/CRA-PWAserviceWorker.unregister();// 脱机工作 4.4 src/index.css 全局样式 body，一些页面初始化的样式可以在这里写1234567891011121314body &#123; margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;code &#123; font-family: source-code-pro, Menlo, Monaco, Consolas, \"Courier New\", monospace;&#125; 4.5 src/App.js App.css 组件 app 与 其对应的 css 样式12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react';// 为什么导入的是 &#123; Component &#125;import logo from './logo.svg';// 导入 图片 路径需要响应的修改！！！！！！！！！！！！！！！！！！import './App.css';//导入 css 文件class App extends Component &#123; // 这里创建组件，怎么又变成 Component 了，不是 React.Component 的么，因为 ES6 的解构赋值 render() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App; 1234567891011121314151617181920212223242526272829303132.App &#123; text-align: center;&#125;.App-logo &#123; animation: App-logo-spin infinite 20s linear; /* 动画 */ height: 40vmin;&#125;.App-header &#123; background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white;&#125;.App-link &#123; color: #61dafb;&#125;@keyframes App-logo-spin &#123;/*animation 的关键帧 */ from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125; 4.6 src/serviceWorker.js 服务器配置文件，网络代理服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135// This optional code is used to register a service worker.// register() is not called by default.// This lets the app load faster on subsequent visits in production, and gives// it offline capabilities. However, it also means that developers (and users)// will only see deployed updates on subsequent visits to a page, after all the// existing tabs open on the page have been closed, since previously cached// resources are updated in the background.// To learn more about the benefits of this model and instructions on how to// opt-in, read http://bit.ly/CRA-PWAconst isLocalhost = Boolean( window.location.hostname === 'localhost' || // [::1] is the IPv6 localhost address. window.location.hostname === '[::1]' || // 127.0.0.1/8 is considered localhost for IPv4. window.location.hostname.match( /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))&#123;3&#125;$/ ));export function register(config) &#123; if (process.env.NODE_ENV === 'production' &amp;&amp; 'serviceWorker' in navigator) &#123; // The URL constructor is available in all browsers that support SW. const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href); if (publicUrl.origin !== window.location.origin) &#123; // Our service worker won't work if PUBLIC_URL is on a different origin // from what our page is served on. This might happen if a CDN is used to // serve assets; see https://github.com/facebook/create-react-app/issues/2374 return; &#125; window.addEventListener('load', () =&gt; &#123; const swUrl = `$&#123;process.env.PUBLIC_URL&#125;/service-worker.js`; if (isLocalhost) &#123; // This is running on localhost. Let's check if a service worker still exists or not. checkValidServiceWorker(swUrl, config); // Add some additional logging to localhost, pointing developers to the // service worker/PWA documentation. navigator.serviceWorker.ready.then(() =&gt; &#123; console.log( 'This web app is being served cache-first by a service ' + 'worker. To learn more, visit http://bit.ly/CRA-PWA' ); &#125;); &#125; else &#123; // Is not localhost. Just register service worker registerValidSW(swUrl, config); &#125; &#125;); &#125;&#125;function registerValidSW(swUrl, config) &#123; navigator.serviceWorker .register(swUrl) .then(registration =&gt; &#123; registration.onupdatefound = () =&gt; &#123; const installingWorker = registration.installing; if (installingWorker == null) &#123; return; &#125; installingWorker.onstatechange = () =&gt; &#123; if (installingWorker.state === 'installed') &#123; if (navigator.serviceWorker.controller) &#123; // At this point, the updated precached content has been fetched, // but the previous service worker will still serve the older // content until all client tabs are closed. console.log( 'New content is available and will be used when all ' + 'tabs for this page are closed. See http://bit.ly/CRA-PWA.' ); // Execute callback if (config &amp;&amp; config.onUpdate) &#123; config.onUpdate(registration); &#125; &#125; else &#123; // At this point, everything has been precached. // It's the perfect time to display a // \"Content is cached for offline use.\" message. console.log('Content is cached for offline use.'); // Execute callback if (config &amp;&amp; config.onSuccess) &#123; config.onSuccess(registration); &#125; &#125; &#125; &#125;; &#125;; &#125;) .catch(error =&gt; &#123; console.error('Error during service worker registration:', error); &#125;);&#125;function checkValidServiceWorker(swUrl, config) &#123; // Check if the service worker can be found. If it can't reload the page. fetch(swUrl) .then(response =&gt; &#123; // Ensure service worker exists, and that we really are getting a JS file. const contentType = response.headers.get('content-type'); if ( response.status === 404 || (contentType != null &amp;&amp; contentType.indexOf('javascript') === -1) ) &#123; // No service worker found. Probably a different app. Reload the page. navigator.serviceWorker.ready.then(registration =&gt; &#123; registration.unregister().then(() =&gt; &#123; window.location.reload(); &#125;); &#125;); &#125; else &#123; // Service worker found. Proceed as normal. registerValidSW(swUrl, config); &#125; &#125;) .catch(() =&gt; &#123; console.log( 'No internet connection found. App is running in offline mode.' ); &#125;);&#125;export function unregister() &#123; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.ready.then(registration =&gt; &#123; registration.unregister(); &#125;); &#125;&#125; 4.6.1 service worker 介绍可以实现消息推动、地理围栏、离线应用等功能，相当于在浏览器端建立了一个代理服务，实现一些现在看来逆天的功能。 这个是用来做离线缓存的新的 api 实现。其工作原理是 缓存同源路径下的请求，相当于是在前端与后端数据中加了一个缓存层，使得在离线状态下也能够正常访问部分页面。 ，访问中之所以报错，可能是你以本地 (localhost) 等方式打开，并非是在打包中制定的域名下。 目前原生 App 跟 HTML5 相比具有如下优势:富离线体验、消息推送、定时默认更行等功能，这些优势决定了 HTML5 无法取代 native。service worker(后面简称 sw )，就是在这样的背景下提出来的。 sw 是一段运行在浏览器 后端的脚本，独立于页面，是一个 worker，也可以理解为一个 网络代理服务器。因此 sw 是无法与 DOM 进行交互的，但是可以与 js 主线程进行通信。 4.6.2 service worker 实现的功能目前 sw 还是一个草案(现在应该不是了吧，脚手架都用了，)，各个浏览器支持程度还不是很高，除了 chrome 40、firefox 以外，其他浏览器均不支持该功能，但是 sw 提供的逆天功能还是非常值得期待: 后台数据的同步 从其他域获取资源请求 接受计算密集型数据的更新，多页面共享该数据 客户端编译与依赖管理 后端服务的 hook 机制 根据 URL 模式，自定义模板 性能优化 消息推送 定时默认更新 地理围栏 其中最期待的还是通过 HTTP 请求的拦截，进而实现离线应用，提升页面的性能体验。 4.6.3 简单使用12345678910111213141516171819202122232425262728293031323334353637383940//a. 首先在页面注册一个service workerif ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('./index.js').then((reg) =&gt; &#123; console.log('register a service worker: ', reg) &#125;).catch((err) =&gt; &#123; console.log('err: ', err); &#125;);&#125;//b. 接着就可以在Service worker中尽情畅想//以页面的离线应用为出发点，说明sw如实做到离线应用的。const cacheUrl = [ '/base.css', '/france.html'];const cacheName = 'my-site-cache';// install阶段self.addEventListener('install', (event) =&gt; &#123; console.log('sw event: install'); event.waitUntil( caches.open(cacheName).then((cache) =&gt; &#123; console.log('open cache'); return cache.addAll(cacheUrl); &#125;) );&#125;);self.addEventListener('fetch', (event) =&gt; &#123; event.respondWith(caches.match(event.request).then(res =&gt; &#123; if (res) &#123; console.log('match'); return res; &#125; return fetch(event.request); &#125;));&#125;); 4.6.4 生命周期sw（ service worker ） 的说明周期主要包括三个阶段: install、active、working。下面这张图说明各个阶段完成的工作: 4.6.5 事件机制sw （ service worker ）本质上也是一个 worker，所以 sw 开发也是建立在事件的基础上，通过事件机制完成相关业务逻辑的处理。其中 sw （ service worker ）里面的事件在原始事件对象 EVENT,进行了拓展，例如 fetch event 里面拥有 respondWith、waitUtil 方法。 4.6.6 补充介绍: Cache APIcache api 就是对 http 的 request/response 进行缓存管理，是在 service worker 的规范中定义的，往往跟 service worker 一起操作使用，是实现 web app 离线应用的关键一环。但是 cache api 又不依赖于 service worker，可以单独在 window 下使用，。 在 window 对象下，cache api 的操作封装在 caches 对象下面，里面的操作分为两类: 对 cache 的操作、对 cache 里面 http 的操作。下面简单说明下 cache storage 的相关操作: 123456789101112131415161718192021222324252627282930313233343536373839// 下面是对cache的相关操作// open: 创建或打开一个cachecaches.open('test').then(cache =&gt; &#123; return cache.add('/base.css')&#125;).then((val) =&gt; &#123; console.log('create a cache and add \"base.css\" to it');&#125;);// 在cache storage查找缓存的资源caches.match('/base.css').then(res =&gt; &#123; if (!res) return 'can not find this http in caches storage'; return res.text()&#125;).then((result) =&gt; &#123; console.log(result)&#125;);// 得到所有的cachecaches.keys().then(name =&gt; &#123; console.log('names: ', name)&#125;);// 得到某个cachecaches.delete('test').then(val =&gt; &#123; console.log('delete success?: ', val)&#125;);// 对cache里面http进行操作caches.open('test').then(cache =&gt; &#123; // 添加缓存资源 return cache.add('/base.css')&#125;).then((val) =&gt; &#123; console.log('create a cache and add \"base.css\" to it');&#125;);caches.open('test').then(cache =&gt; &#123; // 资源匹配 return cache.match('/base.css')&#125;).then(res =&gt; &#123; return res.text()&#125;).then(str =&gt; &#123; console.log(str)&#125;); 4.7 src/App.test.js 测试文件关于测试可以学习T,当运行 npm run test, Jest 会以 watch 模式启动。每次你保存一个文件，它都会重新运行测试，就像 npm start 重新编译代码一样。 123456789import React from 'react';import ReactDOM from 'react-dom';import App from './App';it('renders without crashing', () =&gt; &#123;// 渲染没有崩溃 const div = document.createElement('div'); ReactDOM.render(&lt;App /&gt;, div);//？？？？？？？？？？？？？ ReactDOM.unmountComponentAtNode(div);// 、？？？？？？？？？？？？？？？？？？？&#125;); 4.8 package.json12345678910111213141516171819202122232425&#123; \"name\": \"todo\", \"version\": \"0.1.0\", \"private\": true, \"dependencies\": &#123; \"react\": \"^16.7.0\", \"react-dom\": \"^16.7.0\", \"react-scripts\": \"2.1.2\" &#125;, \"scripts\": &#123; \"start\": \"react-scripts start\", // 开发环境运行,默认监听 3000 端口 \"build\": \"react-scripts build\",// 生产环境运行，进行项目打包，默认打包到 build 目录 \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\" &#125;, \"eslintConfig\": &#123; \"extends\": \"react-app\" &#125;, \"browserslist\": [ \"&gt;0.2%\", \"not dead\", \"not ie &lt;= 11\", \"not op_mini all\" ]&#125; 六、自己添加的框架思想!!!!!!!!!!!!!!!!!!!!!!!!!!官网网址 12345678910111213141516//按照文件类型来分组,类似这样api/ APIUtils.js APIUtils.test.js ProfileAPI.js UserAPI.jscomponents/ Avatar.js Avatar.css Feed.js Feed.css FeedStory.js FeedStory.test.js Profile.js ProfileHeader.js ProfileHeader.css 避免太多嵌套，不要分太细！文件夹太多，总是 import 不好！ 不要过度思考这个问题，重要的是代码做出东西来！ 例如下面是完整的框架 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960|-- build/ #存放项目被webpack处理后生成的文件；||-- config/ # webpack 配置文件，存放的是项目的配置文件；| |-- jest/| | |-- cssTransform.js| | |-- fileTransform.js| || |-- env.js| |-- paths.js| |-- webpack.config.js| |-- webpackDevServer.config.js||-- node_modules/ # 依赖包，存放 npm 安装的工具包 或 模块||-- public # 静态资源，该目录下的文件不会被webpack处理，它们会被拷贝到 build/ 文件夹下| |-- favicon.ico # 网站图片标识| |-- index.html # 页面模板：一切的开始都从这里开始，所以这个是代码执行的源头| |-- manifest.json # 指定了开始页面为 index.html。||-- scripts # 运行配置，与项目的构建、打包 或 服务 相关的脚本| |-- build.js #| |-- start.js #| |-- test.js #|# |-- src/ # src 目录下的文件才会被 webpack 打包，所以要把 js、css 文件放在 src 目录下，项目的源代码及资源# | |-- App.css# | |-- App.js# | |-- App.test.js# | |-- index.css# | |-- index.js # 入口文件# | |-- logo.svg# | |-- serviceWorker.js# 实际代码中会去修改这个文件夹下的结构，├── src/│ ├──app/ # 存放项目业务代码│ │ ├── App.css│ │ ├── App.js # 根组件，路由也在这里写，或者是在外面写，在这里导入│ │ └── App.test.js│ ││ ├──assets/ # 存放项目共用的代码以外的资源，如：图片、图标、视频 等；│ │ ├── logo.svg│ │ ├── constant.less # 存放 Less 的常量；如果是 scss 就是 scss 常量│ │ ├── index.css # 全局 css 样式│ │ └── constant.js # 存放 js 的常量；│ ││ ├── component/ # 组件│ │ ├──│ │ └──│ ││ ├── views/ # 页面│ │ ├──pagesA/│ │ └──pagesB/│ ││ ├── index.js # webpack 的入口文件；│ └── serviceWorker.js||-- .gitignore # git 上传需要忽略的文件格式|-- package.json # 项目基本信息|-- README.md # 项目说明|-- yarn.lock # 明确 安装包的具体版本 注意修改了项目结构目录之后，不要忘记修改其中文件的路径!!!!!!!!!!!!!!!!!否则会运行错误哦！！！！！！！！！！！！！！！！","tags":[]},{"title":"vue-cli3--[小白入门篇、速学篇]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }- vue-cli3 脚手架/","text":"一、前言前面都是使用 vue-cli1 来搭建的项目，其实现在已经是 vue-cli3 了，而且现在使用的也比较广泛了。 vue-cli3 官网 二、安装 vue-cli3123456789101112131415# -g 是 --global 的简写# -v 是 --version 的简写# -S 是 --save 的简写# -D 是 --dev 的简写$ npm install -g @vue/cli# OR$ cnpm install -g @vue/cli# OR$ yarn global add @vue/cli # 当然这个需要先安装 yarn# 安装之后，就可以在命令行中访问 vue 命令。$ vue --version # 查看 vue-cli 的版本 三、使用 vue-cli3 搭建项目可以参考网上的教程来做 命令行搭建 ui 交互式搭建 3.1 命令行搭建项目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 需要需要的是 ts 版的项目，那么首先要确保电脑安装有 ts$ npm install -g typescript # 首先需要安装有 ts,需要电脑已经存在 ts 就需要再安装了$ tsc -v 查看ts的版本号$ vue create my-app # my-app 是项目名称# 运行上面的命令之后出现下面的选择，# Vue CLI v3.2.1# ? Please pick a preset: (Use arrow keys) 请使用 【向下键】 来选择一个预置方式# &gt; default (babel, eslint) 默认的预置方式 (babel, eslint) 也就是说只有这 2 个插件，直接回车 enter 的话就默认为这个选项# Manually select features 手动选择功能（这里就可以选择为 ts 版本）# 使用 【向下键】 来选择一个预置方式,三角箭头指向那个就是那个# 手动选择：按住 空格键来选择，按住 a 键 代表选择全部， i 键表示反选# ? Check the features needed for your project: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)# (*) Babel 编译器 ES6-ES5# &gt;( ) TypeScript 拓展 TS# ( ) Progressive Web App (PWA) Support [渐进式网页应用](https://juejin.im/post/5a6c86e451882573505174e7)# ( ) Router 路由# ( ) Vuex 状态管理器# ( ) CSS Pre-processors CSS 预处理器，例如 scss，less，Stylus 等等# (*) Linter / Formatter# ( ) Unit Testing 测试单元# ( ) E2E Testing 测试单元# 上面可以选择 css 预处理器，但是貌似没有做好啊！！！！！！！！！！！！！node-scss 老是出 bug！！！！！！！！！！！！！！！！！！！# 可以看出上面已经可以选择安装很多东西了， Router 路由， Vuex 状态管理器，scss 等，这些都可以不需要额外的安装了。如果之前没有选择安装的话也可以现在安装这些个插件 ，使用的是 `yarn add` 命令，当然也可以使用 ui 界面来搜索添加组件$ yarn add router # 创建项目的时候已经安装了其实，如果没有安装，后面需要用到就这样安装$ yarn add vuex # 创建项目的时候已经 选择安装了其实，如果没有安装，后面需要用到就这样安装$ vue add router # 官网还这样来添加，是什么骚操作$ vue add vuex # 官网还这样来添加，是什么骚操作$ yarn add element-ui # 下载饿了么 ui 框架，这个框架是 PC 端的$ yarn add iview # 下载 iview 这个 ui 框架，框架都是选择的，选择其一即可。$ cnpm install axios # 下载前后端数据交互应用$ yarn add axios # 使用 yarn$ npm install normalize.css # 浏览器兼容 css 文件$ npm i v-charts echarts -S # 图表 ui 组件库$ npm install --save dayjs # 日期时间处理，dayjs 库$ yarn serve # 开启服务，运行$ yarn build # 打包$ yarn lint # 执行lint$ yarn test:unit # 执行单元测试 3.1.1 CSS 预处理器12345#vue-cli3 本身就支持 PostCSS、CSS Modules 和包含 Sass、Less、Stylus 在内的预处理器。在搭建项目的时候就可以选择是否需要安装了。# 如果之前没有安装，现在安装就好了npm install -D sass-loader node-sass # Sassnpm install -D less-loader less # Lessnpm install -D stylus-loader stylus # Stylus 123&lt;style lang=\"scss\"&gt;$color: red;&lt;/style&gt; 3.1.2 可以执行的命令12345678910111213141516$ vue create --help # 用这个帮助查看可执行的命令Usage: create [options] &lt;app-name&gt;create a new project powered by vue-cli-serviceOptions: -p, --preset &lt;presetName&gt; Skip prompts and use saved or remote preset -d, --default Skip prompts and use default preset -i, --inlinePreset &lt;json&gt; Skip prompts and use inline JSON string as preset -m, --packageManager &lt;command&gt; Use specified npm client when installing dependencies -r, --registry &lt;url&gt; Use specified npm registry when installing dependencies (only for npm) -g, --git [message] Force git initialization with initial commit message -n, --no-git Skip git initialization -f, --force Overwrite target directory if it exists -c, --clone Use git clone when fetching remote preset -x, --proxy Use specified proxy when creating project -b, --bare Scaffold project without beginner instructions -h, --help output usage information 3.2 ui 交互式界面搭建项目12$ vue-ui # 在浏览器打开一个页面# 在打开的界面鼠标操作来搭建项目 四、项目结构4.1 JS 的项目结构1234567891011121314151617181920212223242526272829.|-- node_modules # 依赖包||-- public # 存放静态文件| |-- favicon.ico # 网站图标| |-- index.html # 入口文件，是一个会被 html-webpack-plugin 处理的模板。在构建过程中，资源链接会被自动注入。||-- src # 源码目录，存放 vue 项目工程文件| |-- assets/ # 静态源码文件| |-- components/ # 公共组件| |-- views/ # 页面组件| |-- App.vue # 页面入口文件| |-- main.js # 程序入口文件，加载各种公共组件| |-- router.js # 路由文件| |-- store.js # vuex 的状态管理| |-- interceptor.js # 自己创建的拦截器||-- .browserslistrc # 指定了项目的目标浏览器的范围，| # 这个值会被 @babel/preset-env 和 Autoprefixer 用来确定| # 需要转译的 JavaScript 特性 和 需要添加的 CSS 浏览器前缀。|-- .eslintrc.js # 这个文件在 cli3 中也是没有的 ，webpack 被封装了，eslint设置也在 package.json 文件夹里面了| # 其他的信息还是像 cli1 版本那样可以设置的选项都在。|-- .gitignore # git 上传需要忽略的文件格式|-- babel.config.js # ES6 语法编译配置|-- package.json # 项目基本信息|-- postcss.config.js # css 预处理器配置|-- README.md # 项目说明|-- vue.config.js # webpack 配置文件（手动创建的：https://segmentfault.com/a/1190000016101954）|-- yarn.lock # 版本限制 4.2 TS 的项目结构12345678910111213141516171819202122232425262728.|-- node_modules # 依赖包||-- public # 存放静态文件| |-- favicon.ico # 网站图标| |-- index.html # 入口文件，这个文件夹下的文件不会纳入webpack的打包中||-- src # 源码目录，存放 vue 项目工程文件| |-- assets/ # 静态源码文件| |-- components/ # 公共组件| |-- views/ # 页面组件| |-- App.vue # 页面入口文件| |-- main.ts # 程序入口文件，加载各种公共组件| |-- router.ts # 路由文件| |-- shims-tsx.d.ts| |-- shims-vue.d.ts| |-- store.ts # vuex 的状态管理| |-- interceptor.ts # 自己创建的拦截器||-- .browserslistrc|-- .gitignore # git 上传需要忽略的文件格式|-- package.json # 项目基本信息|-- postcss.config.js # css 预处理器配置|-- README.md # 项目说明|-- tsconfig.json # 语法编译配置|-- tslint.json # eslint 的限制|-- vue.config.js # webpack 配置文件（手动创建的：https://segmentfault.com/a/1190000016101954）|-- yarn.lock # 版本限制 4.3 public —-HTML 和静态资源public/index.html 文件是一个会被 html-webpack-plugin 处理的模板。在构建过程中，资源链接会被自动注入。另外，Vue CLI 也会自动注入 resource hint (preload/prefetch、manifest 和图标链接 (当用到 PWA 插件时) 以及构建过程中处理的 JavaScript 和 CSS 文件的资源链接。 4.3.1 public/index.html123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt; &lt;!-- 插值：https://cli.vuejs.org/zh/guide/html-and-static-assets.html#prefetch --&gt; &lt;title&gt;todo-&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; &lt;strong&gt;We're sorry but todo- doesn't work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt; &lt;/noscript&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 4.4 src/router.js4.6 babel.config.js123456789101112//babel.config.jsmodule.exports = &#123; presets: [ // 这里一定要给自己看仔细了，是好多对括号！漏了就没法编译，没法编译，yarn serve 肯定就会错啦！！！！！！！！！！！！！！！！ ['@vue/app', &#123; polyfills: [ 'es6.promise', 'es6.symbol' ] &#125;] ]&#125; 4.7 vue.config.js 手动创建的配置文件由于 vue-cli 3 也学习了 rollup 的零配置思路，所以项目初始化后，没有了以前熟悉的 build 目录，也就没有了 webpack.base.config.js、webpack.dev.config.js 、webpack.prod.config.js 等配置文件。 其实这一切都是因为 vue-cli3 的项目初始化，帮开发者已经解决了 80% ，甚至绝大部分情形下的 webpack 配置。在实际开发过程中，肯定还有需要自己去修改配置的地方，就需要在项目根目录下手动新建一个 vue.config.js 官网设置参考掘金配置采坑总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// vue.config.jsmodule.exports = &#123; //① 设置 baseUrl 选项 baseUrl: process.env.NODE_ENV === 'production' ? '/production-sub-path/' //开发服务器架设在根路径 : '/', outputDir: 'dist', // 默认值 dist 设置 打包生成的目录 assetsDir: 'static', //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 indexPath: 'index.html', filenameHashing: true, //hash 以便更好的控制缓存 pages: &#123; index: &#123; entry: 'src/index/main.js',// page 的入口 template: 'public/index.html',// 模板来源 filename: 'index.html',// 在 dist/index.html 的输出 // 当使用 title 选项时， title: 'Index Page',// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; chunks: ['chunk-vendors', 'chunk-common', 'index']// 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 &#125;, // 当使用只有入口的字符串格式时， // 模板会被推导为 `public/subpage.html` // 并且如果找不到的话，就回退到 `public/index.html`。 // 输出文件名会被推导为 `subpage.html`。 subpage: 'src/subpage/main.js' &#125;, lintOnSave: true, // 默认值为 true，// eslint-loader 是否在保存的时候检查 //lintOnSave: process.env.NODE_ENV !== 'production' 在生产构建时禁用 eslint-loader runtimeCompiler: false,// 默认值 false, 是否使用包含运行时编译器的 Vue 核心的构建 transpileDependencies: [],//默认值 [], 默认情况下 babel-loader 忽略其中的所有文件 node_modules productionSourceMap: true,//默认值为 true，细粒话构建 crossorigin: undefined,//默认值为 undefined integrity: false, //Type: Object | Function configureWebpack: (config) =&gt; &#123; // 简单/基础配置，比如引入一个新插件 &#125;, //Type: Object | Function chainWebpack: config =&gt; &#123; config.plugins.delete('prefetch')// 移除 prefetch 插件 // 或者 // 修改它的选项： config.plugin('prefetch').tap(options =&gt; &#123; options[0].fileBlacklist = options[0].fileBlacklist || [] options[0].fileBlacklist.push(/myasyncRoute(.)+?\\.js$/) return options &#125;) //调整内联文件的大小限制。例如，下列代码会将其限制设置为 10kb： config.module .rule('images') .use('url-loader') .loader('url-loader') .tap(options =&gt; Object.assign(options, &#123; limit: 10240 &#125;)) &#125;, // 对组件中 css 的配置 css: &#123; modules: true,//默认值 false extract: false,//默认生产环境下是 true，开发环境下是 false sourceMap: false, loaderOptions: &#123; css: &#123; // 这里的选项会传递给 css-loader &#125;, postcss: &#123; // 这里的选项会传递给 postcss-loader &#125;, scss: &#123; // @/ 是 src/ 的别名 // 所以这里假设你有 `src/variables.scss` 这个文件,可以这样向所有 Sass 样式传入共享的全局变量 data: `@import \"@/variables.scss\";` &#125;, less: &#123; // &#125;, stylus: &#123; // &#125; &#125; &#125;, devServer: &#123; // 对开发服务的设置 Various Dev Server settings proxy: 'http://localhost:4000',//指向开发环境 API 服务器的字符串 //proxy: &#123; // '/api': &#123; // target: '&lt;url&gt;', // ws: true, // changeOrigin: true // &#125;, // '/foo': &#123; // target: '&lt;other_url&gt;' // &#125; //&#125; host: '0.0.0.0', process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined open: true, // 自动调用默认浏览器打开 https: false // 是否使用https, https使用node的一个内部默认的ca证书 &#125;, parallel: require('os').cpus().length &gt; 1, pwa: &#123; // &#125;, pluginOptions: &#123; foo: &#123; // 插件可以作为 `options.pluginOptions.foo` 访问这些选项。 &#125; &#125;&#125; 六、插件 和 Preset6.1 插件插件一些重要的插件可以在 vue create my-app 的时候就手动选择安装了，有的后续安装 vue add xxxx，或者是 vue ui 界面去安装。 6.2 preset 预设置Presetvue create 的时候回有很多 yes/no 的选择就是 Preset，其实它还在 home 目录生成了一个 .vuerc 文件，通过直接编辑这个文件来调整、添加、删除保存好的 preset。下次创建项目就会默认按照这个配置来了。 6.2.1 预设置 文件Preset 的数据会被插件生成器用来生成相应的项目文件 1234567891011121314151617181920212223242526272829// 对于官方插件来说 下面的配置 不是必须的——当被忽略时，CLI 会自动使用 registry 中最新的版本。// 不过我们推荐为 preset 列出的所有第三方插件提供显式的版本范围。&#123; \"useTaobaoRegistry\": false,//默认是为 true 的，因为 vue create 出错所以这里改为 false \"packageManager\": \"yarn\",//默认是 yarn 的，可以改成其他的，但是算了吧，这个是默认配置啊!!!! \"presets\": &#123; \"vue-cli3-preset\": &#123; \"useConfigFiles\": true,//被合并到 package.json 或相应的配置文件中 \"configs\": &#123; \"vue\": &#123;&#125;, \"postcss\": &#123;&#125;, \"eslintConfig\": &#123;&#125;, \"jest\": &#123;&#125; &#125;, \"plugins\": &#123; \"@vue/cli-plugin-babel\": &#123;&#125;, \"@vue/cli-plugin-eslint\": &#123; \"version\": \"^3.0.0\",// 插件的版本管理 \"config\": \"airbnb\", \"lintOn\": [\"save\", \"commit\"], &#125; &#125;, \"router\": true, \"routerHistoryMode\": true, \"vuex\": true, \"cssPreprocessor\": \"sass\"// css 预处理器 scss 比 less 还是其他都好，就默认这个好了 &#125; &#125;&#125; 十、一些 bug ，安装过程 、使用遇到的问题5.1 ERROR command failed: yarn –registry=https://registry.npm.taobao.org –disturl=https://npm.taobao.org/dist创建了一个 ts 版的没有问题，但是再创建一个 js 版的项目就出现了这个问题。所以是什么鬼问题，具体？？？？ 这个问题 gitHub 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# ts 版λ vue create hello-world-ts-Vue CLI v3.2.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, TS, Router, Vuex, CSS Pre-processors, Linter? Use class-style component syntax? Yes? Use Babel alongside TypeScript for auto-detected polyfills? No? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS? Pick a linter / formatter config: TSLint? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)Lint on save? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? NoVue CLI v3.2.1✨ Creating project in F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-ts-.� Initializing git repository...⚙ Installing CLI plugins. This might take a while...yarn install v1.12.3info No lockfile found.[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...[4/4] Building fresh packages...success Saved lockfile.Done in 33.88s.� Invoking generators...� Installing additional dependencies...yarn install v1.12.3[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...[4/4] Building fresh packages...success Saved lockfile.Done in 47.62s.⚓ Running completion hooks...� Generating README.md...� Successfully created project hello-world-ts-.� Get started with the following commands: $ cd hello-world-ts- $ yarn serve 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# js 版λ vue create hello-world-jsVue CLI v3.2.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) Yes? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Sass/SCSS? Pick a linter / formatter config: Basic? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)Lint on save? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? NoVue CLI v3.2.1✨ Creating project in F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js.� Initializing git repository...⚙ Installing CLI plugins. This might take a while...yarn install v1.12.3info No lockfile found.[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4][###########################################################################################################################################################] 1020/1020 Linking dependencies...[4/4] Building fresh packages...success Saved lockfile.Done in 44.86s.� Invoking generators...� Installing additional dependencies...yarn install v1.12.3[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...[4/4] Building fresh packages...`infoerror Visit F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\node-sass: Command failed.`# 这句就爆红了，不知道是什么错误，为什么 ts 版本的就没有这个错误Exit code: 1`Command: node scripts/build.js`https://yarnpkg.com/en/docs/cli/installArguments:Directory: F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\node-sassOutput:Building: C:\\Program Files\\nodejs\\node.exe F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\node-gyp\\bin\\node-gyp.js rebuild --verbose --libsass_ext= for documentation about this command.--libsass_cflags= --libsass_ldflags= --libsass_library=gyp info it worked if it ends with okgyp verb cli [ 'C:\\\\Program Files\\\\nodejs\\\\node.exe',gyp verb cli 'F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js',gyp verb cli 'rebuild',gyp verb cli '--verbose',gyp verb cli '--libsass_ext=',gyp verb cli '--libsass_cflags=',gyp verb cli '--libsass_ldflags=',gyp verb cli '--libsass_library=' ]gyp info using node-gyp@3.8.0gyp info using node@8.11.3 | win32 | x64gyp verb command rebuild []gyp verb command clean []gyp verb clean removing \"build\" directorygyp verb command configure []gyp verb check python checking for Python executable \"python2\" in the PATHgyp verb `which` failed Error: not found: python2gyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed python2 &#123; Error: not found: python2gyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed stack: 'Error: not found: python2\\n at getNotFoundError (F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:13:12)\\n at F (F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:68:19)\\n at E (F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:80:29)\\n at F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:89:16\\nat F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\isexe\\\\index.js:42:5\\n at F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\isexe\\\\windows.js:36:5\\n at FSReqWrap.oncomplete (fs.js:152:21)',gyp verb `which` failed code: 'ENOENT' &#125;gyp verb check python checking for Python executable \"python\" in the PATHgyp verb `which` failed Error: not found: pythongyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed python &#123; Error: not found: pythongyp verb `which` failed at getNotFoundError (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:13:12)gyp verb `which` failed at F (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:68:19)gyp verb `which` failed at E (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:80:29)gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\which\\which.js:89:16gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\index.js:42:5gyp verb `which` failed at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\isexe\\windows.js:36:5gyp verb `which` failed at FSReqWrap.oncomplete (fs.js:152:21)gyp verb `which` failed stack: 'Error: not found: python\\n at getNotFoundError (F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:13:12)\\n at F (F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:68:19)\\n at E (F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:80:29)\\n at F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\which\\\\which.js:89:16\\n at F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\isexe\\\\index.js:42:5\\n at F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\isexe\\\\windows.js:36:5\\n at FSReqWrap.oncomplete (fs.js:152:21)',gyp verb `which` failed code: 'ENOENT' &#125;gyp verb could not find \"python\". checking python launchergyp verb could not find \"python\". guessing locationgyp verb ensuring that file exists: C:\\Python27\\python.exegyp ERR! configure errorgyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable.gyp ERR! stack at PythonFinder.failNoPython (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\node-gyp\\lib\\configure.js:484:19)gyp ERR! stack at PythonFinder.&lt;anonymous&gt; (F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\node-gyp\\lib\\configure.js:509:16)gyp ERR! stack at F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\graceful-fs\\polyfills.js:282:31gyp ERR! stack at FSReqWrap.oncomplete (fs.js:152:21)gyp ERR! System Windows_NT 6.1.7601gyp ERR! command \"C:\\\\Program Files\\\\nodejs\\\\node.exe\" \"F:\\\\qianduan_dir\\\\00program\\\\web-vue-cli3\\\\hello-world-js\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js\" \"rebuild\" \"--verbose\" \"--libsass_ext=\" \"--libsass_cflags=\" \"--libsass_ldflags=\" \"--libsass_library=\"gyp ERR! cwd F:\\qianduan_dir\\00program\\web-vue-cli3\\hello-world-js\\node_modules\\node-sassgyp ERR! node -v v8.11.3gyp ERR! node-gyp -v v3.8.0gyp ERR! not okBuild failed with error code: 1ERROR command failed: yarn --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist 12345678910111213# 修改设置：setting the ~/.vuerc from \"useTaobaoRegistry\": true, to false.# 用户的根目录（home 目录：就是命令行打开的时候 C:\\Users\\Administrator 文件夹：window 系统）中出现了一个.vuerc 文件# &#123;# \"useTaobaoRegistry\": false,// 将原来的 true 修改为 false# \"packageManager\": \"yarn\"# &#125;# 或者重装 vue$ sudo npm uninstall -g vue$ sudo npm uninstall -g vue-cli$ sudo npm uninstall -g @vue/cli$ sudo npm cache clean --force$ sudo npm install -g vue$ sudo npm install -g @vue/cli 5.1 （yarn install 还原依赖错误）node-sass 的问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253liuxm@me ~/work/vue/freegit/code/freeui (develop)λ yarn installyarn install v1.13.0[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.7: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.7\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...warning \"@vue/cli-plugin-babel &gt; babel-loader@8.0.5\" has unmet peer dependency \"webpack@&gt;=2\".warning \"@vue/cli-plugin-eslint &gt; eslint-loader@2.1.1\" has unmet peer dependency \"webpack@&gt;=2.0.0 &lt;5.0.0\".warning \" &gt; sass-loader@7.1.0\" has unmet peer dependency \"webpack@^3.0.0 || ^4.0.0\".[4/4] Building fresh packages...[1/2] ⠄ yorkie`error C:\\Users\\liuxm\\work\\vue\\freegit\\code\\freeui\\node_modules\\node-sass: Command failed.` # node-sass 有错误：命令错误Exit code: 1`Command: node scripts/build.js` # 命令 node scripts/build.jsArguments:`Directory: C:\\Users\\liuxm\\work\\vue\\freegit\\code\\freeui\\node_modules\\node-sass` # 目录Output:Building: C:\\Program Files\\nodejs\\node.exe C:\\Users\\liuxm\\work\\vue\\freegit\\code\\freeui\\node_modules\\node-gyp\\bin\\node-gyp.js rebuild --verbose --libsass_ext= --libsass_cflags= --libsass_ldflags= --libsass_library=gyp info it worked if it ends with okgyp verb cli [ 'C:\\\\Program Files\\\\nodejs\\\\node.exe',gyp verb cli 'C:\\\\Users\\\\liuxm\\\\work\\\\vue\\\\freegit\\\\code\\\\freeui\\\\node_modules\\\\node-gyp\\\\bin\\\\node-gyp.js',.............................gyp ERR! node -v v10.15.0gyp ERR! node-gyp -v v3.8.0gyp ERR! not okBuild failed with error code: 1# 解决这个问题就是 删除 node_modal 文件夹，重新的还原依赖！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！# 其他的问题也是一样的，没有正确，就删除重装一下看看是不是网络问题没有下载好，重装一次试一下啦！！！！！！！！！！！！！！！！！！# 在下载来的项目中还原依赖，但是不成功，不知道是因为什么，删除 node_modal 文件之后，重新还原，居然已经出好的了。# 删除之后重新下载如下操作liuxm@me ~/work/vue/freegit/code/freeui (develop)λ yarn installyarn install v1.13.0[1/4] Resolving packages...info There appears to be trouble with your network connection. Retrying...info There appears to be trouble with your network connection. Retrying...info There appears to be trouble with your network connection. Retrying...[2/4] Fetching packages...info fsevents@1.2.7: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.7\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...warning \"@vue/cli-plugin-babel &gt; babel-loader@8.0.5\" has unmet peer dependency \"webpack@&gt;=2\".warning \"@vue/cli-plugin-eslint &gt; eslint-loader@2.1.1\" has unmet peer dependency \"webpack@&gt;=2.0.0 &lt;5.0.0\".warning \" &gt; sass-loader@7.1.0\" has unmet peer dependency \"webpack@^3.0.0 || ^4.0.0\".[4/4] Building fresh packages...success Saved lockfile.Done in 239.96s. 网上的一堆人都遇到这个问题，看不懂是什么鬼问题，下次遇到就直接删除重装就ok了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ githublaravel 5.2 npm install -g @vue/cli 的错误12345678910111213141516λ npm install -g @vue/clinpm WARN deprecated hoek@5.0.4: This version is no longer maintained. Please upgrade to the latest version.# $ npm install hoek@5.0.4 -gnpm WARN deprecated cross-spawn-async@2.2.5: cross-spawn no longer requires a build toolchain, use it instead# 不推荐使用 cross-spawn-async@2.2.5 模块，cross-spawn 而不再需要构建工具链。 应该使用它 cross-spawn 才是# $ npm install cross-spawn -gC:\\Users\\Administrator\\AppData\\Roaming\\npm\\vue -&gt; C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\@vue\\cli\\bin\\vue.js&gt; protobufjs@6.8.8 postinstall C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\@vue\\cli\\node_modules\\protobufjs&gt; node scripts/postinstall&gt; nodemon@1.18.9 postinstall C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\@vue\\cli\\node_modules\\nodemon&gt; node bin/postinstall || exit 0npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\@vue\\cli\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)# fsevents@1.2.4 是苹果电脑使用的，而不表示在 win 系统使用的，但是则呢删除呀？？？？每次都出现这个!!!!!!+ @vue/cli@3.2.1added 672 packages from 503 contributors in 201.079s 123456789101112# 产生的别的问题λ npm install hoek # 直接这样找不到 package.json 文件的npm WARN saveError ENOENT: no such file or directory, open 'F:\\qianduan_dir\\package.json'npm WARN enoent ENOENT: no such file or directory, open 'F:\\qianduan_dir\\package.json'npm WARN webpack-cli@3.1.2 requires a peer of webpack@^4.x.x but none is installed. You must install peer dependencies yourself.npm WARN qianduan_dir No descriptionnpm WARN qianduan_dir No repository field.npm WARN qianduan_dir No README datanpm WARN qianduan_dir No license field.# $ npm install hoek -g 改成这样全局# $ npm install cross-spawn -g 5.3 vue create app,~/.vuerc may be outdated. Please delete it and re-run vue-cli in manual mode.1234567ERROR ~/.vuerc may be outdated. Please delete it and re-run vue-cli in manual mode.# ~/.vuerc 文件失效，需要删除然后再 使用 vue-cli3 手动模式搭建项目。# 为啥会出现错误呢？？？就是在 home 目录修改之后就出错了，官方不是说可以自己修改么？？？？# 其实错在自己 vuerc 文件编辑错误，不是写法错误就是注释错误，总之就是错了，然后找不到文件。# 正确的配置参考 6.2.1 章节!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$ cat ~/.vuerc # 此命令可以查阅自己的 .vuerc 文件内容 5.4 λ yarn serve：Unknown option: .polyfills.运行不成功，首选看下是不是下载别人的项目，没有还原依赖啊 123456789101112131415161718192021222324yarn run v1.12.3$ vue-cli-service serve INFO Starting development server... 94% after seal ERROR Failed to compile with 1 errors 14:56:33 `error` in ./src/main.jsModule build failed (from ./node_modules/babel-loader/lib/index.js):`ReferenceError`: [BABEL] F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\src\\main.js: Unknown option: .polyfills. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options. # 这里已经说明了是 不明选项错误 at throwUnknownError (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\validation\\options.js:123:11) at Object.keys.forEach.key (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\validation\\options.js:107:5) at Array.forEach (&lt;anonymous&gt;) at validateNested (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\validation\\options.js:83:21) at validate (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\validation\\options.js:74:10) at instantiatePreset (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\full.js:244:36) at cachedFunction (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\caching.js:33:19) at loadPresetDescriptor (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\full.js:235:45) at config.presets.reduce (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\full.js:77:21) at Array.reduce (&lt;anonymous&gt;) at recurseDescriptors (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\full.js:74:38) at loadFullConfig (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\config\\full.js:108:6) at process.nextTick (F:\\qianduan_dir\\00program\\web-vue-cli3\\todo-\\node_modules\\@babel\\core\\lib\\transform.js:28:33) at _combinedTickCallback (internal/process/next_tick.js:131:7) at process._tickCallback (internal/process/next_tick.js:180:9) @ multi (webpack)-dev-server/client?http://192.168.2.103:8080/sockjs-node (webpack)/hot/dev-server.js ./src/main.js github,上面也有有遇到了一样的问题，都是粗心的人啊，还查了半天才知道是哪里错误了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 12345678910111213141516171819202122232425262728 //bable.config.js 文件 //这个文件写法不正确，难怪搞成了不正确的！！！！！！！！！！！！！！！！！！！！！！!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //不细心啊，还有就是命令行报错其实已经提示错误在哪里了!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // 还有就是 `ReferenceError` 这个会告诉我们错误的地方，不要总是看 `error` 的提示!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! module.exports = &#123; presets: [ '@vue/app'/* , &#123; polyfills: [ 'es6.promise', 'es6.symbol' ] &#125; */ ]&#125;//正确的写法module.exports = &#123; presets: [ ['@vue/app', &#123; polyfills: [ 'es6.promise', 'es6.symbol' ] &#125;] ]&#125; 5.5 webpack 的问题1234567891011liuxm@me ~/work/vue/freegit/code/freeui (import-iview-ui)λ yarn add iviewyarn add v1.13.0[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.7: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.7\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...`warning \"@vue/cli-plugin-babel &gt; babel-loader@8.0.5\" has unmet peer dependency \"webpack@&gt;=2\".``warning \"@vue/cli-plugin-eslint &gt; eslint-loader@2.1.1\" has unmet peer dependency \"webpack@&gt;=2.0.0 &lt;5.0.0\".``warning \" &gt; sass-loader@7.1.0\" has unmet peer dependency \"webpack@^3.0.0 || ^4.0.0\".` 问题： cli3 中 对 webpack 进行了封装，CLI 服务,上面的只是警告，不用理会，react 的 create-react-app 2.0 中好像也是这样的问题。 5.6 eslint 的问题在 cli3 中没有单独的 .eslint.js 文件了，它直接在 package.json 文件中去配置，具体的配置项目可以在 eslint 的文章去具体查看，eslint 文章 网站教程 123456789101112131415# package.json 文件 eslint 部分代码 ，\"eslintConfig\": &#123; \"root\": true, \"env\": &#123; \"node\": true &#125;, \"extends\": [ \"plugin:vue/essential\", \"eslint:recommended\" ], \"rules\": &#123;&#125;, \"parserOptions\": &#123; \"parser\": \"babel-eslint\" &#125; &#125;, 5.6.1 不使用 eslint如果不需要 eslint 的话，就直接注释删除掉这段代码，注意 json 文件也不能带注释的呢！！！！！否则会发生错误，而且如果错误没有提示原因的话，这个错误就很难发现了。 如果以后还会有机会想到使用 eslint 就不想删掉这个代码，那么就在 vue.config.js 中将以下三项设置为 false 1234567devServer: &#123; overlay: &#123; warnings: false, errors: false &#125;, lintOnSave: false &#125; 5.6.2 使用 eslint 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187\"rules\": &#123;&#125;,# 在这修改自己ID规则即可rules: &#123; \"规则名\": [规则值, 规则配置]&#125;规则值\"off\"或者0 //关闭规则关闭 0 无规则\"warn\"或者1 //在打开的规则作为警告（不影响退出代码） 1 不，不需要这样，可以这样也可以不这样\"error\"或者2 //把规则作为一个错误（退出代码触发时为1） 2 是的，就是这样，就是不允许这样其中的一些常见的配置\"no-alert\": 0,//禁止使用alert confirm prompt\"no-array-constructor\": 2,//禁止使用数组构造器\"no-bitwise\": 0,//禁止使用按位运算符\"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\"no-class-assign\": 2,//禁止给类赋值\"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\"no-console\": 2,//禁止使用console\"no-const-assign\": 2,//禁止修改const声明的变量\"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\"no-continue\": 0,//禁止使用continue\"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\"no-debugger\": 2,//禁止使用debugger\"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\"no-dupe-args\": 2,//函数参数不能重复\"no-duplicate-case\": 2,//switch中的case标签不能重复\"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\"no-empty\": 2,//块语句中的内容不能为空\"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\"no-empty-label\": 2,//禁止使用空label\"no-eq-null\": 2,//禁止对null使用==或!=运算符\"no-eval\": 1,//禁止使用eval\"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\"no-extend-native\": 2,//禁止扩展native对象\"no-extra-bind\": 2,//禁止不必要的函数绑定\"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\"no-extra-parens\": 2,//禁止非必要的括号\"no-extra-semi\": 2,//禁止多余的冒号\"no-fallthrough\": 1,//禁止switch穿透\"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\"no-func-assign\": 2,//禁止重复的函数声明\"no-implicit-coercion\": 1,//禁止隐式转换\"no-implied-eval\": 2,//禁止使用隐式eval\"no-inline-comments\": 0,//禁止行内备注\"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\"no-invalid-regexp\": 2,//禁止无效的正则表达式\"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\"no-irregular-whitespace\": 2,//不能有不规则的空格\"no-iterator\": 2,//禁止使用__iterator__ 属性\"no-label-var\": 2,//label名不能与var声明的变量名相同\"no-labels\": 2,//禁止标签声明\"no-lone-blocks\": 2,//禁止不必要的嵌套块\"no-lonely-if\": 2,//禁止else语句内只有if语句\"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\"no-mixed-requires\": [0, false],//声明时不能混用声明类型\"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\"linebreak-style\": [0, \"windows\"],//换行风格\"no-multi-spaces\": 1,//不能用多余的空格\"no-multi-str\": 2,//字符串不能用\\换行\"no-multiple-empty-lines\": [1, &#123;\"max\": 2&#125;],//空行最多不能超过2行\"no-native-reassign\": 2,//不能重写native对象\"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\"no-new\": 1,//禁止在使用new构造一个实例后不赋值\"no-new-func\": 1,//禁止使用new Function\"no-new-object\": 2,//禁止使用new Object()\"no-new-require\": 2,//禁止使用new require\"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\"no-octal\": 2,//禁止使用八进制数字\"no-octal-escape\": 2,//禁止使用八进制转义序列\"no-param-reassign\": 2,//禁止给参数重新赋值\"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\"no-plusplus\": 0,//禁止使用++，--\"no-process-env\": 0,//禁止使用process.env\"no-process-exit\": 0,//禁止使用process.exit()\"no-proto\": 2,//禁止使用__proto__属性\"no-redeclare\": 2,//禁止重复声明变量\"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\"no-return-assign\": 1,//return 语句中不能有赋值表达式\"no-script-url\": 0,//禁止使用javascript:void(0)\"no-self-compare\": 2,//不能比较自身\"no-sequences\": 0,//禁止使用逗号运算符\"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\"no-sync\": 0,//nodejs 禁止同步方法\"no-ternary\": 0,//禁止使用三目运算符\"no-trailing-spaces\": 1,//一行结束后面不要有空格\"no-this-before-super\": 0,//在调用super()之前不能使用this或super\"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\"no-undef\": 1,//不能有未定义的变量\"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\"no-undefined\": 2,//不能使用undefined\"no-unexpected-multiline\": 2,//避免多行表达式\"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\"no-unreachable\": 2,//不能有无法执行的代码\"no-unused-expressions\": 2,//禁止无用的表达式\"no-unused-vars\": [2, &#123;\"vars\": \"all\", \"args\": \"after-used\"&#125;],//不能有声明后未被使用的变量或参数\"no-use-before-define\": 2,//未定义前不能使用\"no-useless-call\": 2,//禁止不必要的call和apply\"no-void\": 2,//禁用void操作符\"no-var\": 0,//禁用var，用let和const代替\"no-warning-comments\": [1, &#123; \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" &#125;],//不能有警告备注\"no-with\": 2,//禁用with\"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\"arrow-parens\": 0,//箭头函数用小括号括起来\"arrow-spacing\": 0,//=&gt;的前/后括号\"accessor-pairs\": 0,//在对象中使用getter/setter\"block-scoped-var\": 0,//块语句中使用var\"brace-style\": [1, \"1tbs\"],//大括号风格\"callback-return\": 1,//避免多次调用回调什么的\"camelcase\": 2,//强制驼峰法命名\"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\"comma-spacing\": 0,//逗号前后的空格\"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\"complexity\": [0, 11],//循环复杂度\"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\"consistent-return\": 0,//return 后面是否允许省略\"consistent-this\": [2, \"that\"],//this别名\"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\"curly\": [2, \"all\"],//必须使用 if()&#123;&#125; 中的&#123;&#125;\"default-case\": 2,//switch语句最后必须有default\"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\"dot-notation\": [0, &#123; \"allowKeywords\": true &#125;],//避免不必要的方括号\"eol-last\": 0,//文件以单一的换行符结束\"eqeqeq\": 2,//必须使用全等\"func-names\": 0,//函数表达式必须有名字\"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\"generator-star-spacing\": 0,//生成器函数*的前后空格\"guard-for-in\": 0,//for in循环要用if语句过滤\"handle-callback-err\": 0,//nodejs 处理错误\"id-length\": 0,//变量名长度\"indent\": [2, 4],//缩进风格\"init-declarations\": 0,//声明时必须赋初值\"key-spacing\": [0, &#123; \"beforeColon\": false, \"afterColon\": true &#125;],//对象字面量中冒号的前后空格\"lines-around-comment\": 0,//行前/行后备注\"max-depth\": [0, 4],//嵌套块深度\"max-len\": [0, 80, 4],//字符串最大长度\"max-nested-callbacks\": [0, 2],//回调嵌套深度\"max-params\": [0, 3],//函数最多只能有3个参数\"max-statements\": [0, 10],//函数内最多有几个声明\"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\"new-parens\": 2,//new时必须加小括号\"newline-after-var\": 2,//变量声明后是否需要空一行\"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\"object-shorthand\": 0,//强制对象字面量缩写语法\"one-var\": 1,//连续声明\"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\"padded-blocks\": 0,//块语句内行首行尾是否要空行\"prefer-const\": 0,//首选const\"prefer-spread\": 0,//首选展开运算\"prefer-reflect\": 0,//首选Reflect的方法\"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\"radix\": 2,//parseInt必须指定第二个参数\"id-match\": 0,//命名检测\"require-yield\": 0,//生成器函数必须有yield\"semi\": [2, \"always\"],//语句强制分号结尾\"semi-spacing\": [0, &#123;\"before\": false, \"after\": true&#125;],//分号前后空格\"sort-vars\": 0,//变量声明时排序\"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\"space-before-blocks\": [0, \"always\"],//不以新行开始的块&#123;前面要不要有空格\"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\"space-infix-ops\": 0,//中缀操作符周围要不要有空格\"space-return-throw-case\": 2,//return throw case后面要不要加空格\"space-unary-ops\": [0, &#123; \"words\": true, \"nonwords\": false &#125;],//一元运算符的前/后要不要加空格\"spaced-comment\": 0,//注释风格要不要有空格什么的\"strict\": 2,//使用严格模式\"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\"valid-jsdoc\": 0,//jsdoc规则\"valid-typeof\": 2,//必须使用合法的typeof的值\"vars-on-top\": 2,//var必须放在作用域顶部\"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\"wrap-regex\": 0,//正则表达式字面量用小括号包起来\"yoda\": [2, \"never\"]//禁止尤达条件","tags":[]},{"title":"JQurey 实战项目--[数独游戏]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑫ -项目实战-jquery-数独游戏/","text":"一、前言本节使用的是 Jquery.js 做一个数独游戏，显示使用 JavaScript 来做，后面使用 TypeScript 来实现。 git 仓库：网址数独游戏没有后端，纯前端 下面是为了让自己久不用会忘记做的一个项目编辑过程，方便自己后面查阅。 二、数独游戏的玩法数独是源自 18 世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含 1-9，不重复。 数独盘面是个九宫，每一宫又分为九个小格。在这八十一格中给出一定的已知数字和解题条件，利用逻辑和推理，在其他的空格上填入 1-9 的数字。使 1-9每个数字在每一行、每一列和每一宫中都只出现一次，所以又称“九宫格”。 三、本文运用知识前端技术： HTML5: 页面结构 less、css: 样式 JavaScript：前方开发语言 jQuery：用于 DOM 开大的 js 库 TypeScript 2.0+ ： JavaScript 开发语言 的超集，提供了可选的 静态类型和 基于接口的OOP 前端构建技术： Node.js 6+: 运行坏境 NPM、 yarn: 工具安装工具（用来安装下载其他工具） install 安装，init 初始化 Gulp: 构建工具 webpack：打包工具 babel： 转译工具 TSC (TypeScript Compiler)：编译 四、框架搭建结构4.1 结构树题外话：结构树，命令行输入 tree 可以查看结构树,但是 windows 的这个 tree 命令不咋地。tree 网址 123456789101112131415161718192021222324├──dist # 文件夹(生成)：编译生成的文件夹| ├──js/ # 文件夹(生成)：编译生成的文件夹，存放编译后的 js 文件| ├──css/ # 文件夹(生成)：编译生成的文件夹，存放编译后的 css 文件| ├──favicon.ico # 文件(生成)： 编译移动到这里的文件，网站的图标，如果需要的话| └─ index.html # 文件(生成)： 编译移动到这里的 html 入口文件，|├──node_modules # 文件夹(生成)：使用 yarn 安装工具产生的文件夹（依赖包）├──src # 文件夹(创建)：生产文件夹 手动创建 或者 命令行创建的文件夹 （src 可自行命名）| ├──js/ # 文件夹(创建)：手动创建 或者 命令行创建的文件夹| └─less/ # 文件夹(创建)：手动创建 或者 命令行创建的文件夹| ├──.gitignore # 文件(创建)：上传 git 时忽略的文件/文件夹├──favicon.ico # 网站的图标(创建)，如果需要的话├──gulpfile.js # 文件(创建)：手动创建的文件 （用于构建）注意：这个文件的名字一定要是 gulpfile ，不能改名，| # 否则运行的 `gulp` 的时候回出现错误 `No gulpfile found` ，在电脑自带命令行运行还莫名的打开了另外一个编辑器| # 使用的是 vscode 编辑代码 cmder 运行打开了webstorm ，这都是文件名称不正确导致的。| # 当然，如果可以找到并修改gulp的配置文件，理论上可以做到按照我们定的文件名来执行。！！！！但是不麻烦么├──index.html # 文件(创建):hmtl 源码文件，页面结构入口文件├──package.json # 文件(生成)：使用 yarn add 安装工具产生的文件 （项目配置文件）├──README.md # 文件(创建):：手动创建的，项目说明文档├──webpack.config.js # 文件(创建):：手动创建 （webpack 配置文件））└──yarn.lock # 文件(生成)：使用 yarn 安装工具产生的文件 （用于锁定安装包的精确版本以及所有依赖项） # 只要不删除 yarn.lock 文件就可以使用命令 `yarn install` 根据 yarn.lock 文件的内容来还原获取所有的依赖包， # 保证所有人用到这个项目的时候安装的依赖包都是一致的。 4.2 使用 yarn 初始化 src 文件夹yarn 下载安装：网址yarn 文档学习：网址，yarn cli 网址 4.2.1 安装 gulp 构建工具1$ npm install -g gulp # 全局安装 gulp 工具 12345678$ yarn init #初始化包：创建或更新 package.json 文件。$ yarn add --dev gulp gulp-util #添加开发 （--dev 或 -D）用的 gulp 与 gulp-util 工具，（生产阶段不需要）$ yarn add --dev gulp-less #添加开发 （--dev 或 -D）用的，用于构建 less 模块（生产阶段不需要，生产阶段用的是转译后的 css）$ yarn add -D webpack-stream #添加开发 （--dev 或 -D）用的，用于打包$ yarn add --dev babel-core babel-loader babel-preset-es2015 #添加开发 babel-core：babel ，babel-loader：webpack的，babel-preset-es2015：一个预设集$ yarn add gulp-connect --dev # 安装 服务器工具 gulp-connect$ yarn install # 在本地 node_modules 目录安装 package.json 里列出的所有依赖。 注意: yarn 工具与 npm 的差异， yarn 是 npm 的升级，要比 npm 要快，yarn 安装 工具 使用 add，只有还原依赖的时候使用 install 4.2.1 生成的 package.json 文件根据上面的命令行安装下载工具之后，在 src 文件夹下的可以看到如下的文件内容。 1234567891011121314151617//package.json 文件下的内容&#123; \"name\": \"shudu\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"devDependencies\": &#123; \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^8.0.4\", \"babel-preset-es2015\": \"^6.24.1\", \"gulp\": \"^3.9.1\", \"gulp-connect\": \"^5.6.1\", \"gulp-less\": \"^4.0.1\", \"gulp-util\": \"^3.0.8\", \"webpack-stream\": \"^5.1.1\" &#125;&#125; 4.2.2 创建的 gulpfile.js 文件123456789101112131415//gulpfile.js 文件const gulp = require('gulp')//定义 webpack 任务：转译 JavaScriptgulp.task('webpack',()=&gt;&#123; //&#125;)//定义 less 任务：转译 less =&gt; cssgulp.task('less',()=&gt;&#123; //&#125;)// 定义默认任务，直接依赖与上面定义的 'webpack' 与 'less' 任务gulp.task('default',['webpack','less']) 先创建上面这样一个文件，先运行 gulp 若没有发生错误，这个文件就编辑正确了。没有错误，再补充这个文件。在这种状态就运行非常简单就可以判断这个文件是否有效，如果等编辑的内容多了再来判断，发生错误的话很麻烦去找出错误的原因，编程就是一步步的判断是否执行正确，发生错误的时候自己能很快的找到错误在哪里，提高效率。下面有可能是会发生很多的错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 完整的 gulpfile.js 文件const gulp = require('gulp'); //引入 gulpconst connect = require('gulp-connect'); // 引入 gulp-connect// 定义一个 web-server 任务：/*设置服务器*/gulp.task('webserver', function () &#123; connect.server(&#123; root: ['dist'], //要运行哪个目录 livereload: true, //是否热更新。 port: 8888 //端口号 &#125;); // gulp 之后生成一个服务器地址 eg：http://localhost:8888&#125;);//定义 webpack 任务：转译 JavaScriptgulp.task('webpack', () =&gt; &#123; const webpack = require('webpack-stream') // 引入 webpack-stream const config = require('./webpack.config.js') // 引入 webpack 的配置文件 gulp.src('./src/js/**/*.js') // 源码中的所有 js 文件 .pipe(webpack(config)) // 转译 过程 .pipe(gulp.dest('./dist/js')) //转译到 www 文件夹下的 js 文件 .pipe(connect.reload());&#125;)//定义 less 任务：转译 less =&gt; cssgulp.task('less', () =&gt; &#123; const less = require('gulp-less') gulp.src('./src/less/*.less') // 源码中的所有 less 文件 // './src/less/*.less' . 表示当前目录的意思，它 等价于 'src/less/*.less' .pipe(less()) // 转译 过程 .pipe(gulp.dest('./dist/css')) //转译到 www 文件夹下的 css 文件 .pipe(connect.reload());&#125;)// 定义任务 将 html 文件移动到另外一个位置：html 不需要编译gulp.task('html', () =&gt; &#123; /*要操作哪些文件 确定源文件地址*/ gulp.src('index.html') .pipe(gulp.dest('./dist')) .pipe(connect.reload());&#125;);gulp.task('ico',()=&gt;&#123; gulp.src('favicon.ico') .pipe(gulp.dest('./dist'))&#125;)// 定义默认任务，直接依赖与上面定义的 'webpack' 与 'less' 任务// 运行 gulp 将会执行这项任务gulp.task('default', ['webpack', 'less', 'html', 'webserver','ico','watch'])// 定义 watch 任务，一旦 js /less 有改变，将自动编译，不需要每次都在命令行去 gulp 执行编译。// 有了这个 watch 任务之后，在命令行执行 `gulp &amp;&amp; gulp watch` 命令，然后再编辑过程中就不需要去动用命令行了，// 会自动的编译，我们就只要关心 html ，src下的 js /less 编辑，以及浏览器 审查就好了。gulp.task('watch', () =&gt; &#123; gulp.watch('src/js/**/*.js', ['webpack']) // 一旦 src 下的 所有 js 文件中有改变的就执行 webpack 任务 gulp.watch('src/less/**/*.less', ['less']) // 一旦 src 下的 less 文件有所改变就执行 less 任务 gulp.watch('index.html', ['html']) // hmtl 文件有所改变就执行 html 任务&#125;) 4.2.3 创建 webpack.config.js 文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var webpack = require('webpack');// 导出对象module.exports = &#123; //入口文件，现在 src/js 文件夹下创建一个 index.js 文件 mode: 'development', entry: &#123; index: './src/js/index' &#125;, // 出口文件,输出在 gulpfile 已经指定了，这里就只需要写 文件名就好 output: &#123; filename: '[name].js' // [name].js 这样是什么意思啊？？？？ &#125;, //细粒度的配置，source map 格式来增强调试过程。不同的值会明显影响到构建(build)和重新构建(rebuild)的速度。 devtool: 'source-map', resolve: &#123; // 解决的问题 extensions: ['.js'] // extensions 扩展 ！！！！！！ &#125;, module: &#123; rules: [&#123; test: /\\.js$/, // 处理的是 js 文件 exclude: /node_modules/, //排除依赖包文件夹 use: [&#123; loader: 'babel-loader', // 使用的是 babel-loader 工具 // loader:用于对模块的源代码进行转换。loader 可以使你在 import 或\"加载\"模块时预处理文件。 // 因此，loader 类似于其他构建工具中“任务(task)” options: &#123; //当前 loader 需要的特殊配置：webpack 2.5 之前为 query，之后为 options // 预置 es2015 presets: ['es2015'] ////按照最新的 ES6 语法规则去转换 &#125; &#125;] &#125;] &#125;, externals: &#123; //外部扩展，提供了「不从bundle 中引用依赖」的方式，也就是说，自己的库本身不打包这个lodash，需要用户环境提供。 // 我们想引用一个库，但是又不想让 webpack 打包 （如果把这个 lodash 打入进去，打包文件就会非常大，影响我们的打包速度） // 总得来说，externals 配置就是为了使 import _ from 'lodash' 这句代码，在本身不引入 lodash 的情况下，能够在各个环境都能解释执行。 \"jquery\": \"jQuery\" &#125;, plugins: [ // ProvidePlugin 允许代码中直接使用定义的属性，而不需要 require() // 比如下面的定义可以直接使用 $，而不再需要 const $ = require(\"jquery\"); // 这里使用到 webpack 需要在文件开头引入 var webpack = require('webpack'); // 否则会报错 ReferenceError: webpack is not defined new webpack.ProvidePlugin(&#123; $: \"jquery\" &#125;) ]&#125; 4.2.4 webpack.config.js 与 gulpfile.js 编辑过程的错误关于 module 模块的学习，可以查看这该网址：地址 ① extensions: [‘.js’] 注意单词拼写！！！② webpack 版本的问题 webpack.config.js 文件中 query 与 optionswebpack2.5 之前为 query，之后为 options。 新版本的 webpack 不要忘记更新。 该问题可以查看：Stack Overflow 1234567891011λ gulp[18:21:13] Using gulpfile F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\gulpfile.js[18:21:13] Starting 'webpack'...[18:21:17] 'webpack' errored after 3.99 s[18:21:17] WebpackOptionsValidationError: Invalid configuration object. Webpack has been initialised using a configuration object that does not match the API schema. - configuration.module has an unknown property 'loader'. These properties are valid: object &#123; defaultRules?, exprContextCritical?, exprContextRecursive?, exprContextRegExp?, exprContextRequest?, noParse?, rules?, strictExportPresence?, strictThisContextOnImports?, unknownContextCritical?, unknownContextRecursive?, unknownContextRegExp?, unknownContextRequest?, unsafeCache?, wrappedContextCritical?, wrappedContextRecursive?, wrappedContextRegExp? &#125; -&gt; Options affecting the normal modules (`NormalModuleFactory`). - configuration.resolve has an unknown property 'extentions'. These properties are valid: object &#123; alias?, aliasFields?, cachePredicate?, cacheWithContext?, concord?, descriptionFiles?, enforceExtension?, enforceModuleExtension?, extensions?, fileSystem?, mainFields?, mainFiles?, moduleExtensions?, modules?, plugins?, resolver?, symlinks?, unsafeCache?, useSyncFileSystemCalls? &#125; -&gt; Options for the resolver ③ webpackloader: ‘babel-loader’ 不要漏写说明东西！！！ 该问题可以查看：Stack Overflow 1234567891011121314151617181920212223242526272829303132333435363738λ gulpinternal/streams/legacy.js:59 throw er; // Unhandled stream error in pipe. ^Error: Entry module not found: Error: Can't resolve 'babel' in 'F:\\qianduan_dir\\00program\\JQuery\\shudu\\src'(这里有说明错误)BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders. You need to specify 'babel-loader' instead of 'babel', see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removedresolve 'babel' in 'F:\\qianduan_dir\\00program\\JQuery\\shudu\\src' Parsed request is a module using description file: F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\package.json (relative path: .) resolve as module F:\\qianduan_dir\\00program\\JQuery\\shudu\\node_modules doesn't exist or is not a directory F:\\qianduan_dir\\00program\\JQuery\\node_modules doesn't exist or is not a directory F:\\qianduan_dir\\00program\\node_modules doesn't exist or is not a directory F:\\node_modules doesn't exist or is not a directory looking for modules in F:\\qianduan_dir\\node_modules No description file found looking for modules in F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\node_modules using description file: F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\package.json (relative path: ./node_modules) using description file: F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\package.json (relative path: ./node_modules/babel) no extension F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\node_modules\\babel doesn't exist No description file found .js F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\node_modules\\babel.js doesn't exist no extension F:\\qianduan_dir\\node_modules\\babel doesn't exist .json F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\node_modules\\babel.json doesn't exist .js F:\\qianduan_dir\\node_modules\\babel.js doesn't exist as directory F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\node_modules\\babel doesn't exist .json F:\\qianduan_dir\\node_modules\\babel.json doesn't exist as directory F:\\qianduan_dir\\node_modules\\babel doesn't exist ④ webpack 与 babel 版本 123456Unhandled rejection Error in plugin \"webpack-stream\"Message: ./js/index.jsModule build failed (from ./node_modules/babel-loader/lib/index.js):Error: Cannot find module '@babel/core' babel-loader@8 requires Babel 7.x (the package '@babel/core'). If you'd like to use Babel 6.x ('babel-core'), you should install 'babel-loader@7' 这个问题在安装 babel-loader 的时候有提示下面的提示。（题外话：install has been replaced with add to add new dependencies. Run “yarn add babel-loader” instead.） 1234567891011121314151617λ yarn add --dev babel-loaderyarn add v1.9.4[1/4] Resolving packages...[2/4] Fetching packages...info fsevents@1.2.4: The platform \"win32\" is incompatible with this module.info \"fsevents@1.2.4\" is an optional dependency and failed compatibility check. Excluding it from installation.[3/4] Linking dependencies...warning \" &gt; webpack-cli@3.1.2\" has unmet peer dependency \"webpack@^4.x.x\".warning \" &gt; babel-loader@8.0.4\" has unmet peer dependency \"@babel/core@^7.0.0\".warning \" &gt; babel-loader@8.0.4\" has unmet peer dependency \"webpack@&gt;=2\".[4/4] Building fresh packages...success Saved 1 new dependency.info Direct dependencies└─ babel-loader@8.0.4info All dependencies└─ babel-loader@8.0.4Done in 12.13s. 上面三个警告解决[3/4] Linking dependencies…warning “ &gt; webpack-cli@3.1.2“ has unmet peer dependency “webpack@^4.x.x”.warning “ &gt; babel-loader@8.0.4“ has unmet peer dependency “@babel/core@^7.0.0”.warning “ &gt; babel-loader@8.0.4“ has unmet peer dependency “webpack@&gt;=2”. 链接依赖项，需要将后者下载下来。 ⑤ mode 1234567891011121314151617λ gulp[00:13:30] Using gulpfile F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\gulpfile.js[00:13:30] Starting 'webpack'...[00:13:36] Finished 'webpack' after 6.13 s[00:13:36] Starting 'less'...[00:13:38] Finished 'less' after 1.99 s[00:13:38] Starting 'default'...[00:13:38] Finished 'default' after 99 μs[00:13:46] Version: webpack 4.23.1Built at: 2018-11-03 00:13:46 Asset Size Chunks Chunk Namesindex.js 944 bytes 0 [emitted] indexEntrypoint index = index.jsWARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ 错误警告：没有设定是开发模式还是生产模式,要求指定.解决：网址,这里用的的是 mode: &#39;development&#39;，是开发阶段使用的。 ⑥ weback is not undefined 12345678910111213// 在 wepack.config.js 中加入这段代码之后出错 externals: &#123; \"jquery\": \"jQuery\" &#125;, plugins: [ // ProvidePlugin 允许代码中直接使用定义的属性，而不需要 require() // 比如下面的定义可以直接使用 $，而不再需要 const $ = require(\"jquery\"); // 这里使用到 webpack 需要在文件开头引入 var webpack = require('webpack'); // 否则会报错 ReferenceError: webpack is not defined new webpack.ProvidePlugin(&#123; $: \"jquery\" &#125;) ] 123456λ gulp[15:34:38] Working directory changed to F:\\qianduan_dir\\00program\\JQuery\\shudu\\src[15:34:38] Using gulpfile F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\gulpfile.js[15:34:38] Starting 'webpack'..[15:34:39] 'webpack' errored after 201 ms[15:34:39] ReferenceError: webpack is not defined 解决问题：编译器已经告诉我们是因为 webpack 没有定义了，需要使用到这个变量，我们需要在 wepack.config.js 文件开头就将这个 webpack 引进来。问题 1var webpack = require('webpack'); // 开头引进来，后面才能使用 webpack 这个变量 ⑦ 浏览器运行问题 1WebSocket connection to 'ws://localhost:35729/livereload' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED 这是命令行关闭了，没有在运行，所以浏览器找不到服务器了。 4.3 使用 npm 初始化 src 文件夹五、 页面实现，数据结构设计，数据处理页面视觉设计一般是视觉设计师做的活。页面实现、数据结构设计是前端工程师的活。 在这里，我们做的是数组游戏，使用的是 数组结构（二维数组/矩阵数组），二维数组 A[m][n]，这是一个 m 行，n 列的二维数组。 m 就是第 m 行， n 是每行的第 n 列。每行是一个 一维数组（内层数组）,整个九宫格是一个二维数组（外层数组） 二维数组/矩阵数组 matix每行数据（一维数组）：aRow = matix[i]每个格子数据（数字）：aCell = aRow[j]格子中的数据是 1-9 ，空时为 0 ，在 js 中它对应的布尔值为 false ，对应布尔值的值有 null，undefined，’’ ，0 ，这里使用 0 ，为了数据类型的统一。 5.1 数据结构-二维数组123456789101112131415161718192021222324252627282930313233// 创建 一维数组function makeRowArray(v) &#123; // 传一个默认值为 0 的变量 v const arr = new Array(9) // 创建一个长度为 9 的数组 ，赋值给常量 arr arr.fill(v) // 用变量 v 填充整个数组 arr return arr&#125;// 创建二维数组function makeMatix(v) &#123; const arr = new Array(9) // 调用 Array.from() 创建数组，使用第二个参数对 类数组中的元素进行处理 return Array.from(&#123; length: 9 &#125;, () =&gt; makeRowArray(v)) //return Array.from(&#123;length:9&#125;).map(()=&gt;makeRowArray()) 这里是传一个参数，得到数组使用 map() 方法&#125;var a = makeMatix(0) // 这里怎么使用 const ？？？、不懂a[2][2] = 2console.log(a)/*λ node .[ [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 2, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ] ]*/// 得到上面这样的代码就可以正确的创建了一个九宫格二维数组了 5.2 洗牌算法-随机生成二维数组数据洗牌算法，简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。Fisher–Yates shuffle 算法是一个非常高效又公平的随机排序算法，如果有随机排序数组的需求，就用这个算法，非常的高效。 洗牌算法 方法动画 123456789101112131415161718192021// 给 Array 类 添加 shuffle 方法，并且是从后面开始交换Array.prototype.shuffle = function () &#123; let n = this.length - 1 for (var i = n; i &gt;= 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); [this[j], this[i]] = [this[i], this[j]] &#125; return this; //this 表示的是 Array 类&#125;// 编写一个 shuffle1 方法，并且是从前面开始交换function shuffle1(arr) &#123; let n = arr.length // 交换 n-1 次就ok 了 for (let i = 0; i &lt; n - 1; i++) &#123; let j = i + Math.floor(Math.random() * (n - i)); // （i 位置）与 （ i 到最后元素中的一个，包含 i） 做交换 [arr[i], arr[j]] = [arr[j], arr[i]] &#125; return arr&#125; 5.3 洗牌算法-检查算法：检查洗牌算法填入的数字是否符合 数独游戏的要求（每行，每列，每宫 由1-9组成，每个数字出现一次）5.4 工具包 toolkit大规模的设计，需要将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。而不是在一个入口执行文件写大段的代码，这样不利于编程。 在 ES6 之前， JS 是没有自己的模块的，它使用的是 commonJS ，也就是 module.export-&gt;require 形式.其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有 @import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 ES6 之后拥有了这个 module ，我们可以将大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。很多 js 代码我们可以编辑在工具包内，不应该都写在入口执行文件内。 JavaScript 的 module ES5 commonJS: module.export-&gt;requireES6 module : export-&gt;import 关于这两个使用模块的方法，可以查看这边文章：搞明白require和import 本文中我们也是使用 ES5 commonJS 来做这个工具包模块的导出导入应用。将 5.1 、5.2 节的代码编写成模块。 1234567891011121314151617181920212223// Toolkit.js 文件 const martixToolkit = &#123; makeRowArray(v = 0) &#123; const arr = new Array(9) arr.fill(v) return arr &#125;, makeMatix() &#123; return Array.from(&#123; length: 9 &#125;, () =&gt; this.makeRowArray()) // 在 ES6 的模块中不能使用this &#125;, shuffle(arr) &#123; let n = arr.length - 1 for (var i = n; i &gt;= 0; i--) &#123; var j = Math.floor(Math.random() * (i + 1)); [arr[j], arr[i]] = [arr[i], arr[j]] &#125; return arr; &#125; &#125; module.exports = martixToolkit; 123456//index.js 入口文件const toolkit=require('./toolkit') // commonJS 模块导入方法const matix=toolkit.makeMatix() // 调用 toolkit 的 makeMatix() 方法创建一个 matix 二维数组/矩阵console.log(matix)console.log(toolkit.shuffle([1,2,3,4,5,6,7,8,9])) 5.5 HTML 页面制作5.5.1 gulp 构建编辑好 html 文件，使用 gulp 构建 less-&gt;css,module.js-&gt;js.src 中保存在的是编译之前的文件，以及下载安装的依赖包，www 中保存的是编译之后生成的文件，以及编辑的 html 文件。 12$ gulp # 代码编辑之后构建$ gulp &amp;&amp; gulp watch # 在 webpack.config.js 写上 watch 任务，监听变化构建 5.5.2 html 代码 写代码之前先写分行写注释：便于识别代码区域，后期也好维护 用 less 编辑的 复杂的代码，就像是表格这种是用 js 生成的，（用时长），不要忘记要在 js 中保证文本加载完全再做操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\"&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- &lt;script src=\"https://code.jquery.com/jquery-3.1.1.min.js\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"js/index.js\"&gt;&lt;/script&gt; &lt;!-- 引入jquery库，以及 www.js 下编译生成的 js --&gt; &lt;title&gt;数独游戏&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"main\"&gt; &lt;!-- 标题，难易度星星 --&gt; &lt;div class=\"shudu-title\"&gt; &lt;div class=\"title\"&gt;数独游戏&lt;/div&gt; &lt;div class=\"level\"&gt;关卡 9&lt;/div&gt; &lt;/h1&gt; &lt;/div&gt; &lt;!-- 用时，帮助 --&gt; &lt;div class=\"time-help\"&gt; &lt;div class=\"time\"&gt;用时&lt;/div&gt; &lt;div&gt;帮助&lt;/div&gt; &lt;/div&gt; &lt;!-- 九宫格 --&gt; &lt;div id=\"container\" class=\"container gird\"&gt; &lt;/div&gt; &lt;!-- 操作按钮组,数字选择框 --&gt; &lt;div class=\"number-board\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt; &lt;/div&gt; &lt;!-- 操作按钮组 --&gt; &lt;div class=\"operation-board\"&gt; &lt;div&gt;返回&lt;/div&gt; &lt;div&gt;前进&lt;/div&gt; &lt;div&gt;重置&lt;/div&gt; &lt;div&gt;暂停&lt;/div&gt; &lt;div&gt;提交&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123@shadowBottom: 0 0.2rem 0.3rem rgba(48, 48, 48, 192);@shadowTop: 0 -0.1rem 0.2rem rgba(48, 48, 48, 192);html &#123; font-size: 14px; body &#123; margin: 0; padding: 0; font-family: \"Consolas\", \"微软雅黑\"; background: #fff; user-select: none; /* 禁止选择复制内容，如果允许选择，碰到选择了会用户体验不好 */ max-width: 450px; &gt; * &#123; max-width: 450px; &#125; .main &#123; padding: 0.5rem; .shudu-title &#123; // rem 是 css3 中新增的尺寸单位：相对的 HTML根 元素的大小，后期值需要更新 html 根元素的尺寸即可。 margin-bottom: 1.5rem; padding: 1rem; font-size: 1.5rem; display: flex; justify-content: space-between; color: #fff; background: rgb(54, 148, 192); box-shadow: @shadowBottom; .title &#123; flex: 2; &#125; .level &#123; flex: 1; &#125; &#125; .time-help &#123; padding: 0.5rem; display: flex; justify-content: flex-end; .help &#123; margin: 0.5rem; border-radius: 1rem; &#125; &#125; #container &#123; margin: 1rem 0; padding: 0 5%; .row &#123; display: flex; justify-content: center; &gt; span &#123; // &gt; span 是什么？ display: inline-block; cursor: pointer; text-align: center; width: 10%; //height: 24px; //line-height: 24px; border: 1px solid #cccccc; border-right-width: 0; border-bottom-width: 0; background: white; &amp; :first-child &#123; border-left-width: 2px; &#125; &amp; :last-child &#123; border-right-width: 2px; &#125; // 这里为什么需要 &amp; ？？？ &amp;.col_g_right &#123; border-right-width: 2px; &#125; &#125; &amp; :first-child &#123; &gt; span &#123; border-top-width: 2px; &#125; &#125; &amp; :last-child &#123; &gt; span &#123; border-bottom-width: 2px; &#125; &#125; // 这里为什么需要 &amp; ？？？ &amp;.row_g_bottom &#123; &gt; span &#123; border-bottom-width: 2px; &#125; &#125; &#125; &#125; .number-board, .operation-board &#123; margin: 0.1rem 0; padding: 0.5rem; display: flex; justify-content: space-between; align-items: center; &#125; .number-board &#123; div &#123; padding: 0.5rem 0.8rem; background: rgb(223, 152, 46); //height: 2rem; font-size: 1.3rem; //width: 2rem; border-radius: 1rem; &#125; &#125; .operation-board &#123; div &#123; padding: 0.5rem 1rem; background: rgb(54, 148, 192); //height: 3rem; font-size: 1.3rem; //width: 3rem; border-radius: 1rem; &#125; &#125; &#125; &#125;&#125; 5.5.3 用 js 代码生成九宫格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// index.jsconst toolkit = require('./toolkit') // commonJS 模块导入方法//const matix = toolkit.makeMatix()class Gird &#123; // 这个类 需要传入一个 $('') 选择器 constructor(container) &#123; this._$container = container // ？？？ &#125; /* map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 map() 方法按照原始数组元素顺序依次处理元素。注意： map() 不会对空数组进行检测。map() 不会改变原始数组。 */ build() &#123; const martix = toolkit.makeMatix(); // 调用矩阵，创建一个元素都是 0 的二维数组 const rowGroupClasses = ['row_g_top', 'row_g_middle', 'row_g_bottom'] // 定义行样式，使用解构赋值，需要操作的是 row_g_bottom const colGroupClasses = ['col_g_left', 'col_g_middle', 'col_g_right'] // 定义列样式，使用解构赋值，需要操作的是 col_g_right //martix.map(RowArray =&gt; $div); // 二维数组的 元素 也就是 一维数组/每行数据 映射为 div //RowArray.map(cellValue =&gt;) // 一维数组/每行数据 映射为 &lt;span&gt;cellValue&lt;/span&gt; const $cells = martix.map(rowValues =&gt; rowValues.map((cellValue, colIndex) =&gt; &#123; return $(\"&lt;span&gt;\") // 2 个 map 遍历，可以执行九宫格中所有的数组 .addClass(colGroupClasses[colIndex % 3]) //addClass() - 向被选元素添加一个或多个类 (每宫右边的外框加粗线) .text(cellValue); //&lt;span&gt;cellValue&lt;/span&gt; //设置 text(str) 或返回 text() 所选元素的文本内容 &#125;)); const $divArray = $cells.map(($spanArray, rowIndex) =&gt; &#123; // 1 个 map 遍历，每次处理 1 行 return $(\"&lt;div&gt;\") .addClass('row') .addClass(rowGroupClasses[rowIndex % 3]) //(每宫底边的外框加粗线) .append($spanArray); // append() 在被选元素的结尾插入内容 // http://www.runoob.com/jquery/jquery-dom-add.html &#125;) this._$container.append($divArray); &#125; // 给 Gird 类添加一个布局方法 layout() &#123; const width = $('span:first', this._$container).width() // $ 里面传 2 个参数？？？ $('span', this._$container) .height(width) // 是的高度等于宽度 .css(&#123; 'line-height': `$&#123;width&#125;px`, // ES6 字符串模本语法 'font-size': width &lt; 32 ? `$&#123;width/2&#125;px` : '' &#125;) &#125;&#125;// 要在文档加载完全之后执行 window.onload =函数/* $(document).ready(function () &#123; const gird=new Gird($(\"#container\")) gird.build(); gird.layout();&#125;); */$(function () &#123; var gird = new Gird($(\"#container\")) gird.build(); gird.layout();&#125;) 六、 完整的代码实现过程6.1 重构代码：就是框架，代码，模块的划分6.1.1 脚本目录结构：src/js 下的 JavaScript 目录结构这里是前面章节的 整体结构树 12345678910111213141516171819└─src # 文件夹：源码文件夹 手动创建 或者 命令行创建的文件夹 （src 为约定俗成命名） ├──js | └───index.js # 文件夹：手动创建 或者 命令行创建的文件夹 ├──less # 文件夹：手动创建 或者 命令行创建的文件夹 ├──node_modules # 文件夹：使用 yarn 安装工具产生的文件夹（依赖包） ├──package.json # 文件：使用 yarn 安装工具产生的文件 （项目配置文件） ├──webpack.config.js # 文件：手动创建 （webpack 配置文件） ├──yarn.lock # 文件：使用 yarn 安装工具产生的文件 （用于锁定安装包的精确版本以及所有依赖项） | # 只要不删除 yarn.lock 文件就可以使用命令 `yarn install` 根据 yarn.lock 文件的内容来还原获取所有的依赖包， | # 保证所有人用到这个项目的时候安装的依赖包都是一致的。 ├──gulpfile.js # 文件：手动创建的文件 （用于构建）注意：这个文件的名字一定要是 gulpfile ，不能改名， | # 否则运行的 `gulp` 的时候回出现错误 `No gulpfile found` ，在电脑自带命令行运行还莫名的打开了另外一个编辑器 | # 使用的是 vscode 编辑代码 cmder 运行打开了webstorm ，这都是文件名称不正确导致的。 | # 当然，如果可以找到并修改gulp的配置文件，理论上可以做到按照我们定的文件名来执行。！！！！但是不麻烦么└─www # 文件夹：生产文件夹 手动创建 或者 命令行创建的文件夹 （www 可自行命名） | # 文件夹：手动创建 或者 命令行创建的文件夹 ├──css # gulp 编译生成的文件夹，以及内部文件 ├──js # gulp 编译生成的文件夹，以及内部文件 └─ index.html # 手动创建编辑的 html 页面结构入口文件。 src/js 目录更新为 1234567891011~src/js ├──index.js # 页面入口以及事件绑定 ├──core/ # 算法以及数据结构相关的脚本 | ├──toolkit.js # 工具方法集 | ├──generator.js # 生成数独解决方案：洗牌算法 | ├──checker.js # 检查数独解决方案：检查洗牌算法 | ├──shudu.js # 生成数独游戏 | └─ ui/ # 界面相关的脚本 ├──gird.js # 生成九宫格 └──number-board.js # 处理弹出的操作面板？？？我做的不需要吧 12λ .\\node_modules\\.bin\\gulp &amp;&amp; .\\node_modules\\.bin\\gulp watch # 项目内运行λ gulp &amp;&amp; gulp watch # 全局运行 ①问题：要在 src 目录项运行 下面这里没有在 src 而是在 js 下面运行，没有 index.js 入口文件，运行时会报错的，这里就报错了， throw er; // Unhandled stream error in pipe.，如果不知道的话，还以为是 webpack 文件出错，但是在 src 运行又正确了，。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051λ gulp &amp;&amp; gulp watch[22:24:57] Working directory changed to F:\\qianduan_dir\\00program\\JQuery\\shudu\\src[22:24:59] Using gulpfile F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\gulpfile.js[22:24:59] Starting 'webpack'...[22:25:07] Finished 'webpack' after 7.62 s[22:25:07] Starting 'less'...[22:25:08] Finished 'less' after 1.35 s[22:25:08] Starting 'default'...[22:25:08] Finished 'default' after 101 μsinternal/streams/legacy.js:59 throw er; // Unhandled stream error in pipe. ^Error: ./js/ui/gird.jsModule not found: Error: Can't resolve './core/toolkit' in 'F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui'resolve './core/toolkit' in 'F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui' using description file: F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\package.json (relative path: ./js/ui) Field 'browser' doesn't contain a valid alias configuration using description file: F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\package.json (relative path: ./js/ui/core/toolkit) no extension Field 'browser' doesn't contain a valid alias configuration F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui\\core\\toolkit doesn't exist .js Field 'browser' doesn't contain a valid alias configuration F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui\\core\\toolkit.js doesn't exist as directory F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui\\core\\toolkit doesn't exist[F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui\\core\\toolkit][F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\ui\\core\\toolkit.js] @ ./js/ui/gird.js 8:14-39 @ ./js/index.jsF:\\qianduan_dir\\00program\\JQuery\\shudu\\src (shudu@1.0.0)λ .\\node_modules\\.bin\\gulp &amp;&amp; .\\node_modules\\.bin\\gulp watch[22:30:39] Using gulpfile F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\gulpfile.js[22:30:39] Starting 'webpack'...[22:30:42] Finished 'webpack' after 2.89 s[22:30:42] Starting 'less'...[22:30:43] Finished 'less' after 786 ms[22:30:43] Starting 'default'...[22:30:43] Finished 'default' after 122 μs[22:30:46] Version: webpack 4.23.1Built at: 2018-11-06 22:30:46 Asset Size Chunks Chunk Names index.js 9.6 KiB index [emitted] indexindex.js.map 9.38 KiB index [emitted] indexEntrypoint index = index.js index.js.map[22:30:49] Using gulpfile F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\gulpfile.js[22:30:49] Starting 'watch'...[22:30:49] Finished 'watch' after 54 ms ② 问题解决：网址 1234567891011121314151617181920212223[22:30:49] Starting 'watch'...[22:30:49] Finished 'watch' after 54 ms[22:36:35] Starting 'webpack'...[22:36:38] Finished 'webpack' after 2.74 s[22:36:38] Starting 'webpack'...[22:36:38] 'webpack' errored after 7.04 ms[22:36:38] ConcurrentCompilationError in plugin \"webpack-stream\"Message: You ran Webpack twice. Each instance only supports a single concurrent compilation at a time. # 你运行Webpack两次。 每个实例一次只支持一个并发编译。Details: details: undefined missing: undefined origin: undefined dependencies: undefined module: undefined[22:36:40] Version: webpack 4.23.1Built at: 2018-11-06 22:36:40 Asset Size Chunks Chunk Names index.js 9.62 KiB index [emitted] indexindex.js.map 9.45 KiB index [emitted] indexEntrypoint index = index.js index.js.map 运行非 index.js 文件，不是用 gulp 构建，还是使用 node 来直接运行。 12F:\\qianduan_dir\\00program\\JQuery\\shudu\\src\\js\\coreλ node generator.js to apply style from 'http://localhost:8888/pages/css/home.css' because its MIME type ('text/html') is not a supported stylesheet MIME type, and strict MIME checking is enabled.12home.html:10 GET http://localhost:8888/pages/js/home.js net::ERR_ABORTED 404 (Not Found) 因为 是 home.css 的文件路径不对，编辑时， index.html 与 home.html 放置的位置是不同的因为 是 home.js 的文件路径不对，编辑时， index.js 与 home.js 放置的位置是不同的","tags":[]},{"title":"vue-cli1--[小白入门篇、速学篇]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }- vue-cli1 脚手架/","text":"一、前言学习了 vue.js,vue-cli,vue-router,axios,element-ui,lodash.js 或者其他等等框架。 Vue CLI 是一个 Vue.js 快速开发的完整系统， 搭建交互式项目脚手架。Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写你的应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需跳出。不需要我们花时间去创建各种文件夹。 通过 @vue/cli 搭建交互式项目脚手架。 通过 @vue/cli + @vue/cli-service-global 快速创建零配置原型。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有智能的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 二、环境准备：应用的安装仅为 windows 系统 npm 安装方法 2.1全局安装 node.js12345# 安装 node.js，命令行输入 node -v 查看版本来测试是否成功安装① 中文地址：http://nodejs.cn/download/② 英文地址：https://nodejs.org/en/download/③ 历史版本下载地址：https://nodejs.org/dist/④ 全面的详解安装方法：http://www.runoob.com/nodejs/nodejs-install-setup.html 2.2全局安装 npm123# 新版本的 node.js 中已经含有 NPM，如果是新版本不需要再安装 NPM，# 安装NPM， 命令行输入 `npm -v` 查看版本来测试是否成功安装# 全面的详解安装方法：http://www.runoob.com/nodejs/nodejs-npm.html 2.3全局安装 cnpm12$ npm install -g cnpm --registry=https://registry.npm.taobao.org # 安装 cnpm# 安装 CNPM，可以使用 `cnpm-v` 查看版本来测试是否成功安装 2.4 全局安装 pnpm12# install pnpm$ npm install -g pnpm # pnpm 是先使用缓存，要比 npm 要好一点 2.4升级NPM版本123# 升级 npm 版本，命令行输入$ npm install npm -g ，或者是淘宝镜像$ cnpm install npm -g 2.5 vue 安装12$ cnpm install vue --g# 全局安装 vue.js 2.6 vue-cli 安装（包括 vue-router）123$ npm install vue-cli -g # 或者是 cnpm，pnpm 全局安装 vue.js$ vue -V # 查看版本，疑问，这个是查 vue-cli 的版本？？？vue 的版本呢？？ #（注意这个 V 是大写的，否则错误，查不到版本） 2.7 安装 Vue Devtools 调试工具以上为 npm 的安装，下面开始使用 vue 创建项目 https://github.com/vuejs/vue-devtools#vue-devtools 安装 Vue Devtools 调试工具 三、初始化项目：vue 项目构建完整构建过程3.1 完整的创建项目过程3.1.1 webpack 模板名称创建项目之前先知道一下模板名称，vue-cli 官方为我们提供了 5 种模板：一般情况下，都是用 webpack 模板 12345# webpack: 一个全面的 webpack+vue-loader 的模板，功能包括热加载，linting 检测和 CSS 扩展。# webpack-simple 一个简单 webpack+vue-loader 的模板，不包含其他功能，让你快速的搭建vue的开发环境。# browserify：一个全面的 Browserify+vueify 的模板，功能包括热加载，linting,单元检测。# browserify-simple:一个简单 Browserify+vueify 的模板，不包含其他功能，让你快速的搭建 vue 的开发环境。# simple:一个最简单的单页应用模板。 3.1.2 vue 框架项目创建 JavaScript 项目 JavaScript 项目 JavaScript 项目!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1234567891011121314151617181920212223242526272829303132# -S 表示 --save# i 表示 install$ vue init webpack projectname # 创建 vue 项目$ cd projectname # 进入到项目目录$ cnpm install # 下载 vue 依赖包$ cnpm run dev # 获取访问端口：http://localhost:8080/,开发过程调试等工作# http://0.0.0.0:4000 如果运行后得到的网址是这个，直接复制这个是打开是不行的，# 127.0.0.1:4000 要换成这个去运行， 0.0.0.0 是没有的，# 还不行的话，多试几遍，再是不行的话，看看是不是同时有别的的项目在运行，用了 4000 这个端口。# 经过几次的项目创建，发现没有 run 之前安装 vuex ， ui 组件这些都没有成功，# 非是要 run 之后再来安装这些依赖包，方可使用。所以还是先 run 一下，再安装下面的安装包吧。$ cnpm install vuex #下载 vuex 状态管理器（状态就是某种条件状态下的数据保存起来），$ cnpm iinstall element-ui --save # 下载饿了么 ui 框架，这个框架是 PC 端的$ cnpm install iview --save # 下载 iview 这个 ui 框架，框架都是选择的，选择其一即可。$ cnpm install vux --save # 下载 vux 这个 ui 框架，这个框架是移动端的$ cnpm install mint-ui --save # 下载饿了么 ui 框架，这个框架是移动端的$ cnpm install axios # 下载前后端数据交互应用$ yarn add axios # 使用 yarn$ npm install normalize.css # 浏览器兼容 css 文件$ npm i v-charts echarts -S # 图表 ui 组件库$ npm install --save dayjs # 日期时间处理，dayjs 库# 开发过程$ cnpm run build #开发完之后，打包 disc 文件夹部署上线 还可以引人其他的工具库: 阿里图标：内含千万字符实体图标选择使用 Lodash工具库：一套工具库，内部封装了很多字符串、数组、对象等常见数据类型的处理函数，方便我们处理js的各种类型数据 3.1.3 vue 框架项目创建 TypeScript 项目 TypeScript 项目 TypeScript 项目!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!12345678910111213141516171819202122232425262728$ vue init webpack projectname # 创建 vue 项目$ cd projectname # 进入到项目目录$ cnpm install # 下载 vue 依赖包$ cnpm run dev # 获取访问端口：http://localhost:8080/,开发过程调试等工作# http://0.0.0.0:4000 如果运行后得到的网址是这个，直接复制这个是打开是不行的，# 127.0.0.1:4000 要换成这个去运行， 0.0.0.0 是没有的，# 还不行的话，多试几遍，再是不行的话，看看是不是同时有别的的项目在运行，用了 4000 这个端口。# 经过几次的项目创建，发现没有 run 之前安装 vuex ， ui 组件这些都没有成功，# 非是要 run 之后再来安装这些依赖包，方可使用。所以还是先 run 一下，再安装下面的安装包吧。$ cnpm install vuex #下载 vuex 状态管理器（状态就是某种条件状态下的数据保存起来），$ cnpm iinstall element-ui --save # 下载饿了么 ui 框架，这个框架是 PC 端的$ cnpm install iview --save # 下载 iview 这个 ui 框架，框架都是选择的，选择其一即可。$ cnpm install vux --save # 下载 vux 这个 ui 框架，这个框架是移动端的$ cnpm install mint-ui --save # 下载饿了么 ui 框架，这个框架是移动端的$ cnpm install axios # 下载前后端数据交互应用$ yarn add axios # 使用 yarn$ npm install normalize.css # 浏览器兼容 css 文件$ npm i v-charts echarts -S # 图表 ui 组件库$ npm install --save dayjs # 日期时间处理，dayjs 库# 开发过程$ cnpm run build #开发完之后，打包 disc 文件夹部署上线 3.2 初始化步骤123456vue init 模板名称 项目名称 # ①选择模板-创建文件夹：一直回车即可cd 项目名称 # ②进入项目目录cnpm install # ③根据 package.json 文件中 # 安装 dependencies 和 devDempendencies 字段中的模块npm run dev # ④运行服务器:开发阶段测试npm run build # ⑤打包项目 disc 文件：生产 1234567891011121314再如：①vue init webpack pos②cnpm install③cnpm run dev-----------------------------------------------①或者手动建立一个文件夹 pos，命令行进入该文件夹，②vue init webpack③cnpm install④cnpm run dev-----------------------------------------------①再或者是命令行建立文件夹 mkdir pos，然后进去文件夹②vue init webpack③cnpm install④cnpm run dev 3.3 查看各应用版本12345# 应用 命令# node node -v# npm npm -v# cnpm cnpm -v# vue vue -V 这个是大写的 3.4 安装过程爬的坑3.4.1 查看版本的坑 -v 前面一定要有空格 vue 的版本查看 -V 要是大写的才能识别， vue -V ，大写了还是无法识别版本，有可能是 npm 版本过低，可以使用 npm install -g npm 来更新版本 3.4.2 旧版本缓存的坑 vue-cli 的坑， 如果安装失败，可以使用 npm cache clean 清理缓存，然后再重新安装。后面的安装过程中，如有安装失败的情况，也需要先清理缓存 3.4.3 创建项目时出错 `chromedriver@2.41.0 install: node install.js`$ vue init webpack 12345678910111213141516171819202122232425262728# Installing project dependencies ...# ========================npm WARN deprecated browserslist@2.11.3: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.npm WARN deprecated bfj-node4@5.3.1: Switch to the `bfj` package for fixes and new features!npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0npm WARN deprecated istanbul-lib-hook@1.2.1: 1.2.0 should have been a major version bump&gt; chromedriver@2.41.0 install F:\\qianduan_dir\\00program\\todolist\\node_modules\\chromedriver&gt; node install.jsDownloading https://chromedriver.storage.googleapis.com/2.41/chromedriver_win32.zipSaving to C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\chromedriver\\chromedriver_win32.zipChromeDriver installation failed Error with http(s) request: Error: read ECONNRESETnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! chromedriver@2.41.0 install: `node install.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the chromedriver@2.41.0 install script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-20T10_29_09_118Z-debug.log chromedriver 是 google 为网站开发人员提供的自动化测试接口，是网站测试架构 selenium 的 chrome 基础部分，主要是通过 http 通信实现的。它是 selenium 和 浏览器进行通信的桥梁。 填坑：首先出现这个错误是因为 Google 在国内无法使用，即使采用科学上网的方法也仍然无法获取文件。命令行中需要额外的来解决这个问题。这个坑不要解决也 ok ，因为它是自动化测试接口。 npm install chromedriver -g 没有安装过 chromedriver 首选需要全局安装一下 npm install chromedriver –chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver 如果上面的代码不行，可以试试这个命令，使用淘宝镜像安装 3.4.4 克隆他人项目代码无法 run（webpack-dev-server 不是内部或外部命令）cnpm run dev 无法运行，webpack-dev-server 不是内部或外部命令，也不是可运行的程序或批处理文件 1234567891011121314151617181920212223242526272829λ cnpm run dev&gt; todolist@1.0.0 dev F:\\qianduan_dir\\00program\\todolist&gt; webpack-dev-server --inline --progress --config build/webpack.dev.conf.jsmodule.js:549 throw err; ^Error: Cannot find module 'concat-map' at Function.Module._resolveFilename (module.js:547:15) at Function.Module._load (module.js:474:25) at Module.require (module.js:596:17) at require (internal/module.js:11:18) at Object.&lt;anonymous&gt; (F:\\qianduan_dir\\00program\\todolist\\node_modules\\brace-expansion\\index.js:1:79) at Module._compile (module.js:652:30) at Object.Module._extensions..js (module.js:663:10) at Module.load (module.js:565:32) at tryModuleLoad (module.js:505:12) at Function.Module._load (module.js:497:3)npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! todolist@1.0.0 dev: `webpack-dev-server --inline --progress --config build/webpack.dev.conf.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the todolist@1.0.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-20T11_51_01_114Z-debug.log 填坑：依赖包是需要重新安装的，我们需要 cnpm install 下载项目的依赖包一般来说别人的仓库文件是不会上传 node-modules 文件的，如果上传者没有把这个文件删除，我们需要先删除这个文件夹。再 cnpm install 下载项目的依赖包，重新生成正确的 node-modules 文件， 3.4.5 热更新报错 log.error(‘[WDS] Errors while compiling. Reload prevented.’)1index.js?bed3:161 [WDS] Errors while compiling. Reload prevented. WDS 其实是 ebpack-dev-serverwebpack 的意思，用来实现自动刷新的。 先看看自己的项目是不是没有 cnpm run dev ，如果已经运行，你在Vue组件进行频繁刷新时，如果没有安装 Webpack，虽然页面可以正常显示，但是控制台会在你每次刷新时就报错。解决方法是：在开发目录下安装 Webpack，命令为 npm install webpack-dev-server –save-dev 即可，安装完成之后会在 node_modules/bin 下找到。此时重新打开工程，命令为：npm run dev，即可解决热更新报错问题。 如果还是不正确那么就是创建项目的时候有了其他的错误，比如创建步骤导致的错误，重新创建一个项目目录好了。 3.4.61content.js:1 [Violation] Added non-passive event listener to a scroll-blocking &apos;touchmove&apos; event. Consider marking event handler as &apos;passive&apos; to make the page more responsive. See https://www.chromestatus.com/feature/5745543795965952 3.4.7 依赖包出错无法run123456789没有给这些选项指定值：config-name, context, entry, module-bind, module-bind-post, module-bind-pre, output-path, output-filename, output-chunk-filename, output-source-map-filename, output-public-path, output-jsonp-function, output-library, output-library-target, records-input-path, records-output-path, records-path, define, target, watch-aggregate-timeout, devtool, resolve-alias, resolve-extensions, resolve-loader-alias, optimize-max-chunks, optimize-min-chunk-size, prefetch, provide, plugin, open-pagenpm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! love@1.0.0 dev: `webpack-dev-server --inline --progress --config build/webpack.dev.conf.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the love@1.0.0 dev script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in: 有可能是 webpack 除了新版本，有 bug 了，之前的 2.10.0 版本就出现过 bug ，但是先不要考虑这个原因。 首先看下 package.json 文件中我们的 webpack 的版本。上网搜一下是不是 bug 重新安装依赖包 删除掉项目中的 node-modules 文件夹 清除缓存：npm cache clean 安装依赖：cnpm install 如果知道是版本出错，卸载版本，下载可以使用的版本。 123npm remove webpack-dev-servernpm install webpack-dev-server@2.9.1 // 这里假设是要下载 2.9.1 版本npm run dev 3.4.8 vux安装出错1234567891011121314λ npm install vux --savenpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\ajv\\node_modules\\conpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\globby\\node_modules\\object-assignnpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\globby\\node_modules\\pinkie-promisenpm ERR! path F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\ajv\\node_modules\\conpm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access &apos;F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\ajv\\node_modules\\co&apos;npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-09-30T15_57_14_849Z-debug.log 3.4.9、卸载 vue 项目中的依赖出错12$ cnpm uninstall xxx --save后者是 remove 也是一样的错误 12345678910111213λ cnpm uninstall vux --savenpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modunpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modunpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modunpm ERR! path F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\ajv\\node_modules\\conpm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access &apos;F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-09-30T16_09_50_845Z-debug.log 报错说不存在这个文件夹。怎么解决？？？？？？？ 四、框架结构详解由于版本实时更新和你选择安装的不同（这里列出的是模板为 webpack 的目录结构），所以你看到的有可能和下边的有所差别。上一章也说道，模板使用最多的就是 webpack，这章的结构也将讲解的是 webpack 模板创建初始化的项目。 123456789101112131415161718192021222324252627282930.|-- build // 项目构建 (webpack) 相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查 node、npm 等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器 //webpack.dev.conf.js // 构建本地服务器 新版本的服务器构建文件| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack 基础配置| |-- webpack.dev.conf.js // webpack 开发环境配置| |-- webpack.prod.conf.js // webpack 生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue 公共组件| |-- store // vuex 的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json 数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6 语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git 上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico //图标|-- index.html // 入口页面|-- package.json // 项目基本信息 4.1 .babelrc 文件Babel 解释器的配置文件,存放在根目录下。Babel 是一个转码器，项目里需要用它将 ES6 代码转为 ES5 代码。如果你想了解更多，可以查看 babel 的知识。 1234567891011121314151617&#123; //设定转码规则 \"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"stage-2\" ], //转码用的插件 \"plugins\": [\"transform-runtime\"], \"comments\": false, //对 BABEL_ENV 或者 NODE_ENV 指定的不同的环境变量，进行不同的编译操作 \"env\": &#123; \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], \"plugins\": [ \"istanbul\" ] &#125; &#125;&#125; 4.2 package.json 文件package.json 文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。 1234\"scripts\": &#123; \"dev\": \"node build/dev-server.js\", \"build\": \"node build/build.js\" &#125;, dependencies 字段和 devDependencies 字段 dependencies 字段指项目运行时所依赖的模块；devDependencies 字段指定了项目开发时所依赖的模块；在命令行中运行 npm install 命令，会自动安装 dependencies 和 devDempendencies 字段中的模块。 npm run build 命令后，在你的项目根目录生成了 dist 文件夹，这个文件夹里边就是我们要传到服务器上的文件。 dist 文件夹下目录包括： index.html 主页文件:因为我们开发的是单页 web 应用，所以说一般只有一个 html 文件。 js static 静态资源文件夹：里边 js、CSS 和一些图片。 CSS 4.3 .editorconfig 文件该文件定义项目的编码规范，编译器的行为会与 .editorconfig 文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。 12345678root = true [*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用 utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为 2 个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格 4.4 dev-server.js 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 检查 Node 和 npm 版本require('./check-versions')()// 获取 config/index.js 的默认配置var config = require('../config')// 如果 Node 的环境无法判断当前是 dev / product 环境// 使用 config.dev.env.NODE_ENV 作为当前的环境if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)// 使用 NodeJS 自带的文件路径工具var path = require('path')// 使用 expressvar express = require('express')// 使用 webpackvar webpack = require('webpack')// 一个可以强制打开浏览器并跳转到指定 url 的插件var opn = require('opn')// 使用 proxyTablevar proxyMiddleware = require('http-proxy-middleware')// 使用 dev 环境的 webpack 配置var webpackConfig = require('./webpack.dev.conf')// default port where dev server listens for incoming traffic// 如果没有指定运行端口，使用 config.dev.port 作为运行端口var port = process.env.PORT || config.dev.port// Define HTTP proxies to your custom API backend// https://github.com/chimurai/http-proxy-middleware// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置var proxyTable = config.dev.proxyTable// 使用 express 启动一个服务var app = express()// 启动 webpack 进行编译var compiler = webpack(webpackConfig)// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, stats: &#123; colors: true, chunks: false &#125;&#125;)// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reloadvar hotMiddleware = require('webpack-hot-middleware')(compiler)// force page reload when html-webpack-plugin template changescompiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// proxy api requests// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(context, options))&#125;)// handle fallback for HTML5 history API// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require('connect-history-api-fallback')())// serve webpack bundle output// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// serve pure static assets// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static('./static'))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; var uri = 'http://localhost:' + port console.log('Listening at ' + uri + '\\n') // when env is testing, don't need open it // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125;&#125;) 4.5 webpack.base.confg.js webpack的基础配置文件123456789101112131415161718192021222324252627282930......module.export = &#123; // 编译入口文件 entry: &#123;&#125;, // 编译输出路径 output: &#123;&#125;, // 一些解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js 文件用 babel 转码 &#123; test: /\\.js$/, loader: 'babel', include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // vue文件一些相关配置 vue: &#123;&#125;&#125; 六、解读Vue-cli的模板 工作原理 index.html：一个框架的网页入口就是根目录下的文件， //html main.js：html 文件其对应的 js 文件。 //js APP.vue 导出的组件提供，提供 main.js 引入 //html，js,CSS index.js 组件的路由设置，在 main.js 做全局引入, //js HelloWord.vue 导出的组件提供，提供 APP.vue 引入 //html，js,CSS 6.1 index.html 项目 html 入口文件12345678910111213&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;title&gt;todo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt;&lt;/html&gt; 6.2 main.js 项目 js 入口文件1234567891011121314//main.jsimport Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false //生产环境提示，这里设置成了 false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 从 main.js文件可以看出，这个文件导入了 Vue.js 之外。还有APP.vue： main.js 对应导入的组件：引进了 Ap p的组件和 App 的模板router.js：main.js 对应的路由设置文件：Vue-router 学习 6.3 APP.vue 入口文件 main.js 的导入组件模板123456789101112131415161718192021222324&lt;!-- APP.vue --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;router-view/&gt; &lt;!-- 组件通过通过这个标签插入 app.vue 中 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'App' &#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; app.vue 文件我们可以分成三部分解读， &lt;template&gt;&lt;/template&gt;标签包裹的内容：template 模板 这是模板的 HTMLDom 结构，里边引入了一张图片和&lt;router-view&gt;&lt;/router-view&gt;标签， &lt;router-view&gt;标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲 Vue-router。 router-view 标签，（vue 内部定义的一个自定义组件），他默认代表的是“/”这个路径。 更新路由路径更新的就是这个部分的内容，其他内容是不变的。 &lt;script&gt;&lt;/script&gt;标签包括的js内容： script 标签 你可以在这里些一些页面的动态效果和Vue的逻辑代码。 &lt;style&gt;&lt;/style&gt;标签包裹的css内容： style 样式标签 这里就是你平时写的 CSS 样式，对页面样子进行装饰用的， 需要特别说明的是你可以用&lt;style scoped&gt;&lt;/style&gt;来声明这些css样式只在本模板中起作用。 有 scoped 代表此模式仅用于此组件，没有 scoped 代表应用于所有的组件。 6.4 组件 .vue 创建与路由设置 index.jsrouter 文件夹下 index.js 文件 123456789101112131415import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) component 文件夹下创建其他的 .vue 文件 1234567891011121314151617181920&lt;template&gt; &lt;div id=\"xiaomi\"&gt; &#123;&#123;mag&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'HelloWorld'， data()&#123; return&#123; msg:'xiaomi' &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 6.5 其他子组件创建与路由设置component 文件夹下创建其他的 .vue 文件。并在 index.js 设置路由 与 6.4 节一样，都是创建一个 .vue 文件，然后再 router.js 中设置路由，通过 router-view 这个标签导入到其他的组件中。或者是 router-link 做页面切换。具体需要学习 vue-router 路由设置之后做更多的子组件。页面切换效果。 七、爬坑之旅7.1 vue-cli 创建的项目中 APP.vue 文件中有设置 logo 以及 margin-top: 60px这个是 vue 官方做的一个主页，自己用到的时候删除或者更新 helloworld.vue 文件，不要忘记 APP.vue 文件中也需要改写。 把不需要的 v 这个 logo 删掉， style 标签中的样式改写 12345678910&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; /*这行一定更记得删除或者*/&#125;&lt;/style&gt; 六、css 样式处理6.1 .vue 文件导入外部样式 @import1234&lt;style lang=\"scss\"&gt; @import \"assets/style/reset\"; /* 样式一般放在与 .vue 文件同级目录，这样也好操作 */ @import url(\"//at.alicdn.com/t/font_948116_ddr9s3usi5o.css\"); /* 这里是外部链接 url 导入 */&lt;/style&gt; 6.2 在 vue 项目中 css 使用 scss 或者 LESS 处理6.3 在 .vue 中同时使用 css 与 scss 或者 LESS可以在一个文件夹中使用多个 &lt;style&gt; 标签。 12345678910&lt;style scoped lang=\"scss\"&gt; @import \"admin.scss\";&lt;/style&gt;&lt;style lang=\"less\"&gt;&lt;/style&gt;&lt;style&gt; /* 不写就默认是 css */&lt;/style&gt;","tags":[]},{"title":"render 函数 在 vue 中使用","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】-render-在vue中使用.1/","text":"一、前言vue 的 render 二、render 函数2.1 工作原理/流程render 函数:生成虚拟节点 =&gt; createElement():基于虚拟节点创建 DOM 节点 =&gt; diff: 状态更新后，进行对比，生成补丁对象 =&gt; patch:遍历补丁对象生成 DOM 节点 2.2 createElement() 函数 规则111 div : 第 1 个参数必选，可以是 1 个 HTML 标签，也可以是 1 个组件或函数。必填的，标签不可以没有class=”ee”: 第 2 个是可选参数，数据对象，可以没有属性，没有特性111 第 3 个是子节点，也是可选，可以没有内容，没有元素 简单来说 第 1 个参数是 标签，第 2 个参数是属性与特性，事件等等，第 3 个参数是标签内的内容（文本或者是子标签） 123456789101112131415161718192021222324252627render: createElement =&gt; &#123; return createElement( 'div',//第 1 个参数必选，可以是 1 个 HTML 标签，也可以是 1 个组件或函数； &#123; // 第 2 个参数数据对象，可选参数 class:&#123; show:this.show &#125;,//v-bind:class style:&#123; // &#125; // 当然这里不只是这些，还有很多属性，参照 2.3 节 &#125;, [ // 第 3 个是子节点，子节点 array 数组，可选参数，也是用 createElement() 函数构造的 createElment('h1','hello world'), createElment(MyComponent,&#123; props:&#123; someProp:'foo' &#125; &#125;), 'bar'// 这个是什么子节点啊 指的是&lt;div&gt;&lt;/div&gt; 中的内容，文本，或者是其他的子标签 // 这里的意思是 div 标签中有 一个 h1 标签，一个 MyComponent 子组件 还有直接文本 bar ] )&#125;// 这里的 render 函数中创建的虚拟跟节点是 一个 div 123456&lt;!-- 得到的普通 DOM 效果如下代码--&gt;&lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;MyComponent :someProp='foo'&gt;&lt;/MyComponent&gt; bar&lt;/div&gt; 2.3 createElement() 函数 3 个参数完整的值情况/ h() 是 createElement() 的简写。 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 h 失去作用，在应用中会触发报错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145render:(h,params) =&gt; &#123;//如果有传参，带上 params return h( \"div\",// 这里是根 div 也就是 第 1 个参数 11111111111111111111111111111111111111111111111111111111111111111111111 //'h' + this.level, //若 level 为 1 则是 h1 标签 11111111111111111111111111111111111111111111111111111111111111111111 &#123; // 这里是 div 的 属性与特性，也就是 第 2 个参数 22222222222222222222222222222222222222222222222222222222222222222222222222 完整 key:'myKey' , //string | number //节点的 key 属性，用于作为节点的标识，有利于 patch 的优化 slot:'name-of-slot', //string 如果组件是其他组件的子组件，需为插槽指定名称 scopedSlots:&#123; // 作用域插槽格式 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; default: props =&gt; createElement('span', props.text)//&#123;[key:string],ScopedSlot&#125; &#125;, ref:'myRef',//如果你在渲染函数中向多个元素都应用了相同的 ref 名，那么 `$refs.myRef` 会变成一个数组 refInFor: true, tag:'',//当前节点的标签名 staticClass:'', class:&#123; //和`v-bind:class`一样的 API，接收一个字符串、对象或字符串和对象组成的数组 foo: true,// 任何类型数据 bar: false, 'show':this.show &#125;, staticStyles:&#123;&#125;,//&#123;[key:string],any&#125; style:&#123; //和`v-bind:style`一样的 API，接收一个字符串、对象或对象组成的数组 color: 'red', fontSize: '14px',// object[],object // 具体，因为 render 函数是 js 中的，css 中的样式连接转成 驼峰形式 \"margin-bottom\": \"10px\"// 在 iview-ui 组件中试了，这样引号引起来也可以做到的 &#125;, props:&#123; someProp:'foo'//&#123;[key:string],any&#125; 组件 props &#125;, attrs:&#123; id:'idName',//&#123;[key:string],any&#125; 普通的 HTML 特性 name: headingId, href: '#' + headingId, 'id':'element', style: \"margin-bottom:10px\"// style 也是一个 attrs 也可以写在 attrs 里面的 &#125;, domProps:&#123; // DOM 属性 innerHTML: 'baz'//&#123;[key:string],any&#125; &#125;, hook:&#123;&#125;,//&#123;[key:string],func&#125; on:&#123; //事件监听器基于 `on`，所以不再支持如 `v-on:keyup.enter` 修饰器，需要手动匹配 keyCode。 click: this.clickHandler//&#123;[key:string],func,func[]&#125; click: () =&gt; &#123; this.remove(params.index) &#125; &#125;, nativeOn:&#123; //仅用于组件，用于监听原生事件，而不是组件内部使用，`vm.$emit` 触发的事件。 click: this.nativeClickHandler//&#123;[key:string],func,func[]&#125; &#125;, transition:object, show:true,// boolean inlineTemplate:&#123; render:function()&#123;&#125;, staticRenderFns:function[] &#125;, directives: [ // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` 赋值，因为 Vue 已经自动为你进行了同步。 //VNodeDirective[] &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], keepAlive:true //boolean on: &#123; onOk: this.changeDesc() // render 中的确认回调这样写 &#125; &#125;, [ // 这里是 div 标签内的 文本或者是子元素,也就是第 3 个元素 [子元素可以与很多，因此是 [] 这个括号包裹起来]333333333333333333333333333333 h( 'h' + this.level, //若 level 为 1 则是 h1 标签 1111111111111111111111111111111111111111111111111111参考上面的1111111111 ) h( \"div\",//第 1 个参数 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 &#123; //第 2 个参数 222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222 style: &#123; \"margin-bottom\": \"10px\"// 或者写成 marginBottom: \"10px\" &#125; &#125;, `项目名称: $&#123;data.name&#125;`//第 3 个参数 333333333333333333333333333333333333333333333333333333 ), h(\"div\", `创建时间: $&#123;data.create_at&#125;`), // 按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮，按钮， h('Button', &#123; props: &#123; type: 'error', size: 'small' &#125;, style: &#123; marginRight: '5px' &#125; on: &#123; click: () =&gt; &#123; this.remove(params.index) &#125; &#125; &#125;, '删除' ), // icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon，icon， h('Icon', &#123; props: &#123; type: 'person' &#125; &#125; ), // render 中使用 input 元素，并且实现双向绑定 input,input,input,input,input,input,input,input,input,input,input,input,input,i h(\"label\", `项目描述：`), h( \"Input\", &#123; props: &#123; type: \"textarea\", value: data.desc// input 的双向绑定 &#125;, on: &#123; \"on-blur\": event =&gt; &#123; data.desc = event.target.value;//input 的上相绑定 &#125; &#125; &#125; ) ] );&#125; 12345678910111213141516171819202122232425262728293031//render 函数组件vue.component('ele',&#123; render:function(createElement)&#123; return createElement( 'div', &#123; class:&#123; 'show':this.show &#125;, attrs:&#123; 'id':'element', style: \"margin-bottom:10px\" &#125;, on:&#123; click:this.handleClick &#125; &#125;, '文本内容' ) &#125;, data:function()&#123; return&#123; show:true &#125; &#125;, methods:&#123; handleClick()&#123; // &#125; &#125;&#125;) 4.3.5 完整示例12345678910111213141516171819202122232425262728293031323334353637var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join('')&#125;Vue.component('anchored-heading', &#123; render: function (createElement) &#123; // 创建 kebab-case 风格的ID var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^\\-|\\-$)/g, '') //返回一个 createElement 构建的虚拟 DOM return createElement( 'h' + this.level,//第一个参数 [//第二个参数 createElement('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 二、Node 节点 与 VNode 虚拟节点2.1 普通 DOM 节点与 虚拟 DOM 节点123456&lt;!-- 普通 DOM --&gt;&lt;div id=\"main\"&gt; &lt;p&gt;111&lt;/p&gt; &lt;p&gt;222&lt;/p&gt; 333&lt;/div&gt; 123456789101112/* 虚拟 DOM */var vnode=&#123; tag:'div', attributes:&#123; id:'main' &#125;, children:[ &#123;tag:'p','111'&#125;, &#123;tag:'p','222'&#125;, '333' ],&#125; 2.2 vue 中的 vnode 虚拟节点tag：当前节点的标签名data：当前节点的数据对象（下⼀页）children：⼦节点，数组，也是 VNode 类型text：当前节点的⽂本，⼀般⽂本节点或注释节点会有该属性elm：当前虚拟节点对应的真实的 DOM 节点ns：节点的 namespacecontent：编译作⽤域functionalContext： 函数化组件的作⽤域key：节点的key属性，⽤于作为节点的标识，有利于 patch 的优化componentOptions：创建组件实例时会⽤到的选项信息child：当前节点对应的组件实例parent：组件的占位节点raw：原始 htmlisStatic：静态节点的标识isRootInsert：是否作为根节点插被 &lt;transition&gt; 包裹的节点，该属性的值为falseisComment：当前节点是否是注释节点isCloned：当前节点是否为克隆节点isOnce：当前节点是否有 v-once 指令 123456789101112131415161718192021/* 源码中 VNode 的定义 */export interface VNode&#123; tag：//当前节点的标签名 data：//当前节点的数据对象（下一页） children//节点，数组，也是 VNode 类型 text：//当前节点的文本，一般文本节点或注释节点会有该属性 elm：//当前虚拟节点对应的真实的 DOM 节点 ns：//节点的 namespace content：//编译作用域 functionalContext： //函数化组件的作⽤域 key：//节点的key属性，用于作为节点的标识，有利于 patch 的优化 componentOptions：//创建组件实例时会用到的选项信息 child：//当前节点对应的组件实例 parent：//组件的占位节点 raw：//原始 html isStatic：//静态节点的标识 isRootInsert：//是否作为根节点插入，被 &lt;transition&gt; 包裹的节点， 该属性的值为false isComment：//当前节点是否是注释节点 isCloned：//当前节点是否为克隆节点 isOnce：//当前节点是否有 v-once 指令&#125; 六、约束6.1 VNodes 必须唯一所有的组件树中，如果 VNode 是组件，或含有组件的 slot，那 VNode 必须唯一 6.2 组件的复用123456789101112131415161718//局部声明组件,&lt;div id=\"app\"&gt; &lt;ele&gt;&lt;/ele&gt;&lt;/div&gt;var Child=&#123; render:function(createElement)&#123; return createElement('p','text') &#125;&#125;vue.component('ele',&#123; render:function(createElement)&#123; var ChildNode = createElement(Child) return createElement('div', ChildNode, //这里的做法是错误，因为组件重复了xxxxxxxxxxxxx ChildNode ) &#125;&#125;) 1234567891011121314151617//局部声明组件，我们可以哟弄 map 遍历的办法var Child=&#123; render:function(createElement)&#123; return createElement('p','text') &#125;&#125;vue.component('ele',&#123; render:function(createElement)&#123; return createElement('div', Array.apply(null,&#123; // 对的，√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√ length:5 &#125;).map(function()&#123; return createElement(Child) &#125;) ) &#125;&#125;) Array.apply() 函数与 ES6 的 Array.from() 有点类似.apply() 的第一个参数是对象，第二个参数是数组，作为参数列表。{length: 5} 就可以看作一个类数组对象，长度是 5，每个元素，比如 v[0]是 undefined。所以Array.apply(null, { length: 5}) 相当于Array(undefined, undefined, undefined, undefined, undefined) 既然已经到了 ES6 了，那么我们还是用 Array.from() 方法比较好, Array.from() 123456Array.from(&#123; length: 3 &#125;); //[ undefined, undefined, undefined ]// 这个方案只需要一个参数就可以了，不需要再用 null 了，//当然Array.from() 方法可以有第 2 个参数，就是对 第一个参数中 的每个值进行遍历。就类似 .map Array.from(arrayLike, x =&gt; x * x); // Array.from() 方法的 第 2 个参数Array.from(arrayLike).map(x =&gt; x * x); // 数组的 map() 方法 如果用的是 Array.from 上面的 render 函数可以修改如下。 12345678910111213//局部声明组件，我们可以哟弄 map 遍历的办法var Child=&#123; render:function(createElement)&#123; return createElement('p','text') &#125;&#125;vue.component('ele',&#123; render:function(createElement)&#123; return createElement('div', Array.from(&#123;length:5&#125;,()=&gt;createElement(Child))// 对的，√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√ ) &#125;&#125;) 6.3 slot 的克隆1234567891011121314151617181920212223242526272829 &lt;!-- 错误做法,因为 slot 包含了组件，并且重复了 --&gt;&lt;div id='app'&gt; &lt;ele&gt; &lt;div&gt; &lt;Child&gt;&lt;/Child&gt; &lt;/div&gt; &lt;/ele&gt;&lt;div&gt;&lt;script&gt; // 全局 vue.component('Child',&#123; // 错的 render:function(createElement)&#123; return createElement('p','text') &#125; &#125;) vue.component('ele',&#123; render:function(createElement)&#123; return createElement('div', [ this.$slots.defalut,// 错的 this.$slots.defalut ] ) &#125; &#125;) var app = new Vue(&#123; el:'#app' &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233// 正确的做法vue.component('ele',&#123; render:function(createElement)&#123; // 克隆 slot 的节点方法 function cloneVNode(VNode)&#123; // 递归遍历所有的子节点并且克隆 const clonedChildren = VNode.children &amp;&amp; VNode.children.map(function(vnode)&#123; return cloneVNode(vnode) &#125;) const cloned = createElement( vnode.tag, vnode.data, clonedChildren ) cloned.text = vnode.text //当前节点的文本，一般文本节点或注释节点会有该属性 cloned.isComment= vnode.isComment////当前节点是否是注释节点 cloned.componentOptions= vnode.componentOptions//创建组件实例时会用到的选项信息 cloned.elm= vnode.elm//当前虚拟节点对应的真实的 DOM 节点 cloned.context= vnode.context cloned.ns= vnode.ns//节点的 namespace cloned.isStatic= vnode.isStatic//静态节点的标识 cloned.key= vnode.key//节点的key属性，用于作为节点的标识，有利于 patch 的优化 return cloned &#125; const vNodes = this.$slots.default const clonedVNnodes = vNodes.map(function(vNode)&#123; return createElement('div',[ vNodes, clonedVNnodes ]) &#125;) &#125;&#125;) 七、 使用 js 代替模板功能在 Render 函数中，没有指令，一切都可以⽤用 JS 来实现。就是说 v-if，v-else，wx-if，wx-for 这样的指令在 render 函数中是不存在的，v-if，v-else，wx-if ：在 render 函数中 js 代码就是 if…else 语句来的，v-for，wx-for：在 render 函数中 js 代码就是 map 遍历来做的 7.1 v-if，v-else，wx-if123456789101112131415161718192021222324252627282930&lt;div id='app'&gt; &lt;ele :show='show'&gt;&lt;/ele&gt; &lt;!-- 这里是 ele 子组件 --&gt; &lt;button @click='show = !show'&gt;切换 show&lt;/button&gt;&lt;div&gt;&lt;script&gt;//在 ele 这个组件中创建 子组件 vue.component('ele',&#123; render:function(createElement)&#123; if(this.show)&#123; return createElement('p','show 的值为 true') &#125;else&#123; return createElement('p','show 的值为 false') &#125; &#125;, props:&#123; // 这是从 app 组件传来的 show 值 props 传值 show:&#123; type:Boolean, defalut:false &#125; &#125; &#125;) var app = new Vue(&#123; el:'#app', data:&#123; show:&#123; show:false &#125; &#125; &#125;)&lt;/script&gt; 7.2 v-for,wx-for1234567891011121314151617181920212223242526&lt;div id='app'&gt; &lt;ele :list='list'&gt;&lt;/ele&gt; &lt;!-- 这里是 ele 子组件 --&gt;&lt;div&gt;&lt;script&gt; vue.component('ele',&#123; render:function(createElement)&#123; var nodes = [] var n = this.list.length for(var i =0;i&lt;n;i++)&#123; nodes.push(createElement('p',this.list[i]) &#125; return createElement('div',nodes) &#125;, props:&#123; // 这是从 app 组件传来的 show 值 props 传值 list:&#123; type:Array, &#125; &#125; &#125;); var app = new Vue(&#123; el:'#app', data:&#123; list:['xiaomi','liuliu','meimei'] &#125; &#125;)&lt;/script&gt; 7.3 v-if 与 for 结合1234567891011121314151617181920212223242526272829303132&lt;div id='app'&gt; &lt;ele :list='list'&gt;&lt;/ele&gt; &lt;!-- 这里是 ele 子组件 --&gt;&lt;div&gt;&lt;script&gt;//在 ele 这个组件中创建 子组件 vue.component('ele',&#123; render:function(createElement)&#123; var n = this.list.length if(n)&#123; return createElement('ul',this.list.map(function(item)&#123; return createElement('li',item) &#125;)) &#125;else&#123; return createElement('p','列表为空') &#125; &#125;, props:&#123; // 这是从 app 组件传来的 show 值 props 传值 list:&#123; type:Array, defalut:function()&#123; return [] &#125; &#125; &#125; &#125;); var app = new Vue(&#123; el:'#app', data:&#123; list:['xiaomi','liuliu','meimei'] &#125; &#125;)&lt;/script&gt; 7.4 v-model1234567891011121314151617181920212223vue.component('ele',&#123; render:function(createElement)&#123; var that = this return createElement('div',[ createElement('input',&#123; domProps:[ value:this.value ], on:&#123; input:function(e)&#123; than.value = e.target.value &#125; &#125; &#125;), createElement('p','value:'+ this.value) ]) &#125;, data:function()&#123; return:&#123; value:'' &#125; &#125; &#125;) 八、render 事件修饰符123456.stop =&gt; event.stopPropagation().prevent =&gt; event.preventDefault().self =&gt; if(event.target !== event.currentTarget) return.enter / .13 =&gt; if(event.keyCode !== 13) return # 替代 13 位 需要的 keyCode.ctrl/.alt/.shift/.mata =&gt; if(!event.ctrlKey) return# 根据需要替换 ctrlKey 为 ctrlKey 或 altKey 又或者 shiftKey ，再或者 mataKey 8.1 事件修饰前缀123.capture =&gt; !.once =&gt; ~.capture.once/.once.capture =&gt; ~! 12345on:&#123; '!click':this.doThisInCapturingMode, // 发生在捕获阶段的事件函数 '~keyup':this.doThisOnce,//按键执行一次 '~!mouseover':this.doThisOnce,//鼠标经过捕获阶段执行一次&#125; 九、插槽 slot插槽分为， 单个插槽 ：内容由父组件决定 （不传值） 静态插槽 &lt;Child&gt;333333&lt;/Child&gt; ` &lt;slot&gt;&lt;/slot&gt; ` 具名插槽 ：内容由父组件决定 （不传值） 静态插槽 111 222 333 ` &lt;slot name=&apos;header&apos;&gt;&lt;/slot&gt; &lt;slot name=&apos;body&apos;&gt;&lt;/slot&gt; &lt;slot name=&apos;footer&apos;&gt;&lt;/slot&gt; ` 作用域插槽：内容由子组件决定（子组件绑定传值给父组件） 作用域插槽 &lt;Child scoped-slot=&#39;props&#39;&gt;&lt;/Child&gt; ` &lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt; ` 9.1 this.$slots 访问 静态插槽 的内容可以通过 this.$slots 访问 静态插槽 的内容，得到的是一个 VNodes 数组： 1234567render: function (createElement) &#123; //返回 `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement( 'div', this.$slots.default )&#125; 9.2 this.$scopedSlots 访问作用域插槽 scoped-slot = ‘props’this.$scopedSlots 访问 作用域插槽，得到的是一个返回 VNodes 的函数： 123456789101112props: ['message'],render: function (createElement) &#123; //返回 `&lt;div&gt;&lt;slot :text=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement( 'div', [ this.$scopedSlots.default(&#123; text: this.message &#125;) ] )&#125; 123456789101112131415161718192021222324252627282930//用 渲染函数 向子组件 中 传递作用域插槽 参见 4.3.4render: function (createElement) &#123; return createElement( 'div', [ createElement( 'child', &#123; // 在数据对象中传递 `scopedSlots` // 格式：&#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement( 'span', props.text ) &#125; &#125; &#125; ) ] )&#125;//上面返回的 html 如下&lt;div&gt; &lt;child scoped-slot='props'&gt; &lt;span&gt;&#123;&#123;props.text&#125;&#125;&lt;/span&gt; &lt;/child&gt;&lt;/div&gt; 9.3 slot 默认内容this.$slot.default = undefined,说明父组件中没有定义 slot ，这时可以自定义显示的内容。 123456789101112131415161718192021&lt;div id='app'&gt; &lt;ele :list='list'&gt;&lt;/ele&gt; &lt;ele&gt; &lt;p&gt;slot 的内容，这里 ele 组件插槽里面是有这段 p 标签的内容的&lt;/p&gt; &lt;/ele&gt;&lt;div&gt;&lt;script&gt;//在 ele 这个组件中创建 子组件 vue.component('ele',&#123; render:function(createElement)&#123; if(this.$slot.default)&#123; return createElement('div','没有使用 slot 时 显示的文本') &#125;else&#123; return createElement('div','this.$slot.default') &#125; &#125; &#125;); var app = new Vue(&#123; el:'#app' &#125;)&lt;/script&gt; 十、函数式组件Vue.js 提供了 1 个 functional 的布尔值选项，设置为 true 可以使组件无状态和无实例，也就是没有data 和 this 上下文，这样用render 函数返回虚拟节点可以更容易渲染，因为函数化组件只是 1 个函数，渲染开销要⼩很多。 使用函数化组件时，Render 函数提供了第 2 个参数 context 来提供临时上下文，组件需要的 data、props、slots、children、parent 都是通过这个上下文 来传递，比如 this.level 要改写为context.props.level，而 this.$slots.default 改写为 context.children。 十二、vue.js 中 的 render ~~~~~~~~~~1234567891011121314151617181920212223242526272829303132333435363738394041424344// 直接使用 h() 方法构建 虚拟 DOMrender: (h, params) =&gt; &#123; return h(\"ButtonGroup\", [ h( \"Button\", &#123; props: &#123; type: \"info\", icon: \"ios-analytics\" &#125;, on: &#123; click: () =&gt; &#123; this.showDetail(params.index); &#125; &#125; &#125;, \"详情\" ), h( \"Button\", &#123; props: &#123; type: \"error\", icon: \"ios-trash\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.index); &#125; &#125; &#125;, \"删除\" ) ]);&#125;// 直接使用 h() 方法构建 虚拟 DOM// 触发事件/*on: &#123; click: () =&gt; &#123; this.showDetail(params.index); &#125;&#125;*/ 12345678910111213141516171819202122232425// return 中写的是 html 片段render: (h, params) =&gt; &#123; return ( &lt;ButtonGroup size=\"default\"&gt; &lt;Button type=\"success\" icon=\"md-create\" onClick=&#123;() =&gt; &#123; this.handleClickEditRobot(params.row) &#125;&#125;&gt;&lt;/Button&gt; &lt;Button type=\"warning\" disabled=&#123;params.row.status === '掉线'&#125; icon=&#123;params.row.status === '运行中' ? 'ios-pause' : 'ios-play'&#125; onClick=&#123;() =&gt; &#123; this.handleClickPlayOrPause(params.row) &#125;&#125;&gt;&lt;/Button&gt; &lt;Button type=\"error\" icon=\"ios-trash\" onClick=&#123;() =&gt; &#123; this.handleClickDelete(params.row) &#125;&#125;&gt;&lt;/Button&gt; &lt;/ButtonGroup&gt; )&#125;// return 中写的是 html 片段// 触发事件/*onClick=&#123;() =&gt; &#123; this.handleClickEditRobot(params.row)&#125;&#125; */// 通过一对花括号来写一个函数片段在里面!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!值得学习。 10.2 上传1234567891011121314151617181920'h('Upload', &#123; props: &#123; action: 'http://hete-api.gofoer.com/v1/file?sid=' + this.data1[params.index].id, showUploadList: false, onSuccess: () =&gt; &#123; this.$Message.success(\"数据文件添加成功！\") &#125;, onError: () =&gt; &#123; this.$Message.error(\"添加失败！\") &#125; &#125;&#125;, [ h('Button', &#123; props: &#123; type: 'success', size: 'small' &#125;, style: &#123;&#125; &#125;, '添加文件')])","tags":[]},{"title":"react.js--[react-router v4 (react-router-dom) 路由]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-react-router v4 【react router dom】 路由/","text":"一、前言react.js 是 单页应用，页面切换需要依靠 路由。 github 官方npm 官方中文文档 二、React Router V4 讲解React Router V4 于 17 年 3 月升级，本次升级 React Router V4 吸取了 React 的理念：所有的东西都是 Component。因此 升级之后的 Route、Link、Switch……等都是一个普通的组件。 React Router V4 基于 Lerna 管理多个 Repository。在此代码库包括： 12345- react-router React # Router 路由的核心功能- react-router-dom # 用于 DOM 绑定的 React Router!!!!!!!!!!!!!!!!!!!!!!!!!!!! DOM bindings for React Router- react-router-native # 用于 React Native 的 React Router- react-router-redux # React Router 和 Redux 的集成- react-router-config # 静态路由配置帮助助手 React Router V4 中文文档 2.1 react-router 和 react-router-dom 还有 react-router-native 的区别区别网址区别网址 react-router 实现了路由的核心功能react-router-dom基于react-router，加入了在浏览器运行环境下的一些功能， Link 组件，会渲染一个 a 标签，Link 组件源码 a 标签行; BrowserRouter 和 HashRouter 组件，前者使用 pushState 和 popState 事件构建路由，后者使用 window.location.hash 和 hashchange 事件构建路由。 react-router-dom 依赖 react-router，所以我们使用 npm 安装依赖的时候，只需要安装相应环境下的库即可，不用再显式安装 react-router。基于浏览器环境的开发，只需要安装 react-router-dom； 安装了 react-router-dom，npm 会解析并安装上述依赖包。可以看到，其中包括 react-router。react-router-native 基于react-router，类似 react-router-dom，加入了 eact-native 运行环境下的一些功能。 基于 react-native 环境的开发，只需要安装 react-router-native 。npm 会自动解析 react-router-dom 包中 package.json 的依赖并安装。 二、安装引入2.1 npm 安装、引入网址 1234# $ npm install -S react-router # npm 安装法# $ yarn add react-router # yarn 安装法# 以前是上面的方法安装的，但是 v4 版本之后就升级了，是安装 react-router-dom ，因为 react-router 不需要显示的安装了$ npm install --save react-router-dom # 这样安装时候也已经包含了 react-router 2.3 create-react-app 2.0 项目示例!!!!!!!!!!!!!!!!！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！2.3.1 React Router 4.0 之前 （现在不是这样用了…….）12345678910111213141516// src/App.js！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！// React Router 4.0 之前 路由可以单独的写在一个文件里面，其他页面不需要设置 Route ，但是现在不可以这样了// 但是现在使用的是 4.0 + 版本的，不再是这样嵌套路由的写法了，而是将子路由写在对应的 子组件里面。&lt;Router&gt; &lt;div className=\"App\"&gt; &lt;div&gt; 一些导航条或者是其他的上面 html 文档 &lt;/div&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/login\" component=&#123;Login&#125; /&gt; &lt;Route path=\"/groups\" components=&#123;Groups&#125; /&gt; &#123;/* 1 级路由 */&#125; &lt;Route path=\"/users\" components=&#123;Users&#125;&gt; &#123;/* 1 级路由 */&#125; &lt;Route path=\"/users/:userId\" component=&#123;Profile&#125; /&gt;&#123;/* 2 级路由 */&#125; &lt;/Route&gt; &lt;/div&gt;&lt;/Router&gt; 2.3.1 React Router 4.0+（现在这样用）4.0以后，嵌套的路由 与 之前 的就完全不同了，需要单独放置在嵌套的根 component 中去处理路由，否则会一直有警告。 warning:You should not use &lt;Route component&gt; and &lt;Route children&gt; in the same route 123456789101112131415161718192021222324252627282930313233343536// src/App.js！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！// 根组件import React, &#123; Component &#125; from 'react';/* import logo from '../assets/logo.svg'; *///import BasicExample from '../router/BasicExample/BasicExample';import Home from '../views/Home/Home';import Login from '../views/Login/Login';import './App.scss';import &#123; BrowserRouter as Router, Route/* , Link */&#125; from 'react-router-dom'//导入路由插件，组件class App extends Component &#123; render() &#123; return ( // router react 4.0 之后，多级路由嵌套不再是 写在一个单独文件里面 而是在 每个需要路由的组件中去配置 // App.js 根组件 配置 1 级路由，首先是需要一个 &lt;Router&gt; 标签来包裹 &lt;Router&gt; &lt;div className=\"App\"&gt; &lt;div&gt; 一些导航条或者是其他的上面 html 文档 &lt;/div&gt; &lt;Route path=\"groups\" components=&#123;Groups&#125; /&gt; &#123;/* 1 级路由 */&#125; &lt;Route path=\"users\" components=&#123;Users&#125;&gt; &#123;/* 1 级路由 */&#125; &#123;/*&lt;Route path=\"users/:userId\" component=&#123;Profile&#125; /&gt; 2 级路由 不能在这里设置了， 而是应该到 Users 组件里面去设置*/&#125; &lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 123456789101112//Users.js// 这里不需要 router 标签包裹了 &lt;div&gt; &lt;div className=\"left\"&gt; &lt;Link to=\"/user/\"&gt;个人中心&lt;/Link&gt; &lt;Link to=\"/user/info\"&gt;用户信息&lt;/Link&gt; &lt;Link to=&#123;`$&#123;this.props.match.params.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/div&gt; &lt;Route exact path=\"/user/\" component=&#123;Main&#125; /&gt; &lt;Route path=\"/user/info\" component=&#123;Info&#125; /&gt; &lt;Route path=&#123;`$&#123;this.props.match.params.url&#125;/:userId`&#125; component=&#123;Profile&#125;/&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//Home 组件import React, &#123; Component &#125; from 'react';import './Home.scss';import &#123; Input,List,Button &#125; from 'antd';class Home extends Component &#123; constructor()&#123; super() this.state=&#123; title:'待办列表', list:[], value:'', completeList:[] &#125; /* this.addList=this.addList.bind(this) */ &#125;/* static getDerivedStateFromProps(nextProps, prevState)&#123; // &#125; */ componentDidMount() &#123; this.getLocaleData() &#125; getLocaleData=()=&gt;&#123; this.setState(&#123; list:JSON.parse(localStorage.getItem('todoList'))||[], completeList:JSON.parse(localStorage.getItem('completeList'))||[] &#125;) &#125; setLocaleData=()=&gt;&#123; localStorage.setItem('todoList',JSON.stringify(this.state.list||[])) localStorage.setItem('completeList',JSON.stringify(this.state.completeList||[])) &#125; getValue = (e)=&gt;&#123; this.setState(&#123; value:e.target.value &#125;) &#125; addList = ()=&gt;&#123; let value = this.state.value if(value)&#123; let newList = this.state.list newList.push(value)//返回值是 索引值 this.setState(&#123; list: newList,//这里一定是这样修改值，才行，与 vue 是有区别的，this.setState 类似程序 value: ''// 如何做到添加之后 value 为空啊？？？？？、 &#125;) this.setLocaleData() &#125; &#125; complete=(index,e)=&gt;&#123; /* console.log(e,'9999',index) */ let newList = this.state.list let completeList = this.state.completeList let value = newList.splice(index,1)//返回被删除的元素 completeList.push(value) this.setState(&#123; list: newList,//这里一定是这样修改值，才行，与 vue 是有区别的，this.setState 类似程序 completeList:completeList &#125;) this.setLocaleData() &#125; del=(index,e)=&gt;&#123; let completeList = this.state.completeList completeList.splice(index,1) this.setState(&#123; completeList:completeList &#125;) this.setLocaleData() &#125; render() &#123; return ( &lt;div className=\"Home\"&gt; &lt;p&gt;&#123;this.state.title&#125;&lt;/p&gt; &lt;Input placeholder=\"请输入待办事项\" addonAfter=&#123;&lt;Button type=\"primary\" ghost onClick=&#123;this.addList&#125;&gt;添加待办&lt;/Button&gt;&#125; size=\"large\" value=&#123;this.state.value&#125; onChange=&#123;(e)=&gt; this.getValue(e)&#125; onPressEnter = &#123;this.addList&#125; /&gt; &lt;br/&gt; &lt;br/&gt; &lt;List header=&#123;&lt;div&gt;待办列表&lt;/div&gt;&#125; /* footer=&#123;&lt;div&gt;Footer&lt;/div&gt;&#125; */ bordered dataSource=&#123;this.state.list&#125; renderItem=&#123;(item,index) =&gt; (&lt;List.Item actions=&#123;[&lt;Button size='small' onClick = &#123;(e)=&gt;this.complete(index,e)&#125;&gt;完成&lt;/Button&gt;]&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125; /&gt; &lt;br/&gt; &lt;br/&gt; &lt;List header=&#123;&lt;div&gt;已完成列表&lt;/div&gt;&#125; /* footer=&#123;&lt;div&gt;Footer&lt;/div&gt;&#125; */ bordered dataSource=&#123;this.state.completeList&#125; renderItem=&#123;(item,index) =&gt;(&lt;List.Item actions=&#123;[&lt;Button size='small' onClick = &#123;(e)=&gt;this.del(index,e)&#125;&gt;删除&lt;/Button&gt;] &#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 123456789101112131415161718192021//Login 组件import React, &#123; Component &#125; from 'react';import './Login.scss';class Login extends Component &#123; constructor()&#123; super() this.state=&#123; title:'欢迎使用待办列表APP' &#125; &#125; render() &#123; return ( &lt;div className=\"Login\"&gt; &lt;tag&gt;&#123;this.state.title&#125;&lt;/tag&gt; &lt;/div&gt; ); &#125;&#125;export default Login; 三、工作原理3.1 路由器(Router)在你开始项目前，你需要决定你使用的路由器的类型。对于网页项目，存在 &lt;BrowserRouter&gt; 与 &lt;HashRouter&gt;两种组件。当存在服务区来管理动态请求时，需要使用 &lt;BrowserRouter&gt; 组件，而 &lt;HashRouter&gt; 被用于静态网站。 通常，我们更倾向选择 &lt;BrowserRouter&gt;，但如果你的网站仅用来呈现静态文件，那么 &lt;HashRouter&gt;将会是一个好选择。 对于我们的项目，将设将会有服务器的动态支持，因此我们选择 &lt;BrowserRouter&gt; 作为路由器组件。肯定现在做的都是需要服务器的。 渲染 &lt;Router&gt; 路由器组件无法接受两个及以上的子元素。基于这种限制的存在，创建一个 &lt;App&gt; 组件来渲染应用其余部分是一个有效的方法（对于服务端渲染，将应用从 router 组件中分离也是重要的）。 12345678//index.jsimport &#123; BrowserRouter &#125; from 'react-router-dom'ReactDOM.render(( // App 组件要包裹在 BrowserRouter 组件里面。 &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt;), document.getElementById('root')) 123456789101112131415161718192021222324252627282930313233343536// 实际项目中，通常不是上面那样来包裹 App 组件，而是下面这样来包裹的， 其实都是一样的。// 习惯上是这样来的做的， router-react v4 官网也是这样来做的。//App.jsimport &#123; BrowserRouter as Router,// 这里就是引入我们的 `&lt;BrowserRouter&gt;` 然后使用 Router 简写!!!!!!!!!!!!!!!!!!!!!!!1 Route/* , Link */&#125; from 'react-router-dom'//导入路由插件，组件class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &#123;/* 在这个根组件，要有个 路由器 组件来包裹 */&#125; &lt;div className=\"App\"&gt; &lt;AuthButton/&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/public\"&gt;公开页面&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/protected\"&gt;非公开页面&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/public\" component=&#123;Public&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &lt;PrivateRoute path=\"/protected\" component=&#123;Protected&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App;// 通常都是这样来做成一个布局把。具体都是栏自己的项目页面的需求了/*&lt;div&gt; &lt;Header /&gt; &lt;Main /&gt;&lt;/div&gt; */ 3.2 历史(History)每个路由器都会创建一个 history 对象并用其保持追踪当前 location 并且在有变化时对网站进行重新渲染。这个 history 对象保证了 React Router提供的其他组件的可用性，所以其他组件必须在 router 内部渲染。一个 React Router 组件如果向父级上追溯却找不到 router 组件，那么这个组件将无法正常工作。 123456789// [1] locations 是一个含有描述 URL 不同部分属性的对象：// 一个基本的 location 对象&#123; pathname: '/', search: '', hash: '', key: 'abc123', state: &#123;&#125;&#125; 3.3 路由(Route)&lt;Route&gt; 组件是 React Router 中主要的结构单元。在任意位置只要匹配了URL 的路径名 (pathname) 你就可以创建 元素进行渲染。 3.4 路径(Path)&lt;Route&gt; 接受一个数为 string 类型的 path，该值路由匹配的路径名的类型。 12345678910// 当路径名为'/'时, path不匹配// 当路径名为'/roster'或'/roster/2'时, path匹配&lt;Route path='/roster'/&gt;// 当你只想匹配'/roster'时，你需要使用\"exact\"参数// 则路由仅匹配'/roster'而不会匹配'/roster/2'&lt;Route exact path='/roster'/&gt;// 注意：在匹配路由时，React Router 只关注 location 的路径名。当 URL 如下时：// http://www.example.com/my-projects/one?extra=false// React Router 去匹配的只是 '/my-projects/one' 这一部分。 注：你可以渲染无路径的 &lt;Route&gt;，其将会匹配所有 location。此法用于访问存在上下文中的变量与方法。????例如：&lt;Route path=&#39;/roster&#39;/&gt; 会匹配以 /roster[注2] 开头的路径名。[2] 在当前 path 参数与当前 location 的路径相匹配时，路由就会开始渲染 React 元素。若不匹配，路由不会进行任何操作[注3]。[3] 如果你使用 children 参数，即便在当前 location 不匹配时 route 也将进行渲染。?????? 3.4.1 匹配路径**????说的什么玩意path-to-regexp 包用来决定 route 元素的 path 参数与当前 location 是否匹配。它将路径字符串编译成正则表达式，并与当前 location 的路径名进行匹配比较。除了上面的例子外，路径字符串有更多高级的选项，详见 [path-to-regexp文档]。当路由地址匹配成功后，会创建一个含有以下属性的match对象： url ：与当前 location 路径名所匹配部分path ：路由的地址isExact ：path 是否等于 pathnameparams ：从 path-to-regexp 获取的路径中取出的值都被包含在这个对象中(传递的参数) 使用 route tester 这款工具来对路由与 URL 进行检验。 注意：本例中路由路径仅支持绝对路径[注4]。//[4] 当需要支持相对路径的 &lt;Route&gt; 与 &lt;Link&gt; 时，你需要多做一些工作。相对 将会比你之前看到的更为复杂。// 因其使用了父级的 match 对象而非当前 URL 来匹配相对路径。????? 3.4.2 创建路由可以在 路由器 (router) 组件 中的任意位置创建多个 &lt;Route&gt;，但通常我们会把它们放在同一个位置。使用 &lt;Switch&gt; 组件来包裹一组 &lt;Route&gt;。&lt;Switch&gt;会遍历自身的子元素（即路由）并对 第一个匹配 当前路径的元素进行渲染。 对于本网站，我们希望匹配一下路径： / ： 主页/roster ： 团体列表/roster/:number ：运动员页面，使用运动员的编号作为标识/schedule ：团队的赛程表 为了在应用中能匹配路径，在创建 &lt;Route&gt;元素时必须带有需要匹配的 path 作为参数。 12345&lt;Switch&gt; &lt;Route exact path='/' component=&#123;Home&#125;/&gt; &lt;Route path='/roster' component=&#123;Roster&#125;/&gt; &#123;/* both /roster and /roster/:number begin with /roster */&#125; &lt;Route path='/schedule' component=&#123;Schedule&#125;/&gt;&lt;/Switch&gt; 3.5 是如何渲染的当一个路由的 path 匹配成功后，路由用来确定渲染结果的参数有 三种。只需要提供其中一个即可。 1234567891011121314151617181920212223// ① component: 一个 React 组件。当带有 component 参数的 route 匹配成功后，// route 会返回一个新的元素，其为 component 参数所对应的 React组件（使用 React.createElement 创建）。&lt;Route path='/page' component=&#123;Page&#125; /&gt;// ② render : 一个返回 React element 的函数 [注5]。当匹配成功后调用该函数。// 该过程与传入 component 参数类似，并且对于行级渲染与需要向元素传入额外参数的操作会更有用。????什么鬼意思//[5] 这是一个本质上无状态的函数组件。内部实现，component 参数与 render 参数的组件是用很大的区别的。// 使用 component 参数的组件会使用 React.createElement 来创建元素，// &lt;Route path='/one' component=&#123;One&#125;/&gt; // React.createElement(props.component)// 使用 render 参数的组件则会调用 render 函数。// &lt;Route path='/two' render=&#123;() =&gt; &lt;Two /&gt;&#125;/&gt; // props.render()// 如果我们定义一个内联函数并将其传给 component 参数，这将会比使用 render 参数慢很多。const extraProps = &#123; color: 'red' &#125;&lt;Route path='/page' render=&#123;(props) =&gt; ( &lt;Page &#123;...props&#125; data=&#123;extraProps&#125;/&gt;)&#125;/&gt;// ③ children : 一个返回 React element 的函数。与上述两个参数不同，无论 route 是否匹配当前 location，其都会被渲染!!!!!!!!!!!!!!&lt;Route path='/page' children=&#123;(props) =&gt; ( props.match ? &lt;Page &#123;...props&#125;/&gt; : &lt;EmptyPage &#123;...props&#125;/&gt;)&#125;/&gt; 通常 component 参数与 render 参数被更经常地使用。children 参数偶尔会被使用，它更常用在 path 无法匹配时呈现的’空’状态。在本例中并不会有额外的状态，所以我们将使用 &lt;Route&gt;的 component 参数。 通过 &lt;Route&gt; 渲染的元素会被传入一些参数。分别是 match 对象，当前 location 对象[注6] 以及 history 对象（由 router 创建）[注7]。[6] &lt;Route&gt; 与 &lt;Switch&gt; 组件都会带有 location 参数。这能让你使用与实际 location 不同的 location 去匹配地址。?????[7] 可以传入 staticContext 参数，不过这仅在服务端渲染时有用。?????? 3.7 路径参数this.props.match.params.xxx 3.8 Link 链接我们应用需要在各个页面间切换。如果使用锚点元素（就是）实现，在每次点击时页面将被重新加载。React Router 提供了 &lt;Link&gt; 组件用来避免这种状况的发生。当你点击 &lt;Link&gt;时，URL 会更新，组件会被重新渲染，但是页面不会重新加载。 12345678910111213141516171819202122232425262728import &#123; Link &#125; from 'react-router-dom'//在项目中应该是 class 类来创建组件的const Header = () =&gt; ( &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to='/'&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/roster'&gt;Roster&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/schedule'&gt;Schedule&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt;)//&lt;Link&gt; 使用 'to' 参数来描述需要定位的页面。它的值即可是 字符串 也可是 location对象（包含pathname，search，hash与state属性）。// 一个基本的 location 对象/*&#123; pathname: '/', search: '', hash: '', key: 'abc123', state: &#123;&#125;&#125; *///如果其值为字符床将会被转换为 location 对象。`&lt;Link to=&#123;&#123; pathname: '/roster/7' &#125;&#125;&gt;Player #7&lt;/Link&gt;` //本例的 link 的 pathname 属性只能是绝对路径？？？？？//[4] 当需要支持相对路径的 `&lt;Route&gt;` 与 `&lt;Link&gt;` 时，你需要多做一些工作。相对 &lt;Link&gt; 将会比你之前看到的更为复杂。// 因其使用了父级的 match 对象而非当前 URL 来匹配相对路径。????? 3.9 获取路由我们已经了解了构建网站所需要的所有必须组件（&lt;BrowserRouter&gt;, &lt;Route&gt;, 以及 &lt;Link&gt;）。当然，还有一些我们没有涉及的组件。所幸React Router 拥有优质的文档，可以查看并从中了解更多的信息。文档也提供一系列的例子与源代码。 三、路由传值3.1 to 动态路由传值- componentDidMount 生命周期获取值123456//App.js 路由设置 &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/news\" component=&#123;News&#125; /&gt; &lt;Route path=\"/product\" component=&#123;Product&#125; /&gt; &lt;Route path=\"/productcontent\" component=&#123;ProductContent&#125; /&gt; &lt;Route path=\"/content/:aid\" component=&#123;Content&#125; /&gt; // 路由的传值与 link 连接处相互对应起来 12345678910111213141516171819202122232425//new.js 路由发起页面this.state = &#123; list:[ &#123; aid:'11', title:'我是新闻1111' &#125;, &#123; aid:'222', title:'我是新闻222' &#125;, &#123; aid:'3', title:'我是新闻333' &#125;, &#123; aid:'4', title:'我是新闻4444' &#125; ]&#125;;// 下面就是动态传值&lt;li key=&#123;key&#125;&gt; &lt;Link to=&#123;`/content/$&#123;value.aid&#125;`&#125;&gt;&#123;value.title&#125;&lt;/Link&gt;&lt;/li&gt; 12345678910111213//content.js 路由跳转到页面// props 获取传值constructor(props) &#123; super(props); this.state = &#123; // &#125;;&#125;//生命周期函数componentDidMount()&#123; //获取动态路由的传值 console.log(this.props.match.params.aid); &#125; 3.2 url get 传值-componentDidMount 生命周期获取值12345678910111213141516171819202122232425//new.js 路由发起页面this.state = &#123; list:[ &#123; aid:'11', title:'我是新闻1111' &#125;, &#123; aid:'222', title:'我是新闻222' &#125;, &#123; aid:'3', title:'我是新闻333' &#125;, &#123; aid:'4', title:'我是新闻4444' &#125; ]&#125;;// 下面就是动态传值&lt;li key=&#123;key&#125;&gt; &lt;Link to=&#123;`/content/$&#123;value.aid&#125;`&#125;&gt;&#123;value.title&#125;&lt;/Link&gt;&lt;/li&gt; 12345678910111213//content.js 路由跳转到页面// props 获取传值constructor(props) &#123; super(props); this.state = &#123; // &#125;;&#125;//生命周期函数componentDidMount()&#123; //获取动态路由的传值 console.log(this.props.location.serach); // 这个获取到的是 ？ 号后面的一串字符串，需要解析。&#125; 3.3 缓存传值五、5.1 基本 Basic12345678910111213141516171819202122232425262728293031//App.jsimport React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";import Home from '../views/Home/Home';import Login from '../views/Login/Login';import About from '../views/About/About';import Topics from '../views/Topics/Topics';class App extends Component &#123; render() &#123; return ( &lt;Router&gt;&#123; /* 只有根组件才需要这个 &lt;Router&gt; 标签 */&#125; &lt;div className=\"App\"&gt; &#123;/* 导航 */&#125; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123;/* 1 级路由配置 exact 表示精确查看，如果没有的话 路径 / 就会匹配到很多页面了*/&#125; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/login\" component=&#123;Login&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;Route path=\"/topics\" component=&#123;Topics&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 123456789101112131415//Home.jsimport React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";class Home extends Component &#123; render() &#123; return ( &lt;div className=\"Home\"&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default Home; 123456789101112131415//Login.jsimport React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";class Home extends Component &#123; render() &#123; return ( &lt;div className=\"Login\"&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default Login; 123456789101112131415//About.jsimport React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";class About extends Component &#123; render() &#123; return ( &lt;div className=\"About\"&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default About; 12345678910111213141516171819202122232425262728293031323334353637//Topics.jsimport React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";import Topic from 'Topic';//这个子组件应该放在哪里比较好呢？？？class Topics extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; list: [] &#125; &#125; render() &#123; return ( &lt;div className=\"Topics\"&gt; &lt;h2&gt;Topicst&lt;/h2&gt; &lt;ul&gt; &#123; /* 这里是 3 个链接，怎么下面路由只有两个？？？看不懂啊 */&#125; &lt;li&gt;&lt;Link to=&#123;`$&#123;this.props.match.url&#125;/rendering`&#125;&gt;Rendering with React&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;this.props.match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;this.props.match.url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &#123; /* 这里是 2 级 路由 外层不需要 router 标签了？？？？？？？ 还有为什么要 $&#123;this.props.match.path&#125; 一定这样么？？可以用它字符串地址的吧？ 还是为了后期不需要更改 二级路由的 url 与 路径？方便管理用的？*/&#125; &lt;Route path=&#123;`$&#123;this.props.match.path&#125;/:topicId`&#125; component=&#123;Topic&#125; /&gt; &lt;Route exact path=&#123;this.props.match.path&#125; render=&#123;() =&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt;&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default Topics; 123456789101112131415161718192021//Topic.jsimport React from \"react\";import &#123; BrowserRouter as Router, Route, Link &#125; from \"react-router-dom\";class Topic extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; list: [] &#125; &#125; render() &#123; return ( &lt;div className=\"Topic\"&gt; &lt;h3&gt;&#123;this.props.match.params.topicId&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;export default Topic; 5.2 URL 参数 URL Parameters123456789101112131415161718192021222324252627282930313233//App.js 根组件import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'import Child from './Child'import ComponentWithRegex from './ComponentWithRegex'class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div className=\"App\"&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/netflix\"&gt;Netflix&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/zillow-group\"&gt;Zillow Group&lt;/Link&gt;&lt;/li&gt; &lt;li&gt; &lt;Link to=\"/yahoo\"&gt;Yahoo&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/modus-create\"&gt;Modus Create&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/:id\" component=&#123;Child&#125; /&gt; &#123; /* 传递参数 id */ &#125; &lt;Route path=\"/order/:direction(asc|desc)\" &#123; /* 传递参数 :direction(asc|desc) */ &#125; component=&#123;ComponentWithRegex&#125; /&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 12345678910111213141516171819202122232425//Child 组件import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'class Child extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; // &#125; &#125; render() &#123; return ( &lt;div className=\"Child\"&gt; &lt;h3&gt;ID: &#123;this.props.match.params.id&#125;&lt;/h3&gt; &lt;/div&gt; ) &#125;&#125;export default Child; 12345678910111213141516171819202122232425//ComponentWithRegex 组件import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link&#125; from 'react-router-dom'class ComponentWithRegex extends Component &#123; constructor(props)&#123; super(props) this.state=&#123; // &#125; &#125; render() &#123; return ( &lt;div className=\"ComponentWithRegex\"&gt; &lt;h3&gt;Only asc/desc are allowed: &#123;this.props.match.params.direction&#125;&lt;/h3&gt; &lt;/div&gt; ) &#125;&#125;export default ComponentWithRegex; 5.3 认证重定向 Redirects (Auth) ？？？？？？？？？？？、实在是看不懂在 3.x 版本中的 Router 里需配置 history 属性,当前版本中无需配置此属性，4.x 版本中提供 三种不同的路由组件用来代替 history 属性的作用，分别是&lt;BrowserRouter&gt;：&lt;HashRouter&gt;：有 # 号，一般不会使用这个&lt;MemoryRouter&gt;： 1234567891011121314151617181920212223242526272829303132333435//App.js 根组件import React, &#123; Component &#125; from 'react';import &#123; BrowserRouter as Router, Route, Link, // 需要重定向的，还有 2 个需要导入 重定向 Redirect 与 是否推入 history 栈 withRouter Redirect, withRouter&#125; from 'react-router-dom'import Public from './Public'// 不需要登录就可以访问的页面import Login from './Login'import Protected from './Protected'// 需要登录之后才能登录的页面class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div className=\"App\"&gt; &lt;AuthButton/&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/public\"&gt;公开页面&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/protected\"&gt;非公开页面&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route path=\"/public\" component=&#123;Public&#125;/&gt; &lt;Route path=\"/login\" component=&#123;Login&#125;/&gt; &lt;PrivateRoute path=\"/protected\" component=&#123;Protected&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 123456789101112//AuthButton.js 组件const AuthButton = withRouter((&#123; history &#125;) =&gt; ( fakeAuth.isAuthenticated ? ( &lt;p&gt; 欢迎! &lt;button onClick=&#123;() =&gt; &#123; fakeAuth.signout(() =&gt; history.push('/')) &#125;&#125;&gt;登出&lt;/button&gt; &lt;/p&gt; ) : ( &lt;p&gt;请先登录&lt;/p&gt; ))) 5.4 自定义链接1234567891011121314151617181920212223242526272829303132//App.jsimport React, &#123; Component &#125; from 'react';import './App.scss';import '../interactor.js'import &#123; BrowserRouter as Router, Route, Link/* , Redirect, withRouter */&#125; from 'react-router-dom'import OldSchoolMenuLink from '../component/OldSchoolMenuLink'import Home from '../pages/Home'import About from '../pages/About'class App extends Component &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;OldSchoolMenuLink activeOnlyWhenExact=&#123;true&#125; to=\"/\" label=\"首页\"/&gt; &lt;OldSchoolMenuLink to=\"/about\" label=\"关于\"/&gt; &lt;hr/&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125;/&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125;export default App; 12345678// OldSchoolMenuLink 组件const OldSchoolMenuLink = (&#123; label, to, activeOnlyWhenExact &#125;) =&gt; ( &lt;Route path=&#123;to&#125; exact=&#123;activeOnlyWhenExact&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;div className=&#123;match ? 'active' : ''&#125;&gt; &#123;match ? '&gt; ' : ''&#125;&lt;Link to=&#123;to&#125;&gt;&#123;label&#125;&lt;/Link&gt; &lt;/div&gt; )&#125;/&gt;) 十五、各种错误15.1 这个错误是路由配置导致的其实，？？？？？？1234Warning: Can’t perform a React state update on an unmounted component. # 警告：无法对卸载的组件执行React状态更新。This is a no-op, but it indicates a memory leak in your application.#这是一个无操作，但它表示应用程序中存在内存泄漏。To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.#要修复，请取消 componentWillUnmount 中的所有订阅 和 异步任务方法。 但是其实现在 componentWillUnmount 周期函数已经不推荐使用的，在组件中也没有使用这个周期函数，还是报出这个错误。","tags":[]},{"title":"iview-ui【1】- 小白入门篇【记录一些使用的注意之处 & 自己经常犯的错】","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } ui 组件库 iview-ui/","text":"一、前言iView 是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。面向中后台业务的一整套前端解决方案，包含了工程构建、主题定制、多语言等功能，极大提升了开发效率。官网：网址。 由于官网对各个组件的使用并没有详细的使用方法，有个的属性或者方法的使用还是有比较大的坑的，这里的文章就是用来填补这些坑的。使用的时候查阅官网即可，本文写一些注意的地方，以及自己经常犯的错。对官网各个组件的使用的补充 二、安装过程的坑2.1 cnpm 的问题12345678910λ cnpm install iveiw --save`× Install fail! Error: GET https://registry.npm.taobao.org/iveiw response 404 status`Error: GET https://registry.npm.taobao.org/iveiw response 404 status at get (C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npminstall\\lib\\get.js:57:17) at get.next (&lt;anonymous&gt;) at onFulfilled (C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\co\\index.js:65:19) at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7)npminstall version: 3.10.0npminstall args: C:\\Program Files\\nodejs\\node.exe C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\cnpm\\node_modules\\npminstall\\bin\\install.js --fix-bug-versions --china --userconfig=C:\\Users\\Administrator\\.cnpmrc --disturl=https://npm.taobao.org/mirrors/node --registry=https://registry.npm.taobao.org iveiw --save 2.212345678910111213141516171819λ npm install iview --save`npm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-json-stable-stringify` npm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-deep-equalnpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\pinkie-promise\\node_modules\\pinkienpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modulesnpm WARN checkPermissions Missing write access to F:\\qianduan_dir\\00program\\todolist1\\node_modules\\pinkie-promise\\node_modulesnpm WARN request-promise-core@1.1.1 requires a peer of request@^2.34 but none is installed. You must install peer dependencies yourself.npm WARN request-promise-native@1.0.5 requires a peer of request@^2.34 but none is installed. You must install peer dependencies yourself.npm ERR! path F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-json-stable-stringifynpm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access 'F:\\qianduan_dir\\00program\\todolist1\\node_modules\\ajv\\node_modules\\fast-json-stable-stringify'npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-08-21T07_18_57_459Z-debug.log 三、vue 项目中使用 iview-ui 组件引用方法！！！！！！！！！！！！！！！！！！！！！！！！！！重点，重点，重点，重点官网中引用，它使用的并不是 vue-cli 脚手架来搭建的，因此它的引用跟我们使用 vue-cli 的有些区别，如果完全安装官网来操作，会发现自己的项目无法运行.官网中是使用 iview-cli 脚手架生成的，通常我是使用 vue-cli 脚手架来搭建框架的，因此 main.js 文件与 iview-ui 组件库的官网有出入， vue-cli 以下面的文件为准。 3.1 全局引用 main.js 中引入 iview 与 iview.css .vue 文件中使用组件 12345678910111213141516//main.jsimport Vue from 'vue'import App from './App'import router from './router'import iView from 'iview' //导入iview-uiimport 'iview/dist/styles/iview.css'//导入iview.cssVue.config.productionTip = falseVue.use(iView); //全局使用iviewnew Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 3.2 按需引用 babel-plugin-import插件安装 配置 .babelrc 文件（引入 iview） main.js 中引入 iview.css .vue 文件中使用组件 babel-plugin-import插件挂网: 1npm install babel-plugin-import --save-dev 1234567// .babelrc&#123; \"plugins\": [[\"import\", &#123; \"libraryName\": \"iview\", \"libraryDirectory\": \"src/components\" &#125;]]&#125; 12//main.jsimport 'iview/dist/styles/iview.css'; //按需引用还需要引如 css 样式 四、iview-ui 组件使用规范4.1 props 传参使用 :prop 传递数据格式为 数字、布尔值或函数时，必须带 : (兼容 String 除外，具体看组件文档)，比如： 12&lt;Page :current=\"1\" :total=\"100\"&gt;正确使用&lt;/Page&gt;&lt;Page current=\"1\" total=\"100\"&gt;没有正确使用&lt;/Page&gt; 4.2 非 template/render 模式下组件名要分隔例如 DatePicker 必须要写成 date-picker 12&lt;date-picker&gt;正确使用&lt;/date-picker&gt;&lt;DatePicker&gt;没有正确使用&lt;/DatePicker&gt; 4.3 非 template/render 以下组件加i- Button:&nbsp;&nbsp;&nbsp;i-button Col:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i-col Table:&nbsp;&nbsp;&nbsp;&nbsp;i-table Input: &nbsp;&nbsp; i-input Form: &nbsp; &nbsp; i-form Menu: &nbsp; &nbsp; i-menu Select: &nbsp; i-select Option: &nbsp; i-option Progress: i-progress Time: &nbsp;&nbsp;&nbsp; i-time 4.4 (除非使用 iview-loader)其他任何情况 以下组件加i- Switch: i-switch Circle: i-circle 什么是非 template/render模式？解析： 五、全局配置使用 iView 3 时，可以进行全局配置组件的一些属性。 目前只支持配置 transfer 和 size 两个属性。组件会优先使用 prop 设置的属性，如果未设置，再使用全局配置。 transfer：所有带浮层的组件，是否将浮层放置在 body 内，默认为不设置，详见各组件默认的 transfer 值。可选值为 true 或 false。size：所有带有 size 属性的组件的尺寸，默认为不设置，详见各组件默认的 size 值。可选值为 default、small 或 large。用法如下： 在 main.js 文件 1234Vue.use(iView, &#123; transfer: true, size: 'large'&#125;); 七、定制主题iView 默认提供了一套 UI 主题，并且可以在一定程度上定制新主题，以满足业务和品牌上的多样化视觉需求。 iView 的样式是基于 Less 进行开发的，默认以前缀 .ivu- 作为命名空间，并且定义了一套样式变量，定制主题，就是编辑这个变量列表。 步骤①：创建如 my-theme 目录 步骤②：创建 index.less 文件 123@import '~iview/src/styles/index.less';// Here are the variables to cover, such as:@primary-color: #8c0776; 完整的变量列表可以查看 默认样式变量网址 步骤③： main.js 中引入 index.less 12345import Vue from 'vue';import iView from 'iview';import '../my-theme/index.less'; //引入 index.less 文件Vue.use(iView); 步骤④：修改 index.less 文件内容以修改主题颜色 7.1 vue-cli 脚手架床架的项目中修改主题！！！九、使用 iveiw-ui 遇到的坑/自己犯的错9.1 引入 iveiw 的出现 import iView from &#39;...iview&#39;，找不到模块这个不是坑，import iView from &#39;...iview&#39;，既然是 import，它肯定需要导入的，需要时间，刚开始打开这个文件，会出现…，一会加载完，它就会好了。 9.1 使用 type 类型正确的坑12345678910vue.esm.js?efeb:591 [Vue warn]: Invalid prop: custom validator check failed for prop \"type\".found in---&gt; &lt;Button&gt; &lt;Content&gt; &lt;Layout&gt; &lt;HelloWorld&gt; at src\\components\\home.vue &lt;App&gt; at src\\App.vue &lt;Root&gt; 如上错误出现的话，说的是在 src\\components\\home.vue 这个 vue 文件中的 Button 组件在使用 type 使用错误。可能是编辑错误，字母刺写错了，还是多可空格等等其他符号啦。 示例：可能是想要个灰色的按钮，但是这个按钮的 type 是不能这样写的，不存在这个类型。 12345&lt;Button type=\"disabled\" shape=\"circle\" @click=\"handleSelectAll(false)\"&gt;取消全选&lt;/Button&gt; &lt;Col&gt;改成&lt;i-col&gt;1234567891011121314151617181920 ✘ https://google.com/#q=vue%2Fno-parsing-error Parsing error: x-invalid-end-tag src\\components\\pages\\home.vue:13:11 &lt;/Col&gt; ^ ✘ https://google.com/#q=vue%2Fno-parsing-error Parsing error: x-invalid-end-tag src\\components\\pages\\home.vue:14:32 &lt;Col span=&quot;12&quot;&gt;col-12&lt;/Col&gt; ^✘ 2 problems (2 errors, 0 warnings)Errors: 2 https://google.com/#q=vue%2Fno-parsing-errorYou may use special comments to disable some warnings.Use // eslint-disable-next-line to ignore the next line.Use /* eslint-disable */ to ignore all warnings in a file. 官网说明在非 template/render 模式下（例如使用 CDN 引用时），组件名要分隔，例如 DatePicker 必须要写成 date-picker。以下组件，在非 template/render 模式下，需要加前缀 i-：Button: i-buttonCol: i-colTable: i-tableInput: i-inputForm: i-formMenu: i-menuSelect: i-selectOption: i-optionProgress: i-progressTime: i-time以下组件，在所有模式下，必须加前缀 i-，除非使用 iview-loader：Switch: i-switchCircle: i-circle input组件样式修改iview 框架中，不能使用 css 写样式直接修改，这里用到主题。iview 的样式是用 less 制作的，主题也可以使用less 变量来修改。iview中的网址：git 在 vue-cli 框架中，用 webpack 创建的项目目录。node_modules→_iview@3.1.1@iview→src→styles 中是这个框架的样式这是文件，可以在这里看iview作者的代码设计，但是不要去改动 node_modules 文件夹的东西。 12345678910111213These dependencies were not found:* iview in ./src/main.js* iview/dist/styles/iview.css in ./src/main.js* !!vue-style-loader!css-loader?&#123;&quot;sourceMap&quot;:true&#125;!../../../node_modules/vue-loader/lib/style-compiler/index?&#123;&quot;vue&quot;:true,&quot;id&quot;:&quot;data-v-5e4cad4c&quot;,&quot;scoped&quot;:true,&quot;hasInlineConfig&quot;:false&#125;!less-loader?&#123;&quot;sourceMap&quot;:true&#125;!../../../node_modules/vue-loader/lib/selector?type=styles&amp;index=0!./home.vue in ./src/components/pages/home.vueTo install them, you can run: npm install --save iview iview/dist/styles/iview.css !!vue-style-loader!css-loader?&#123;&quot;sourceMap&quot;:true&#125;!../../../node_modules/vue-loader/lib/style-compiler/index?&#123;&quot;vue&quot;:true,&quot;id&quot;:&quot;data-v-5e4cad4c&quot;,&quot;scoped&quot;:true,&quot;hasInlineConfig&quot;:false&#125;!less-loader?&#123;&quot;sourceMap&quot;:true&#125;!../../../node_modules/vue-loader/lib/selector?type=styles&amp;index=0!./home.vue 1npm install style-loader --save 十、各个组件的使用补充!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(官网写的太简单了)官网没有对每个组件的，每个属性，时间，或者方法进行完善，对于一些组件使用起来会遇到各种坑，因此这章就是对组件的补充的。 10.1 Modal 对话框10.1.1 Modal instance 对话框实例的 config 对象使用（这个是在 js 代码中写的）通过直接调用以下方法来使用： 1234567891011121314151617181920212223242526272829303132this.$Modal.info(config)this.$Modal.success(config)this.$Modal.warning(config)this.$Modal.error(config)this.$Modal.confirm(config)//以上方法隐式地创建及维护 Vue 组件。参数 config 为对象，具体说明如下：methods:&#123; edit(index) &#123; this.$Modal.confirm(&#123; title: '提示', content: '确认要删除这条记录么?一旦删除将无法恢复!',//注意，如果有render 函数，那么这个 content 就没有用了 render: h =&gt; &#123; return h(//) &#125;, width:900,// 单位是 px 值是 number，或者 string，默认值是 416px width:'10%',// 问题？？？？？？？？？？？？？？？？？？？？？？？如果这个字符串是这样的，有百分百的吧？？？？？ okText: '删除',//默认值是 确定 cancelText: '取消',//默认值是 取消（this.$Modal.confirm 中有效，其他无效） onOk: () =&gt; &#123; alert('你赢了！'); this.changeDesc(); &#125;, onCancel:()=&gt;&#123; alert('取消！');//这个事件，是在（this.$Modal.confirm 中有效，其他无效） &#125; &#125;) &#125;, changeDesc()&#123; // &#125;&#125; 10.1 按钮 中使用 阿里图库1234567&lt;Button type=\"primary\" shape=\"circle\" icon=\"ios-search\"&gt;&lt;/Button&gt;&lt;!-- 这里是 iview 自己的图标 icon=\"ios-search\" 以属性的方式使用--&gt;&lt;!-- 这里是使用阿里图库 --&gt;&lt;Button type=\"primary\" size=\"small\" style=\"margin-right: 5px\" @click=\"show(index)\"&gt; &lt;i class=\"iconfont icon-fengjin\"&gt;&lt;/i&gt; 查看&lt;/Button&gt; 10.2 menu 导航栏10.2.1 Menu methods 导航栏的方法updateOpened 手动更新展开的子目录，注意要在 $nextTick 里调用updateActiveName 手动更新当前选择项，注意要在 $nextTick 里调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;Menu ref=\"left_menu\" theme=\"dark\" :active-name=\"activeName\" @on-select=\"selectMenu\"&gt; &lt;MenuItem name=\"project\"&gt; &lt;Icon type=\"md-git-branch\"/&gt; &lt;span class=\"menu-text\"&gt;项目管理&lt;/span&gt; &lt;/MenuItem&gt; &lt;MenuItem name=\"organization\"&gt; &lt;Icon type=\"ios-people\"/&gt; &lt;span class=\"menu-text\"&gt;组织管理&lt;/span&gt; &lt;/MenuItem&gt; &lt;MenuItem name=\"notice\"&gt; &lt;Icon type=\"ios-notifications\"/&gt; &lt;span class=\"menu-text\"&gt;消息通知&lt;/span&gt; &lt;/MenuItem&gt; &lt;MenuItem name=\"profile\"&gt; &lt;Icon type=\"logo-snapchat\"/&gt; &lt;span class=\"menu-text\"&gt;个人中心&lt;/span&gt; &lt;/MenuItem&gt;&lt;/Menu&gt;&lt;script&gt;data() &#123; return &#123; activeName: \"project\" &#125;; &#125;, watch: &#123; //监听路由器变化，使得 header 点击的时候，侧边菜单栏的 active 值跟着改变，并且渲染 head 的中部！！！！！ // 监听这里需要设置变化，还有 点击函数 noticeFunc() profileFunc() 这里还是要设置变化的，为什么呀？？ // 完全看不明白，这个是个什么鬼东西噢噢噢噢哦哦哦哦哦哦 $route() &#123; this.$nextTick(() =&gt; &#123; this.initMenuActive(); this.activeName = this.$route.name; this.$refs.left_menu.updateActiveName(); &#125;); &#125; &#125;, methods:&#123; noticeFunc() &#123; const that = this; that.$nextTick(() =&gt; &#123; that.activeName = \"notice\"; that.$refs.left_menu.updateActiveName();// 注意到他们只是一个调用函数，我们根据更新激活的 :active-name=\"activeName\" // 通过改变绑定的激活 name 值来更新展开的 menu 项 &#125;); that.$router.push(\"/notice\"); &#125; &#125;&lt;/script&gt; 10.3 upload 组件10.3.5 上传图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;template&gt; &lt;div class=\"demo-upload-list\" v-for=\"item in uploadList\"&gt; &lt;!--这个 uploadlist 指的是用于展示的，额外加的 一个数据 --&gt; &lt;template v-if=\"item.status === 'finished'\"&gt; &lt;!--这个 条件也是可以自己去修改的 --&gt; &lt;img :src=\"item.url\"&gt; &lt;div class=\"demo-upload-list-cover\"&gt; &lt;Icon type=\"ios-eye-outline\" @click.native=\"handleView(item.name)\"&gt;&lt;/Icon&gt; &lt;Icon type=\"ios-trash-outline\" @click.native=\"handleRemove(item)\"&gt;&lt;/Icon&gt; &lt;/div&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;Progress v-if=\"item.showProgress\" :percent=\"item.percentage\" hide-info&gt;&lt;/Progress&gt; &lt;/template&gt; &lt;/div&gt; &lt;Modal title=\"查看图片\" v-model=\"visible\"&gt; &lt;!-- &lt;img :src=\"'https://o5wwk8baw.qnssl.com/' + imgName + '/large'\" v-if=\"visible\" style=\"width: 100%\"&gt; --&gt; &lt;img :src=\"url\" v-if=\"visible\" style=\"width: 100%\"&gt; &lt;/Modal&gt; &lt;Upload ref=\"upload\" :show-upload-list=\"false\" :default-file-list=\"defaultList\" // 这里的 defaultList 指的是 upload 组件默认已上传到服务端的文件列表，这个数据的数据格式 iview 规定好的。 :on-success=\"handleSuccess\" :format=\"['jpg','jpeg','png']\" :max-size=\"2048\" :on-format-error=\"handleFormatError\" :on-exceeded-size=\"handleMaxSize\" :before-upload=\"handleBeforeUpload\" :on-progress=\"handleProgresseUpload\" name=\"image\" // 例子里没有这个属性 ，默认值是 file，要注意跟自己后端连接起来，响应的更新属性值 multiple // 是否支持多选文件,默认值是 false，根据我们的后端接口来确定是否是多选的。 type=\"drag\" //action=\"//jsonplaceholder.typicode.com/posts/\" // 这是 http 请求的接口，还是写到 data 里面去比较好吧，还有 headers 的请求头设置呢。 --&gt; :action=\"httpData.url\" :headers=\"httpData.headers\" style=\"display: inline-block;width:58px;\"&gt; &lt;div style=\"width: 58px;height:58px;line-height: 58px;\"&gt; &lt;Icon type=\"ios-camera\" size=\"20\"&gt;&lt;/Icon&gt; &lt;/div&gt; &lt;/Upload&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; // 上传图片请求数据 httpData:&#123; url:'',// 后端接口，注意这里不是用 axios 来请求的，这里就要写上完整的 接口地址 headers:&#123; // 根据后端接口写上要求的请求头内容 Authorization: localStorage.getItem(\"token\") &#125; &#125;, // 这里是 iview 规定了数据项 的数据（已经上传到 服务端的数据），数据格式就是 &#123;name:'',url:''&#125; defaultList: [], imgName: '', visible: false, // 这里是用于展示文件 的数据，如果 defaultList 已经满足要求的话，就可以不需要这个了的。 // 假设我们不只是要 名称与 url 链接图片，还要创建时间呀，等等，就需要一个中间值了，就是接收后端的 返回 uploadList: [] &#125; &#125;, mounted () &#123; this.uploadList = this.$refs.upload.fileList;// 加载的时候讲数据给它？？？？为啥？？？？？？？？？？？？？？ &#125; methods: &#123; //before-upload 钩子的 函数：上传文件之前的钩子，参数为上传的文件 file，若返回 false 或者 Promise 则停止上传 handleBeforeUpload (file) &#123; // 假设上传需要动态改变附带的参数 data 及上传的路径 url ？但 before-upload 动态改变时，子组件中参数未改变时已执行上传操作？ //let researchId = this.activeUploadId; // this.uploadUrl = 'api?research_id=' + researchId + '&amp;filetype=' + file.name.split('.')[1]; // this.uploadData = &#123; // role: patient, // abc: file // &#125;; // let promise = new Promise((resolve) =&gt; &#123; // this.$nextTick(function () &#123; // resolve(true); // &#125;); // &#125;); // return promise; //通过返回一个promis对象解决 const check = this.uploadList.length &lt; 5; if (!check) &#123; this.$Notice.warning(&#123; title: '最多只能上传 5 张图片' &#125;); &#125; return check; &#125;, //文件上传时的钩子，返回字段为 event, file, fileList handleProgresseUpload()&#123; // &#125;, // 文件上传成功时的钩子，返回字段为 response, file, fileList handleSuccess (res, file) &#123; // res 是后端返回的数据，返回上传文件对应的数据 // file 上传文件的信息 // fileList 上传文件列表的信息（假设后端可以上传多份文件，前端也设置了 multiple 为 ture） // 因为上传过程为实例，这里模拟添加 url，就不要管下面这 2 行就好了，这个是 iview 用来展示用的 // file.url = 'https://o5wwk8baw.qnssl.com/7eb99afb9d5f317c912f08b5212fd69a/avatar' // file.name = '7eb99afb9d5f317c912f08b5212fd69a' var tFile = &#123; name: res.fileName, url: res.url &#125;; this.defaultList.push(tFile);// 上传成功，还要把上传成功的文件添加到 默认已上传列表 defaultList 中 //this.addproductFormData.images.push(res.id); 如果我们是某个表单需要使用到上传的数据，那么就是需要给数据给这个 表单中的数据咯。 &#125;, //文件格式验证失败时的钩子，返回字段为 file, fileList handleFormatError (file) &#123; this.$Notice.warning(&#123; title: '文件格式不正确', desc: '文件 ' + file.name + ' 格式不正确，请上传 jpg 或 png 格式的图片' &#125;); &#125;, //文件超出指定大小限制时的钩子，返回字段为 file, fileList handleMaxSize (file) &#123; this.$Notice.warning(&#123; title: '超出文件大小限制', desc: '文件 ' + file.name + '太大，不能超过 2M。' &#125;); &#125;, // 查看文件 handleView (name) &#123; this.imgName = name; this.visible = true; &#125;, // 移除文件：// 从 upload 实例删除数据 handleRemove (file) &#123; const fileList = this.$refs.upload.fileList; this.$refs.upload.fileList.splice(fileList.indexOf(file), 1); &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; .demo-upload-list&#123; display: inline-block; width: 60px; height: 60px; text-align: center; line-height: 60px; border: 1px solid transparent; border-radius: 4px; overflow: hidden; background: #fff; position: relative; box-shadow: 0 1px 1px rgba(0,0,0,.2); margin-right: 4px; &#125; .demo-upload-list img&#123; width: 100%; height: 100%; &#125; .demo-upload-list-cover&#123; display: none; position: absolute; top: 0; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,.6); &#125; .demo-upload-list:hover .demo-upload-list-cover&#123; display: block; &#125; .demo-upload-list-cover i&#123; color: #fff; font-size: 20px; cursor: pointer; margin: 0 2px; &#125;&lt;/style&gt;","tags":[]},{"title":"vue---API 接口","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-API 接口/","text":"一、前言学会了vue.js怎么使用的之后，后续使用文档应该看API来查看使用。 二、全局配置指的是给创建的vue项目做全局配置。在vue-cli脚手架创建的项目中是在.editorconfig文件中。 先来了解一下什么是EditorConfig：EditorConfig帮助开发人员在不同的编辑器和IDE之间定义和维护一致的编码样式的插件。EditorConfig项目由用于定义编码样式的文件格式和一组文本编辑器插件组成，这些插件使编辑器能够读取文件格式并遵循定义的样式。EditorConfig文件易于阅读，并且与版本控制系统配合使用。这个插件在很多编辑器都含有，不必要额外的安装，vscode，webstorm等等编辑器都有的，直接创建一个.editorconfig：项目全局配置文件 编辑即可。为vue-cli脚手架会自动生成这个文件. 12345678910//vue-cli脚手架创建的项目下该文件的默认的配置root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true 2.1 编辑的代码格式配置合作项目的时候,项目经理会在这里设置好代码的统一格式. 2.2 vue的全局配置vue官网全局配置 silent Vue 所有的日志与警告配置。 optionMergeStrategies 自定义合并策略/自定义选项的混入策略 devtools 是否允许 vue-devtools 检查代码 errorHandler warnHandler ignoredElements keyCodes 自定义键位别名。[方便键盘事件修饰] performance 组件初始化、编译、渲染和打补丁的性能追踪 productionTip 阻止 vue 在启动时生成生产提示 三、全局APIvue官网全局API 什么是全局API？构造器：Constructor 别称:构造方法、构造函数、建构子 new Vue()全局API并不在构造器里，而是先声明全局变量或者直接在Vue上定义一些新功能。说的简单些就是，在构造器外部用Vue提供给我们的API函数来定义新的功能。Vue内置了一些全局API，如下： Vue.extend Vue.nextTick Vue.set Vue.delete Vue.directive 注册或获取全局指令 Vue.filter Vue.component Vue.use Vue.mixin Vue.compile Vue.version 3.1 Vue.extend这里的data里面与new Vue({})不同，不是直接写属性了，而是需要些一个匿名函数，在返回值里面写data的属性与值 Vue.extend 返回的是一个“扩展实例构造器”,也就是预设了部分选项的Vue实例构造器。经常服务于Vue.component用来生成组件，可以简单理解为当在模板中遇到该组件名称作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂载到自定义元素上。 ①：在普通标签上使用拓展可以通过HTML标签上的id或者class来生成扩展实例构造器，Vue.extend里的代码是一样的，只是在挂载的时候，我们用类似jquery的选择器的方法，来进行挂载就可以了。 12345678910111213&lt;div id=\"app\"&gt;&lt;/div&gt;&lt;script&gt; var appExtend = Vue.extend(&#123; template: '&lt;p&gt;&#123;&#123;somebody&#125;&#125; has &#123;&#123;carname&#125;&#125; car!&lt;/p&gt;', data: function () &#123; return &#123; somebody: 'xiaomi', carname: 'minicooper' &#125; &#125; &#125;) new appExtend().$mount('#app')&lt;/script&gt; ②：自定义标签上拓展想象一个需求，需求是这样的，要在博客页面多处显示作者的网名，并在网名上直接有链接地址。我们希望在html中只需要写&lt;author&gt;&lt;/author&gt; ，这和自定义组件很像，但是他没有传递任何参数，只是个静态标签。 12345678910111213&lt;author&gt;&lt;/author&gt;&lt;script&gt; var authorExtend = Vue.extend(&#123; template: '&lt;p&gt;&lt;a href=\"aHref\"&gt;&#123;&#123;name&#125;&#125;&lt;a&gt;&lt;/p&gt;', data: function () &#123; return &#123; aHref: '../assets/img/rabbit.gif', name: '兔子' &#125; &#125; &#125;) new authorExtend().$mount('author')&lt;/script&gt; 3.2 Vue.nextTick在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 3.3 Vue.set向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’) 3.3.1 什么是外部数据就是不在Vue构造器里里的data处声明，而是在构造器外部声明，然后在data处引用就可以了。外部数据的加入让程序更加灵活，我们可以在外部获取任何想要的数据形式，然后让data引用 123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;input type=\"button\" value=\"add\" @click=\"addevent\" /&gt;&lt;/div&gt;&lt;script&gt; //在vue构造器外部定于数据 var outdata = &#123; count: 1, good: 'car' &#125; //然后再vue构造器内部data去引用外部的数据 var app = new Vue(&#123; el: '#app', data: outdata, methods: &#123; addevent: function () &#123; this.count++; &#125; &#125; &#125;)&lt;/script&gt; 3.3.2 使用 Vue.setVue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法。比如在vue构造器内部定义了一个count为1的数据，我们在构造器外部定义了一个方法，要每次点击按钮给值加1.就需要用到Vue.set。 12345678910111213141516171819202122&lt;div id=\"app2\"&gt; &lt;ol&gt; &lt;li v-for=\"car in cars\"&gt;&#123;&#123;car&#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;p&gt; &lt;input type=\"button\" value=\"换车\" onclick=\"changeCar()\" /&gt;&lt;/p&gt;&lt;script&gt; var myCars = &#123; cars: ['minicooper', '奔驰', '法拉利', '兰博基尼'] &#125; var carsvue = new Vue(&#123; el: '#app2', data: myCars &#125;) function changeCar() &#123; // cars[1] = '宝马';//这样写是改变不了数据数组里面的值的，因为js有保护原数据的机制。 Vue.set(myCars.cars, 1, '宝马'); //这样设置才会改变里面的数据 &#125;&lt;/script&gt; 3.4 Vue.delete删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。 3.5 Vue.directive注册或获取全局指令。自定义指令。指令的名称不能有大写字母！！ 也就是changecolor不能存在大写字母，否则会出错。 vue中有v-if v-else v-show就是vue的内部指令，我们如果有自己的需求，可以自定义指令。如下指令为v-changelolor。 3.5.1 自定义指令中传递的三个参数el: 指令所绑定的元素，可以用来直接操作DOM。binding: 一个对象，包含指令的很多信息。 binding：捆绑vnode: Vue编译生成的虚拟节点。 vnode ：vue编译生成的虚拟node节点语法：Vue.directive(‘自定义指令名称’,function(el,binding,vnode){….}) 12345678910111213141516171819202122232425&lt;div id=\"app\"&gt; &lt;div v-changecolor=\"&#123;color:red&#125;\"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;input type=\"button\" value=\"add\" v-on:click=\"add\" /&gt;&lt;/div&gt;&lt;script&gt;Vue.directive('changecolor', function (el, binding, vnode) &#123; // 这里将会被 `bind` 和 `update` 调用 //el:代表的是运用该自定义命令的DOM元素 //binding:一个对象，包含自定义命令名称name属性&#123;name: \"changecolor\", rawName: \"v-changecolor\", value: \"red\", expression: \"color\", modifiers: &#123;…&#125;, …&#125; //vnode:VNode &#123;tag: \"div\", data: &#123;…&#125;, children: Array(1), text: undefined, elm: div, …&#125; el.style.color = binding.value.color;&#125;)var vm = new Vue(&#123; el: '#app', data: &#123; text: 18, red: 'red' &#125;, methods: &#123; add: function () &#123; this.text += 1; &#125; &#125;&#125;) 3.5.2 自定义指令中传递的三个参数自定义指令的生命周期 自定义指令有五个生命周期（也叫钩子函数） 分别是 bind,inserted,update,componentUpdated,unbind bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。 inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。 update:(常用)被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用。 钩子函数的参数有： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 alue: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的表达式或变量名。 例如 v-my-directive=”1 + 1” ， expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id=\"app\"&gt; &lt;div v-xiaomi=\"&#123;color:red&#125;\"&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;input type=\"button\" value=\"add\" v-on:click=\"add\" /&gt;&lt;/div&gt;&lt;p&gt; &lt;input type=\"button\" value=\"解绑\" onclick=\"unbind()\" /&gt;&lt;/p&gt;&lt;script&gt; Vue.directive('xiaomi', &#123; bind: function () &#123; console.log('bind'); &#125;, inserted: function () &#123; console.log('inserted'); &#125;, update: function () &#123; console.log('update'); &#125;, componentUpdated: function () &#123; console.log('componentUpdated'); &#125;, unbind: function () &#123; console.log('unbind'); &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; text: 18, red: 'red' &#125;, methods: &#123; add: function () &#123; this.text += 1; &#125; &#125; &#125;) function unbind() &#123; vm1.$destroy(); &#125;&lt;/script&gt; 3.6 Vue.filter注册或获取全局过滤器。 3.7 Vue.component注册或获取全局组件。注册还会自动使用给定的id设置组件的名称 component组件是Vue学习的重点、重点、重点，重要的事情说三遍。必须学好Vue component。其实组件就是制作自定义的标签，这些标签在HTML中是没有的！！！！！！！比如：&lt;xiaomi&gt;&lt;/xiaomi&gt; 这里说的是全局自定义组件。在选项中会有局部组件。 一、全局化注册组件 语法：Vue.component(&apos;my-component-name&apos;, { template: ... }) 全局化就是在构造器的外部用Vue.component来注册， 我们注册现在就注册一个&lt;xiaomi&gt;&lt;/xiaomi&gt;的组件来体验一下。 --&gt; 123456789101112131415161718&lt;div id=\"app\"&gt; &lt;xiaomi&gt;&lt;/xiaomi&gt;&lt;/div&gt;&lt;div id=\"app1\"&gt; &lt;xiaomi&gt;&lt;/xiaomi&gt;&lt;/div&gt;&lt;!--&lt;xiaomi&gt;&lt;/xiaomi&gt;这样写是没有效果的，即使是全局的组件，也需要对应的写一个Vue构造函数行的。--&gt;&lt;script&gt; Vue.component('xiaomi', &#123; template: '&lt;p&gt;我是全局组件&lt;/p&gt;', &#125;) var vmapp = new Vue(&#123; el: '#app' &#125;) var vmapp1 = new Vue(&#123; el: '#app1' &#125;) &lt;/script&gt; 全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的JavaScript 的无谓的增加。不要这来来注册组件，后面学习局部组件创建。 3.8 Vue.use会自动阻止多次注册相同插件，届时只会注册一次该插件 3.9 Vue.mixin全局混入 3.10 Vue.compile在 render 函数中编译模板字符串。只在独立构建时有效 123456789var res = Vue.compile('&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;')new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) 3.11 Vue.version提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。 123456789var version = Number(Vue.version.split('.')[0])if (version === 2) &#123; // Vue v2.x.x&#125; else if (version === 1) &#123; // Vue v1.x.x&#125; else &#123; // Unsupported versions of Vue&#125; 四、选项vue官网选项 选项 / 数据 data props propsData computed methods watch 选项 / DOM el template render renderError 选项 / 生命周期钩子 beforeCreate created beforeMount mounted beforeUpdate updated activated deactivated beforeDestroy destroyed errorCaptured 选项 / 资源 directives filters components 选项 / 组合 parent mixins extends provide / inject 选项 / 其它 name delimiters functional model inheritAttrs comments 4.1 data Vue 实例的数据对象。4.2 props 可以是数组或对象，用于接收来自父组件的数据。props选项就是设置和获取标签上的属性值的，例如我们有一个自定义的组件&lt;xiaomi&gt;&lt;/xiaomi&gt;,这时我们想给他加个标签属性写成&lt;panda here=&quot;China&quot;&gt;&lt;/panda&gt; 意思就是熊猫来自中国，当然这里的China可以换成任何值。定义属性的选项是props。China就是属性的值 1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;panda here=\"China\"&gt;&lt;/panda&gt;&lt;/div&gt;&lt;script&gt; var vmapp = new Vue(&#123; el: '#app', components: &#123; 'panda': &#123; //指的是一个panda标签，标签里面的文本以及标签元素就是template模板里面的字符串， //插值&#123;&#123;&#125;&#125;值就是在html中panda标签的属性，值是在写html的panda标签的时候设置的。 //这里的属性与我们的原生的htmlclass属性有？？？？？ template: '&lt;p style=\"color:red;\"&gt;panda from &#123;&#123;here&#125;&#125;!&lt;/p&gt;', props: ['here'] // 属性设置 &#125; &#125; &#125;)//上面的代码定义了panda的组件，并用props设置了here的属性值，//在here属性值里传递了China给组件。//最后输出的结果是红色字体的Panda from China.&lt;/script&gt;","tags":[]},{"title":"vue--[ 生命周期钩子函数]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-生命周期钩子函数/","text":"一、前言生命周期是一个重点，也是比较难以区分的选项。 二、生命周期 在谈到 Vue 的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了 init（init 是 vue 组件里面默认去执行的），在 init 的过程当中首先调用了 beforeCreate，然后在 injections（注射）和 reactivity（反应性）的时候，它会再去调用 created。所以在 init 的时候，事件已经调用了，我们在beforeCreate 的时候千万不要去修改 data 里面赋值的数据，最早也要放在 created 里面去做（添加一些行为）。 当 created 完成之后，它会去判断 instance（实例）里面是否含有 “el”option（选项），如果没有的话，它会调用 vm.$mount(el) 这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有 “template” 这个选项，如果有的话，它会把 template 解析成一个 render function ，这是一个 template 编译的过程，结果是解析成了render 函数： 123render (h) &#123; return h('div', &#123;&#125;, this.text)&#125; render 函数里面的传参 h 就是 Vue 里面的 createElement 方法，return 返回一个 createElement 方法，其中要传 3 个参数，第一个参数就是创建的 div 标签；第二个参数传了一个对象，对象里面可以是我们组件上面的 props，或者是事件之类的东西；第三个参数就是 div 标签里面的内容，这里我们指向了 data 里面的 text。 使用 render 函数的结果和我们之前使用 template 解析出来的结果是一样的。render 函数是发生在 beforeMount 和 mounted 之间的，这也从侧面说明了，在 beforeMount 的时候，$el 还只是我们在 HTML 里面写的节点，然后到 mounted 的时候，它就把渲染出来的内容挂载到了 DOM 节点上。这中间的过程其实是执行了 render function 的内容。 在使用 .vue 文件开发的过程当中，我们在里面写了 template 模板，在经过了 vue-loader 的处理之后，就变成了 render function，最终放到了 vue-loader 解析过的文件里面。这样做有什么好处呢？原因是由于在解析 template 变成 render function 的过程，是一个非常耗时的过程，vue-loader 帮我们处理了这些内容之后，当我们在页面上执行vue 代码的时候，效率会变得更高。 beforeMount 在有了 render function 的时候才会执行，当执行完 render function 之后，就会调用 mounted 这个钩子，在 mounted 挂载完毕之后，这个实例就算是走完流程了。 后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用 beforeUpdate，然后经过 Virtual DOM，最后 updated 更新完毕。当组件被销毁的时候，它会调用 beforeDestory，以及 destoryed。 以上就是 vue实例从新建到销毁的一个完整流程，以及在这个过程中它会触发哪些生命周期的钩子函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596data()&#123; return&#123; message:'xxx' &#125;&#125;,beforeCreate()&#123;// 状态：实例初始化之后，this 指向创建的实例。**数据观测 (data observer)** 和 **event/watcher 事件配置** 之前被调用。// 此时 $el 和 data 都为 undefined,没有初始化// 场景：常用于初始化非响应式变量。不能直接访问到 data、computed、watch、methods 上的方法和数据// 实际应用：// 可以进行 loading 事件 之类的动画加载，在加载实例时触发（就是避免 created 出现白屏，在这个钩子做的一个动画加载 ），在 created 时进行移除// 但是通常我们使用 css 来做到 loading 的效果，没有接触到使用 js 来做的。//面试题：vue 怎么在 beforeCreate 里获取 data// 实际上 data 的是 created() 初始化的，但是我们要在这里获取数据的话，就需要是使用到 this.$nextTick(callBack) 异步操作。// 这个 this.$nextTick 可以使得里面的 回调函数 到下次 DOM 更新循环结束后才会执行。（循环：数据更新--下一次数据更新之前）// this.$nextTick(function () &#123;// console.log(this.message);// &#125;)// 但是我们还是不要去这样做吧？ vue 给了我们什么周期该干什么就干什么，这样才能很好的利用啊。&#125;created()&#123; // 状态：在实例创建完成后被立即调用。，可访问 data、computed、watch、methods 上的方法和数据，未挂载到 DOM，不能访问到 $el 属性，$ref 属性内容为空数组 // 创建后 data 初始化了,而 $el 没有 // 场景：对 data 数据进行操作，常用于简单的 ajax 请求，页面初始化，将 ajax 请求将返回的数据赋给 data，还可以进行网络接口的请求操作； // 实际应用： // 在这结束 loading，然后做一些数据的初始化，实现函数自执行（这个在 Vue 的生命周期只会执行一次） // 实际工作：假如你需要中 vux 中取数据，在模版中使用，那么你需要在 dom 挂载之前获取到数据，这个操作就在 created 里面做 //问题：页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态&#125;beforeMount()&#123; // 状态：在挂载开始之前被调用，beforeMount 之前，会找到对应的 template，并编译成 render 函数 // $el和data都初始化了 //在挂载开始之前被调用：相关的 render 函数首次被调用。&#125;mounted()&#123; // 状态：实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，$ref 属性可以访问 // 场景：常用于获取 VNode 信息和操作，ajax 请求，也可以进行后台获取数据操作 // 实际应用： // 在这发起后端请求，拿回数据，配合路由钩子做一些事情 （会经常进行数据处理和更新） //el 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标 //注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted： // 实际工作：如果需要手工操作 dom 或者其它非 vue 插件需要操作 dom，那么必须得在 dom 生成后，那这时候就得在 mounted 触发。 // 问题：不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 this.$nextTick&#125;beforeUpdate()&#123; //状态：响应式数据更新时调用之前，发生在虚拟 DOM 打补丁之前。 //场景：适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。 // 实际应用： // 因为在 mounted 的时候就会经常进行数据的更新，所以就没必要在这个生命周期进行数据处理了 // 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom&#125;updated()&#123; //状态：虚拟 DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM 的操作 // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 //updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated // 避免在这个钩子函数中操作数据，可能陷入死循环 // 实际应用： // 对数据统一处理，在这里写上相应函数&#125;activated()&#123; //keep-alive 组件激活时调用。 //在使用 vue-router 时有时需要使用 &lt;keep-alive&gt;&lt;/keep-alive&gt;来缓存组件状态，这样可以避免 created 钩子就不会被重复调用了， //场景：如果我们的子组件需要在每次加载的时候进行某些操作，可以使用 activated 钩子触发。&#125;deactivated()&#123; //keep-alive 组件停用时调用。&#125;beforeDestroy()&#123; // 状态：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例 // 场合：常用于销毁定时器、解绑全局事件、销毁插件对象等操作 // 实际应用：你确认删除 XX 吗、 点击下一步的时候、或者需要是存浏览器储存的时候、清除定时器等等， // 因为 vue 是一个单页面，如果定时器在 vue 生命周期销毁之前不清除的话，那就会导致定时器一直在运行，影响性能!!!!!!!!!!!!&#125;destroyed()&#123; //场合：Vue 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 //调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 // 实际应用； // 当前组件已被删除，清空相关内容。下一步，跳转路由。等等？？？？？？？？？？不懂这里&#125;errorCaptured(err,vm,info)&#123; //当捕获一个来自子孙组件的错误时被调用。 //(err: Error, vm: Component, info: string) =&gt; ?boolean //错误对象，发生错误的组件实例，错误来源信息的字符串 //此钩子可以返回 false 以阻止该错误继续向上传播。&#125; 2.1 created 阶段的 ajax 请求与 mounted 请求的区别： created：页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态 mounted ：不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 this.$nextTick 2.2 生命周期的执行情况 单组件 初始化组件时，仅执行了beforeCreate、created、beforeMount、mounted 四个钩子函数（执行一次） 当改变 data 中定义的变量（响应式变量）时，会执行 beforeUpdate、updated 钩子函数（ —–可多次执行） 当切换组件（当前组件未缓存）时，会执行 beforeDestory、destroyed 钩子函数（执行一次） 初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate、updated 可多次执行 父子组件 仅当子组件完成挂载后，父组件才会挂载 当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次） 父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践） 销毁父组件时，先将子组件销毁后才会销毁父组件 1.父 beforeCreate、created、beforeMount2.子 beforeCreate、created、beforeMount、mounted3.父 mounted、beforeUpdate、updated（加载子组件之后自动的执行一次更新：理论上单组件的更新钩子是由于用户的操作 数据更新才会执行的， 里相当于 子组件使得父组件的数据更新了） 4.在这里中间，如果用户操作数据更新，相应的执行父子组件中的周期钩子函数 beforeUpdate、updated。各自数据更新，执行各自的（自己的 data 改变，互不相干）5.如果 props 发生改变，（父子有关系的）执行 父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated6.子组件销毁，子组件的 beforeDestory、destroyed7.父组件销毁，子组件的 父 beforeDestory → 子 beforeDestory → 子 destroyed → 父 destroyed 父、兄弟组件的生命周期 组件的初始化（mounted 之前）分开进行，挂载是从上到下依次进行 当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的 给子组件增加兄弟姐妹之后 1.父 beforeCreate、created、beforeMount2.子一 beforeCreate、created、beforeMount 子二 beforeCreate、created、beforeMount 子一 mounted 子二 mounted3.父 mounted、beforeUpdate、updated（加载子组件之后自动的执行一次更新：理论上单组件的更新钩子是由于用户的操作 数据更新才会执行的， 里相当于 子组件使得父组件的数据更新了） 4.在这里中间，如果用户操作数据更新，相应的执行父子组件中的周期钩子函数 beforeUpdate、updated。各自数据更新，执行各自的（自己的 data 改变，互不相干） 子一更新数据：子一 beforeUpdate、updated 子二更新数据：子二 beforeUpdate、updated5.如果 props 发生改变，（父子有关系的）执行 父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated6.子组件销毁，子组件的 beforeDestory、destroyed7.父组件销毁，子组件的 父 beforeDestory → 子一 beforeDestory → 子一 destroyed → 子二 beforeDestory → 子二 destroyed → 父 destroyed 宏 mixin 的生命周期 mixin 中的生命周期与引入该组件的生命周期是紧密关联的，且 mixin 的生命周期优先执行 1.mixin-beforeCreate 、beforeCreate、mixin-created、created、mixin-beforeMount、beforeMount、mixin-mounted、mounted 如果有子组件，就会在 beforeMount 与 mounted 之间去执行2.mixin-beforeUpdate、beforeUpdate、mixin-updated、updated3.mixin-beforeDestory、beforeDestory、mixin-destroyed 、destroyed 如果有子组件，就会在 beforeDestory 与 destroyed 之间去执行 总结执行顺序，对照 DOM 事件的捕获和冒泡过程来看： beforeCreate 、 created 、 beforeUpdate 、 beforeDestroy 是在“捕获”过程中调用的； mounted 、 updated 、 destroyed 是在“冒泡”过程中调用的。 同时，可以看到，在初始化流程、 update 流程和销毁流程中，子级的相应声明周期方法都是在父级相应周期方法之间调用的。比如子级的初始化钩子函数（ beforeCreate 、 created 、 mounted ）都是在父级的 created 和 mounted 之间调用的，这实际上说明等到子级准备好了，父级才会将自己挂载到上一层 DOM 树中去，从而保证界面上不会闪现脏数据。 路由切换时，组件生命周期的执行（就不考虑 update 了） 可以看到，从 A 组件切换到 B 组件时A beforeCreateA createdA beforeMountA mounted要是 A update 就是在这里就是在这个时候 从 A 切换到 B 页面的。B beforeCreateB createdB beforeMountA beforeDestroyA destroyedB mounted，要是 B update 就是在这里，然后再切换别的就是 三、实际应用根据第二章的总结，对照 DOM 事件的捕获和冒泡过程来看： beforeCreate 、 created 、 beforeUpdate 、 beforeDestroy 是在“捕获”过程中调用的； mounted 、 updated 、 destroyed 是在“冒泡”过程中调用的。 同时，可以看到，在初始化流程、 update 流程和销毁流程中，子级的相应声明周期方法都是在父级相应周期方法之间调用的。比如子级的初始化钩子函数（ beforeCreate 、 created 、 mounted ）都是在父级的 created 和 mounted 之间调用的，这实际上说明等到子级准备好了，父级才会将自己挂载到上一层 DOM 树中去，从而保证界面上不会闪现脏数据。","tags":[]},{"title":"react.js--[事件处理]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-事件处理/","text":"一、事件处理 在 react 的 ES6 class 组件中，事件函数与其他的周期选项是平级的 事件函数的 this 要处理好，（ES6 this 的关系） 二、绑定事件处理函数 this 的几种写法2.1 在构造函数中绑定 this.bind(this) 在 构造器中定义方法的时候使用 Function.prototype.bind 123456789101112131415161718192021222324252627282930313233import React, &#123; Component &#125; from 'react';class Toggle extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isToggleOn: true, msg:'some msg' &#125;; this.handleClick = this.handleClick.bind(this);//在构造函数加上这语句代码 this.run = this.run.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123;// 注意这样不要使用 this.state 或者 this.props 因为可能是异步的， isToggleOn: !prevState.isToggleOn // 使用 函数，传参 prevState props &#125;)); &#125; run()&#123; alert(this.state.name) &#125; render() &#123; return ( &lt;div&gt; /* 上面的 this 要处理好，不然这里无法获取到 handleClick 事件处理方法，因为这里是回调函数，this 值不是原来的值了 */ &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt; &lt;button onClick=&#123;this.handleClick(this,id)&#125;&gt;&#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; &lt;button onClick=&#123;this.run&#125;&gt;按钮&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export defalut Toggle; 必须谨慎对待 JSX 回调函数中的 this，ES6 中类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this.handleClick 的值会是 undefined。 上面代码中也说了 vue 也存在 this 的问题，也要注意。因为这个 this 是 JS 中的问题，它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。 5.2.2 属性初始化器语法（使用箭头函数）（这个办法应该算是最简答的办法了！！！！！！！！！！！）如果使用 bind 让你很烦，这里有两种方式可以解决。如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数： 123456789101112131415161718class LoggingButton extends React.Component &#123; // 事件函数使用箭头函数写法 handleClick = () =&gt; &#123; console.log('this is:', this); &#125; run=()=&gt; &#123; alert(this.state.name) &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;this.run&#125;&gt;按钮&lt;/button&gt; ); &#125;&#125;export defalut LoggingButton; 5.2.3 在 render 中使用箭头函数，（不推荐这个办法，会有性能问题，所以不一般都没有说这个办法吧，不要在 render去处理这里问题）使用这个语法有个问题就是 每次 LoggingButton 渲染的时候 都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类 性能问题。 123456789101112class LoggingButton extends React.Component &#123; handleClick() &#123; console.log('this is:', this); &#125; render() &#123; // This syntax ensures `this` is bound within handleClick return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;Click me&lt;/button&gt;// 不推荐 // 不推荐在 render 中这样使用箭头函数，会有性能问题，虽然这也是一个办法 ); &#125;&#125; 六、触发事件-传递参数：2 种办法6.1 render 中回调函数传参（但是上面好像说这个办法不可取啊？？？？？） 事件 event 必须显示传参，并且是最后一位 1234567891011121314151617181920212223242526class LoggingButton extends React.Component &#123; constructor()&#123; super(props) this.state=&#123; name:'xiaomi' &#125; &#125; preventPop=(name, e)=&gt;&#123; //接收显示 传递过来的 event 是放在最后的 e.preventDefault(); alert(name); &#125; deleteRow=(id,e)=&gt;&#123; //不需要传递参数的时候就不用写回调了。 &#125; render() &#123; // This syntax ensures `this` is bound within handleClick return ( &lt;div&gt; // 事件 event 要显示传递，放在最后传递 &lt;a href=\"https://reactjs.org\" onClick=&#123;(e)=&gt;this.preventPop(this.state.name,e)&#125;&gt;Click&lt;/a&gt; &lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt; // 参数 e 作为 React 事件对象将会被作为 第 2 个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递。 &lt;/div&gt; ); &#125;&#125; 6.2 render 中 bind 传参（还是用这个办法好了） 事件 event 是隐示传参，接收参数也是在最后一位 this 是一个显示传递的参数，但是接收没有它。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class LoggingButton extends React.Component &#123; constructor()&#123; super(props) this.state=&#123; name:'xiaomi', completeList:[] &#125; &#125; preventPop=(name, e)=&gt;&#123; //接收隐式传递过来的 事件对象 e 要放在最后 e.preventDefault(); alert(name); &#125; deleteRow=(id)=&gt;&#123; // &#125; handleClick=(porps0, props1, ..., event)=&gt;&#123; // your code here &#125; del=(index,e)=&gt;&#123; let completeList = this.state.completeList completeList.splice(index,1) this.setState(&#123; completeList:completeList &#125;) this.setLocaleData() &#125; render() &#123; return ( // 事件 event 不需要显示传递，只是隐式的传递过来了 &lt;div&gt; &lt;a href=\"https://reactjs.org\" onClick=&#123;this.preventPop.bind(this,this.state.name)&#125;&gt;Click&lt;/a&gt; &lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; &lt;button /* onClick=&#123;this.handleClick.bind(this, props0, props1, ...&#125; */&gt;&lt;/button&gt; &lt;List header=&#123;&lt;div&gt;已完成列表&lt;/div&gt;&#125; bordered dataSource=&#123;this.state.completeList&#125; renderItem=&#123;(item,index) =&gt;(&lt;List.Item actions=&#123;[&lt;Button size='small' onClick = &#123;this.del.bind(this,index)&#125;&gt; 删除&lt;/Button&gt;] &#125;&gt;&#123;item&#125;&lt;/List.Item&gt;)&#125;/&gt; &lt;/div&gt; // 通过 bind 的方式，事件对象 e 以及更多的参数将会被隐式的进行传递。写的表达式中我们看不到传递，但是却可以使用了。 // 但是需要注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面 //render 触发事件：this.handleclick.bind(this，要传的参数) // 事件 函数 处理：handleclick(传过来的参数，event) ); &#125;&#125; 七、事件函数注意的问题7.1 onClick={activateLasers} 触发事件函数React 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同: React 事件绑定属性的命名采用 驼峰式写法，而不是小写。因为 React 是 JS ，而 DOM 元素 是 html 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法) 12345678&lt;!-- DOM 元素 绑定事件: 使用引号--&gt;&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt;&lt;!-- 使用返回 false 的方式阻止默认行为 --&gt;&lt;a href=\"#\" onclick=\"console.log('The link was clicked.'); return false\"&gt; Click me&lt;/a&gt; 1234567891011121314151617/* React 元素绑定事件：使用花括号，注意，使用花括号之后就不要用引号了 */&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt;/* 不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。 */function ActionLink() &#123; //在这里，e 是一个合成事件。React 根据 W3C spec 来定义这些合成事件，所以你不需要担心跨浏览器的兼容性问题。 function handleClick(e) &#123; e.preventDefault(); console.log('The link was clicked.'); &#125; return ( &lt;a href=\"#\" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; ); 7.2 事件 e 的处理","tags":[{"name":"react.js事件处理","slug":"react-js事件处理","permalink":"https://liuxmoo.com/tags/react-js事件处理/"}]},{"title":"react.js--入门教程","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-入门/","text":"一、前言虽然我们有中国尤大神的 vue 做 web 端，有有 mpvue 做小程序，但是相比来说还是没有国外的 react 来的好，首先它支持的终端更多。 web 端，移动端，小程序，支付宝程序，等等，这些它都比 vue 延伸的一些源工具要好。ui 库 也有更多的人来维护。很多大公司使用的也是 reac.js。 react 中文网react 16.7.0英文网 React 是一个采用声明式，高效而且灵活的用来构建用户界面的 框架。 从第二章开始学习之前，先要学习 ReactDOM.render() 这个 API 接口，这样我们才能看得动下面的文章学习。从第二章开始学习之前，先要学习 ReactDOM.render() 这个 API 接口，这样我们才能看得动下面的文章学习。从第二章开始学习之前，先要学习 ReactDOM.render() 这个 API 接口，这样我们才能看得动下面的文章学习。 二、先需要学习一下 JSX 拓展语言 &amp;&amp; render 函数去相应的文章去学习。这里省略。 三、React 教程:组件 &amp; PropsReact 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。阮一峰的教程：React.createClass 方法就用于生成一个组件类，但是我们现在使用的是 ES6 ，要与时俱进，现在是 React.Component!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 组件可以将 UI 切分成一些 独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。组件从概念上看就 像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的 React 元素。组件名称必须以 大写字母开头。例如，&lt;div /&gt; 表示一个 DOM 标签，但 &lt;Welcome /&gt; 表示一个组件，并且在使用该组件时你必须定义或引入它。 3.1. 函数定义/类定义组件：JavaScript 函数 &amp;&amp; ES6 class两种方式得到的结果是一样的，下面就是用两种方法来创建同样的一个 React 元素。 3.1.2 JavaScript 函数该函数是一个有效的 React 组件，它接收一个单一的 “props” 对象并返回了一个 React 元素。我们之所以称这种类型的组件为函数定义组件，是因为从字面上来看，它就是一个 JavaScript 函数。 1234//JavaScript函数： 定义组件function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; 3.1.2 ES6 class12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 3.2 组件渲染const element = &lt;div&gt;&lt;/div&gt;; 这个 React 元素 是 DOM 标签/元素：const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;//这个 React 元素 是 用户自定义的组件： 1&lt;div id='root'&gt;&lt;/div&gt; 12345678910//当 React 遇到的元素是 用户自定义的组件，它会将 JSX 属性作为单个对象传递给该组件，这个对象称之为 “props”。function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=\"Sara\" /&gt;;ReactDOM.render( element, document.getElementById('root')); 转译之后得到 123&lt;div id='root'&gt; &lt;h1&gt;Hello, Sara&lt;/h1&gt;&lt;/div&gt; 解析上面的转译过程： 对 &lt;Welcome name=&quot;Sara&quot; /&gt; 元素调用了 ReactDOM.render() 方法。 React 将 {name: &#39;Sara&#39;} 作为 props 对象 传入并调用 Welcome 组件 Welcome 组件将 &lt;h1&gt;Hello, Sara&lt;/h1&gt; 元素作为结果返回 React DOM 将 DOM 更新为 &lt;h1&gt;Hello, Sara&lt;/h1&gt;。 重点!!!!!!!!!!!!!!!!!!!!!!!!!!!!!组件名称必须以 大写字母开头。例如，&lt;div/&gt; 表示一个DOM标签，但 表示一个组件，并且在使用该组件时你必须定义或引入它。 3.3 组合组件组件可以在它的输出中引用其它组件，这就可以让我们用同一组件来抽象出任意层次的细节。在 React 应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。 12345678910111213141516171819202122//创建一个 App 组件，用来多次渲染 Welcome 组件：就是多次复用 Welcome 组件 咯function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root'));//通常，一个新的 React 应用程序的顶部是一个 App 组件。//但是，如果要将 React 集成到现有应用程序中，则可以从下而上使用像 Button 这样的小组件作为开始，并逐渐运用到视图层的顶部。?????看不懂//组件的返回值只能 有一个根元素 !!!!!!!!!!!!!!!!。这也是我们要用一个 &lt;div&gt; 来包裹所有 &lt;Welcome /&gt; 元素的原因。 3.4 提取组件提取组件一开始看起来像是一项单调乏味的工作，但是在大型应用中，构建可复用的组件完全是值得的。当你的 UI 中有一部分重复使用了好几次（比如，Button、Panel、Avatar），或者其自身就足够复杂（比如，App、FeedStory、Comment），类似这些都是抽象成一个可复用组件的绝佳选择，这也是一个比较好的做法。 123456789101112131415161718192021222324//可以将组件切分为更小的组件，这没什么好担心的。function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;div className=\"UserInfo\"&gt; &lt;img className=\"Avatar\" src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125;//这个组件接收 author(对象)、 text(字符串) 、以及 date(Date对象)作为 props，用来描述一个社交媒体网站上的评论。//这个组件由于嵌套，变得难以被修改，可复用的部分也难以被复用。所以让我们从这个组件中提取出一些小组件。 1234567891011//提取 Avatar 组件：function Avatar(props) &#123; return ( &lt;img className=\"Avatar\" src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125;//Avatar 作为 Comment 的内部组件，不需要知道是否被渲染。因此我们将 author 改为一个更通用的名字 user。//建议从组件 自身的角度 来命名 props，而不是 根据使用组件的 上下文命名。 123456789101112131415161718function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;div className=\"UserInfo\"&gt; &lt;Avatar user=&#123;props.author&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 1234567891011//提取一个 UserInfo 组件，用来渲染 Avatar 旁边的用户名：function UserInfo(props) &#123; return ( &lt;div className=\"UserInfo\"&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className=\"UserInfo-name\"&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 12345678910111213function Comment(props) &#123; return ( &lt;div className=\"Comment\"&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;div className=\"Comment-text\"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=\"Comment-date\"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; 3.1.5 Props的只读性无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props。React 是非常灵活的，但它也有一个严格的规则：所有的 React 组件必须像纯函数那样使用它们的 props。 当然，应用的界面是随时间动态变化的，我们将在下一节介绍一种称为 “state” 的新概念，State 可以在不违反上述规则的情况下，根据用户操作、网络响应、或者其他状态变化，使组件动态的响应并改变组件的输出。 12345678function sum(a, b) &#123; return a + b;&#125;//类似于上面的这种函数称为 “纯函数”，它没有改变它自己的输入值，当传入的值相同时，总是会返回相同的结果。//与之相对的是非纯函数，它会改变它自身的输入值：function withdraw(account, amount) &#123; account.total -= amount;&#125; 四、react 教程: State &amp; 生命周期前面学习都是 ReactDOM.render() 方法来创建渲染，本节说的是使用 ES6 的 class 类来创建。 ES6 中class 类会有它自己的 属性与 方法，这个属性其实就是数据。 这里我们就使用 ES6 的 class 类来创建我们的组件。状态 State 与 属性 十分相似，但是 状态是私有的，完全受控于当前组件。定义为类的组件有一些特性。局部状态就是如此：一个功能只适用于类。 4.1 将函数转化为类上面的篇幅中提到一个创建间歇调用的函数，使用的是 函数形式来创建使用组件，这里我们就将它换成 类的形式。 123456789101112131415161718// 函数function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Clock 类// 使用类就允许我们使用其它 特性，例如 局部状态、生命周期钩子!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!// 添加一个类构造函数来初始化状态 this.state ,其实也就是说将外面传进来的 props 放置在 构造函数 state 中//传递 props 到基础构造函数，为一个类添加局部状态，// render 的时候就冲 state 去获取相应的数据class Clock extends React.Component &#123;//创建一个 名称扩展 为 React.Component 的 ES6 类 //① 构造函数 设置组件的初始化状态 constructor(props) &#123; super(props);// 这一句不要忘记了。 this.state = &#123;date: new Date()&#125;;// 需要在 render 中使用到 用状态，不使用到的不需要用。 &#125; // 组件已经被渲染到页面中后触发：此时页面中有了真正的 DOM 的元素，可以进行 DOM 相关的操作 componentDidMount() &#123; // 生命周期，当组件输出到 DOM 后会执行 componentDidMount() 钩子，这是一个建立定时器的好地方： this.timerID = setInterval(// 设置定时器 () =&gt; this.tick(), 1000 ); &#125; //② 组件即将被渲染到页面之前触发，此时可以进行开启定时器、向服务器发送请求等操作 ??????? 正确么？？？？不对吧， // 官网的定时器都是在 componentDidMount() 周期去触发的。 componentWillUnmount() &#123; // 生命周期 clearInterval(this.timerID);// 卸载定时器 &#125; // 更新组件局部状态，要正确的使用 更新状态 this.setState，有点像是小程序的 MINA 框架，更新数据的方式 // 不要直接赋值，直接赋值是不会得到更新的，this.state.date = '2018'; 这个是不成功，这种的只能是在 constructor 初始化数据用的 tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; xxx()&#123; // Wrong, this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。 //this.setState(&#123; // counter: this.state.counter + this.props.increment, //&#125;); //setState() 来接受一个函数,不要使用任何的 this.props 和 this.state,直接使用一个传值。 this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment &#125;)); //this.setState(function(prevState, props) &#123; ES5 的写法 // return &#123; // counter: prevState.counter + props.increment // &#125;; //&#125;); &#125; // 组件渲染 render() &#123; //创建一个叫做 render() 的空方法,将函数体移动到 render() 方法中 // toLocaleTimeString() 是哪里来的 ？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？ return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;// 从 &lt;Clock /&gt; 元素移除 date 属性：ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); 当 &lt;Clock /&gt; 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.state 。 我们稍后会更新此状态。 React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。 当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。 浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState() 来调度UI更新。 通过调用 setState() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新DOM。 一旦Clock组件被从DOM中移除，React会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。 4.2 生命周期去相应的文章学习，这里省略。 4.3 数据自顶向下流动父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。 12345678// 组件可以选择将其状态作为属性传递给其子组件：&lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;//这也适用于用户定义的组件：&lt;FormattedDate date=&#123;this.state.date&#125; /&gt;//FormattedDate 组件将在其属性中接收到 date 值，并且不知道它是来自 Clock 状态、还是来自 Clock 的属性、亦或手工输入：function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;&#125; 这通常被称为 自顶向下或 单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。 1234567891011121314151617//为了表明所有组件都是真正隔离的，我们可以创建一个 App 组件，它渲染三个Clock：function App() &#123; return ( &lt;div&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root'));// 每个 Clock 建立自己的定时器并且独立更新。// 在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。 五、事件处理去看事件处理章节 六、react 教程:条件渲染在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后还可以根据应用的状态变化 只渲染其中的一部分。 React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或 条件运算符 来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。 123456789//两个组件: 子组件// 已经登录显示function UserGreeting(props) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;// 没有登录游客状态显示function GuestGreeting(props) &#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;;&#125; 123456789101112131415// 我们将创建一个 Greeting 组件，它会根据用户是否登录来显示其中之一：function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;// 根据 isLoggedIn 的值渲染不同的问候语。ReactDOM.render( // Try changing to isLoggedIn=&#123;true&#125;: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById('root')); 6.1 元素变量6.1.1 使用 JavaScript 操作符 if 或 条件运算符 来创建表示当前状态的元素 条件渲染可以使用 变量来 储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。 12345678910111213141516// 登录function LoginButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;// 登出function LogoutButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Logout &lt;/button&gt; );&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//一个名为 LoginControl 的 有状态 的组件。class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isLoggedIn: false &#125;; this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn: true&#125;); &#125; handleLogoutClick() &#123; this.setState(&#123;isLoggedIn: false&#125;); &#125; render() &#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; //JSX &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; //JXS &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById('root')); 声明变量并使用 if 语句是条件渲染组件的不错的方式，但有时你也想使用更简洁的语法，在 JSX 中有如下几种方法。 6.1.2 变量 与 与运算符 &amp;&amp; 条件渲染你可以通过用 花括号包裹代码 在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &amp;&amp;，它可以方便地条件渲染一个元素。 之所以能这样做，是因为在 JavaScript 中，true &amp;&amp; expression 总是返回 expression，而 false &amp;&amp; expression 总是返回 false。因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。 12345678910111213141516171819function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125;const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById('root')); 6.1.3 变量 与 三目运算符 条件渲染条件渲染的另一种方法是使用 JavaScript 的条件运算符 condition ? true : false。 像在 JavaScript 中一样，你可以根据团队的习惯选择更易读的方式。还要记住如果条件变得过于复杂，可能就是提取组件的好时机了。 12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; 123456789101112render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; &#123;isLoggedIn ? ( &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt; ) : ( &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt; )&#125; &lt;/div&gt; );&#125; 6.2 阻止组件渲染在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。 在下面的例子中，&lt;WarningBanner /&gt; 根据属性 warn 的值条件渲染。如果 warn 的值是 false，则组件不会渲染： 12345678910111213141516171819202122232425262728293031323334353637383940414243function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=\"warning\"&gt; Warning! &lt;/div&gt; );&#125;class Page extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; showWarning:true &#125; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? 'Hide' : 'Show'&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Page /&gt;, document.getElementById('root')); 组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。?????????????????????? 什么鬼意思？？？？？？？ 七、react 教程：列表 &amp; Keys12345//使用 map() 函数让数组中的每一项翻倍,我们得到了一个新的数列 doubledconst numbers = [1, 2, 3, 4, 5];const doubled = numbers.map((number) =&gt; number * 2);console.log(doubled);//在 React 中，把 数组 转化为 数列元素 的过程是相似的 7.1 渲染多个组件1234567891011//通过使用 &#123;&#125; 在 JSX 内构建一个元素集合const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;);//使用 Javascript 中的 map() 方法遍历 numbers 数组。对数组中的每个元素返回 &lt;li&gt; 标签，最后我们得到一个数组 listItems//把整个 listItems 插入到 ul 元素中，然后渲染进 DOM:ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root')); 7.2 基础列表组件:渲染一个列表到组件中12345678910111213141516171819//给每个列表元素分配一个 key// 没有设置的话 将会看到一个警告 a key should be provided for list items ，意思是当你创建一个元素时，必须包括一个特殊的 key 属性function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 7.3 key7.3.1 使用 keyKeys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 123456const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt;); 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的 id ,作为元素的 key: 12345const todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 没有 id 就用 index 做, 但时 如果列表可以重新排序，我们不建议使用索引来进行排序，因为这会导致渲染变得很慢。如果你想要了解更多，请点击深度解析 key 的必要性 123456const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 7.3.2 用 keys 提取组件元素的 key 只有在 它和它的兄弟节点 对比 时才有意义。 比方说，如果你提取出一个 ListItem 组件，你应该把 key 保存在数组中的这个 &lt;ListItem /&gt; 元素上，而不是放在 ListItem 组件中的 &lt;li&gt;元素上。 1234567891011121314151617181920212223242526//当你在 map()方法 的内部调用元素时，你最好随时记得为每一个元素加上一个独一无二的 key。function ListItem(props) &#123; // 对啦！这里不需要指定key: return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 又对啦！key应该在 数组的上下文 中被指定 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); 7.3.3 元素的 key 在他的兄弟元素之间应该唯一数组元素中使用的 key 在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键 1234567891011121314151617181920212223242526272829303132333435function Blog(props) &#123; const sidebar = ( &lt;ul&gt; &#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125;&gt; &#123;post.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); // key 会作为给 React 的提示，但不会传递给你的组件。如果您的组件中需要使用和 key 相同的值，请将其作为属性传递： // Post 组件可以读出 props.id，但是不能读出 props.key const content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [ &#123;id: 1, title: 'Hello World', content: 'Welcome to learning React!'&#125;, &#123;id: 2, title: 'Installation', content: 'You can install React from npm.'&#125;];ReactDOM.render( &lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById('root')); 7.4 在 jsx 中嵌入 map()1234567891011121314// 声明了一个单独的 listItems 变量并将其包含在 JSX 中function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125; 123456789101112131415// JSX 允许在大括号中嵌入任何表达式，所以我们可以在 map() 中这样使用：// 这么做有时可以使你的代码更清晰，但有时这种风格也会被滥用。//就像在 JavaScript 中一样，何时需要为了可读性提取出一个变量，这完全取决于你。// 但请记住，如果一个 map() 嵌套了太多层级，那可能就是你提取出组件的一个好时机。function NumberList(props) &#123; const numbers = props.numbers; return ( &lt;ul&gt; &#123;numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; )&#125; &lt;/ul&gt; );&#125; 八、react 教程：表单HTML 表单元素与 React 中的其他 DOM 元素有所不同,因为表单元素生来就保留一些内部状态。例如，下面这个表单只接受一个唯一的 name。 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type=\"text\" name=\"name\" /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt; 当用户提交表单时，HTML的默认行为会使这个表单跳转到一个新页面。在React中亦是如此。但大多数情况下，我们都会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。 8.1 受控组件十、API 接口看相应的文章，本章省略。 十一、合成事件 SyntheticEvent文档 十五、this.props.children 组件的所有子节点this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 12345678910111213141516171819202122class NotesList extends React.Component&#123; render() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body);//上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取，运行结果如下。 这里需要注意， this.props.children 的值有 三种 可能：① 如果当前组件没有子节点，它就是 undefined ;② 如果有一个子节点，数据类型是 object ；③ 如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。","tags":[{"name":"react.js事件处理","slug":"react-js事件处理","permalink":"https://liuxmoo.com/tags/react-js事件处理/"}]},{"title":"[ dayjs 库]--moment.js 的轻量级 ","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】-dayjs==Js 库/","text":"一、前言时间格式处理库，在很多时候，我们的页面需要使用到时间日期，但是格式却是有要求的，这个 dayjs 就是一个处理库。 Day.js 是一个轻量的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持完全一样.Day.js 虽然仅有 2kb 大小，但是功能一点都没有阉割。包含了时间处理的全部常用方法。 Day.js – 2kB超轻量时间库Moment.js – 200k+ with locals(可能一般项目也只使用到了她几个常用的API ,因此 dayjs 更好用于时间处理)，他们之间的比较，地址 🕒 和 Moment.js 相同的 API 和用法 比 moment.js 轻量级 💪 不可变数据 (Immutable) 🔥 支持链式操作 (Chainable) dayjs().startOf(‘month’).add(1, ‘day’).set(‘year’, 2018).format(‘YYYY-MM-DD HH:mm:ss’); 🌐 I18n 国际化 📦 仅 2kb 大小的微型库 👫 全浏览器兼容 GitHub 地址源码解析，可以查看这个文章，说得特别的好。地址 Dayjs 并没有改变或覆盖 Javascript 原生的 Date.prototype， 而是创造了一个全新的包含 Javascript Date 对象的 Dayjs 的对象。Dayjs 对象是不可变的, 所有的 API 操作都将返回一个新的 Dayjs 对象。 二、安装 与 引入1234# 安装$ npm install --save dayjs$ yarn add dayjs 12// .vue 或者 react.js 引入，要引入才能使用的import dayjs from \"dayjs\" 三、 dayjs 使用Day.js 有很多 API 来解析、处理、校验、增减、展示时间和日期 3.1 创建/解析 dayjs 构造 dayjs(existing?:string | number | Date | Dayjs)：构造一个 Dayjs 实例对象 克隆 .clone() | dayjs(original: Dayjs)：在已有 Dayjs 实例对象的基础上克隆返回一个新的 Dayjs 实例对象 验证 .isValid()：验证该 Dayjs 实例对象是否有效 1.当没有参数时，会返回一个新的 Dayjs 实例对象，且为当前日期和时间 12345678// ① 不传入任何东西dayjs() // 不传入任何东西，默认为传入 Date.now() 当前时间,获取当前时间// 等价于// ② 传入 Date.now()dayjs(Date.now())// ③ 传入 一个表达式dayjs(Date.now() - 24 * 60 * 60 * 1000) // 昨天 2.当参数为 ISO 8601 标准的字符串时 1234// ④ 传入一个字符串var day = dayjs('1995-12-25') // 1995-12-25 传入字符串，一个标准的 ISO 8601 时间字符串。var day = dayjs('2018-08-08') // 2018-08-08dayjs('2018-07-01T12:00:00.000Z') 3.当参数为 unix 时间戳时 12// ⑤ 传入一个数字 语法 dayjs(Number);dayjs(1318781876406); 4.当参数为一个原生的 JavaScript Date 对象时 12// ⑥ 传入一个 Date 对象 语法 dayjs(Date); 传入的一个 Javascript Date 对象。dayjs(new Date(2018, 8, 18)); dayjs() 构造函数会返回一个 Dayjs 实例对象克隆 .clone() | dayjs(original: Dayjs)会克隆返回一个新的 Dayjs 对象，有两种方法 12345// 1.使用 .clone() 方法dayjs().clone()////Dayjs 对象是不可变的，如果你想获得一个对象的拷贝，请执行 .clone()。 向 dayjs() 里传入一个 Dayjs 对象也能实现同样的效果// 2.使用 dayjs 构造函数，且传入的参数为被克隆的 Dayjs 实例对象dayjs(dayjs('2018-7-1')) 验证 .isValid()返回一个布尔值，表示该 Dayjs 实例对象是否有效 12// ② 验证是否有效dayjs().isValid();// true 3.2 展示/显示 格式化 .format(stringWithTokens: string) 差别 .diff(compared: Dayjs, unit: string (default: ‘milliseconds’), float?: boolean) Unix 时间戳（毫秒） .valueOf() Unix 时间戳（秒） .unix() 某月的天数 .daysInMonth() 转换为 JavaScript Date 对象 .toDate 转换为数组 .toArray() 转换为 JSON .toJSON() 转换为 ISO 8601 标准格式的字符串 .toISOString() 转换为对象 .toObject() 转换为字符串 .toString() 1.格式化 1234567891011121314//语法：dayjs().format(String);dayjs().format('YYYY年MM月DD日 HH:mm:ss') // 2018年08月08日 00:00:00//从后端获取到的时间 t（时间戳 ms） 格式化 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!这个是重点啦dayjs(ti).format('YYYY年MM月DD日 HH:mm:ss') // 2018年08月08日 00:00:00// 如果后端给的时间是 s，不要忘记 * 1000 转化为时间戳dayjs(t * 1000).format(\"YYYY-MM-DD HH:mm:ss\");// format 后面是自己需要的格式就okdayjs().format('[YYYY]') // \"[2018]\"。 [] 里的会原样输出。dayjs().format('&#123;YYYY&#125; MM-DDTHH:mm:ss SSS [Z] A') //dayjs().format(); // \"2014-09-08T08:02:17-05:00\" (ISO 8601, no fractional seconds)dayjs().format(\"[YYYY] MM-DDTHH:mm:ssZ\"); // \"[2014] 09-08T08:02:17-05:00\"dayjs('2019-01-25').format('DD/MM/YYYY'); // '25/01/2019'dayjs('2019-01-25').format('&#123;YYYY&#125; MM-DDTHH:mm:ssZ[Z]'); // '&#123;2019&#125; 01-25T00:00:00-02:00Z 2.时间差:返回两个 Dayjs 实例对象的时间差 1234567891011//语法：dayjs().diff(Dayjs, unit); 获取两个 Dayjs 对象的时间差，默认毫秒。//差别 .diff(compared: Dayjs, unit: string (default: 'milliseconds'), float?: boolean)dayjs().diff(dayjs(), 'years'); // 0const date1 = dayjs('2019-01-25');const date2 = dayjs('2018-06-05');date1.diff(date2); // 20214000000date1.diff(date2, 'months'); // 7date1.diff(date2, 'months', true); // 7.645161290322581date1.diff(date2, 'days'); // 233 3.unix 时间戳（毫秒） .valueOf() 12dayjs().valueOf();// 返回 Unix 时间戳 (毫秒)dayjs('2019-01-25').valueOf(); // 1548381600000 4.unix 时间戳（秒） .unix() 12dayjs().unix(); //返回 Unix 时间戳 (秒)。dayjs('2019-01-25').unix(); // 1548381600 5.某月的天数 .daysInMonth() 12dayjs().daysInMonth(); //返回月份的天数。dayjs('2018-7-1').daysInMonth() // 31 6.转换为（原生 Date 对象 | 数组 | json | ISO 8601 字符串 | 对象 | 字符串） 123456789101112131415161718192021222324// 1.转换为 原生 Date 对象dayjs('2019-01-25').toDate()// 2.转换为 数组dayjs('2019-01-25').toArray() // [ 2019, 0, 25, 0, 0, 0, 0 ]// 3.转换为 jsondayjs('2019-01-25').toJSON() // '2019-01-25T02:00:00.000Z'// 4.转换为 ISO 8601 字符串dayjs('2019-01-25').toISOString() // '2019-01-25T02:00:00.000Z'// 5.转换为 ISO 8601 字符串dayjs('2019-01-25').toObject()/* &#123; years: 2019, months: 0, date: 25, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 &#125; */// 6.转换为 字符串dayjs('2019-01-25').toString() // 'Fri, 25 Jan 2019 02:00:00 GMT' 3.3 获取与设置时间 年 .year() 月 .month() 日 .date() 星期几 .day() 时 .hour() 分 .minute() 秒 .second() 毫秒 .millisecond() 设置 .set(unit: string, value: number) 1234567891011121314151617// 设置时间// 语法：dayjs().set(unit : String, value : Int);//设置时间 传入的单位 (unit) 对大小写不敏感。dayjs().set('month', 3); // Aprildayjs().set('date', 1) // 设置 “日” 为 1 日dayjs().set('month', 3) // 设置 “月” 为 4 月dayjs().set('second', 30) // 设置 “秒” 为 30 秒// 获取时间dayjs().year(); //获取年份dayjs().month(); //获取月份dayjs().date(); //获取日期dayjs().day() //获取星期几dayjs().hour(); //获取小时dayjs().minute();//获取分钟dayjs().second();//获取秒dayjs().millisecond();// 获取毫秒//上面返回的值与用原生 Date.prototype 对象下的方法获取 “年月日...” 的值是一样的，其实在源码中，就是使用的 Date 的原生方法获取的 “年月日...” 3.4 操作/方法 对 Dayjs 对象如下增加减少之类的操作 添加 .add(value: number, unit: string) 减少 .subtract(value: number, unit: string) 开始的时间 .startOf(unit: string) 结束的时间 .endOf(unit: string) 12345678910111213141516//① 加法 语法：dayjs().add(value : Number, unit : String);dayjs().add(7, 'day') // 之后、往后的第 7 天dayjs().add(1, 'year') // 之后的第 1 年// ② 减法 语法：dayjs().subtract(value : Number, unit : String);dayjs().subtract(1, 'months') // 上个月dayjs().subtract(7,'year')// ③ 开头时间 语法：dayjs().startOf(unit : String); 返回当前时间的开头时间的 Dayjs() 对象，如月份的第一天。dayjs().startOf('months') // 获取该月份的第一天。dayjs().startOf('year'); // 获取该年年初一天dayjs().startOf('week') // 本周开始的时间//④ 末尾时间 语法：dayjs().endOf(unit : String); 返回当前时间的末尾时间的 Dayjs() 对象，如月份的最后一天。dayjs().endOf('year') // 获取一年年末dayjs().endOf('month'); // 获取该月的最后一天 1234567// dayjs 中的方法是可以链式的dayjs().startOf('month').add(1, 'day').subtract(1, 'year')dayjs('2018-7-1') .add(1, 'day') .substract(1, 'year').toString()// 在 2018-7-1 基础上添加 1 天，然后减少 1 年，最后转换为字符串 3.4 查询 （返回布尔值） 是否在之前 .isBefore(compared: Dayjs) 是否相同 .isSame(compared: Dayjs) 是否在之后 .isAfter(compared: Dayjs) 是否是 Dayjs 实例对象 isDayjs() 123456789101112131415//是否相同 检查一个 Dayjs 对象是否和另一个 Dayjs 对象时间相同。dayjs().isSame(dayjs()); // true//是否早于dayjs('2010-10-20').isBefore('2010-10-21') // truedayjs().isBefore(dayjs()) // false//是否晚于 检查一个 Dayjs 对象是否在另一个 Dayjs 对象时间之后。dayjs('2010-10-20').isAfter('2010-10-19') // truedayjs().isAfter(dayjs()); // false//是否是 Dayjs 实例对象dayjs.isDayjs(dayjs()); // truedayjs.isDayjs(new Date()); // false 3.5 dayjs 内置插件（需要额外的导入加载） 相对时间 relativeTime 是否是闰年 支持农历 buddhistEra 特色格式化 advancedFormat 123456//dayjs 使用插件的语法//dayjs 的插件，通过挂载到 dayjs 函数下的 extend 函数加载，然后使用：import plugin // 导入插件dayjs.extend(plugin) // 加载插件dayjs.extend(plugin, options) // 或者加载插件的同时，加入插件所需要的参数 1.相对时间 12//相对时间//使用 .from .to .fromNow .toNow 方法来获得相对时间 2.判断是否是闰年 12345//判断是否是闰年import isLeapYear from 'dayjs/plugin/isLeapYear'// ① 导入插件像这样，需要先引入才能使用这个方法dayjs.extend(isLeapYear) // ② 加载插件dayjs('2000-01-01').isLeapYear() // true ③ 使用插件方法 语法：dayjs().isLeapYear();// dayjs() 没有参数，默认指的是判断当前时间 3.支持农历 buddhistEra 4.特色格式化 advancedFormat 12345import advancedFormat from 'dayjs/plugin/advancedFormat' // 按需加載插件，导入插件dayjs.extend(advancedFormat) // 加载插件dayjs().format('Q Do k kk X x') // 使用插件方法 3.6 编写自己的 dayjs 插件通过阅读插件的源码，我们知道了插件的方法，可以挂载到 Dayjs 类上、Dayjs 类原型上以及 dayjs 函数对象上。并且，可以通过插件选项（option），来对插件进行配置。通过插件，可以很方便的进行 dayjs 库的方法的扩展，来更好的服务我们的具体的业务需求。官方文档也提供了插件开发的模板： 123456789101112131415161718export default (option, dayjsClass, dayjsFactory) =&gt; &#123; // 扩展 dayjs() 实例 // 例：添加 dayjs().isSameOrBefore() 实例方法 dayjsClass.prototype.isSameOrBefore = function (arguments) &#123;&#125; // 扩展 dayjs 类 // 例：添加 dayjs.utc() 类方法 dayjsFactory.utc = (arguments) =&gt; &#123;&#125; // 覆盖已存在的 API // 例：扩展 dayjs().format() 方法 const oldFormat = dayjsClass.prototype.format dayjsClass.prototype.format = function (arguments) &#123; // 原始format结果 const result = oldFormat(arguments) // 返回修改后结果 &#125;&#125; 3.7 国际化（语言，时间）（也是按需加载）12345import 'dayjs/locale/es' // 按需加載dayjs.locale('es') // 全局使用西班牙語dayjs('2018-05-05').locale('zh-tw').format() // 局部使用繁體中文","tags":[]},{"title":"HTTP--[小白入门版、速学版]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑨-【HTTP】-HTTP-网络请求-入门/","text":"一、前言在公司合作项目，前后端都是分开的，主打前端可以不知道怎么写后端，但是后端提供的 API 接口文件需要知道如何调用、获取数据展现在前端。后端会提供类似以下格式的 api 接口文件： 发送登录请求 API 示例 1234567POST /v1/login Http/1.1 Content-Type: application/json&#123;&quot;username&quot;:&lt;username&gt;,&quot;password&quot;:&lt;password&gt;&#125; 这里的前后端通信就需要通过 http 协议进行，要理解就要掌握 http 协议是如何工作的。两本高手级别的书 《HTTP权威指南》，《TCP/IP详解，卷I》，内容艰涩难懂，学习难度大。对于像我这种门外汉来说，直接学习两本圣经书，我是没法看下去的，好在日本 上野宣 著有一书 《图解HTTP》 ，本书全书几乎全以图片讲解，让人易于学习。 二、HTTP 工作原理在学习如何使用 http 之前，首先要知道它的工作原理。 HTTP 协议工作于客户端-服务端架构上。用于客户端和服务端的通信。请求访问文本或图像等资源的一段被称为客户端：例如浏览器，桌面应用，手机浏览器，手机 APP 应用等。提供资源相应的一端称为服务器。 客户端通过URL向服务端发送所有请求消息（请求报文），服务器根据接收到的请求后，向客户端发送响应消息（相应报文）。例如上面写的代码，前端发送这段代码给后端以获取信息。 请求与相应的消息都称为报文，包括报文首部+空行+报文主体 三、HTTP协议使用3.1 客户端发送请求HTTP报文结构客户端发送一个HTTP请求(请求报文)到服务器的请求。 请求消息包括以下格式： 请求行：请求方法，请求 URI/URL，HTTP 协议版本&nbsp;&nbsp;&nbsp;HTTP首部字段：（可选）&nbsp;&nbsp;&nbsp;空行&nbsp;&nbsp;&nbsp;请求数据/请求内容实体：（可选） 以下为新增文件夹的接口示例：（后端提供的API文件） 12345678POST /v1/account/storage/folder Http/1.1 请求行Authorization: &lt;token&gt; 首部字段-(postman中的headers) 空行&#123;&quot;label&quot;:&quot;folder&quot;, 请求实体--(postman中的body)&quot;name&quot;:&quot;?????&quot;,&quot;parentID&quot;:&quot;5aa14f9f8e1a0be97ee9abe3&quot;&#125; 3.1.1请求行 请求行：POST /v1/account/storage/folder Http/1.1 请求—-方法：POST（请求访问服务器的类型），请求—-URL：/v1/account/storage/folder（指明访问的资源对象），http 版本号：Http/1.1（提示客户端用的 http 协议功能） 序号 请求方法 说明 支持的 HTTP 协议版本 1 GET 获取资源 -1.1 2 POST 传输实体主体：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 -1.1 3 PUT 传输文件：从客户端向服务器传送的数据取代指定的文档的内容。 -1.1 4 HEAD 获取报文首部：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 -1.1 5 DELETE 删除文件：请求服务器删除指定的页面。 -1.1 6 link 建立和资源的联系 仅支持1.0 7 unlink 断开连接关系 仅支持1.0 8 TRACE 追踪路径：回显服务器收到的请求，主要用于测试或诊断。 1.1 9 OPTIONS 询问支持的方法：允许客户端查看服务器的性能。 1.1 10 CONNECT 要求用隧道协议链接代理：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 1.1 3.1.2 首部字段 Authorization: token 具体学习见第四章:HTTP 报文首部 3.2 服务器相应信息反馈 响应消息包括以下格式： 状态行：HTTP 协议版本,状态码,原因短语HTTP 首部字段：（可选）空行响应数据/响应内容实体：（可选） 以下为新增文件夹的接口示例：（后端提供的 API 文件） HTTP 响应(相应报文)也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。以下为相应示例： 12345678HTTP/1.1 200 OK 状态行Date: Mon, 27 Jul 2018 12:28:53 GMT HTTP首部字段Content-Length: 724Content-Type: text/html&lt;html&gt; 响应内容实体...&lt;/html&gt; 3.2.1 状态行 状态行：TTP/1.1 200 OK http版本号：Http/1.1状态—-码：200原因–短语：ok 123456# 状态码 类别 原因短语# 1.. informational(信息状态码) 服务器收到请求，需要请求者继续执行操作，正在处理请求# 2.. success（成功状态码） 请求正常处理完毕，操作被成功接收并处理 (成功)# 3.. Redirction（重定向） 需要进一步的操作以完成请求 # 4.. Client（客户端错误） 客户端错误，请求包含语法错误或无法完成请求 (前端错误/后端错误)# 5.. Server Error（服务端错误） 服务器错误，服务器在处理请求的过程中发生了错误 (后端错误) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 1.. informational(信息状态码) 服务器收到请求，需要请求者继续执行操作，正在处理请求# 100 Continue 继续。# 客户端应继续其请求，需要请求者继续执行操作| # 102 Switching Protocols（成功状态码）切换协议。# 服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议# 2.. success（成功状态码） 请求正常处理完毕，操作被成功接收并处理 (成功)# 200 OK 请求成功。# 一般用于 GET 与 POST 请求# 201 Created 已创建。# 成功请求并创建了新的资源# 202 Accepted 已接受# 已经接受请求但未处理完成# 203 Non-Authoritative Information 非授权信息# 请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本# 204 No Content 无内容# 服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档# 205 Reset Content 重置内容# 服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域|# 206 Partial Content 部分内容# 服务器成功处理了部分GET请求|# 3.. Redirction（重定向） 需要进一步的操作以完成请求 # 300 Multiple Choices =&gt;多种选择# 请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择# 301 Moved Permanently =&gt;永久移动，请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。# 今后任何新的请求都应使用新的URI代替# 302 Found =&gt; 临时移动。与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI# 303 See Other =&gt; 查看其它地址。 与301类似。使用GET和POST请求查看# 304 Not Modified =&gt; 未修改。 所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。# 客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源# 305 Use Proxy =&gt; 使用代理。 所请求的资源必须通过代理访问# 306 Unused xxxxx =&gt; 已经被废弃的HTTP状态码# 307 Temporary Redirect =&gt; 临时重定向。与302类似。使用GET请求重定向# 4.. Client（客户端错误） 客户端错误，请求包含语法错误或无法完成请求 (前端错误/后端错误)# 400 Bad Request =&gt; 客户端请求的语法错误，服务器无法理解# 401 Unauthorized =&gt; 请求要求用户的身份认证# 402 Payment Required =&gt; 保留。将来使用# 403 Forbidden =&gt; 服务器理解请求客户端的请求，但是拒绝执行此请求# 404 Not Found =&gt; 服务器无法根据客户端的请求找到资源（网页） 【前端错误/后端错误】# 通过此代码，网站设计人员可设置 \"您所请求的资源无法找到\" 的个性页面# 405 Method Not Allowed =&gt; 客户端请求中的方法被禁止# 406 Not Acceptable =&gt; 服务器无法根据客户端请求的内容特性完成请求# 407 Proxy Authentication Required =&gt; 请求要求代理的身份认证# 与 401 类似，但请求者应当使用代理进行授权# 408 Request Time-out =&gt; 服务器等待客户端发送的请求时间过长，超时# 409 Conflict =&gt; 服务器完成客户端的 PUT 请求是可能返回此代码，服务器处理请求时发生了冲突# 410 Gone =&gt; 客户端请求的资源已经不存在# 410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置# 411 Length Required =&gt; 服务器无法处理客户端发送的不带 Content-Length 的请求信息# 412 Precondition Failed =&gt; 客户端请求信息的先决条件错误# 413 Request Entity Too Large =&gt; 由于请求的实体过大，服务器无法处理，因此拒绝请求。# 为防止客户端的连续请求，服务器可能会关闭连接。# 如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息# 414 Request-URI Too Large =&gt; 请求的 URI 过长（ URI 通常为网址），服务器无法处理# 415 Unsupported Media Type =&gt; 服务器无法处理请求附带的媒体格式# 416 Requested range not satisfiable =&gt; 客户端请求的范围无效# 417 Expectation Failed =&gt; 服务器无法满足 Expect 的请求头信息# 5.. Server Error（服务端错误） 服务器错误，服务器在处理请求的过程中发生了错误 (后端错误)# 500 Internal Server Error =&gt; 服务器内部错误，无法完成请求# 501 Not Implemented =&gt; 服务器不支持请求的功能，无法完成请求# 502 Bad Gateway =&gt; 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求# 503 Service Unavailable =&gt; 由于超载或系统维护，服务器暂时的无法处理客户端的请求。# 延时的长度可包含在服务器的Retry-After头信息中# 504 Gateway Time-out =&gt; 充当网关或代理的服务器，未及时从远端服务器获取请求# 505 HTTP Version not supported =&gt; 服务器不支持请求的HTTP协议的版本，无法完成处理 3.2.2 首部字段123Date: Mon, 27 Jul 2018 12:28:53 GMTContent-Length: 724Content-Type: text/html 具体学习见第四章:HTTP报文首部 四、HTTP 报文首部 4.1 HTTP 报文分类 请求报文 响应报文 4.2 HTTP 首部字段类型 通用首部字段：请求报文和响应报文两方都会使用的首部 请求首部字段：从客户端向服务器发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关 优先级等信息 响应首部字段：从服务器向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息 实体首部字段：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等实体有关的信息 HTTP首部字段由 首部字段名 : 字段值 构成，字段值可以有多个，如：Keep-Alive：timeout=15，max=100 ——————-通用首部字段 —————————————————————————————————————————————实体首部字段—————– 序号 通用首部字段名 说明 序号 实体首部字段名 说明 1 Cache-Control 控制缓存的行为 1 Allow 资源可支持的HTTP方法 2 Connection 逐跳首部、连接的管理 2 Content-Encoding 实体主体的适用的编码方式 3 Date 创建报文的日期时间 3 Content-Language 实体主体的自然语言 4 Pragma 报文指令 4 Content-Length 实体主体的大小（单位：字节） 5 Trailer 报文末端的首部一览 5 Content-Location 替代对应资源的URI 6 Transfer-Encoding 指定报文主体的传输编码方式 6 Content-MD5 实体主体的报文摘要 7 Upgrade 升级为其他协议 7 Content-MD5 实体主体的报文摘要 8 Via 代理服务器的相关信息 8 Content-Range 实体主体的位置范围 9 Warning 错误通知 9 Content-Type 实体主体的媒体类型 10 Expires 实体主体过期的日期时间 ——————-请求首部字段 —————————————————————————————————————————————响应首部字段—————– 序号 请求首部字段名 说明 序号 响应首部字段名 说明 1 Accept 用户代理可处理的媒体类型 1 Accept-Ranges 是否接受字节范围请求 2 Accept-Charset 优先的字符集 2 Age 推算资源创建经过时间 3 Accept-Encoding 优先的内容编码 3 ETag 资源的匹配信息 4 Accept-Language 优先的语言（自然语言） 4 Location 令客户端重定向至指定的URI 5 Authorization Web认证信息 5 Proxy-Authenticate 代理服务器对客户端的认证信息 6 Expect 期待服务器的特定行为 6 Reter-After 对再次发起请求的时机要求 7 From 用户的电子邮箱地址 7 Server HTTP服务器的安装信息 8 Host 请求资源所在服务器 8 Vary 代理服务器缓存的管理信息 9 if-Match 比较实体标记（ETag） 9 WWW-Authenticate 服务器对客户端的认证信息 10 if-Modified-Since 比较资源的更新时间 11 if-None-Match 比较实体标记（与if-Match相反） 12 if-Range 资源未更新时发送实体Byte的范围请求 13 if-Unmodified-Since 比较资源的更新时间（与if-Modified-Since相反） 14 Max-Forwards 最大传输逐跳数 15 Proxy-Authorization 代理服务器要求客户端的认证信息 16 Proxy-Authorization 代理服务器要求客户端的认证信息 17 Referer 对请求中URI的原始获取方法 18 TE 传输编码的优先级 19 User-Agent HTTP客户端程序的信息 4.3 HTTP 请求报文首部、 HTTP 响应报文首部HTTP请求报文首部 请求行 请求首部字段 通用首部字段 实体首部字段 HTTP响应报文首部 状态行 响应首部字段 通用首部字段 实体首部字段 五、HTTP 背景，web、网络基础 TCP/IP十、bug10.112345Uncaught (in promise) DOMException: Failed to execute 'open' on 'XMLHttpRequest': '' is not a valid HTTP method. at dispatchXhrRequest (webpack-internal:///./node_modules/axios/lib/adapters/xhr.js:45:13) at new Promise (&lt;anonymous&gt;) at xhrAdapter (webpack-internal:///./node_modules/axios/lib/adapters/xhr.js:12:10) at dispatchRequest (webpack-internal:///./node_modules/axios/lib/core/dispatchRequest.js:59:10) 是因为在 ajax 请求，或者是 axios 封装的请求中，url 或者是 method 写了 ‘’。没有写到的代码就先不要把 请求先写了，会报各种的错误。 这个错误有的时候回说是 url 的问题，可能是填写的 url 不完整，没有 http 或者 https ，或者是缺少其他的。","tags":[]},{"title":"webpack 小白入门","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑩ - 【命令-工具】webpack== 打包工具-构建工具/","text":"一、前言本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(static module bundler)。在 webpack 处理应用程序时，它会在内部创建一个依赖图(dependency graph)，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。简而言之就是一个打包工具。 wenpack 的版本会不断的更新，每个时期的版本使用方法都是会存在差异的。具体使用的时候查阅官方文档。 英文文档：网址中文文档：网址 在开始前你需要先理解它的核心概念： 入口(entry) 输出(output) loader 插件(plugins) 二、webpack 应用实例vue-cli 脚手架创建的项目，就是使用这个 webpack 来打包的。 其他工具没有做好打包的话，需要自己使用 webpack 工具自行打包。实战项目中的数独游戏便是使用 jQuery.js + webpack 自行实现打包的。数独游戏项目网址 vue 中 wepack123456789101112//webpack.jsmodule.exports = &#123; //mode: 'production' //webpack 4+ 使用这个方式，webpack 3 或者以下 的版本使用下面的 plugins 插件放入'process.env.NODE_ENV' plugins: [ // ... //webpack 3 及其更低版本中，你需要使用 DefinePlugin //Vue 源码会根据 process.env.NODE_ENV 决定是否启用生产环境模式，默认情况为开发环境模式。 new webpack.DefinePlugin(&#123; 'process.env.NODE_ENV': JSON.stringify('production') &#125;) ]&#125; 十五、安装 webpack 、webpack-cli 过程中遇到的坑15.1 Missing write access 没有正确的地址来安装1234567891011121314151617181920212223242526272829303132333435λ npm install webpack@4.19.1 -gnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\async-each # 没有正确的地址来安装npm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\balanced-matchnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\brorandnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\buffer-fromnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\chownrnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\console-browserifynpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\constants-browserifynpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\copy-descriptornpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\core-util-isnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\decode-uri-componentnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\eventsnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\for-innpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\https-browserifynpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\iferrnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\inheritsnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\is-accessor-descriptornpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\is-data-descriptornpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\is-extglobnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\is-globnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\kind-ofnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\define-property\\node_modules\\is-descriptornpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\define-propertynpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\fseventsnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\utilnpm WARN checkPermissions Missing write access to C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\define-property\\node_modulesnpm ERR! path C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\async-eachnpm ERR! code ENOENTnpm ERR! errno -4058npm ERR! syscall accessnpm ERR! enoent ENOENT: no such file or directory, access 'C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\node_modules\\async-each'npm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoentnpm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-12-25T02_51_29_082Z-debug.log 这是因为，之前全局安装了，虽然现在项目搭建中没有找到 webpack ，但是这个包在电脑上是存在的，所以需要手动的删除 webpack。地址就是\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\ 将这个 webpack 文件夹全局删除，有 webpack-cli 的话也顺便随手删除掉好了， 123456# 删除本地 webpack 相关文件夹$ npm uninstall webpack -g # 全局卸载 webpack$ npm uninstall webpack-cli -g # 全局卸载 webpack-cli$ npm cache verify # 清除缓存$ npm install webpack@4.19.1 --save-dev -g # 重装 webpack$ npm install webpack-cli@3.1.2 -D # 这个貌似不需要全局安装？？？ 15.2 pm WARN optional SKIPPING OPTIONAL DEPENDENC12345λ npm install webpack@4.19.1 -gC:\\Users\\Administrator\\AppData\\Roaming\\npm\\webpack -&gt; C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\bin\\webpack.jsnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\webpack\\node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted &#123;\"os\":\"darwin\",\"arch\":\"any\"&#125; (current: &#123;\"os\":\"win32\",\"arch\":\"x64\"&#125;)# fsevent 是 mac osx 系统的，在 win 或者 Linux 下使用了 所以会有警告，忽略即可。意思就是你已经安装成功了。 你的项目有可能是团队项目，别人在他的 mac 上安装了 fsevents 相关依赖库，所以到这边你也就安装到你的 windows 上边了。你可以检查你的package.json 文件中是不是有 fsevents 相关依赖，删除即好！或者更这个只是警告，可以不用管理。 C:\\Users\\Administrator\\AppData\\Roaming\\npm\\node_modules\\webpack\\文件夹下的 package.json 文件夹下的删除&quot;fetchSpec&quot;: &quot;4.19.1&quot; 15.3 We will use “npm” to install the CLI via “npm install -D”123456λ webpack -v # 全局查看 webpack-cli 的版本，出现下面的错误因为是没有全局安装One CLI for webpack must be installed. These are recommended choices, delivered as separate packages: - webpack-cli (https://github.com/webpack/webpack-cli) The original webpack full-featured CLI.We will use \"npm\" to install the CLI via \"npm install -D\".# webpack 单独分离出了wepack-cli，需要我们安装wepack-cli。 12# 安装 webpack-cli，好像我们也不需要这样全局来安装 webpack-cli 的版本的$ npm install webpack-cli@3.1.2 -D 15.4","tags":[]},{"title":"vue 实战项目【5】--[仿网易云音乐 APP 端做 web 端]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑫ -项目实战-vue.js 仿网易云音乐/","text":"一、前言前面学习了 vue.js，已经学习它的框架 vue-cli，状态管理器 vuex，现在搭配一个 ui 框架 iview 来做一个项目：仿网易云音乐 APP 的 UI 界面做一个网易云音乐 web 端。 git 仓库：网址 后端：网址，用了git@github.com:Binaryify/NeteaseCloudMusicApi.git仓库提供的后端。 下面是为了让自己久不用会忘记做的一个项目编辑过程，方便自己后面查阅。 二、项目搭建vue-cli2.1 搭建过程搭建过程命令：网址，该文章中写的 cnpm，npm，请自行按照自己的实际情况选择使用。ui 组件库请按照自己的项目需要选择安装。 注意点：Eslint，vscode，vetur之间的冲突解决：网址,以及 console.log 调试的 ESlint 报错，都可以在这篇文章解决。 三、框架更新3.1 更改项目以便 vscode，vetur，eslint 不冲突【vscode】-编辑器默认格式化， ESlint 扩展格式化，vetur 扩展格式化，三者之间的冲突. 网址, 更改框架中的eslintrc.js 文件， 设置好cscode配置项。 3.2 更改 build 文件夹下的 webpack.base.conf.js 以便使用 less如果项目是需要使用 less 来写样式的话，就修改这个项目配置。在 module，rules 中添加如下 12345678910111213 module: &#123; rules: [// 下面这里两个对象是自己添加的 &#123; test: /\\.less$/, loader: \"style-loader!css-loader!less-loader\" &#125;, &#123; test:/\\.css$/, //loader:'css-loader!style-loader' loader:'style-loader' &#125; ] 3.3 iview 主题修改如果需要修改主题的可以做这步，iview-ui 官网：地址，我们做的就是 webpack 模式的项目，因此直接添加文件在 main.js 引入即可。 3.3.1 主题修改的 less 文件引入的错误123456789error in ./my-theme/index.less Module build failed: // https://github.com/ant-design/ant-motion/issues/44 .bezierEasingMixin(); Inline JavaScript is not enabled. Is it set in your options? in F:\\qianduan_dir\\00program\\web-vue\\musiccloud\\node_modules\\_iview@3.1.3@iview\\src\\styles\\color\\bezierEasing.less (line 110, column 0) @ ./my-theme/index.less 4:14-250 13:3-17:5 14:22-258 @ ./src/main.js @ multi ./node_modules/_webpack-dev-server@2.9.1@webpack-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js 这个没有解决！！！！！！！！！！！！！！！！不知道怎么用的。引如 less 就没法 run 了 3.4 最终的 index.html，main.js ， APP.vue ，router 下的 index.js为了方便后续自己查阅，这就将所有依赖引入之后的代码挂在这里。 3.4.1 index.html 中的更新&lt;script src=&quot;//at.alicdn.com/t/font_848641_rz8h99j994g.js&quot;&gt;&lt;/script&gt;这里是阿里字体图的网址引入方式，连接根据自己在阿里图标上的文件库地址更新修改。阿里图标的使用方法：网址,这里我们使用的是第三种方法，在 style 中引入样式， .icon 然后再 .vue 中用标签 svg 来使用。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt; &lt;script src=\"//at.alicdn.com/t/font_848641_rz8h99j994g.js\"&gt;&lt;/script&gt; &lt;title&gt;cloudmusic&lt;/title&gt; &lt;style type=\"text/css\"&gt; .icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125;/* &lt;svg class=\"icon\" aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#icon-wangyiyunyinle\"&gt;&lt;/use&gt; &lt;/svg&gt; */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt; 3.4.2 main.js1234567891011121314151617181920212223242526272829303132// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import router from './router'import iView from 'iview' //导入 iview 组件库import 'iview/dist/styles/iview.css'//导入 iview-ui 的样式import './theme/index.less' //导入修改的主题样式import Vuex from 'vuex' //导入vuex状态管理器import store from '@/vuex/store'// 导入 store.js 文件import axios from 'axios' //导入// import './assets/styles/index'// 引入自定义的 less 文件// 怎么引入才正确Vue.use(iView) //使用 iviewVue.use(Vuex) //使用 vuexaxios.defaults.baseURL = 'http://localhost:3000'// http://127.0.0.1:3000，项目后端默认路径设置Vue.prototype.axios = axiosVue.prototype.$massage = iView.MessageVue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router,//注册路由 store,//注册vuex components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 3.4.3 APP.vue这个文件的 margin-top：60px。删掉的，其他的根据自己的需求修改或删除。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt; #app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; /* margin-top:60px; */ &#125; /* 我们样式的边距初始化可以卸载 APP.VUE 父组件中 */ html,body&#123; padding: 0; margin: 0; &#125;&lt;/style&gt; 3.4.4 router下的 index.js 路由设置这个文件是路由设置，具体是根据自己项目页面来设置，这里是为了方便自己学习子路由设置记录的。具体路由设置学习这篇文章路由设置：网址。 先导入组件，然后为组件配置路由 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from 'vue'import Router from 'vue-router'import Home from '@/components/pages/home'import Homecontent from '@/components/pages/homecontent'import Setting from '@/components/pages/setting'import Musicdetail from '@/components/pages/musicdetail'import Find from '@/components/pages/find'import Personalfm from '@/components/pages/personalfm'import Video from '@/components/pages/video'import Friends from '@/components/pages/friends'import Localmusic from '@/components/pages/localmusic'import Load from '@/components/pages/load'import Musicnet from '@/components/pages/musicnet'import Musickeep from '@/components/pages/musickeep'import Musiclikelist from '@/components/pages/musiclikelist'import Musiclist from '@/components/pages/musiclist'Vue.use(Router)export default new Router(&#123; mode: 'history', //这里是取消网址中的#号 routes: [ &#123; path: '/', component: Home, children: [ &#123; path: 'setting', name: 'Setting', component: Setting&#125;, &#123; path: 'musicdetail', name: 'Musicdetail', component: Musicdetail&#125;, &#123; path: '/', component: Homecontent, // 注意这里不要直接写 Content 路由， iview 组件库已经将它作为布局组件了 // 不注意的话会出错啊，原来的布局组件被替换了，布局就会发生错误了。 children: [ &#123;path: '/', name: 'Find', component: Find&#125;, &#123;path: 'personalfm', name: 'Personalfm', component: Personalfm&#125;, &#123;path: 'video', name: 'Video', component: Video&#125;, &#123;path: 'friends', name: 'Friends', component: Friends&#125;, &#123;path: 'localmusic', name: 'Localmusic', component: Localmusic&#125;, &#123;path: 'load', name: 'Load', component: Load&#125;, &#123;path: 'musicnet', name: 'Musicnet', component: Musicnet&#125;, &#123;path: 'musickeep', name: 'Musickeep', component: Musickeep&#125;, &#123;path: 'musiclikelist', name: ' Musiclikelist', component: Musiclikelist&#125;, &#123;path: 'msiclist', name: ' Musiclist', component: Musiclist&#125;] &#125;] &#125;]&#125;) 四、项目开始编辑4.1 布局home 作为首页， 原来使用iview组件中的 &lt;Header&gt;&lt;Content&gt;&lt;Footer&gt;布局。但是实际上布局的话我们还是自己写比较好，组件库提供的布局我们还要去修改，很麻烦的，我们不知道 iview 背后是怎么做这个布局的话更麻烦，大框架布局还是我们自己写的好。 而且ui组件库提供的布局中： iview 中的 Header，Footer 为64px，自己修改所需。line-height 也不要忘记。 写了 header 与 footer，content 用 router-view 写子组件替换。 4.1.1 基础布局将 components 文件夹中创建两个文件夹，一个 pages 存放页面，一个 common 存放共有组件(非页面)。 框架中的 HelloWorld.vue 就是框架设置的首页， router 下 index.js 路由也可以知道，我们就在首页做基础布局。将 HelloWorld.vue 原有代码删除。改写为 Home.vue，当然也可以修改为 Index.vue 或者其他的，这里只是自己的取名， 重要的是，这里.vue组件的名称每个单词的首字母都是大写的 ，就因为框架的是这样写的，就是去的 name 的对应名称，不因为什么，就是约定俗成，大家都好理解。 布局网址:flex 与 calc 公式 4.1.2 style编辑修改-scopedscoped的学习：vue-loader官网，其他网址 4.1.3 style编辑修改-使用less ①安装less cnpm install less less-loader --save-dev 注意不要只安装 less，在 vue 中要用 less，还需要安装 less-loader –save-dev 表示编写时依赖这些环境但编译后运行时不再依赖 这里用 cnpm，如果用 npm 可能会安装不成功 ②vue-cli 脚手架 webpack 模式创建的项目不需要去修改配置。只需要第①步安装即可使用。如果不是 vue-cli 的 webpack 创建的，还需要以下的配置。 1234//在 webpack.dev.conf.js 中，我们可以看到下面的代码： module: &#123; rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;) &#125;, ③ 在 .vue 中使用 less，开标签加上lang=&quot;less&quot;即可 已经在 webpack 中配置了，所以这里不需要引入任何 less 文件。 在 style中 声明lang=”less”。 注意： scoped 的作用仅仅是限定 css 的作用域，防止变量污染。 less 具体使用方法：网址 123&lt;style scoped lang=\"less\"&gt;&lt;/style&gt; 4.1.4 less 中使用 calc 公式less 中使用 calc 公式与 css3 中是不一样的，因为 less 中有冲突，我们需要对公式进行相应的处理才行。学习地址 网站部署vue 项目 build 生成 dist 文件夹1$ npm run build 使用 nginx 服务器 服务器部署网站：nginx 服务器网站部署","tags":[]},{"title":"new Vue({}) 与 export default{} 选项的写法区分","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-new Vue&&component/","text":"一、前言学习 vue 的时候我们知道，vue 有诸多选项。用在 new Vue({}),也叫做属性，这个 new Vue 是建立在 html 原生标签上的。 学习到组件 component [也就是自定义标签] 的时候。因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项（除了一些 vue 特别的选项 el 这些，component 没有之外）。component 的选项就不能写成属性形式了，要写成函数形式。 学习到 vue-cli 脚手架创建的项目的时候。 main.js 文件使用的是 new Vue({}) .vue 文件其实都是组件 component，而且它还使用了 ES6/ES2015 的方法。 es6 的 export default 相当于暴露组件，很好理解，前端底层无非是 html，css，js。而 .vue 文件是其他文件， .vue 或者 .js 文件引入的。最后都是解析为 html，css，js 的。肯定要把 .vue 文件做成导出件。 export default{} 这里区分一下 main.js 中可用的 new Vue({}) 即构造函数的选项与 .vue 文件 export default({}) 即自定义组件(标签)的选项写法 首先要知道一点：二者的选项是大多相同，有差不多一样的选项，但是不同，有特别的选项为其一所属。 二、new Vue({}) 与 export default{}2.1 el 与 name 的特殊el :是 new Vue({}) 特有的，el 是 element 的缩写，就是知道它是原生标签，对于自定义组件标签自然是没有的。提供的元素只能作为挂载点。因此不推荐挂载 root 实例到 &lt;html&gt;或者 &lt;body&gt;上。name：export default({}) 中组件的名称。 2.2 data 共有选项，组件中写成函数data:{} 与 data:function(){} / data(){} 123456789101112&lt;!-- new Vue(&#123;&#125;)----- --&gt;&lt;div id=\"app\"&gt; &#123;&#123;count&#125;&#125;&lt;div&gt;&lt;script&gt;new Vue(&#123; el:'#app', data: &#123; count: 0 &#125;&#125;)&lt;/script&gt; 1234567891011121314151617181920&lt;!-- export default(&#123;&#125;) ----- --&gt;&lt;template&gt; &lt;div class=\"home\"&gt; &#123;&#123;count&#125;&#125; &lt;div&gt;&lt;template&gt;&lt;script&gt;export default(&#123; name:'Home', data: function () &#123; //这里是 ES5 ，最佳是 ES6 写法 data () &#123;return &#123;count: 0&#125;&#125; return &#123; count: 0 &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 2.3 propsData 与 props 的特殊propsData：new Vue({}) 特有props：组件特有：父组件的数据传递给后代组件，用于接收来自父组件的数据，可以是数组或对象，学习这个选项之前可以先学习 components 选项 2.2.1 propsData 是 new xxx({}) 构造函数的 全局扩展的数据传递propsData 不是和属性有关，他用在全局扩展时进行传递数据。先回顾一下 Vue.extend 全局扩展的知识，作一个&lt;header&gt;&lt;/header&gt;的扩展标签出来。实际我们不推荐用全局扩展的方式作自定义标签，我们学了组件，完全可以使用组件来做.这里只是为了演示 propsData 的用法。全局拓展用的不多，那么这个 propsData 用的也不多，一般都是用组件。虽然用的不多，但是既然设计出来了，一定有它的特别的用处。 创建实例时传递 props。主要作用是方便测试。我们用 propsData 三步解决传值： 1、在全局扩展里加入 props 进行接收。 2、传递时用 propsData 进行传递。 3、用插值的形式写入模板。 1234567891011121314151617181920212223&lt;header&gt;&lt;/header&gt;&lt;div id=\"header\"&gt;&lt;/div&gt;&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;script&gt; var header = Vue.extend(&#123; template: `&lt;p&gt;我有&#123;&#123;message&#125;&#125;车&#123;&#123;num&#125;&#125;辆&lt;/p&gt;`, //用插值的形式写入模板。&#123;&#123;a &#125;&#125; //拓展的 data 不像 vue 里面的 data 不能直接写，而是应该在在函数的 return 里面 data: function () &#123; return &#123; message: 'minicooper' &#125; &#125;, props: ['num'] //在全局扩展里加入 props 进行接收。 &#125;); var vm=new header(&#123; //类似 new Vue 了 propsData: &#123; num: 18 &#125; //传递时用 propsData 进行传递。 &#125;).$mount('header'); //这里是拓展的挂载 new header().$mount('#header'); //这里是拓展的挂载,这样用的话在 html 中这个就是一个 id 名，来使用 new header().$mount('.header'); //这里是拓展的挂载,这样用的话在 html 中这个就是一个 class 名，来使用&lt;/script&gt; 2.2.2 props 是 export default{}/components①在父组件的 js 中的 component 选项直接写 1234567891011121314&lt;div id=\"app\"&gt; &lt;panda here=\"China\"&gt;&lt;/panda&gt;&lt;/div&gt;&lt;script&gt; var vmapp = new Vue(&#123; el: '#app', components: &#123; 'panda': &#123; //指的是一个 panda 标签，这里是子组件 template: '&lt;p style=\"color:red;\"&gt;panda from &#123;&#123;here&#125;&#125;!&lt;/p&gt;', props: ['here'] // 这个参数 here 就是从父亲 id=app 那里传来的 &#125; &#125; &#125;)&lt;/script&gt; 上面的代码更新成 vue-cli 中的写法就是②父子组件分开，在各自的文档 1234567891011121314151617&lt;!-- .APP父组件----------------------- --&gt;&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt; 用于渲染匹配的组件，它基于 Vue 的动态组件系统，所以它继承了一个正常动态组件的很多特性。 &lt;panda here=\"China\"&gt;父组件从这里传参&lt;/panda&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App', props: ['here'] //app.vue 子组件中有 props 选项用于从父亲哪里接收参数&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 1234567891011121314151617181920212223242526&lt;!-- Home子组件----------------------- --&gt;&lt;template&gt; &lt;div class=\"home\"&gt; &#123;&#123; here &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Home', props: &#123; //传进来的参数需要检查的，查看官网 here: &#123; type: String, required: true &#125; &#125;, data () &#123; return &#123; name: 'xiaomi' &#125; &#125;&#125;&lt;/script&gt;&lt;style &gt;&lt;/style&gt; ③注意属性尽量不要用连字符号我们在写属性名时经常会加入’-‘来进行分词， 比如：&lt;panda from-here=&quot;China&quot;&gt;&lt;/panda&gt;,那这时我们在 props 里如果写成props:[&#39;form-here&#39;]是错误的，我们必须用小驼峰式写法props:[&#39;formHere&#39;]。因此避免使用这种连字符号！ 1234567891011121314&lt;div id=\"app\"&gt; &lt;xiaomi from-here=\"China\"&gt;&lt;/xiaomi&gt;&lt;/div&gt;&lt;script&gt; var app1 = new Vue(&#123; el: '#app', components: &#123; 'xiaomi': &#123; template: `&lt;div style=\"color:red;\"&gt;Panda from &#123;&#123; fromHere &#125;&#125;.&lt;/div&gt;`, props: ['fromHere'] &#125; &#125; &#125;)&lt;/script&gt; 2.4 computed 共有选项，组件中写成函数123456789101112131415161718192021222324252627&lt;!-- new Vue(&#123;&#125;) --&gt;&lt;div id=\"app\"&gt; &#123;&#123;a&#125;&#125;-&#123;&#123;aDouble&#125;&#125;-&#123;&#123;aPlus&#125;&#125; &lt;!-- 效果为1-2-2 --&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el:'#app', data: &#123; a: 1 &#125;, computed: &#123; aDouble: function () &#123; // 仅读取 return this.a * 2 &#125;, aPlus: &#123; // 读取和设置 get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // =&gt; 2vm.aPlus = 3vm.a // =&gt; 2vm.aDouble // =&gt; 4&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!-- export default&#123;&#125;------------ --&gt;&lt;template&gt; &lt;div class=\"home\"&gt; &#123;&#123;a&#125;&#125;-&#123;&#123;aDouble&#125;&#125;-&#123;&#123;aPlus&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var vm=export default &#123; name:'Home', data() &#123; return&#123; a: 1 &#125; &#125;, computed: &#123; // 仅读取 aDouble () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get () &#123; return this.a + 1 &#125;, set (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // =&gt; 2vm.aPlus = 3vm.a // =&gt; 2vm.aDouble // =&gt; 4&lt;/script&gt; 2.5 methods 共有选项方法全部改为 es5 写法编写,不要写成 ES6 ，即不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 123456789101112131415161718//new Vue(&#123;&#125;)&lt;div id=\"app\"&gt; &#123;&#123;a&#125;&#125; &lt;button v-on:click=\"plus\"&gt;Add 1&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el:'#app', data: &#123; a: 1 &#125;, methods: &#123; plus:function() &#123; this.a++ &#125; &#125;&#125;)&lt;/script&gt; 12345678910111213141516171819202122&lt;!-- export default&#123;&#125;------------ --&gt;&lt;template&gt; &lt;div class=\"home\"&gt; &#123;&#123;a&#125;&#125; &lt;button v-on:click=\"plus\"&gt;Add 1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:'Home', data() &#123; return&#123; a: 1 &#125; &#125;, methods: &#123; plus() &#123; this.a++ &#125; &#125;&#125;)&lt;/script&gt; 2.6 watch 共有选项????是不是应该用function？？一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- new Vue(&#123;&#125;) --&gt;&lt;div id=\"app\"&gt; &#123;&#123;a&#125;&#125; &lt;button v-on:click=\"plus\"&gt;Add 1&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, b: 'someMethod', // 方法名，直接调用someMethod方法 c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true // 深度 watcher，参数 deep 的默认值是 false &#125;, d: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, immediate: true // 该回调将会在侦听开始之后被立即调用 &#125;, e: [ //监听对象 function handle1 (val, oldVal) &#123; /* ... */ &#125;, function handle2 (val, oldVal) &#123; /* ... */ &#125; ], 'e.f': function (val, oldVal) &#123; /* ... */ &#125; // watch vm.e.f's value: &#123;g: 5&#125; &#125;, methods: &#123; someMethod: function () &#123; lert(\"b is changed\"); &#125; &#125;&#125;)vm.a = 2 // =&gt; new: 2, old: 1&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!-- 这里是export default&#123;&#125; --&gt;&lt;template&gt; &lt;div class=\"home\"&gt; &lt;div&gt;&#123;&#123; here &#125;&#125;&lt;/div&gt; &lt;div&gt; &#123;&#123; a &#125;&#125;-&#123;&#123; b &#125;&#125;-&#123;&#123; c &#125;&#125;-&#123;&#123; d &#125;&#125;&lt;/div&gt; &lt;div&gt;&#123;&#123; e.f.g &#125;&#125;&lt;/div&gt; &lt;button @click=\"plus\"&gt;Add 1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Home', props: &#123; here: &#123; type: String, required: true &#125; &#125;, data () &#123; return &#123; name: 'xiaomi', a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125; &#125;, computed: &#123; // 仅读取 aDouble () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get () &#123; return this.a + 1 &#125;, set (v) &#123; this.a = v - 1 &#125; &#125; &#125;, watch: &#123; a (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, b: 'someMethod', // 方法名，直接调用 someMethod 方法 c: &#123; handler (val, oldVal) &#123; /* ... */ &#125;, deep: true // 深度 watcher，参数 deep 的默认值是 false &#125;, d: &#123; handler (val, oldVal) &#123; /* ... */ &#125;, immediate: true // 该回调将会在侦听开始之后被立即调用 &#125;, e: [ // 监听对象 function handle1 (val, oldVal) &#123; /* ... */ &#125;, function handle2 (val, oldVal) &#123; /* ... */ &#125; ], 'e.f' (val, oldVal) &#123; /* ... */ &#125; // watch vm.e.f's value: &#123;g: 5&#125; &#125;, methods: &#123; plus () &#123; this.a++ this.b++ this.c++ this.d++ this.g++ &#125;, someMethod () &#123; alert('b is changed') &#125; &#125;&#125;&lt;/script&gt;&lt;style &gt;&lt;/style&gt; 2.7 template 共有选项 ？？？？一个字符串模板作为 Vue 实例的标识使用。模板将会 替换 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。 如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。常用的技巧是用 &lt;script type=&quot;x-template&quot;&gt; 包含模板。 出于安全考虑，你应该只使用你信任的 Vue 模板。避免使用其他人生成的内容作为你的模板。如果 Vue 选项中包含渲染函数，该模板将被忽略。 12345678910&lt;div id=\"app\"&gt;11&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', store, router, components: &#123;App&#125;, template: '&lt;App/&gt;' 这里什么鬼用啊？&#125;)&lt;/script&gt; 12345678910//全局API创建组件？？？？default中呢？Vue.component('custom-input', &#123; props: ['value'], template: ` &lt;input v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; `&#125;) 2.8 render 渲染函数？？？？？ 共有选项字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode。 如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。 Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。 2.9 renderError错误时渲染函数？？？？？ 共有选项只在开发者环境下工作。 当 render 函数遭遇错误时，提供另外一种渲染输出。其错误将会作为第二个参数传递到 renderError。这个功能配合 hot-reload 非常实用。 12345678new Vue(&#123; render (h) &#123; throw new Error('oops') &#125;, renderError (h, err) &#123; return h('pre', &#123; style: &#123; color: 'red' &#125;&#125;, err.stack) &#125;&#125;).$mount('#app') 2.10 周期函数/钩子函数 共用选项 beforeCreate () {}, created () {}, beforeMount () {}, mounted () {}, beforeUpdate () {}, updated () {}, activated () {}, deactivated () {}, beforeDestroy () {}, destroyed () {}, errorCaptured () {}, 2.11 directives 局部自定义组件 共有选项1234567891011121314151617181920&lt;template&gt; &lt;div class=\"home\"&gt; &lt;p v-focus&gt;22&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Home', directives: &#123; focus: &#123; // 组件局部指令的定义 bind: function (el) &#123; //el.focus() 这个函数什么鬼意思? el.innerHTML ='xiaomi' &#125; &#125; &#125;&#125;//最后得到的是 xiaomi 这个字符串而不是 22&lt;/script&gt; 2.11.1 自定义指令的周期函数/钩子函数钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind: function (el,binding,vnode,oldVnode) {} 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted: function (el,binding,vnode,oldVnode) {} 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update: function (el,binding,vnode,oldVnode) {} 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变， 也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 2.11.2 钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。 el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中， 修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 2.11.3 钩子函数简写/默认包含 bind 和 update 钩子1234Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value //这里面是 bind 和 update 时候执行的语句&#125;) 2.12 filters 共有选项？？？？？？注册或获取全局过滤器。 // 注册Vue.filter(‘my-filter’, function (value) { // 返回处理后的值}) // getter，返回已注册的过滤器var myFilter = Vue.filter(‘my-filter’) 2.13 components 共有选项局部注册组件局部注册组件局部注册组件和全局注册组件是相对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 （在不同 id 的 Vue 里面，作用就不一样）局部注册其实就是写在构造器里，需要注意的是，构造器里的 components 是加s的，而全局注册是不加s的。因为局部这样定义定义多个组件。对于 components 对象中的每个属性来说，其属性名就是自定义元素的名字(因此是要带字符串的),其属性值就是这个组件的选项对象 12345678910&lt;div id=\"app\"&gt;11&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', store, router, components: &#123;App&#125;, //这里注册APP组件 template: '&lt;App/&gt;' &#125;)&lt;/script&gt; 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;zihua&gt;&lt;/zihua&gt;&lt;/div&gt;&lt;div id=\"app1\"&gt; &lt;zihua&gt;&lt;/zihua&gt; 在这里使用这个组件标签是没有效果的，因为 zihua 局部组件是在 app 中注册的， app1 中没法使用&lt;/div&gt;&lt;script&gt; var vmapp = new Vue(&#123; el: '#app', components: &#123; 'zihua': &#123; template: '&lt;p&gt;我是局部组件&lt;/p&gt;' &#125; &#125; &#125;)&lt;/script&gt; 12345678910111213141516171819202122232425//把模板写在外面，赋值给变量 &lt;div id=\"app\"&gt; &lt;zihua&gt;&lt;/zihua&gt; &lt;zihua-a&gt;&lt;/zihua-a&gt; &lt;zihua-b&gt;&lt;/zihua-b&gt; &lt;/div&gt; &lt;script&gt; var component = &#123; template: '&lt;p&gt;我是局部组件1&lt;/p&gt;' &#125;, componentA = &#123; template: '&lt;p&gt;我是局部组件2&lt;/p&gt;' &#125;, componentB = &#123; template: '&lt;p&gt;我是局部组件3&lt;/p&gt;' &#125;; var vmapp = new Vue(&#123; el: '#app', components: &#123; 'zihua': component, 'zihua-a': componentA, 'zihua-b': componentB &#125; &#125;) &lt;/script&gt; 注意：组件名的要求 在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：Vue.component(&#39;my-component-name&#39;, { /* ... */ })该组件名就是 Vue.component 的第一个参数。你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或单文件组件) 的时候，我们强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。你可以在风格指南中查阅到关于组件名的其它建议。 2.13.1 父子组件在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"app\"&gt; &lt;panda&gt; &lt;!-- 父组件 --&gt; &lt;city&gt;&lt;/city&gt; &lt;!-- 子组件 --&gt; &lt;/panda&gt;&lt;/div&gt;&lt;script&gt; var panda = &#123; template: `&lt;p&gt; panda form China &lt;city&gt;&lt;/city&gt;&lt;/p&gt;`, components: &#123; 'city': &#123; template: `&lt;span&gt;city of Guangxi&lt;/span&gt;` &#125; &#125; &#125; var vmapp = new Vue(&#123; el: '#app', components: &#123; 'panda': panda &#125; &#125;) //或者写成，但是上面更好，用一个变量来代替，把代码写在构造函数外边是比较好的选择。 var vmapp = new Vue(&#123; el: '#app', components: &#123; 'panda': &#123; template: `&lt;p&gt; panda form China &lt;city&gt;&lt;/city&gt;&lt;/p&gt;`, components: &#123; 'city': &#123; template: `&lt;span&gt;city of Guangxi&lt;/span&gt;` &#125; &#125; &#125; &#125; &#125;)&lt;/script&gt; 2.13.2 内置组件&lt;component&gt;&lt;component&gt;&lt;/component&gt;标签是 Vue 框架内部定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。在 vue-cli 中用的是路由啦控制子组件，这个貌似也没有什么用处。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"app\"&gt; &lt;component v-bind:is=\"whichComponent\"&gt;&lt;/component&gt; &lt;button @click=\"changeComponent\"&gt;changeComponent&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var componentA = &#123; template: `&lt;p style=\"color:red;\"&gt;I am A&lt;/p&gt;`, props: ['massage'] &#125;, componentB = &#123; template: `&lt;p style=\"color:pink;\"&gt;I am B&lt;/p&gt;` &#125;, componentC = &#123; template: `&lt;p style=\"color:gray\"&gt;I am C&lt;/p&gt;` &#125;; var vmapp = new Vue(&#123; el: '#app', data: &#123; massage: 18, whichComponent: 'componentA' &#125;, components: &#123; 'componentA': componentA, 'componentB': componentB, 'componentC': componentC, &#125;, methods: &#123; changeComponent: function () &#123; switch (this.whichComponent) &#123; case 'componentA': this.whichComponent = 'componentB'; break; case 'componentB': this.whichComponent = 'componentC'; break; default: this.whichComponent = 'componentA'; break; &#125; &#125; &#125; &#125;) &lt;/script&gt; 2.14 mixins 共有选项？？？mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。 Mixins一般有两种用途： 1、在你已经写好了构造器后，(项目已经上线了，或者是项目经理又要添加一些新功能)需要增加方法或者临时的活动时使用的方法。不想去改变之前已经写好的构造器。这时用混入会减少源代码的污染。 2、很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"add\"&gt;add&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.mixin(&#123; updated: function () &#123; console.log('全局方式混入'); &#125; &#125;) //这个也要写在Vue的上边， var appconsoleObject = &#123; updated: function () &#123; console.log(\"数据改变成了\" + this.num); &#125; &#125; //上面的代码为什么一定要写在vue的前面，写在下面会出错？？？？？？ var vmapp = new Vue(&#123; el: '#app', data: &#123; num: 18 &#125;, methods: &#123; add: function () &#123; this.num++; &#125; &#125;, updated: function () &#123; console.log(\"vue构造器的原生updated钩子\"); &#125;, mixins: [appconsoleObject] &#125;) /* 假如上面是我们已经完成的代码编辑，但是后期有要求要添加什么内容。 我们不希望去修改原来的代码， 而是在外边去添加代码去添加新的功能。 就是下面这样来添加。 var appconsoleObject = &#123; updated: function () &#123; console.log(\"数据改变成了\" + this.num); &#125; &#125; 当然还是要在原来的 vue 里面添加一小行代码的， mixins: [appconsoleObject] 这个数组来表示这段外部的 diamante 是添加到哪里的 */ /* 如果这时我们希望每次数据变化时都能够在控制台打印出提示：“数据发生变化”. 这里就是mixins的第一个作用。 1、在你已经写好了构造器后，(项目已经上线了，或者是项目经理又要添加一些新功能) 需要增加方法或者临时的活动时使用的方法。不想去改变之前已经写好的构造器。 这时用混入会减少源代码的污染。 */ /* 注意： 外部对象混入的的周期函数与 vue 内部的周期函数是有区别的， 混入的函数要比 vue 内部的函数先执行 从执行的先后顺序来说，都是混入的先执行，然后构造器里的再执行， 需要注意的是，这并不是方法的覆盖，而是被执行了两边。 当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。*//* ② 作用二学习 &lt;!--Mixins 一般有两种用途： 1、在你已经写好了构造器后，(项目已经上线了，或者是项目经理又要添加一些新功能) 需要增加方法或者临时的活动时使用的方法。不想去改变之前已经写好的构造器。 这时用混入会减少源代码的污染。 2、很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 就是单独的写成一个js用在其他的 --&gt; */ /* 全局API混入方式 我们也可以定义全局的混入，这样在需要这段代码的地方直接引入js，就可以拥有这个功能了。 我们来看一下全局混入的方法： */ /* 全局混入的执行顺序要前于混入和构造器里的方法。 */&lt;/script&gt; 2.15 extends 共有选项？？允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。 通过外部增加对象的形式，对构造器进行扩展。它和混入非常的类似。稍微有点区别 123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"add\"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var ExtendsObject = &#123; updated: function () &#123; console.log(\" extends的update\") &#125;, methods: &#123; /* add: function () &#123; console.log(\"extends 的方法\") &#125; 方法名与原生的 Vue 方法重名，这里就不会被执行了 */ /* addnum: function () &#123; console.log(\"extends 的方法\") &#125; 这样写也是不能被执行的*/ &#125; &#125; var vmapp = new Vue(&#123; el: '#app', data: &#123; num: 18 &#125;, methods: &#123; add: function () &#123; this.num++; console.log(\"Vue原生方法\") &#125; &#125;, updated: function () &#123; console.log(\"Vue原生updated\") &#125;, extends: ExtendsObject //扩展在 vue 里面放的是对象，24 节混入放的是数组，扩展只能有一个，混入可以是很多个。 &#125;) &lt;/script&gt; 2.16 provide / inject 共有选项？？？provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或一个对象，对象的 key 是本地的绑定名，value 是：在可用的注入内容中搜索用的 key (字符串或 Symbol)，或一个对象，该对象的：from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)default 属性是降级情况下使用的 value提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 2.17 delimiters 共有选项delimiters 的作用是改变我们插值的符号。Vue 默认的插值是双大括号。但有时我们会有需求更改这个插值的形式。 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;p&gt;$&#123;num&#125;&lt;/p&gt; &lt;button v-on:click=\"add\"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vmapp = new Vue(&#123; el: '#app', data: &#123; num: 18 &#125;, methods: &#123; add: function () &#123; this.num++; console.log(\"Vue 原生方法\") &#125; &#125;, delimiters: ['$&#123;', '&#125;'] //这里指的是将构造器改为 $&#123;&#125;， //['$&#123;', '&#125;'] 这里是 2 项数组 //现在我们的插值形式就变成了 $&#123;&#125;。 &#125;) &lt;/script&gt; 2.18 functional2.19 model2.20 inheritAttrs2.21 comments三、实例属性3.1 vm.$el3.2 vm.$props3.3 vm.$data3.4 vm.$options 用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：123456new Vue(&#123; customOption: 'foo', created: function () &#123; console.log(this.$options.customOption) // =&gt; 'foo' &#125;&#125;) 3.5 vm.$parent 父实例3.6 vm.$root 当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。3.7 vm.$children 当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。 3.8 vm.$slots 用来访问被插槽分发的内容。每个具名插槽 有其相应的属性 (例如：slot=”foo” 中的内容将会在 vm.$slots.foo 中被找到)。default 属性包括了所有没有被包含在具名插槽中的节点。在使用渲染函数书写一个组件时，访问 vm.$slots 最有帮助。 3.9 vm.$scopedSlots","tags":[]},{"title":"vue-router--[小白入门篇、速学篇]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } vue-router 路由设置/","text":"前言Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。 包含的功能有： 嵌套的路由/视图表 模块化的、基于组件的路由配置 路由参数、查询、通配符 基于 Vue.js 过渡系统的视图过渡效果 细粒度的导航控制 带有自动激活的 CSS class 的链接 HTML5 历史模式或 hash 模式，在 IE9 中自动降级 自定义的滚动条行为 官网地址 二、安装2.1 npm安装步骤①：下载 vue-router 1cnpm install vue-router 步骤②：引入 vue-router 如果在一个模块化工程中使用它，必须要通过 Vue.use() 手动引入/明确地安装路由功能： 12345//在 src/router 文件夹下的 index.js 路由设置文件中引入 vue-routerimport Vue from 'vue'import Router from 'vue-router'Vue.use(Router) 在创建 vue 项目vue init webpack my-project 的时候有选项是否选择安装 vue-router ,如果已经选择安装，在index.js 中已经存在了。只需要使用即可 2.2 CDN 安装（可以控制版本）CDN链接：如下引入 vue-router.js，这样 vue-router 会被注册为一个全局变量，不需要再手动引入。 1&lt;script src=\"https://cdn.bootcss.com/vue-router/3.0.1/vue-router.js\"&gt;&lt;/script&gt; 2.3 独立版本引入官网下载文件放置在项目目录下。如下引入 vue-router.js，这样 vue-router 会被注册为一个全局变量，不需要再手动引入。 1&lt;script src=\"./vue-router.js\"&gt;&lt;/script&gt; 三、vue-router 工作原理用 Vue.js + Vue Router 创建单页应用，是非常简单的。使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。 入口页面 index.html id=app入口页面对应的 js 文件， main.js new Vue（el：APP）入口页面 js 文件对应的组件 APP.vue template script（export default） style路由设置：router 文件夹下的 index.js export default new Router路由对应的组件：component 文件夹下的 HelloWorld.vue template script（export default） style 以下是 vue-cli 框架中使用 vue-router 的示例解析： 3.1 安装 vue-router根据第二章给项目安装 vue-router 3.2 app.vue 文件：父组件设置路由出口app.vue 文件 123456789101112131415161718192021222324&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;路由出口、路由匹配到的组件将渲染在这里&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'App'&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; router-view 标签:（vue 内部定义的一个自定义组件），他默认代表的是“/”这个路径。 更新路由路径更新的就是这个部分的内容，其他内容是不变的。 router-link 制作导航 如果需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要标签，我们先来看一下它的语法。 `&lt;router-link to=&quot;/&quot;&gt;[显示字段]&lt;/router-link&gt;` to：&#39;我们的导航路径&#39;，填写的是你在 router/index.js 文件里配置的 path 值，如果要导航到默认首页，只需要写成 to=&quot;/&quot; ， [显示字段] 就是我们要显示给用户的导航名称，比如首页新闻页。明白了 router-link 的基本语法。我们可以在首页做如下的导航 12345678&lt;p&gt;导航 ： &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/hi\"&gt; Hi 页面&lt;/router-link&gt;&lt;/p&gt;&lt;p&gt;导航 ： &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/hi\"&gt;Hi 页面&lt;/router-link&gt;&lt;/p&gt; 3.3 router文件夹下index.js文件：路由设置文件12345678910111213141516import Vue from 'vue'//如果使用模块化机制编程，导入 Vue 和 VueRouter，要调用 Vue.use(VueRouter)import Router from 'vue-router'//如果使用模块化机制编程，导入 Vue....import HelloWorld from '@/components/HelloWorld'//①导入(路由) 组件Vue.use(Router)//如果使用模块化机制编程，导入 Vue 和 VueRouter，要调用 Vue.use(VueRouter)export default new Router(&#123; //③ new Roter 来创建 router 实例，然后传 `routes` 配置 routes: [ //②定义路由，每个路由应该映射一个组件。 &#123; //其中 \"component\" 可以是通过 Vue.extend() 创建的组件构造器 path: '/', // '/'链接路径 name: 'HelloWorld', // 'HelloWorld' 路由名称， component: HelloWorld // HelloWorld 对应的组件模板 .vue 文件 &#125; ]&#125;)//上边的代码中已经对每行都进行了注释，其实在这个路由文件里只配置了一个功能，就是在进入项目时，显示//HelloWorld.vue 里边的内容代码。 3.4 main.js文件：router 配置参数注入路由123456// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') 3.5 components 文件夹下的 Helloworld.vue 文件： 定义（路由）组件 123456789101112131415161718192021 &lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 3.6 访问路由通过上面的3.1-3.4步骤，注入路由器，我们可以在 任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由： 如下在 home.vue 组件访问路由 12345678910111213141516// Home.vueexport default &#123; computed: &#123; username () &#123; // 我们很快就会看到 `params` 是什么 return this.$route.params.username &#125; &#125;, methods: &#123; goBack () &#123; window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push('/') &#125; &#125;&#125; 该文档通篇都常使用 router 实例。留意一下 this.$router 和 router 使用起来完全一样。我们使用 this.$router 的原因是我们并不想在每个独立需要封装路由的组件中都导入路由。 要注意，当 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active 四、新建页面与路由设置：一级路由最初的页面是 index.html，main.js，APP.vue，helloworld 插入到 app.vue 中 来做成一个入口页面。现在是有了helloworld 这个页面。我们知道 vue 是单页应用那么如何来做其他的页面呢。 如何更换页面：用 inde.js 路由设置，更换组件来达到更换页面的效果，这节学习的是在这些页面中我们还要再设置一些路由（子路由）组件，达到更局部的页面内容替换，比如：轮播图啦这种的局部替换的，总的说就是子路由（局部内容修改）在父路由（类似页面替换效果）中设置的。 从第三章我们知道 router-view 标签，（vue 内部定义的一个自定义组件），他默认代表的是“/”这个路径。 更新路由路径更新的就是这个部分的内容，其他内容是不变的。那么要做一个子路由，就是在新建立的页面替换的组件中新建一个 router-view 标签，也就是组件，用来替换内容 具体步骤：①：在 component 文件夹下建立 page1.vue 与 page2.vue 组件（作为页面组件）②：在 router 文件下 index.js 路由设置新增页面的路由③：在 app.vue 中设置页面切换 router-link 或者其他办法 push 都行，根据设计需要 index.js 文件改写 123456789101112131415161718192021222324252627import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Page1 from '@/components/Page1'import Page2 from '@/components/Page2'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;, &#123; path: '/page1', name: 'Page1', component: Page1 &#125;, &#123; path: '/page2', name: 'Page2', component: Page2 &#125; ]&#125;) 六、children：页面局部更新与路由设置：子路由/孙子路由假设页面 page1 中设置子组件 sub1.vue 与 sub2.vue。步骤如下： 具体步骤：①：在 component 文件夹下建立 sub1.vue 与 sub2.vue（作为局部组件）②：在 router 文件下 index.js 路由设置子组件的路由③：在 page1 中设置局部切换 index.js 文件改写 123456789101112131415161718192021222324252627282930313233343536373839404142434445import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Page1 from '@/components/Page1'import Page2 from '@/components/Page2'import Sub1 from '@/components/sub1'import Sub2 from '@/components/sub1'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;, &#123; path: '/page1', //name: 'Page1', 有了子组件之后，这个就不要写 name 了 component: Page1, children: [ &#123; path: '/', name: 'Page1', component: Page1 &#125;, &#123; path: 'sub1', //注意子组件这里是没有 / 的,没有为什么，就是 vue-router 的格式要求 name: 'Sub1', component: Sub1 &#125;, &#123; path: 'sub2', //注意子组件这里是没有 / 的 name: 'Sub2', component: Sub2 &#125;] &#125;, &#123; path: '/page2', name: 'Page2', component: Page2 &#125; ]&#125;) 结合第四第五章，我们知道有的组件是作为页面组件，有的是作为局部组件，为了区分，便于维护，我们可以将component 文件下创建两个文件夹。当然这样设置之后， import 导入的时候不要忘记路径的修改。 pagevue 文件夹：存放页面组件 commonvue 文件夹：存在一些局部组件，公用组件等等 五、参数传递开发中，参数的传递是个最基本的业务需求。通过 URL 地址来传递参数是一个形式，这节课我们就看看 vue-router 为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你现在所看的页面位置（类似于面包屑导航）。 5.1 name 传递参数假设 index.js 如下 12345678910111213141516171819202122232425262728293031323334353637383940import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Page1 from '@/components/Page1'import Page2 from '@/components/Page2'import Sub1 from '@/components/sub1'import Sub2 from '@/components/sub1'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;,&#123; path: '/page1', //name: 'Page1', 有了子组件之后，这个就不要写name了 component: Page1, children: [&#123; path: '/', name: 'Page1', component: Page1 &#125;,&#123; path: 'sub1', //注意子组件这里是没有/的 name: 'Sub1', component: Sub1 &#125;,&#123; path: 'sub2', //注意子组件这里是没有/的 name: 'Sub2', component: Sub2 &#125;] &#125;,&#123; path: '/page2', name: 'Page2', component: Page2 &#125; ]&#125;) APP.vue 文件：在入口组件 APP.vue 中写 , 用于接收参数输出参数 1234567891011121314&lt;template&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'APP'&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 5.2 to 传递参数 [选择这种办法传参]APP.vue 文件传参：这里传的是名字与 id，可以传递其他的，params 是个参数对象 1234567891011121314151617&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt;| &lt;router-link to=\"/page1\"&gt;page1页面&lt;/router-link&gt;| &lt;router-link :to=\"&#123;name:'page2',params:&#123;username:'xiaomi',id:18&#125;&#125;\"&gt;page2&lt;/router-link&gt; &lt;router-link to=\"/page1/sub1\"&gt;page1/sub1&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'APP'&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; sub1.vue 文件接收参数 1234567891011121314&lt;template&gt; &lt;div class=\"sub1\"&gt; &#123;&#123;$route.params.username&#125;&#125;&#123;&#123;$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Sub1'&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 5.3 url 传递参数以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用 URL 传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。 ①在 components 文件下做 params 页面组件 ，用 等接受参数输出参数②在 index.js 路由设置 path 路径 例子： path:’/params/:newsId/:newsTitle’, :冒号的形式传递参数，这就是对参数的绑定。 语法：就是在路径后面斜杠冒号 /:名词 这里我们需要传递参数是新闻 ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。③在 APP.vue 中 router-link 标签中传参利用 url 传值。 例子： 正则表达式在 URL 传值中的应用 我们希望我们传递的新闻 ID 只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue 是支持正则的。 加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。 path:&#39;/params/:newsId(\\\\d+)/:newsTitle&#39; (\\d+) 代表的是\\d 一个或者是多个 加入了正则，我们再传递数字之外的其他参数，params.vue 组件就没有办法接收到。 七、单页面多路由区域操作，就是一个页面多个局部路由单页面多路由区域操作：实际需求是这样的，在一个页面里我们有 2 个以上区域，我们通过配置路由的 js 文件，来操作这些区域的内容。例如我们在 src/App.vue 里加上两个 router-view 标签。现在假如我们在 APP.vue 中设置两个区域 A，B。 具体步骤：①：在 component 文件夹下建立 A.vue 与 B.vue （单页面多路由区域局部组件）②：在 router 文件下 index.js 路由设置子组件的路由③APP.vue 文件中写两个 router-view 标签，用 name 属性来指定所关联的组件 index.js 如下 1234567891011121314151617181920212223import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import A from '@/components/A'import B from '@/components/B'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', components: &#123; default:HelloWorld, left:A, right:B &#125; //注意component:XXX要变成components：&#123;&#125; &#125; ]&#125;) APP.vue 文件 12345678910111213141516&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!-- 这里是指默认页面替换 --&gt; &lt;router-view name=\"left\"&gt;&lt;/router-view&gt; &lt;!-- 这里是值弄 name 所对应的组件替换 --&gt; &lt;router-view name=\"right\"&gt;&lt;/router-view&gt;&lt;!-- 这里是值弄 name 所对应的组件替换 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'APP'&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 单页面多路由：是指几个路由同时出现在一个页面，helloworld，A，B 是共存的。组件 A，B 可以做各自的替换组件 八、重定向：redirect（切换到统一页面）开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向 redirect 参数。简单说就是两个不同的路径打开的页面是一样的 8.1 实现重定向重定向不需要组件，写的其实是两个路径。path：写的是当前路径，可以在这里传递参数。redirect 写的是需要跳转到的路径 ①在 index.js 中配置路径，不需要减组件，只有路径 { path: ‘/gohome’, 配置路径 redirect: ‘/‘ 重定向到首页的路径 }, ②在 app.vue 中写作链接 1234567891011121314151617181920212223//JSimport Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import A from '@/components/A'import B from '@/components/B'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', components:&#123;default:HelloWorld,left:A,right:B&#125; //注意 component:XXX 要变成 components：&#123;&#125; &#125;, &#123; path: '/gohome', 配置路径 redirect: '/' 重定向到首页的路径 &#125; ]&#125;) 8.2 重定向传递参数{ path:’/params/:newsId(\\d+)/:newsTitle’, component:Params},{ path:’/goParams/:newsId(\\d+)/:newsTitle’, 配置路径/并且传参 redirect:’/params/:newsId(\\d+)/:newsTitle’ 重定向到首页的路径} 九、alias 别名的使用：给路径七个别名通俗的说就是给路径起另外一个名字的这一个意思。 ①index.js 中配置 { path: ‘/hi1’, component: Hi1, alias:’/xiaomi’ } 注意：如果有的时候不出来效果，看下别名中不要放’/‘,这个有的时候会是个 bug 但是新版本的做成要写’/, ②在 App.vue 中做链接 redirect 和 alias 的区别 redirect：仔细观察URL，redirect 是直接改变了 url 的值，把 url 变成了真实的 path 路径。 alias：URL 路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了&lt;router-view&gt;中的内容。 十、切换页面/局部替换：动画在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作。&lt;transition&gt;标签运用。CSS3 学习深入学习 fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。 fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。 fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。 fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。 从上面四个类名可以看出，fade-enter-active 和 fade-leave-active 在整个进入或离开过程中都有效， 所以 CSS 的 transition 属性在这两个类下进行设置。 步骤：①在组件外面嵌套一个 transition 标签,这里我们就给 router-view 标签外面嵌套。 &lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot;&gt; &lt;router-view &gt;&lt;/router-view&gt; &lt;/transition&gt;②style 中设置 css，还有去深入学习 css3 12345678910111213141516171819.fade-enter &#123; opacity:0; &#125; .fade-leave&#123; opacity:1; &#125; .fade-enter-active&#123; transition:opacity .5s; -webkit-transition: opacity .5s;/* Safari */ -moz-transition: opacity .5s;/* Safari */ -o-transition: opacity .5s;/* Safari */ &#125; .fade-leave-active&#123; opacity:0; transition:opacity .5s; -webkit-transition: opacity .5s;/* Safari */ -moz-transition: opacity .5s;/* Safari */ -o-transition: opacity .5s;/* Safari */ &#125; 十一、mode 的设置和 404 页面的处理 mode 的设置：这个 mode 是设置 url 地址中的#号是否需要 404页面：用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的 404 页面。 vue-router 也为我们提供了这样的机制. 11.1 mode设置 history:当你使用 history 模式时，URL 就像正常的 url，例如 http://jsapng.com/lms/也好看！而不是http://jsapng.com/#/lms/跳转页面的时候还会出现闪烁。 hash:默认’hash’值，但是 hash 看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。 index.js 文件 1234567891011121314151617181920212223//JSimport Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import A from '@/components/A'import B from '@/components/B'Vue.use(Router)export default new Router(&#123; mode:'history', //mode设置 routes: [ &#123; path: '/', name: 'HelloWorld', components:&#123;default:HelloWorld,left:A,right:B&#125; //注意 component:XXX 要变成 components：&#123;&#125; &#125;,&#123; path: '/gohome', 配置路径 redirect: '/' 重定向到首页的路径 &#125; ]&#125;) 11.2 404 页面的处理①error.vue 文件创建②index.js 路由设计 index.js文件 12345678910111213141516171819202122232425//JSimport Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Error from '@/components/Error'Vue.use(Router)export default new Router(&#123; mode:'history', //mode 设置 routes: [ &#123; path: '/', name: 'HelloWorld', components:&#123;default:HelloWorld,left:A,right:B&#125; //注意 component:XXX 要变成 components：&#123;&#125; &#125;,&#123; path: '/gohome', 配置路径 redirect: '/' 重定向到首页的路径 &#125;,&#123; path:'*', //path:'*' 指的是找不到页面时的配置，404 页面设置 component:Error &#125; ]&#125;) 十二、路由配置文件中的钩子函数router 文件夹下 index.js 文件 1234567891011121314151617181920212223242526272829303132333435//JSimport Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import Page1 from '@/components/Page1'import Error from '@/components/Error'Vue.use(Router)export default new Router(&#123; mode:'history', //mode 设置 routes: [ &#123; path: '/', name: 'HelloWorld', components:&#123;default:HelloWorld,left:A,right:B&#125; //注意 component:XXX 要变成 components：&#123;&#125; &#125;,&#123; path: '/gohome', //配置路径 redirect: '/' //重定向到首页的路径 &#125;,&#123; path:'/page1', name:'Page1', component:Page1, beforeEnter:(to,from,next)=&gt;&#123; //在进入此路由配置时 console.log('我进入了params模板'); console.log(to); console.log(from); next(); &#125;,&#123; path:'*', //path:'*'指的是找不到页面时的配置 component:Error &#125; ]&#125;) 三个参数： to:路由将要跳转的路径信息，信息是包含在对像里边的。 from:路径跳转前的路径信息，也是一个对象的形式。 next:路由的控制参数，常用的有 next(true) 和 next(false)。 Page1.vue组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=\"page1\"&gt; page1 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Page1', data () &#123; return &#123; msg: 'page' &#125; &#125;, beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(\"准备进入路由模板\"); next(); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(\"准备离开路由模板\"); next(); &#125;&#125;&lt;/script&gt; 十三、编程式导航13.1 this.$router.push&lt;router-link :to=&quot;...&quot;&gt; 编程式：router.push(...) 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 12345const userId = 123router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user 13.2 this.$router.replace跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。history 记录，就是可以用 this.$router.go() 跳转的。 &lt;router-link :to=&quot;...&quot; replace&gt; 编程式:router.replace(…) 13.3 this.$router.go()这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步 在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。 ①this.$router.go(-1) 后退（到之前进入的页面）② this.$router.go(1) 先后退然后再前进才有的效果，都是之前进入过的页面 这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。 router.go(-1) 代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。③this.$router.push(‘/xxx ‘’) 之前跳转某页面 比如说我们做登录的操作的时候，如果成功就跳转首页 写按钮绑定方法来跳转 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class='#'&gt; &lt;button @click=\"back\"&gt;后退&lt;/button&gt; &lt;button @click=\"go\"&gt;前进&lt;/button&gt; &lt;button @click=\"gohome\"&gt;返回首页&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'App', methods: &#123; back () &#123; this.$router.go(-1) &#125;, go () &#123; this.$router.go(1) &#125;, gohome () &#123; this.$router.push('/') &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 十四、无知与不细心爬过的坑14.1 导入组件的时候 import 不细心 少了 from 导致的错误。","tags":[]},{"title":"vuex 状态管理器","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } vuex 状态管理器/","text":"一、Vuex 是什么这篇文章的挺清晰的地址 vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 vue-devtools。提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。 vuex 是一个专门为 vue.js 设计的集中式状态管理架构。状态？ 我把它理解为在 data 中的属性需要共享给其他 vue 组件使用的部分，就叫做状态。简单的说 就是 data 中需要共用的属性。比如：我们有几个页面要显示用户名称和用户等级，或者显示用户的地理位置。如果我们不把这些属性设置为状态，那每个页面遇到后，都会到服务器进行查找计算，返回后再显示。在中大型项目中会有很多共用的数据，所以尤大神给我们提供了 vuex。相当于把需要公用的数据做放到一个仓库中，每次调用就 ok 了 二、vuex 深入了解2.1 什么是“状态管理模式”？12345678910111213141516171819//这个状态自管理应用包含以下 3 个部分：new Vue(&#123; // state：驱动应用的数据源； data () &#123; return &#123; count: 0 &#125; &#125;, // view，以声明方式将 state 映射到视图； template: ` &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; `, // actions，响应在 view 上的用户输入导致的状态变化。 methods: &#123; increment () &#123; this.count++ &#125; &#125;&#125;) 2.2 vuex 用来干什么？多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想。 2.3 什么情况下我应该使用 Vuex？虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。 说白了 vuex 是用来管理那些在多个组件中需要使用到的数据的。在大型应用设计上我们用 vuex 来管理那些多个页面需要使用到的数据。也就是说小型设计就没有必要用了， eventBus.js 就可以解决数据公用问题了。也不是什么数据都放在 vuex 来管理， vuex 管理的数据越少才越好。 二、应该使用 vuex 的情况！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！根据 vue 传值的，学习，我们知道传值的方法非常的多，要适合的去选择传值的方式，有的情况下有的传值方式就是行不通的。 localstorage 本地缓存，可以保存，但是它只能保存 JSON 字符串，如果是对象的话还需要 JS 对象与 JSON 字符串之间的转化来转化去的。 小项目有的时候我们希望使用 eventBus 来传值，但是会发现，旧组件页面 会被销毁，新组件页面 获取不到传递过来的值。旧组件不会被销毁的情况使用 eventBus 比较好。虽然我们可以在旧页面销毁之前去截取数据，但是总感觉不太好。 下面的例子是看的网上别人的，不一定正确，要自己去琢磨的 2.1 组件会被销毁 场景： 假如有这样一个组件，他是弹窗，有一些复选框和输入框，用户会选择和填写信息；然后这个弹窗会被关闭和打开，由于业务需要，这个弹窗输入的内容，希望关闭后可以保留，在重新打开后，内容依然存在。 解决办法： 我们可以考虑将值存在父组件中，也就是说，实际修改的是父组件的值；存在比如 sessionStorage、cookies之类的里面，在 created 时从中读取，destroyed的时候写入其中；可以存到 global-event-bus 里面； 但事实上，最好的还是存在 Vuex 里： 可以直接通过 $store.state 来调用，通过 commit() 来修改值； 也可以在 created 的时候，读取存在 state 里面的值，在 destroyed 的时候，写回 state； 这样处理的优点是 解耦，不跟其他组件打交道。 2.2 组件基于数据而创建 场景： 用户登录后，读取权限配置表，这显然是一个异步操作；这个配置表可能会影响很多页面。比如被影响的组件的加载条件，例如是 v-if=”$store.state.userInfo.superVIP；那么：因为读取权限配置表这个异步操作，可能影响多个组件，而这些组件之间的关系，显然是不可预料的（即不一定是在同一个父组件下面）；那么这个异步操作，写在某一个组件里就不太合适（因为其他组件读取这个组件很不方便，即使他是根组件）； 解决办法： 一个妥协的解决办法，是写在 global-event-bus 里面来实现(就是全局 eventBus)；但是显然，更好的解决办法是写在 vuex 里面更专业一些； 问题：其实这个场合看不懂，还没有去看，就是做 VIP 用户的情况咯，不知道使用 localstorage 可行不？ 2.3 多对多事件——多处触发，影响多处 场景： 假如有一个事件，比如：切换页面显示风格，他将改变某一个变量的值；当该变量为 true 时，那么页面风格为白天（主要影响 v-bind:style 的值）；当该变量为 false 时，那么页面风格为晚上（同上）；在多个地方可以切换这个页面风格开关；毫无疑问，这个变量将影响多个地方的 v-bind:style 的值；这就是 多对多 场景；那么：无论这个变量放在哪个组件里，其他组件调用他都是很麻烦的事情；即使存于根组件，然后通过 this.$root.xx 来获取这个变量，也是很麻烦的，而且很丑陋； 解决办法： 如果不使用 Vuex，那么我们可能会去考虑使用 global-event-bus 来存储这个变量，并使用它；这不是不可以，但不优雅，而且管理麻烦；而使用 Vuex，那么这就是一件很方便的事情了；我们可以通过 $store.state.xxx 来获取这个变量的值；通过 $store.getters.yyy 来获取某些基于这个值的，表示通用样式（例如黑底白字）的对象；通过 $store.commit() 来提交修改（比如在某些情况下可以禁止修改）；甚至可以通过 $store.dispatch() 来获取其他风格的样式，并通过 $store.state 和 $store.getters 来返回新风格的样式； 2.10 总结总而言之，假如你需要 数据 和 组件 分离，分别处理，那么使用 Vuex 是非常合适的。？？？？不太懂？？？？？？相反，如果不需要分离处理，那么不使用 Vuex 也没关系。比如某个数据只跟某组件打交道，是强耦合的。那么这个数据就应该存放在该组件的 data 属性中。 三、安装/引入3.1 安装 vuex123456789101112131415# npm/cnpm 安装$ npm install vuex --save# 这个包我们在生产环境中是要使用的不用 dev，Development：开发坏境，指定是开发坏境需要，不需要在生产坏境中。# 完成安装之后，可以在 vue-cli 的项目框架 package.json 文件中的 dependencies 中查看到版本# CDN安装（可以控制版本）# [CDN链接：](https://www.bootcdn.cn/vuex/)&lt;script src=\"https://cdn.bootcss.com/vuex/3.0.1/vuex.js\"&gt;&lt;/script&gt; # 这样 vuex 会被注册为一个全局变量，不需要再手动引入# 然后这个全局引入就不需要了，可以使用 vuex 了 import Vue from 'vue', import Vuex from 'vuex', Vue.use(Vuex)。# 独立版本引入，就是将代码放在本地的意思，不用的&lt;script src=\"./vuex\"&gt;&lt;/script&gt;# 这样 vuex 会被注册为一个全局变量，不需要再手动引入# 然后这个全局引入就不需要了，可以使用 vuex 了 import Vue from 'vue', import Vuex from 'vuex', Vue.use(Vuex)。 3.2 引入使用 vuex3.2.1 在 main.js 文件中引入 store.js 文件, .vue 获取状态数据与方法【使用这个方法】1// store.js 12345678910111213141516171819202122// main.jsimport Vue from 'vue'import App from './App'import router from './router'import iView from 'iview'import 'iview/dist/styles/iview.css'import store from '@/vuex/store'//导入 store.js 文件，vue-cliimport store from 'store'//导入 store.js 文件，vue-cli3Vue.config.productionTip = falseVue.use(iView)new Vue(&#123; el: '#app', router, store, //注册 store，一种机制将状态从根组件“注入”到每一个子组件中 //把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 //子组件能通过 this.$store 访问到。 components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) 需要注意的是，通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。简单的说，这样全局引用的话，必须以要用 this.$store.state.xxx ,才能获取数据了。没有 this 的话获取不到数据。 123456789101112131415161718&lt;!-- .vue 子组件，不需要再引入 store.js 了，不要忘记加上 this --&gt;&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123;this.$store.state.count&#125;&#125;&lt;/h3&gt; &lt;button @click=\"this.$store.commit('add')\"&gt;加&lt;/button&gt; &lt;button @click=\"this.$store.commit('reduce')\"&gt;减&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; msg:'Hello Vuex', &#125; &#125;, &#125;&lt;/script&gt; 3.2.2 单个文件单独的引入 store.js（一般不用这个方法）这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。因此我们不要这样单独应用！！！一定要全局的引用 store.js 文件：即在，main.js 中引用 1//store.js 123456789101112131415161718192021&lt;!-- 实际应用中会是这样来创建组件的，也是 $store.state.count 这样来调用数据的，而不是上面那样 --&gt;&lt;!-- .vue 组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h3&gt; &lt;button @click=\"$store.commit('add')\"&gt;加&lt;/button&gt; &lt;button @click=\"$store.commit('reduce')\"&gt;减&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import store from '@/vuex/store' // 路径相应的自己去看着自己的项目改变 export default&#123; data()&#123; return&#123; msg:'Hello Vuex', &#125; &#125;, store //注册 在子组件 .vue 中引入 store.js 的注册 &#125;&lt;/script&gt; 四、vuex 具体使用学习vuex 管理数据 store.js文件 .vue 文件中 template 调用数据 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 script 中改写后 ，再在 template 调用。在第三章中我们子组件 .vue 文件，是 template 直接去调用 store.js 文件数据与 mutations 方法,这个状态是在 store.js 中的，在 .vue 文件的 data 中是不存在的。这样如果我们需要在 .vue 文件中多处调用同一个状态数据或者方法的话，就要写很多遍 this.$store.state.XXXX ，this.$store.commit(‘xxx’),这样会很麻烦，我们可以现在 .vue 文件中用 computed 属性选项来改写 state 之后，再在 template 中调用。说白了，这样做的目的就是为了简化 template 中的调用 store.js 状态。 4.2 具体的介绍：state，getters，mutations，actions 的四个办法 state: mutation: 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。简单来说就是一句话：Mutations 就是包含改变 state 的值的方法 getters 从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数, computed: {doneTodosCount () { return this.$store.state.todos.filter(todo =&gt; todo.done).length } } 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。Vuex 允许我们在 store 中定义 “getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。简单来说：getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。你可以把它看作store.js的计算属性。 this.$store.getters.doneTodos,this.$store.getters.donecount 如果在 template 中多处使用同一个数据是很麻烦的，因此我们要在 script 中 computed 中对它进行改写，后再在 template 中调用。 actions 和之前讲的 Mutations 功能基本一样，不同点是，actions 是异步的改变 state 状态，而 Mutations 是同步改变状态。 Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。但是 context 并不是 store 实例本身。更复杂的异步处理学习：vuex官网 方法一：（少的时候可以用，但是通常不会少吧） state：直接在 template 中调用，一长串的 this.$store.state.xxx mutations：直接在 template 中调用，一长串的 @click=”this.$store.commit(‘add’,10)” getters:直接在 template中调用（用属性/方法都可以的） actions：直接在 template 中调用 方法二： state：通过 computed 的 computed 计算属性直接赋值，后在 template 中调用 mutations：通过导入 mapMutations 的对象 methods 方法中放 mapMutations 的对象赋值，再在 template 中调用 getters:通过导入 mapGetters 的对象 computed 方法中放 mapGetters 的对象赋值，再在 template 中调用 actions：通过导入 mapActions 的对象 methods 方法中放 mapActions 的对象赋值，再在 template 中调用 方法三：（太复杂了不用了） state：通过导入 mapState 的对象 computed 的计算属性中放 mapState 的对象赋值，后在 template 中调用 方法四：（直白易懂，通常都使用这样的数组赋值方法！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！） state：通过导入 mapState 的对象 computed 的计算属性中放 mapState 的数组赋值(如果需要使用的数据很多时，通常使用这种，但是如果只使用一次的话，第一种显然又更合理了) mutations：通过导入 mapMutations 的对象 methods 方法中放 mapMutations 的数组赋值，再在 template 中调用 getters:通过导入 mapGetters 的对象 computed 方法中放 mapGetters 的数组赋值，再在 template 中调用 actions：通过导入 mapActions 的对象 methods 方法中放 mapActions 的数组赋值，再在 template 中调用 4.2.1 直接在 template 中使用（见前面的第 3 章）1234567891011121314151617181920212223242526&lt;!-- //.vue子组件 --&gt;&lt;template&gt; &lt;div class=\"count\"&gt; &lt;!-- 一长串的 this.$store.state 全在这里 --&gt; &#123;&#123;msg&#125;&#125; is &#123;&#123;this.$store.state.count&#125;&#125; years old &lt;/div&gt; &lt;button @click=\"this.$store.commit('add',10)\"&gt;加&lt;/button&gt; &lt;button @click=\"this.$store.commit('reduce',19)\"&gt;减&lt;/button&gt; &lt;h3&gt;&#123;&#123;this.$store.state.donecount&#125;&#125;这里用属性 &lt;/h3&gt; &lt;h3&gt;&#123;&#123;this.$store.state.donecount()&#125;&#125;这里用方法 &lt;/h3&gt; &lt;button @click=\"this.$store.dispatch('increment')\"&gt;加&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'Count', // 这里是组件名称 data () &#123; return&#123; msg:'xiaomi' &#125; &#125;&lt;/script&gt; 4.2.2 使用 computed=&gt;state,methods=&gt;mutations（这个其实就是别名的意义！！！）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!-- //.vue子组件 --&gt;&lt;template&gt; &lt;div class=\"count\"&gt; &lt;!-- /* 这里就不需要再像第三张那样复杂的写 &#123;&#123;this.$store.state.count&#125;&#125; 的长串了 */ --&gt; &#123;&#123;msg&#125;&#125; is &#123;&#123;count&#125;&#125; years old &lt;/div&gt; &lt;button @click=\"this.add(10)\"&gt;加&lt;/button&gt; &lt;!-- 注意因为是用 main.js 引入的，不要忘记使用 this. --&gt; &lt;!-- 不需要这样麻烦的调用了this.$store.commit('add',10) --&gt; &lt;button @click=\"this.reduce(19)\"&gt;减&lt;/button&gt; &lt;h3&gt;&#123;&#123;this.aaaaacount&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;this.doneTodos&#125;&#125;&lt;/h3&gt; &lt;button @click=\"this.qqincrement\"&gt;自增&lt;/button&gt; &lt;button @click=\"this.sssaddAction\"&gt;这里每次增加10&lt;/button&gt; &lt;button @click=\"this.sssaddAction(10)\"&gt;这里每次增加20&lt;/button&gt; &lt;button @click=\"this.aaaaareduceAction\"&gt;&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapMutations,mapGetters,mapActions &#125; from 'vuex' //导入 mapState 的对象export default &#123; name: 'Count', // 这里是组件名称 data () &#123; return&#123; msg:'xiaomi' &#125; &#125;, computed: &#123; count () &#123; return this.$store.state.count //main.js 中已经将 store 实例会注入到根组件下的所有子组件中，子组件能通过 this.$store 访问到 //一定要写 this，要不你会找不到 $store 的。 //这种写法很好理解，但是写起来是比较麻烦的 &#125;, ...mapGetters(&#123; aaaaacount:'donecount', // 把 `this.aaaaacount` 映射为 `this.$store.getters.doneTodosCount` aaaaatodos:'doneTodos' // 把 `this.aaaaatodos` 映射为 `this.$store.getters.doneTodosCount` //mapGetters 的对象赋值，其实就是 把这个过滤方法换一个名称， //不建议用这种方法，还是用数组赋值比较好 &#125;) &#125;, methods:&#123; ...mapMutations(&#123; add: 'add', // 将 `this.add()` 映射为 `this.$store.commit('add')` reduce: 'reduce' // 将 `this.reduce()` 映射为 `this.$store.commit('reduce')` //换句话说：想将一个 Mutations 属性另取一个名字，使用对象形式。， //上面可以随便改写名称 //addrrrrr: 'add', 将 `this.addrrrrr()` 映射为 `this.$store.commit('add')` //reducerr:'reduce' 将 `thisreducerr()` 映射为 `this.$store.commit('reduce')` &#125;), ...mapActions(&#123; qqincrement:'increment', // 将 `this.qqincrement()` 映射为 `this.$store.dispatch('increment')` sssaddAction:'addAction', // 将 `this.sssaddAction()` 映射为 `this.$store.dispatch('addAction')` aaaaareduceAction:'reduceAction' // 将 `this.aaaaareduceAction()` 映射为 `this.$store.dispatch('reduceAction')` &#125;) &#125;&lt;/script&gt; 4.2.3 这个方法太复杂了，不看了！！！！！！！！！！！通过导入 mapState 的对象 computed 的计算属性中放 mapState 的对象赋值 方法①很简单，好理解，同一个状态值调用一次可以这样用，但是当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： 1234567891011121314151617181920212223242526//.vue 子组件&lt;template&gt; &lt;div class=\"count\"&gt; /* 这里就不需要再像第三张那样复杂的写&#123;&#123;this.$store.state.count&#125;&#125;的长串了 */ &#123;&#123;msg&#125;&#125; is &#123;&#123;count&#125;&#125; years old ! &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState &#125; from 'vuex' //导入 mapState 的对象export default &#123; name: 'Count', // 这里是组件名称，给 template 中的 class 没有关系，原名为 HelloWorld data () &#123; return&#123; msg:'xiaomi' &#125; &#125;, computed: mapState(&#123; //这里 computed 属性,加上 mapState()，里面是对象 count:state=&gt;state.count,//函数 count 的 ES6 箭头函数写法 countAlias: 'count',// 传字符串参数 'count' 等同于 `state =&gt; state.count`？？？不懂？？ countPlusLocalState (state) &#123; return state.count + this.localCount // 这里为了能够使用 `this` 获取局部状态，必须使用常规函数????budong &#125; &#125;)&lt;/script&gt; 解析：count:state=&gt;state.count，这里我们使用 ES6 的箭头函数来给 count 赋值。意思即使说一个 count 函数传入 state 参数返回值是 state.count。箭头函数是我们必须要理解学会的。这个 ES6 函数可以转化为以下 ES5 函数。便于看不懂 ES6 的理解。 12345computed:mapState(&#123; count:function(state)&#123; return state.count &#125;&#125;) 4.2.4 类似拓展符号的方法引入！！！！！！！！！！！！！！！！！！！！！！！！！！重点，重点，重点，使用这方法来做！！！！！！！通过导入 mapState 的对象 computed 的计算属性中放 mapState 的数组赋值。这个办法是在实际应用中常用的方法，也是最简单的方法。需要注意的是 computed 里面是用的的数组，但是导入的时候都是对象，vuex 里面就是有 mapState 这个对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- //.vue 子组件 --&gt;&lt;template&gt; &lt;div class=\"count\"&gt; &#123;&#123;msg&#125;&#125; is &#123;&#123;count&#125;&#125; years old !&lt;/div&gt; &lt;button @click=\"this.add(10)\"&gt;加&lt;/button&gt;&lt;!-- 注意因为是用 main.js 引入的，不要忘记使用this. --&gt; &lt;!-- 不需要这样麻烦的调用了 this.$store.commit('add',10) --&gt; &lt;button @click=\"this.reduce(19)\"&gt;减&lt;/button&gt;&lt;!-- 不需要这样麻烦的调用了 this.$store.commit('reduce',19) --&gt; &lt;h3&gt;&#123;&#123;this.donecount&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;this.doneTodost&#125;&#125;&lt;/h3&gt; &lt;button @click=\"this.increment\"&gt;自增&lt;/button&gt; &lt;button @click=\"this.addAction\"&gt;这里每次增加 10&lt;/button&gt; &lt;button @click=\"this.addAction(10)\"&gt;这里每次增加 20&lt;/button&gt; &lt;button @click=\"this.reduceAction\"&gt;&lt;/button&gt; &lt;button @click=\"save\"&gt;原方法直接用，不需要 this&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapMutations,mapGetters, mapActions&#125; from 'vuex' //导入 mapGetters 对象export default &#123; name: 'Count', // 这里是组件名称，给 template 中的 class 没有关系，原名为 HelloWorld data () &#123; return&#123; msg:'xiaomi' &#125; &#125;, computed:&#123; newmsg()&#123; //原生 computed 计算属性方法 // &#125;, ...mapState(['count']), //改写 store.js 的 state 状态(和原生的计算属性并列显示) ...mapGetters([ //数组赋值改写 'donecount', 'doneTodos' ]) &#125;, methods:&#123; ...mapMutations([ 'add', // 将 `this.add(n)` 映射为 `this.$store.commit('add',n)` 'reduce' // 将 `this.reduce(n)` 映射为 `this.$store.commit('reduce',n)` ]), ...mapActions([ //数组赋值 'increment', 'addAction', 'reduceAction' ]), save()&#123; //.vue 文件的原方法 /*执行语句*/ &#125; &#125;&lt;/script&gt; 4.3 module 模块组运用随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。那今天我们就学习一下 module：状态管理器的模块组操作。尤其是一个很大的项目很多人同时进行，为了不影响他人的数据，我们每个人都有自己的模块组。将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：避免 store 对象就有可能变得相当臃肿。但是 module 模块组使用有坑，如果项目不是那么的大，建议不要轻易使用模块组。更多的学习到：vuex官网-module模块组 12345678910111213141516171819202122232425262728293031//store.js文件import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex)// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex),也就是上面3句const moduleA=&#123; state:&#123; count:1, &#125;, mutations: &#123; ... &#125;, getters: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const moduleB=&#123; state: &#123; ... &#125;, mutations: &#123;... &#125;, getters: &#123; ... &#125;, actions: &#123; increment (context) &#123; //①参数 context：上下文对象 context.commit('increment') &#125; &#125;,&#125;export default new Vuex.Store(&#123; modules:&#123; a:moduleA, b:moduleB &#125;&#125;) 12345678&lt;!-- .vue 子组件调用，这里是 template 中直接调用，在 script 得到改些到官网学习，太复杂了，如果项目不复杂不要用模块组，无形给自己增添麻烦 --&gt;&lt;template&gt; &lt;div class=\"count\"&gt; &#123;&#123;this.$store.state.a.count&#125;&#125; &lt;button @click=\"this.$store.dipatch.increment\"&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 太难了，后面如果实在项目麻烦，再去学习使用！！！！ 其实 vuex 也要适当的用直接传递参数会比这个好用多 五、JavaScript 的常见的算法类型执行时间12345# 标记 名称 描述# O(1) 常数 不管有多少值，执行的时间都是恒定的。一般表示简单值和存储在变量中的值|# O(log n) 对数 总的执行时间和值的数量相关，但是要完成算法并不一定要获取每个值。例如：二分查找|# O(log n) 线性 总执行时间和值的数量直接相关。例如：遍历某个数组中的所有元素|# O(n2) 平方 总执行时间和值的数量有关，每个值至少要获取 n 次。例如：插入排序| 六、vuex 与 .vue 的配合 完成的使用例子！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！store 与 .vue 组件之间的完整使用 6.1 例子一123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//store.js文件import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex)// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex),也就是上面 3 句const state=&#123; count:1, //这里写一些状态数据（就是类似组件中的 data()&#123;return&#123;//&#125;&#125; ） 中的数据 todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ], name:'xiaomi', cartCount: 0&#125;// 类似 .vue 中的 methods【mutations 是同步的】const mutations=&#123; add(state)&#123; //这里写一些方法，用来改变 state 中的状态值!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! state.count++;//store 中的状态的唯一途径就是显式地提交 (commit) mutation // 提交(commit) mutation 改变 state 中的值。 &#125;, reduce(state)&#123; state.count--; &#125;, increment (state) &#123; //在这里面的方法都是同步进行的 state.count++ &#125;, updateName(state,newName)&#123;//state 是必填的参数，就是原来的状态值，newName 是 在组件中 commit 提交的时候传递过来的值。 state.name = newName; &#125;, updateCartCount(state,newCartCount) &#123;//newCartCount 是传递过来的值 state.cartCount += newCartCount; &#125;&#125;// 类似 .vue 中的 methods【actions 是异步的】const actions=&#123; //这里写一些方法，用来改变 state 中的状态值，在这里面的方法是异步进行的!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! addAction (context) &#123; context.commit('add', 10) // 这里的 'add' 是 mutations 中的方法名称啦 // dispatch 一个 action，action 中在 commit一个 mutation,在 mutation 中改变 state 中的值。 setTimeOut(()=&gt;&#123;context.commit(reduce)&#125;,3000); console.log('我先执行完，因为在这里允许前面的人没有做完，我也可以开始了，我要的时间短，我就先完成了'); //console.log 先执行完毕，然后 setTimeOut(()=&gt;&#123;context.commit(reduce)&#125;,3000);才会被执行完， //事实上 setTimeOut 代码是先执行的，然后他执行时间比较长，后面的一个输出的执行时间比较短，后面一句都//比前面一句先执行完成了。 //关于执行时间的问题可以查看 JavaScript 中代码的执行时间问题。 &#125;, reduceAction (&#123;commit&#125;) &#123; commit('reduce')// 这里的 'reduce' 是 mutations 中的方法名称啦 &#125;, increment (context) &#123; //①参数 context：上下文对象 context.commit('increment') // 这里的 'increment' 是 mutations 中的方法名称啦 &#125;, updateName(context) &#123; context.commit(\"updateName\");// 这里的 'updateName' 是 mutations 中的方法名称啦 &#125;, updateCartCount(context) &#123; context.commit(\"updateCartCount\");// 这里的 'updateName' 是 mutations 中的方法名称啦 &#125;&#125;/* ES6/ES2015 的写法，actions: &#123; increment (&#123; commit &#125;) &#123;//②参数&#123;commit&#125;：直接把 commit 对象传递过来，方法体逻辑和代码更清晰明了。 commit('increment') &#125;&#125;*/const getters=&#123; //这些写一下方法过滤 state 状态的数据 const getters=&#123; count:state=&gt;state.count+10 //ES6 的写法，注意 ES6 返回值不能是赋值的形式，只能这样写 //而不能写成state.count+=10 因为箭头后面就是返回值啊， &#125;, doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) //返回值state.todos.filter(todo =&gt; todo.done) &#125;&#125;export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 1234567891011//组件中：methods: &#123; increment()&#123; this.$store.dispatch(\"updateUserInfo\", 'nick'); //this.$store.commit(\"increment\", 'nick'); &#125;, decrement() &#123; this.$store.dispatch(\"updateCartCount\", 1); // this.$store.commit(\"decrement\", 1); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!-- //.vue 子组件 --&gt;&lt;!-- commit =&gt; mutation //用来触发同步操作的方法 --&gt;&lt;!-- dispatch =&gt; action //用来触发异步操作的方法 具体的区别请查阅下面 4.4 --&gt;&lt;template&gt; &lt;div class=\"count\"&gt; &#123;&#123;msg&#125;&#125; is &#123;&#123;count&#125;&#125; years old !&lt;/div&gt; &lt;!-- count 不需要这样麻烦的调用了 this.$store.state.count --&gt; &lt;button @click=\"this.add(10)\"&gt;加&lt;/button&gt;&lt;!-- 注意因为是用 main.js 引入的，不要忘记使用this. --&gt; &lt;!-- 不需要这样麻烦的调用了 this.$store.commit('add',10) --&gt; &lt;button @click=\"this.reduce(19)\"&gt;减&lt;/button&gt; &lt;!-- 不需要这样麻烦的调用了 this.$store.commit('reduce',19) --&gt; &lt;h3&gt;&#123;&#123;this.donecount&#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123;this.doneTodost&#125;&#125;&lt;/h3&gt; &lt;button @click=\"this.increment\"&gt;自增&lt;/button&gt; &lt;!-- 不需要这样麻烦的调用了 this.$store.dispatch('increment') --&gt; &lt;button @click=\"this.addAction\"&gt;这里每次增加 10&lt;/button&gt; &lt;!-- 不需要这样麻烦的调用了 this.$store.dispatch('addAction') --&gt; &lt;button @click=\"this.addAction(10)\"&gt;这里每次增加 20&lt;/button&gt; &lt;!-- 不需要这样麻烦的调用了 this.$store.dispatch('addAction',10) --&gt; &lt;button @click=\"this.reduceAction\"&gt;&lt;/button&gt; &lt;button @click=\"save\"&gt;原方法直接用，不需要 this&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import &#123; mapState, mapMutations,mapGetters, mapActions&#125; from 'vuex' //导入 mapGetters 对象export default &#123; name: 'Count', // 这里是组件名称，给 template 中的 class 没有关系，原名为 HelloWorld data () &#123; return&#123; msg:'xiaomi' &#125; &#125;, computed:&#123; newmsg()&#123; //原生 computed 计算属性方法 // &#125;, ...mapState(['count']), //改写 store.js 的 state 状态(和原生的计算属性并列显示) ...mapGetters([ //数组赋值改写 'donecount', 'doneTodos' ]) &#125;, methods:&#123; ...mapMutations([ 'add', // 将 `this.add(n)` 映射为 `this.$store.commit('add',n)` 'reduce' // 将 `this.reduce(n)` 映射为 `this.$store.commit('reduce',n)` ]), ...mapActions([ //数组赋值 'increment', // 将 `this.increment(n)` 映射为 `this.$store.dispatch('increment',n)` 'addAction', 'reduceAction' ]), save()&#123; //.vue 文件的原方法 /*执行语句*/ // 上面的 ... 都是为了方便在 html，也就是 template 中去使用这个 mapState, mapMutations,mapGetters, mapActions // 如果需要在 methods 中的原方法，就比如这个 save() 原组件内的方法中去 commit 或者是 dispatch 也是一样的使用呀。 this.add(33)// 去使用 mapMutations 提交 commit 一个 add 方法到 store &#125; &#125;&lt;/script&gt; 6.2 例子二1234567891011121314151617181920212223242526272829303132333435//store.js 这个是 vue-cli3 中的，// 使用的也是 ES6 的写法import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; &#125;, mutations: &#123; increment(state,n)&#123; state.count+=n; &#125;, ADD_NUM:(state,n)=&gt;&#123; state.data = n; &#125;, SET: (state, productObj) =&gt; &#123; state.updateProductFormData = productObj &#125; // 一般来说把 mutations 中的常量，全都大写，可以有下划线，不是，这个去看 types 吧，是常量 &#125;, actions: &#123; incrementAction(&#123;commit&#125;,count)&#123;// &#123;commit&#125; 是 ES6 的写法 commit('ADD_NUM',count.num)// 因为传入的 count 是对象，所以这里是 count.num &#125;, //currentProduct 是传递过来的值 setCurrentProductAction(&#123; commit &#125;, currentProduct) &#123; commit('SET', currentProduct) &#125; &#125;, getters:&#123;&#125;&#125;) 123456789//.VUE 组件中使用（这里是没有使用简化的方法的，只是为了学习一下使用，还是要学会用 ... 简化方法）methods:&#123; add()&#123; this.$store.commit('increment',10) &#125;, add1()&#123; this.$store.dispatch('incrementAction',&#123;num:1&#125;)//这里传过去的数据是 &#123;num:1&#125; 对象 &#125;&#125; 1234567891011121314# &#123;commit&#125; es6 中函数的参数是一个对象，函数中用的是对象中的一个方法，是可以通过对象的解构赋值直接获取到该方法的# 因为 actions 中的函数中 commit mutation, 所以会获取到一个默认的参数 context,它是一个 store 的实例，通过它可以获取到 store 的属性和方法，# 如 context.state 获取 state 属性，context.commit 执行 commit命令。所以把# ES5 写法increment(context,count)&#123; context.commit('ADD_NUM',count.num)&#125;# 简写成 ES6 写法increment(&#123;commit&#125;,count)&#123; commit('ADD_NUM',count.num)&#125; 七、mutations 与 actions 的区别 与 实际应用场景！！！！！！！！！！！！！！！！！！一些比较复杂的学习：地址 123456789101112commit =&gt; mutation //用来触发同步操作的方法 如果想改变 vuex 的store 中的状态的 唯一方法是提交 (commit) mutationdispatch =&gt; action //用来触发异步操作的方法 action 主要处理的是异步的操作，mutation 必须同步执行，而 action 就不受这样的限制，也就是说 action 中我们既可以处理同步，也可以处理异步的操作 如果想在 action 中改变 store 中的状态， 先要 dispatch 一个 action，action 中在 commit一个 mutation,在 mutation 中改变 store 中的值。（action 改变状态，最后是通过 mutation 提交） action 处理异步数据最终提交到数据库 mutation 用来同步数据做业务的处理 ( vuex 中 store 数据改变唯一的方法就是 mutation) Action 提交的是 mutation，而不是直接变更状态。 123456789101112131415mutations: &#123; someMutation (state) &#123; api.callAsyncMethod(() =&gt; &#123; state.count++ //这句代码在这里是不会被执行的 &#125;) &#125;&#125;// 在这个 mutations 中 someMutaion 函数里面是有一个回调函数的，是异步的。内部的代码块是不会被执行到的。// 我们都知道 任何回调函数 中进行的状态改变都是无法追踪的, devtools 会对 mutations 的每一条提交做记录,// 记录上一次提交之前和提交之后的状态,在上面的例子中无法实现捕捉状态,因为在执行 mutations 时,内部回调函数还没有执行,所以此时无法捕捉状态.//为了解决 mutations 只有同步的问题,提出了 actions(异步),专门用来解决 mutations 只有同步无异步的问题.//（mutations 与 actions 最终的目的都是为了改变 state 状态中的值，只是 actions 需要更多的一个步骤而已，它需要通过去调用 mutations 来改变 state） 八、store.js 的完整使用 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！上面我们是学会了 vuex 如何使用，但是如果是在一个大型项目中，我们都是多人开发的，会不利于管理。 通常就会用一个方法定义一个常量，也就是 types。 还有上面的 module 分模块进行的 8.1 types 常量123456789101112131415161718192021222324252627282930313233343536373839404142434445//在需要多人协作的项目中，我们可以使用常量代替 mutation 事件类型。这在各种 Flux 实现中是很常见的模式。同时把这些常量放在单独的文件中可以让协作开发变得清晰。//store.js 这个是 vue-cli3 中的，使用的也是 ES6 的写法import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex),也就是上面 3 句// 常量，通常会放到另外的文件里面，然后再引进来const types = &#123; SET_TARGET_USER: \"SET_TARGET_USER\" //详细资料&#125;;export default new Vuex.Store(&#123; state: &#123; //用户初始化的状态 targetUser: &#123;&#125; //用户详细资料数据 &#125;, getters:&#123; //获取到用户状态, 实时监听 state 值的变化(最新状态) targetUser: state =&gt; state.targetUser &#125; mutations: &#123; //自定义改变state初始值的方法 [types.SET_TARGET_USER](state, targetUser) &#123; if (targetUser) &#123; state.targetUser = targetUser; //如果 targetUser 有内容就赋给状态信息 &#125; else &#123; //如果没内容就给 targetUser 赋空对象 state.targetUser = &#123;&#125;; &#125; &#125;, actions: &#123; //这里面的方法是用来异步触发 mutations 里面的方法, context 与 store 实例具有相同方法和属性 setGargetUser(&#123; commit &#125;, targetUser) &#123; commit(types.SET_TARGET_USER, targetUser); // localStorage.setItem(\"SET_TARGET_USER\", JSON.stringify(targetUser)); &#125; &#125;&#125;) 8.2 module12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//store.js文件（这里是写在一个页面上的，实际开发中会分开成为几个文件，然后引入这里来。）import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex)// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex),也就是上面3句// 常量const types = &#123; SET_TARGET_USER: \"SET_TARGET_USER\" //详细资料&#125;;const moduleA=&#123; state:&#123; //用户初始化的状态 targetUser: &#123;&#125; //用户详细资料数据 &#125;, mutations: &#123; //自定义改变 state 初始值的方法 [types.SET_TARGET_USER](state, targetUser) &#123; if (targetUser) &#123; state.targetUser = targetUser; //如果 targetUser 有内容就赋给状态信息 &#125; else &#123; //如果没内容就给 targetUser 赋空对象 state.targetUser = &#123;&#125;; &#125; &#125;, getters: &#123; //获取到用户状态,//实时监听state值的变化(最新状态) targetUser: state =&gt; state.targetUser &#125;, actions: &#123; //这里面的方法是用来异步触发mutations里面的方法,context与store 实例具有相同方法和属性 setGargetUser(&#123; commit &#125;, targetUser) &#123; commit(types.SET_TARGET_USER, targetUser); // localStorage.setItem(\"SET_TARGET_USER\", JSON.stringify(targetUser)); &#125; &#125;&#125;const moduleB=&#123; state: &#123; ... &#125;, mutations: &#123;... &#125;, getters: &#123; ... &#125;, actions: &#123; increment (context) &#123; //①参数 context：上下文对象 context.commit('increment') &#125; &#125;,&#125;export default new Vuex.Store(&#123; modules:&#123; a:moduleA, b:moduleB &#125;&#125;)//store.state.a // -&gt; moduleA 的状态//store.state.b // -&gt; moduleB 的状态 十、使用过程的坑/与自己的犯错10.1 调用 mutations 方法错误123456789101112131415161718 [Vue warn]: Error in mounted hook: \"SyntaxError: Unexpected token u in JSON at position 0\" # 在 mounted 钩子的时候出错found in---&gt; &lt;Home&gt; at src\\components\\home.vue # 在 home.vue 组件出错 &lt;App&gt; at src\\App.vue &lt;Root&gt;vue.esm.js?efeb:1741 SyntaxError: Unexpected token u in JSON at position 0 # 在位置 0 的 JSON 中出现意外的标记 u at JSON.parse (&lt;anonymous&gt;) # JSON 数据解析出错 JSON.parse at Store.gettabledata (store.js?0dc8:23) at wrappedMutationHandler (vuex.esm.js?358c:697) at commitIterator (vuex.esm.js?358c:389) at Array.forEach (&lt;anonymous&gt;) at eval (vuex.esm.js?358c:388) at Store._withCommit (vuex.esm.js?358c:495) at Store.commit (vuex.esm.js?358c:387) at Store.boundCommit [as commit] (vuex.esm.js?358c:335) at VueComponent.mounted (home.vue?250d:180) 填坑 主要是好好的看报错信息，这样就可以看到我们错误的地方是哪里了，缩小错误的范围了。 10.2","tags":[]},{"title":"JQurey-ui--[ui 组件库]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ jqurey.js 框架 }-框架入门/","text":"一、前言jQuery 是一个 JavaScript 库。jQuery 极大地简化了 JavaScript 编程，jQuery 是一个轻量级的”写的少，做的多”的 JavaScript 库。它封装了很多js的方法，实现了很多有用的功能。使得一些 JS 的特效方法使用起来很方便。它就是用 JS 封装的一些方法，开发者可以直接调用这些方法。不必再为了实现一些特效而费时费力的去编写大段的 JS 脚本。（但是不能不会 JS ，开发者也可以去开发封装函数，做一套新的 JS 库也创建类似 jqurey 的东西出来给开发用）jqurey还封装了浏览器的兼容性问题，使用它我们不必再担心浏览器的兼容问题。目前网络上有大量开源的 JS 框架, 但是 jQuery 是目前最流行的 JS 框架，而且提供了大量的扩展。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 HTML DOM 遍历和修改 CSS 操作 JavaScript 特效和动画 HTML 事件操作 AJAX 异步请求方式：在不刷新的同时更新页面的内容 Utilities Jquery 还提供了大量的插件。 菜鸟教程：网址jquery ：官网 二、jQuery 浏览器兼容问题jQuery 版本 2 以上不支持 IE6，7，8 浏览器。 ①如果需要支持 IE6/7/8，那么请选择1.9，但是不建议这样，新版本有它的新功能。②你还可以通过条件注释在使用 IE6/7/8 时只包含进1.9。 123456&lt;!--[if lt IE 9]&gt; &lt;script src=\"jquery-1.9.0.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;!--[if gte IE 9]&gt;&lt;!--&gt; &lt;script src=\"jquery-2.0.0.js\"&gt;&lt;/script&gt;&lt;!--&lt;![endif]--&gt; 三、jQuery 库的安装/引入3.1 下载 jQuery 库，将文件直接放置在项目中，不建议这种方式，会让项目文件太大。123&lt;head&gt; &lt;script src=\"jquery-1.10.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 3.2 CDN 中载入 jQuery百度服务器 CDN jQurey谷歌服务器 CDN jQureyboot CDN jQurey 1234&lt;head&gt; &lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt; &lt;/script&gt;&lt;/head&gt; 四、jQuery 的语法4.1 jQuery 基本语法 与 概念4.1.1 jQuery 基本语法jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。基础语法： $(selector).action()selector: 选择器，选择符（选择符 “查询”和”查找” HTML 元素）action(): 操作（执行对元素的操作） 123456$(document).ready(function()&#123; $(this).hide() //隐藏当前元素 $(\"p\").hide() //隐藏所有 &lt;p&gt; 元素 $(\"p.test\").hide() //隐藏所有 class=\"test\" 的 &lt;p&gt; 元素 ！！！！ $(\"#test\").hide() // 隐藏所有 id=\"test\" 的元素&#125; $() 的几种用法 前面 2 个是及其关键的。选择 html 中的 DOM 来操作，或者在 html 中生成 DOM。 DOM 选择 就是获取到上下文，不就是在html中查找元素？？？？ DOM 创建 就是使用 jQuery.js 代码来生成 html，可以指定所属的document、属性、事件、甚至所有jQuery方法 见实战：数独游戏 ,九宫格就是使用 jQuery.js 代码生成的。 DOM 加载完成事件监听 $(document).ready()的简化写法。就是 4.2 节中的 2 种写法咯。 $()=$(document).ready()，$(func)=$(document).ready(func) 4.1.2 jQuery 基本概念了解 window window 是浏览器端的全部数据变量的引用。 比如 window.window === window window.jQuery 就是浏览器中的全局变量里的 jQuery。 window.jQuery === jQurey 但是 jQurey 特殊，要写 window.jQuery，不然会出错的。 $ 就是 jQuery的别称 因此 window.jQuery === window.$ ,$=jQuery 4.2 jQuery 的入口函数12345678910$(document).ready(function()&#123; // 执行代码&#125;);//或者$(function()&#123; // 执行代码&#125;);// 也就是 $() = $(document).ready() , $() 就代表了 DOM 监听加载完成 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，也就是说在 DOM 加载完成后才可以对 DOM 进行操作。 如果在文档没有完全加载之前就运行函数，操作可能失败。 4.3 JavaScript 入口函数123window.onload = function () &#123; // 执行代码&#125; 4.4 $(document).ready(function(){} 与 window.onload = function () {} 的区别$(document).ready(function(){}： jQuery 的入口函数是在 html 所有标签 (DOM) 都加载之后，就会去执行。window.onload = function () {}： JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 可以看出 $(document).ready(function(){} 速度是要快一些的。 五、jQuery 对象与 DOM 对象 与 JS 的区别!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!5.1 （DOM 对象） 与 （jqurey 对象）的区别DOM 对象与 jqurey 对象的区别：网址，区分好 DOM 对象 与 jquery 对象是 学好 jquery 的根本，了解了他们的差别，我们在学习 Jquery API 方法的时候才会看得明白。 DOM 对象：即是我们用传统的方法 (JS) 获得的对象，var domObj = document.getElementById(&quot;id&quot;);jQuery 对象：即是用 jQuery 类库的选择器获得的对象; var $obj = $(&quot;#id&quot;); 是通过 jQuery 包装 （DOM 对象）后产生的对象，它是 jQuery独有的。 通常 jQuery 对象，我们在变量前面加一歌 $ 表示，我们就可以快速的分辨 对应的变量是 jQuery 对象 还是 DOM 对象 分清 jQuery 对象 和 DOM 对象 之间的区别，之后学习 jQuery 就会轻松很多的。 12// JavaScript 获取 id 为 foo 的元素内的 html 代码。 document.getElementById(\"foo\").innerHTML; 1234//jQuery 获取 id 为 foo 的元素内的 html 代码。$(function()&#123; $(\"#foo\").html()&#125;) 123456789//在 jQuery 对象 中无法使用 DOM 对象的任何方法。$(\"#id\").innerHTML//错误,jQuery 中没有 innerHTML 这个方法，它是 html()$(\"#id\").html() // 正确$(\"#id\").checked //错误,jQuery 中没有 innerHTML 这个方法，它是 html()$(\"#id\").attr (\"checked\") // 正确//当然 DOM 对象 也不能使用 jQuery 方法 5.1.1 判断是 DOM 对象 还是 jqurey 对象123456789101112131415161718192021222324//jqurey 对象 可以获取版本号，检测它是 jqureyconsole.log(jQuery.fn.jquery);console.log($.fn.jquery);console.log($.prototype.jquery);//DOM 对象 使用 .nodeType 可以获得节点，检测它是DOMconsole.log(object.nodeType);jqueryObject instanceof jQuery; //true jqueryObject 是jQuery对象domObject instanceof jQuery; //false domObject不是jQuery对象domObject instanceof HTMLElement; //true domObject是DOM对象if (object[0]) &#123; console.log(\"obj is a jquery object\");&#125; else &#123; console.log(\"obj is a dom object\");&#125;if(obj instanceof jQuery)&#123;alert(\"这是一个jQuery对象\");&#125;else&#123;alert(\"这是一个其它对象\")&#125; 5.1.2 jQuery 对象 和 DOM 对象 的互相转换!!!!!!!!!!!!!!!!!!!!!!!! 这里是一个重点。jquery 对象和 dom 对象是不一样的！比如 jquery 对象不能使用 dom 的方法，dom 对象不能使用 jquery 方法。 那假如我 jquery 没有封装我要的方法，那能怎么办呢？这时我们可以将 jquery 对象 转换成 dom 对象，然后使用 js 去操作 DOM 对象来实现我们的效果。 jquery提供了两种方法将一个 jquery 对象转换成一个 dom 对象，即 [index] 和 get(index)。因为jquery 对象就是一个数组对象[通过选择器我们可以选择到 1 或者多个 对象。 id ：1 个， class 1个或者多个，元素 1 或者多个…..] 就是数组了!!!!! 12//jQuery 对象 ，是一个集合，也就是类似数组的东西，可以获取它的长度，*/console.log($(\"div\").length);//0 或 1 或 更多 1234567891011121314//jquery对象 转换成 DOM 对象。转换后可以任意使用 DOM 对象中的方法了.var jqureyObject=$(\"domobject\"); //获取一个 jqurey 对象。下面来转化为 DOM 对象var domObject=jqureyObject.get(index); //方法1：使用方法 get(index)var domObject=jqureyObject[index]; //方法2：使用类数组取索引的办法var $cr=$(\"#cr\"); //jquery 对象 统称用 $ 来表示 jquery 对象 变量!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!var crDom = $cr[0]; //dom 对象 也可写成 var cr=$cr.get(0);alert(crDom.checked); //检测这个 checkbox 是否给选中 checked 方法是 DOM 对象才有的//dom 对象 转换成 jquery 对象。转换后可以任意使用 jquery 中的方法了.jquery 对象 提供了一套更加完善的工具用于操作 dom//对于一个 dom 对象，只需要用 $() 把 dom 对象 包装起来，就可以获得一个 jquery 对象了，方法为 $(dom对象);!!!!!!!!!!!!!!!!!var crDom = document.getElementById(\"#cr\"); // dom 对象 crDomvar $cr = $(crDom); //转换成 jquery 对象 123456789101112131415161718192021222324252627$(function () &#123; var jqureyObject = $(\"#aa\"); // 用 jqurey 来获取 html 元素， (jqurey对象) var domObject = document.getElementById(\"aa\");// document 获取 html 元素(DOM对象) console.log(jqureyObject);//jQuery.fn.init [div#div] (jqurey对象) console.log(domObject);// &lt;div id=\"div\"&gt;我是小米粥&lt;/div&gt; (DOM 对象) // 从这两句的结果可以看到，输出是不一样的。 DOM 对象是 html 中的整个元素以及元素内的内容。 // 而 jqurey对象 我们是看不到元素内的内容的。 console.log(jqureyObject.jqurey); //3.3.1 对 jqurey对象 对象 使用 .jqurey 可以获取到对应引入的 jQurey console.log(domObject.nodeType); // 1 DOM元素的节点类型， console.log(jqureyObject.nodeType); //undefined，表示这个对象不是dom对象 console.log(domObject.jqurey); //undefined，表示这个对象不是jqurey对象 console.log($(domObject)); // DOM 对象转 jQuery 对象 ，就是使用 $() 方法传 DOM 对象 console.log($(jqureyObject.get(0)));// jQuery 对象 转 DOM 对象， 使用 .get(index) 方法 console.log($(jqureyObject[0])); // jQuery 对象 转 DOM 对象， 使用 [index] 数组索引 var jqureyObject1 = $(\".bb\"); //用jqurey来获取html元素， (jqurey对象) var domObject1 = document.getElementsByClassName(\"bb\");//document获取html元素 (DOM 对象) console.log(jqureyObject1);//jQuery.fn.init [prevObject: jQuery.fn.init(1)] (jqurey对象) console.log(domObject1);// HTMLCollection [] DOM对象 (DOM 对象) /* 题外知识！ js获取元素的方法中，只有id的是单个DOM元素，可以直接用， tagname、classname，的都是数组，都要借助索引才能得到 单个DOM元素 来操作的！！！！ 5.2 （jQuery 与 js 的区别）的区别 也就是 4.2 节12345678910//jQuery 入口函数:$(document).ready(function()&#123; // 执行代码&#125;);//或者$(function()&#123; // 执行代码&#125;); 123456//JavaScript 入口函数:window.onload = function () &#123; // 执行代码&#125;// jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。// JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。 七、jQuery 对象与 的方法操作方法的网址!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!方法的网址!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!方法的网址!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!方法的网址!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!方法的网址!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!方法的网址!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 网址：方法的网址，这是一个写的很全的方法网址，jquery 3.3.1 的中文文档，但是太小了吧，看着有点难受。 6.1 jQuery 的选择器:获取 jQuery 对象jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器。除此之外，它还有一些自定义的选择器 6.1.1 选择器6.1.1.1 基本选择器：*，element，class，id，this 选择器 描述 * 所有元素选择器 element element 元素选择器 .classname class=’classname’ 的 类选择器 #idname id=’idname’ 的 ID 选择器 this 当前对象选择器 123456789101112131415161718192021&lt;body&gt; &lt;div&gt;1111&lt;/div&gt; &lt;h1&gt;222&lt;/h1&gt; &lt;div class='title'&gt;1111&lt;/div&gt; &lt;h1 id='title' class='title'&gt;222&lt;/h1&gt; &lt;p&gt;如果您点击我，我会消失。&lt;/p&gt; &lt;p&gt;点击我，我会消失。&lt;/p&gt; &lt;p&gt;也要点击我哦。&lt;/p&gt; &lt;script&gt; $(\"*\") //选取所有元素 结果： $(\"div\") //选取 div 元素 结果： $(\".title\") //选取 class='title' 的元素，就是 div 与 h1 都被选择到 $(\"#title\") //选取 id='title' 的元素，就是 h1 被选择到 $(\"p\").click(function()&#123; $(this).hide(); //$(this) 是在方法 click 内，此处的 $(this) 表示的是当前调用 click 方法的对象 $(\"p\")， // 就是表示当前对象，当前调用该方法的对象， //其实不就是 js 中的环境的 this 么，函数坏境内就是触发就是触发函数的对象咯 &#125;); &lt;/script&gt;&lt;body&gt; 6.1.1.2 层级、后代 选择器 选择器 描述 select1，select2…. 匹配任意一个选择器 的元素 $(“a[target=’_blank’]”) 选取所有 target 属性值等于 &quot;_blank&quot; 的 &lt;a&gt; 元素 $(“a[target!=’_blank’]”) 选取所有 target 属性值不等于 &quot;_blank&quot; 的 &lt;a&gt; 元素 $(“:button”) 选取所有 type=&quot;button&quot; 的 &lt;input&gt; 元素 和 &lt;button&gt; 元素 $(“tr:even”) 选取偶数位置的 &lt;tr&gt; 元素 $(“tr:odd”) 选取奇数位置的 &lt;tr&gt; 元素 1234567891011&lt;div&gt;div&lt;/div&gt;&lt;p class=\"myClass\"&gt;111&lt;/p&gt;&lt;span&gt;22&lt;/span&gt;&lt;p class=\"notMyClass\"&gt;&lt;p class=\"notMyClass\"&lt;/p&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"div,span,p.myClass\") //将每一个选择器匹配到的元素合并后一起返回。你可以指定任意多个选择器，并将匹配到的元素合并到一个结果内。 //结果：[ &lt;div&gt;div&lt;/div&gt;, &lt;p class=\"myClass\"&gt;111&lt;/p&gt;, &lt;span&gt;22&lt;/span&gt; ]&#125;);&lt;/script&gt; 1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;p&gt;11&lt;p&gt; &lt;p class='intro'&gt;22&lt;p&gt; &lt;p href='#'&gt;33&lt;p&gt; &lt;p&gt; &lt;span class='intro'&gt;44&lt;span&gt; &lt;p&gt; &lt;span&gt;555&lt;/span&gt;&lt;/div&gt;&lt;ul&gt; &lt;li&gt;q&lt;/li&gt; &lt;li&gt;w&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;o&lt;/li&gt; &lt;li&gt;p&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;$(document).ready(function()&#123; $(\"div p\") //获取 div 下的 所有 p 元素 结果：&lt;p&gt;11&lt;p&gt; 与&lt;p class='intro'&gt;22&lt;p&gt; 与 &lt;p&gt;33&lt;p&gt; $(\"p.intro\")//选取 class 为 intro 的 `&lt;p&gt;` 元素 结果：&lt;p class='intro'&gt;22&lt;p&gt; $(\"p .intro\")//选取 `&lt;p&gt;` 元素下 class 为 intro 的元素 结果： &lt;span class='intro'&gt;44&lt;span&gt; $(\"ul li:first\") // 选取第一个 `&lt;ul&gt;` 元素的第一个 `&lt;li&gt;` 元素 结果: &lt;li&gt;q&lt;/li&gt;!!!!!!!!!!!!!!!!!!!!!!!!!! $(\"ul li:first-child\") //选取每个 `&lt;ul&gt;` 元素的第一个 `&lt;li&gt;` 元素 结果: &lt;li&gt;q&lt;/li&gt; 与 &lt;li&gt;o&lt;/li&gt;!!!!!!!!!!!!!!!! $(\"p:first\")//选取第一个 `&lt;p&gt;` 元素 结果: &lt;p&gt;11&lt;p&gt; $(\"[href]\") //选取带有 `href` 属性的元素 结果：&lt;p href='#'&gt;33&lt;p&gt; $('div&gt;span') // 选择 div 下的直接子元素 span 结果：&lt;span&gt;555&lt;/span&gt;&#125;);&lt;/script&gt; 6.2 jQuery 的选择器:创建 jQuery 对象 （注意不是 DOM 对象） 重点！！！！！！！！！！！！！！！！！！！！！！！！5.3 创建 jQuery 对象12345678910//创建 $(\"&lt;div&gt;内容&lt;/div&gt;\");//放到页面中用 对象.appendTo(\"标签元素\") 方法放进去，放到该元素的最后面 两种办法第一种办法是元素必须是空元素 ① $(\"&lt;a&gt;\",&#123;text:\"jingdong\",href:\"url\",target:\"\",title:\"\"&#125;); ② $(\"&lt;a&gt;jingdong&lt;/a&gt;\").attr(&#123;href:\"url\",target:\"\",title:\"\"&#125;); var div = $(\"&lt;div&gt;hello&lt;/div&gt;\");//但是这样只是定义在内存中，没有放到页面上，/* 我们通过选择器是选择不到它 的，需要先放到页面中*/div.appendTo(\"body\"); //只能是标签么，用\"p1\"怎么不行，var link = $(\"&lt;a&gt;\", &#123; text: \"jingdong\", href: \"url\", target: \"\", title: \"\" &#125;);link.appendTo(\"body\") jQuery()里面提供的4种构建jQuery对象的方式（1）jQuery(expression,[context])（2）jQuery(html,[ownerDocument])（3）jQuery(elements)（4）jQuery(callback) $(“div&gt;p”) //参数是字符串$($(“div&gt;p”)) //参数可以是jQuery对象或者类数组（ArrayLike）的集合$(document) //参数可以是DOM元素$() //$(document)简写$(function(){}) //$(document).ready()的简写$([]) //参数可以是数组$({}) //参数可以是对象$(1) //参数可以是数字，即把1存储到jQuery对象的数据集合中 //注意：后面4行代码都可以被解析，但是这些参数数据（非DOM元素的参数）是被存储到ArrayLike（类数组）集合中，而不是被转换为DOM元素。虽然语法不错，解析正常，但是它们无法完成实际应用。 7.1 $obj.get(index) 返回指定位置的 DOM 对象jqurey 是一个集合，也就是类似数组的东西，我们通常是需要对其中的某些元素进行操作，就要提取元素，也就是索引来获取，之后就用方法来操作,也就是获取到对应的 DOM 元素来操作。 就像是在数组中一样，index 可以为负值，从右边开始选择。或者是与数组长度相加。 12$obj.get(index) //从 Jquery 对象中获取 DOM 对象 数组中某个值$obj.get() //从 Jquery 对象中获取 DOM 对象 数组（所有值） 7.2 $obj[index] 返回指定位置的 DOM 对象7.3 $obj.index（） 返回指定元素相对于其他元素的 index 位置123456789101112131415&lt;body&gt; &lt;p&gt;点击列表项可获得其相对于同胞元素的 index 位置：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Soda&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; $(\"li\").click(function()&#123; alert($(this).index()); // 0 或 1，或 2 ..... // $(this) 也就是当前 HTML 元素。 //index() 返回指定元素相对于其他指定元素的 index 位置。 &#125;);&lt;/script&gt; 123456789101112131415&lt;body&gt; &lt;span&gt;Click a div!&lt;/span&gt; &lt;div&gt;First div&lt;/div&gt; &lt;div&gt;Second div&lt;/div&gt; &lt;div&gt;Third div&lt;/div&gt; &lt;script&gt; $( \"div\" ).click(function() &#123; // 点击某个 div // `this` is the DOM element that was clicked var index = $( \"div\" ).index( this ); $( \"span\" ).text( \"That was div index #\" + index ); // 将 div 的 对应 index 输出在 span 标签内 &#125;); &lt;/script&gt;&lt;/body&gt; 7.4 $obj.toArray() 返回 DOM 对象数组7.5 $obj.eq(index) 返回 jqurey 对象7.6 $obj.first() 返回 jqurey 对象7.7 $obj.last() 返回 jqurey 对象7.8 $obj.parent() 返回 jqurey 对象（一级父元素）7.9 $obj.parents() 返回 jqurey 对象（所有父元素）7.10 $obj.parentsUntil() 返回 jqurey 对象（到某个父元素的所有父元素）7.11 $obj.children() 返回 jqurey 对象（一级子元素）7.12 $obj.contents() 返回 jqurey 对象（返回所有一级子元素带文本节点 对象）7.13 $obj.find() 返回 jqurey 对象（后代元素）7.14 $obj.closest() 返回 jqurey 对象（返回它本身或者是逐级向上(父元素)查找到匹配的元素，没有就是空）","tags":[{"name":"Jquery->ajax","slug":"Jquery-ajax","permalink":"https://liuxmoo.com/tags/Jquery-ajax/"}]},{"title":"vuex 实际应用-web Storage全面认知与使用(localStorage,sessionStorage)","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 } vuex 状态管理器 与 Storage/","text":"一、前言要使用vuex管理后端数据，首先要学习JavaScript如何 获取 存贮 后端数据。获取后端数据应去学习分类:⑧axios前后端数据交互，本文学习 localStorage 与 vuex管理localStorage本地存储的数据 。第一阶段，什么是web存储机制。第二阶段，localStorage如何使用第三阶段，使用vuex管理localStorage本地存储的数据 二、什么是web存储机制1、web存储 Web Storage在JavaScript高级程序设计Nicholas C.Zakas著，李松峰译书中是这样解释的: Web Storage 最早是在 Web 超文本应用技术工作组（WHAT-WG）的 Web 应用 1.0 规范中描述的。这个规范的最初的工作最终成为了 HTML5 的一部分。Web Storage 的目的是克服由 cookie 带来的一些限制，当数据需要被严格控制在客户端上时，无须持续地将数据发回服务器。Web Storage 的两个主要目标是：◆ 提供一种在 cookie 之外存储会话数据的途径；◆ 提供一种存储大量可以跨会话存在的数据的机制。&nbsp;&nbsp;&nbsp;&nbsp;最初的 Web Storage 规范包含了两种对象的定义： sessionStorage 和 globalStorage 这两个对象在支持的浏览器中都是以 windows 对象属性的形式存在的.后来修订之后的html5用localStorage对象取代了globalStorage对象。 通俗一点解析 cookie是早期的数据存储机制 html4 cookie指某些网站为了辨别用户身份而储存在用户本地终端(Client Side)上的数据（通常经过加密。需要深入了解cookie可以查看：维基百科 Web Storage/sessionStorage/localStorage新数据存储机制 html5 由于cookie的局限性，后来就在html5中添加了Web Storage存储机制。Web Storage包含了两种对sessionStorage对象与localStorage对象。 2、cookie与session HTML4的本地存储详解详解 浏览器有缓存机制，这个机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互。cookie和session都是用来跟踪浏览器用户身份的会话方式。 区别： 保存状态：cookie保存在浏览器端，session保存在服务器端 使用方式：（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它（2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。 存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象) 存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。 安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。（1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；（2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；（3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。（4）sessionID是加密的（5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。 应用场景：cookie：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。（2）保存上次登录的时间等信息。（3）保存上次查看的页面（4）浏览计数session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。（1）网上商城中的购物车（2）保存用户登录信息（3）将某些数据放入session中，供同一用户的不同页面使用（4）防止用户非法登录 缺点：cookie：（1）大小受限（2）用户可以操作（禁用）cookie，使功能受限（3）安全性较低（4）有些状态不可能保存在客户端。（5）每次访问都要传送cookie给服务器，浪费带宽。（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。session：（1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。（2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全（3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。3、Web Storage（sessionStorage和localStorage）解释及区别 HTML5的本地存储详解 sessionStorage和localStorage都是html5中Web Storage 规范的对象，拥有一样的方法或属性，即可使用的API都相同。 保存数据：localStorage.setItem(key,value);-sessionStorage.setItem(key,value); 读取数据：localStorage.getItem(key); ——————sessionStorage.getItem(key); 删除单个数据：localStorage.removeItem(key);-sessionStorage.removeItem(key); 删除所有数据：localStorage.clear(); ———————sessionStorage.clear(); 得到某个索引的key：localStorage.key(index);-sessionStorage.key(index); 异同： 保持状态： sessionStorage将数据 暂时 保存在客户端本地(本地磁盘)的通俗一点就是说：session，是指用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览这个网站所花费的时间。session对象可以用来保存在这段时间内所要求保存的任何数据。浏览器关掉了数据就没有了（当然了如果浏览器非正常关闭，崩溃重启这些数据可以恢复）这里需要知道sessionStorage与前面的session不是一个东西，session是后端对象(配合cookie使用)，sessionStorage是前端对象。 localStorage则将数据 永久 保存在客户端本地(本地磁盘)通俗一点说：local嘛就是本地的意思。将数据保存在客户端本地的硬件设备(通常指硬盘，也可以是其他硬件设备)中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站时仍然可以继续使用。一句话概括：sessionStorage为临时保存/回话存储，而localStorage为永久保存。localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空 生命周期：（1）localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。（2）sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。 存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB。 存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。 存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理 获取方式：都是window下的对象window.localStorage;window.sessionStorage; 应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录 4、cookie 与 Web Storage（sessionStorage和localStorage）的区别详解 特性 cookie sessionStorage localStorage 数据生命周期 就会被指定一个maxAge值这就是cookie的生存周期，在这个周期内cookie有效,默认关闭浏览器失效 页面会话期间可用 除非数据被清除,否则-直存在 存放数据大小 4K左右(因为每次http请求都会携带cookie ) 同右 一般5M或更大详细看这(需科学，上网) 与服务器通信 由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 同右 数据不是由每个服务器请求传递的，而是只有在请求时使用数据,不参与和服务器的通信 易用性 cookie需要自己封装setCookie , getCookie 同右 可以用源生接口,也可再次封装来对Object和Array有更好的支持 共同点 都是保存在浏览器端,和服务器端的session机制不同 同左 同左 &nbsp; 三、localStorage的具体使用经过上面的比较，我们知道cookie是浏览器提供的缓存，sessionStorage是会话存储，localStorage是永久存储。在使用vue做前端的时候，我们是要从后端获取的信息永久的保存在本地，提供我们使用。 1、localStorage的方法/属性在第二节的中列出了localStorage的方法/属性，这些可以是API接口，也可以作为属性使用。 但是浏览器不兼容这些属性，还是用方法比较妥当。 保存数据：localStorage.setItem(key,value);-localStorage.key=value 读取数据：localStorage.getItem(key); ——————localStorage.key 删除单个数据：localStorage.removeItem(key);-delete localStorage.key 删除所有数据：localStorage.clear(); ——————— 得到某个索引的key：localStorage.key(index);- 2、localStorage的优势与局限学习localStorage之前先更详细的了解它优势与劣势。 localStorage的优势1、localStorage拓展了cookie的4K限制2、localStorage会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的&nbsp;&nbsp;&nbsp;&nbsp;localStorage的局限1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换3、localStorage在浏览器的隐私模式下面是不可读取的4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡5、localStorage不能被爬虫抓取到 3、保存数据localStorage.setItem(key,value)之localStorage的方法具体应用在登录界面，使用axios向后端发送用户填写的用户名密码等信息，获取后端返货的数据。在这里使用localStorage来保存获取的数据，提供后续使用。通常需要保存的是后端设置的 token。 关于token可以学习:cookie、session、token三者差异详解 如下登录页面中我们点击登录如果成功我们希望跳转主页，并且把个人信息展示在主页，如果没有获取token是没有办法获取后端存储的数据的。通俗一点说就是获得token通行证就过不了这个关。 123456&lt;!-- 登录按钮绑定点击事件触发dologin函数方法 --&gt; &lt;el-button type=\"primary\" class=\"my-login\" @click=\"dologin\"&gt;登录&lt;/el-button&gt; 12345678910111213141516171819202122232425262728293031323334&lt;script&gt;export default &#123; name: 'Home', data () &#123; return &#123; user: &#123; username: '', email: '', password: '' &#125;, activeName: 'first' &#125; &#125;, methods: &#123; /* 这里是切换用户名/邮箱登录 */ handleClick (tab, event) &#123; console.log(tab, event) &#125;, /* 登录方法 */ dologin () &#123; var vm = this vm.axios.post('/v1/login', vm.user) .then(function (response) &#123; window.localStorage.setItem('token', response.data.token) vm.$router.push('/home') &#125;).catch(function (response) &#123; if (vm.activeName === 'first') &#123; vm.$message.error('用户名或者密码错误') &#125; else &#123; vm.$message.error('邮箱或者密码错误') &#125; &#125;) &#125; &#125;&#125; 123456789/* 由于不是所有浏览器都支持localStorage对象（ie8以下就不支持）， 如果需要兼容低版本的，需要判断浏览器是否存在这个对象属性，存在才可以使用*/ if (window.localStorage) &#123; var storage = window.localStorage storage.xiaomi = 'xiaomi' &#125; else &#123; alert('浏览器不支持localstorage') return false &#125; 4、读取数据localStorage.getItem(key)之localStorage的方法具体应用在上面代码中我们已经通过 window.localStorage.setItem(&#39;token&#39;, response.data.token) 将token保存在localStorage中.在home主页我们就可以通过使用这个token来获取信息展示在页面上了。 123456789101112&lt;!--给头像绑定js数据userInfo.imgURL 以下代码均为提取双向绑定了数据的代码，其他代码不展示--&gt;&lt;img :src=\"userInfo.imgURL\" style=\"width:40px; height:40px; border-radius:40px;\"/&gt;&lt;!--给表格的各行各单元格绑定数据 --&gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; getShortTime(scope.row.createAt) &#125;&#125;&lt;/template&gt; &lt;template slot-scope=\"scope\"&gt;&#123;&#123; getShortName(scope.row.name) &#125;&#125;&lt;/template&gt; &lt;template v-if=\"!scope.row.isDir\" slot-scope=\"scope\"&gt;&#123;&#123; getShortSize(scope.row.size) &#125;&#125;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;script&gt;export default &#123; name: 'Home', data () &#123; return &#123; isfit: true,//是否是文件夹？ userInfo: &#123; //用户个人信息userTnfo 'id': '', 'username': '', 'email': '', 'phone': '', 'isAdmin': false, 'permit': '', 'imgURL': '', 'aliPlay': '', 'capacity': '', 'use': 0, 'root': '' &#125;, input5: '', select: '', tableData3: [ //用户存储文件 &#123; 'id': '', 'label': '', 'download': 0, 'visit': 0, 'remark': '', 'name': '', 'size': 0, 'type': '', 'isDir': false, 'createAt': '', 'updateAt': '', 'belong': '', 'uri': '', 'kodeID': '', 'parentID': '', 'share': false &#125; ], multipleSelection: [] &#125; &#125;, mounted () &#123; var vm = this vm.getusermassage() //挂载时获取用户个人信息 vm.getfiles()//挂载时获取用户存储文件 &#125;, methods: &#123; getShortTime (time) &#123; &#125;, getShortName (name) &#123; &#125;, getShortSize (size) &#123; &#125;, //获取用户个人信息方法 getusermassage () &#123; var config = &#123; headers: &#123; 'Authorization': window.localStorage.getItem('token') &#125; &#125; var vm = this vm.axios.get('/v1/account/profile', config) .then(function (response) &#123; vm.userInfo = response.data &#125;) .catch(function (response) &#123; &#125;) &#125;, /* 获取用户个人存储文件方法*/ getfiles () &#123; //定义请求头headers var config = &#123; headers: &#123; 'Authorization': window.localStorage.getItem('token') &#125; &#125; var vm = this vm.axios.get('/v1/account/storage/files', config) .then(function (response) &#123; vm.tableData3 = response.data &#125;) .catch(function (response) &#123; &#125;) &#125; &#125;&#125;&lt;/script&gt; 在上面的代码中，我们使用window.localStorage.getItem(&#39;token&#39;)来读取信息获取token值，使用get方法传递给后端，后端验证通过将用户的信息反馈回来，前端才可以把获得的信息绑定给前端展示。 注意到我们使用在如下代码，将读取的数据赋值给config再使用axios传递给后端， 1234567//定义请求头headers var config = &#123; headers: &#123; &apos;Authorization&apos;: window.localStorage.getItem(&apos;token&apos;) &#125; &#125; vm.axios.get(&apos;/v1/account/storage/files&apos;, config) 请求头headers学习: Google之Postman小工具 这里是谷歌浏览器的Postman，其他浏览器请学习相应的浏览器工具请求头headers学习: HTTP学习,要知道它是如何工作的，要弄懂，可以先去学些http协议。 5、删除单个数据localStorage.removeItem(key)之localStorage的方法具体应用6、删除所有数据localStorage.clear()之localStorage的方法具体应用7、得到某个索引的key值localStorage.key(index)之localStorage的方法具体应用四、vuex管理localStorage本地存储的数据通过第三章的学习，我们发现会有很多地方使用到localStorage存储的数据，我们会在许多地方使用到它的方法，这使得我们的代码复杂化，臃肿了很多，本章将学习使用vuex管理localStorage存储的状态值，简化代码，事半功倍。","tags":[]},{"title":"vue【1】--[ slot 组件内容分发]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-slot 插槽内容分发/","text":"一、什么是 内容分发？内容分发：把父组件的内容 与 子组件自己的模板混合起来使用，这样的过程称为内容的分发 。 也常常被叫作 slot ，也就是插槽。使用特殊的 &lt;slot&gt; 元素作为原始内容的插槽。 Vue中的插槽 &lt;slot&gt;。是一个空壳子，它显 示与否 以及 怎么显示 完全是由父组件来控制。不过，插槽显示的位置由子组件自身决定，slot 写在组件 template 的哪里，父组件传过来的模板将来就显示在哪里。 在写一些组件的时候，slot 能帮助我们做很多事情，也能让组件可复用性变得更为灵活。 vue.js 官网地址 二、slot 核心问题slot 源于Web Components 规范草案，也被称之为插槽，是组件的一块 HTML 模板。 而这块模板显示不显示，以及怎么显示由父组件来决定。 2.1 slot 最核心的两个问题就 显示不显示 怎么显示 2.2 非插槽模板 和 插槽模板任何一个组件，从模板种类的角度来分，共实都可分为 非插槽模板和 插槽模板。 12345678&lt;template&gt; &lt;li :class=\"[prefixCls + '-item-group']\"&gt; &lt;!-- 这里的 &lt;div&gt;&lt;/div&gt; 是 非插槽模板 --&gt; &lt;div :class=\"[prefixCls + '-item-group-title']\" :style=\"groupStyle\"&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;!-- 这里的 &lt;slot&gt;&lt;/slot&gt; 是 插槽模板 --&gt; &lt;ul&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/ul&gt; &lt;/li&gt;&lt;/template&gt; 非插槽模板： 指的是 HTML 模板（也就是 HTML 的一些元素，比如 div、span 等构成的），其 显与否及 怎么显示完全由 插件/子组件自身控制;插槽模板:（也就是 slot）是一个空壳子，它 显与否及 怎么显示完全是由 父组件 来控制。 不过，插槽显示的位置由 插件/子组件自身决定: slot 写在组件 template 的哪里，父组件传过来的模板将来就显示在哪里。 父组件中 引入 子组件，在父组件的 template 中使用子组件标签，在 子组件标签 中写入的内容替换 自组件中 slot 元素 位置。 三、Vue 的编译作用域父组件的内容是在父组件作用域编译，子组件的内容是在子组件作用域编译。而 Vue 的 slot 一般用在父组件向子组件分发内容，该内容的编译作用域名为父组件作用域。 3.1 Vue 的模板在渲染成 UI 之前是有一个编译过程slot 会涉及 Vue 的模板，而 Vue 的模板在渲染成 UI 之前是有一个编译过程的，也会存在模板编译作用域一说。理解清楚这部分内容，也更有助于我们理解 slot。 Vue 中的 template 编译成浏览器可识的过程会经过不少的过程。言外之意，最终在浏览器中呈现的并不是 &lt;template&gt;，而是会解析成标准的 HTML，然后将组件的标签替换为对应的 HTML 片段。 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;template id=\"myComponent\"&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;button @click=\"show\"&gt;Show Message&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;!-- 在 vue-cli 单页面中，通常是把 template 与其对应的 js 放置到 .vue文件中 --&gt;&lt;script&gt;Vue.component('my-component', &#123; template: '#myComponent', data () &#123; return &#123; message: '我是一个Vue组件!' &#125; &#125;, methods: &#123; show: function () &#123; alert(this.message) &#125; &#125;&#125;)let app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 在上面这段代码中，Vue 将会通过其自身的编译机制，将 &lt;my-component&gt; 编译成让浏览器可以识别的 HTML 代码。例通过 new Vue() 创建一个 Vue 的实例，并且将这个实例挂载到 div#app 的元素下（通过 el 挂载），然后把组件 &lt;my-component&gt; 编译成 HTML，最终渲染所需要的 UI 效果。 3.2 编译作用域模板编译的作用域，在Vue中，组件是有一个作用域的：组件模板 &lt;template&gt; 内的就是组件作用域，而其之外的就不是组件的作用域了，比如上面的示例，my-component 组件的作用域就是下面这部分。 123456&lt;template id=&quot;myComponent&quot;&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;show&quot;&gt;Show Message&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 组件的模板是在其作用域内编译的，因此组件选项对象中的 data 也是在组件模板中使用的。简单来说就是：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。 如果我们在前面的示例中的 Vue 实例的组件 my-component 中同时追加一个 display 属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id=\"app\"&gt; &lt;!-- 这里由 vue 实例操作 --&gt; &lt;my-component v-show=\"display\"&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;template id=\"myComponent\"&gt; &lt;!-- 这里由 Vue.component('my-component', &#123; 创建的子组件来控制的 --&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;button @click=\"show\"&gt;Show Message&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;Vue.component('my-component', &#123; template: '#myComponent', // 也就是说下面的 data 选项， methods 选项都是对 template 中的模板操作的，不能操作其他地方 data () &#123; return &#123; message: '我是一个Vue组件!', display: false &#125; &#125;, methods: &#123; show: function () &#123; alert(this.message) &#125; &#125;&#125;)let app = new Vue(&#123; el: '#app', // vue 实例的选项是操作 template 之外的模板的 data () &#123; return &#123; display:true &#125; &#125;&#125;)&lt;/script&gt;&lt;!-- 此时 display 是来源于 Vue 实例，还是 `my-component`组件呢？答案：display 来源于 Vue 实例。也就是现在的 true 。也就是说，在 Vue 中组件的作用域是独立的 --&gt; 通俗地讲，在子组件中定义的数据，只能用在子组件的模板。在 父组件中定义的数据，只能用在 父组件的模板。当然了如果需要父子组件的值相互引用，就需要使用到的传值了，props 或者是 $emit 等等方法。 四、slot 的使用4.1 父组件没有给 子组件标签插入内容（子组件中的 slot 没有被替换）123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;alert&gt;&lt;/alert&gt; &lt;!-- 这里使用了模板，但是没有写内容，那么模板中的 slot 不会被替换掉 --&gt;&lt;/div&gt;&lt;template id=\"alert\"&gt; &lt;div class=\"alert info\"&gt; &lt;button class=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;slot&gt;如果父组件有些内容，我将会被替换掉&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;Vue.component('alert', &#123; template: '#alert'&#125;)let app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 上面的组件真实渲染的结果是 123456&lt;div id=\"app\"&gt; &lt;div class=\"alert info\"&gt; &lt;button class=\"close\"&gt;&amp;times;&lt;/button&gt; 如果父组件有些内容，我将会被替换掉 &lt;/div&gt;&lt;/div&gt; 上面的代码在 alert 组件的模板中指定了一个 &lt;slot&gt; 元素，并且在该元素中放置了一个默认内容 如果父组件有些内容，我将会被替换掉”。 在调用 alert 组件时，并没有向该组件分发任何内容，这个时候运行的结果如下： 父组件没有写入内容，那么 slot 的内容没有被替换。如果父组件未向模板中分发内容（插入内容），则显示插槽中默认内容（前提是slot中设置了默认内容）。 4.2 父组件 给 子组件标签插入内容（子组件中的 slot 的内容将被替换）123456789101112131415161718192021222324&lt;!-- 父组件 --&gt;&lt;div id=\"app\"&gt; &lt;alert&gt; &lt;p&gt;您好啊！&lt;/p&gt; &lt;/alert&gt;&lt;/div&gt;&lt;!-- 子组件 --&gt;&lt;template id=\"alert\"&gt; &lt;div class=\"alert info\"&gt; &lt;button class=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;slot&gt;如果父组件有些内容，我将会被替换掉&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;Vue.component('alert', &#123; template: '#alert'&#125;)let app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 上面的组件， 真实渲染得到的结果是 1234567&lt;div id=\"app\"&gt; &lt;div class=\"alert info\"&gt; &lt;button class=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;p&gt;您好啊！&lt;/p&gt; &lt;/div&gt; &lt;!-- 这里使用了模板，但是没有写内容，那么模板中的 slot 不会被替换掉 --&gt; &lt;/div&gt; 4.3 子组件没有设置 slot 插槽（父组件插入内容不成功）模板中未设置插槽，父组件依旧向其分发了内容，但最终任何分发的内容都不会显示????值得是子组件放在父组件的内容没有了？？？？下面的 &lt;button class=&quot;close&quot;&gt;&amp;times;&lt;/button&gt;也没有么？需要验证一下的。 12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;alert&gt; &lt;p&gt;您好啊&lt;/p&gt; &lt;/alert&gt;&lt;/div&gt;&lt;template id=\"alert\"&gt; &lt;div class=\"alert info\"&gt; &lt;button class=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;!-- 子组件没有插槽 slot --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;Vue.component('alert', &#123; template: '#alert'&#125;)let app = new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 4.4 slot 结合 props ，v-for 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=\"app\"&gt; &lt;alert v-for=\"statu in status\" :status=statu&gt; &lt;!-- :status=statu 这里使用了 props 给子组件传值 --&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; statu &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/alert&gt;&lt;/div&gt;&lt;template id=\"alert\"&gt; &lt;!-- :class=\"[alertStatus]\" 这里是使用的是 class 绑定的数组语法 --&gt; &lt;div class=\"alert\" :class=\"[alertStatus]\" v-show=\"isShow\"&gt; &lt;button class=\"close\" @click=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;slot&gt;This is alert box!&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;Vue.component('alert', &#123; template: '#alert', props: ['status'], data () &#123; return &#123; isShow: true &#125; &#125;, computed: &#123; alertStatus: function () &#123; return this.status &#125; &#125;, methods: &#123; close: function () &#123; this.isShow = !this.isShow &#125; &#125;&#125;)let app = new Vue(&#123; el: '#app', data () &#123; return &#123; status: ['info', 'success', 'danger', 'warning'] &#125; &#125;&#125;)&lt;/script&gt; 上面的代码编译结果是 12345678910&lt;div id=\"app\"&gt; &lt;alert v-for=\"statu in status\" :status=statu&gt; &lt;div class=\"alert\" :class=\"[alertStatus]\" v-show=\"isShow\"&gt; &lt;button class=\"close\" @click=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; statu &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;/alert&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;div class=\"alert\" :class=\"info\" v-show=\"isShow\"&gt; &lt;button class=\"close\" @click=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;div&gt; &lt;h2&gt;info&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"alert\" :class=\"success\" v-show=\"isShow\"&gt; &lt;button class=\"close\" @click=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;div&gt; &lt;h2&gt;success&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"alert\" :class=\"danger\" v-show=\"isShow\"&gt; &lt;button class=\"close\" @click=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;div&gt; &lt;h2&gt;danger&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"alert\" :class=\"warning\" v-show=\"isShow\"&gt; &lt;button class=\"close\" @click=\"close\"&gt;&amp;times;&lt;/button&gt; &lt;div&gt; &lt;h2&gt;warning&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 五、slot 分类5.1 单个插槽在介绍 slot 大致使用方法的一节中，已经知道了，如果子组件 template 中没有包含任何一个 &lt;slot&gt;时，就算父组件分发再多的内容也将会被丢弃。只有子组件模板只要有一个没有属性的 slot（因为在模板中可以有多个带属性的 slot，后面的内容会介绍），父组件传入的整个内容片段将插入到slot 所在的 DOM 位置，并将替换掉 slot 本身。 最初在 &lt;slot&gt; 中的任何内容都被视为备用内容（也可以在最初的 &lt;slot&gt; 中不放置任何默认内容）。备用内容在子组件的作用域内编译，并且只有在宿主元素（父组件没有分发任何内容）为空，且没有要插入的内容时才显示备用内容。 在前面第 四 章使用的都是单个插槽。 5.2 具名插槽（多个插槽使用）&lt;slot&gt; 可以用一个特殊的属性 name 来进一步配置父组件如何分发内容。多个插槽可以有不同的名字。具名插槽将匹配内容片段中有对应 slot 特性的元素。 仍然可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。 对于一个modal组件，其主体结构包括了 modal-header、 modal-body 和 modal-footer（当然，很多时候可能不会同时出现，根据需要选择）。那么在定义 modal 组件的 template 时，可以使用三个 slot，它们的 name 属性分别命名为 header 、body 和 footer。 12345678910111213141516171819202122&lt;!-- 父组件 --&gt;&lt;div id=\"app\"&gt; &lt;modal v-show=\"toggleModal\" @click=\"closeModal\"&gt; &lt;!-- slot=\"header\" 插入 子组件 name='header' 插槽中 --&gt; &lt;div class=\"modal-header\" slot=\"header\"&gt; &lt;div class=\"close rotate\" @click=\"closeModal\"&gt; &lt;i class=\"fa-times fa\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;h3 class=\"modal-title\"&gt;Modal Header&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"modal-body\" slot=\"body\"&gt; &lt;h3&gt;Modal Body&lt;/h3&gt; &lt;p&gt;Modal body conent...&lt;/p&gt; &lt;/div&gt; &lt;div class=\"modal-footer\" slot=\"footer\"&gt; &lt;button class=\"btn\" @click=\"closeModal\"&gt;关闭&lt;/button&gt; &lt;/div&gt; &lt;/modal&gt; &lt;button class=\"btn btn-open\" @click=\"showModal\"&gt;Show Modal&lt;/button&gt;&lt;/div&gt; 1234567891011&lt;!-- 子组件 --&gt;&lt;template id=\"modal\"&gt; &lt;div class=\"modal-backdrop\"&gt; &lt;div class=\"modal\" @click.stop&gt; &lt;!-- 下面三个是具名插槽，父组件中对用的 slot='' 属性与 子组件的 name 属性对应，才会替换--&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;slot name=\"body\"&gt;&lt;/slot&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 5.3 作用域插槽5.3.1（ 在父组件使用 &lt;template slot-scope=&quot;props&quot;&gt;）这里的 props 是子组件 传来的数据对象 作用域插槽是一种特殊类型的插槽，用作一个（能被传递数据的）可重用模板，来代替已经渲染好的元素。 在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样： 在父级中，具有特殊特性 slot-scope 的 &lt;template&gt; 元素必须存在，表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象： 12345678910111213&lt;!-- 父组件 --&gt;&lt;div class=\"parent\"&gt; &lt;child&gt; &lt;!-- 在父组件使用 子组件标签的时候，插入的内容和用一个 &lt;template slot-scope=\"props\"&gt; 容器 --&gt; &lt;!-- `slot-scope` 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 prop 对象： props 只是一个名称，数据就是 子组件中 slot 上的内容 --&gt; &lt;template slot-scope=\"props\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;!-- 这里的props.text 就是 hello from child --&gt; &lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt; 1234&lt;!-- 子组件 --&gt;&lt;div class=\"child\"&gt; &lt;slot text=\"hello from child\"&gt;&lt;/slot&gt;&lt;/div&gt; 编译后得到如下 123456&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt; &lt;span&gt;hello from parent&lt;/span&gt; &lt;span&gt;hello from child&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 5.3.2 在 2.5.0+，slot-scope 能被用在任意元素或组件中而不再局限于 &lt;template&gt;。作用域插槽更典型的用例是在 列表组件中，允许使用者自定义如何渲染列表的每一项： 12345&lt;!-- 父组件 --&gt;&lt;my-awesome-list :items=\"items\"&gt; &lt;!-- :items=\"items\" 传值给 子组件--&gt; &lt;!-- 作用域插槽也可以是具名的 slot=\"item\" 与 name=\"item\" 具名配对--&gt; &lt;li slot=\"item\" slot-scope=\"props\" class=\"my-fancy-item\"&gt; &#123;&#123; props.text &#125;&#125; &lt;/li&gt;&lt;/my-awesome-list&gt; 1234567891011121314151617&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;!-- 这里写入备用内容 --&gt; &lt;slot name=\"item\" v-for=\"item in items\" :text=\"item.text\"&gt;&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; data()&#123; return&#123; // &#125; &#125;, props:['items']&lt;/script&gt; 编译后 1234&lt;ul&gt; &lt;!-- 这里写入备用内容 --&gt; &lt;li v-for=\"item in items\" class=\"my-fancy-item\"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 5.3.3 slot-scope 可以 ES2015/ES6 解构slot-scope 的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。这意味着在受支持的环境 ( 单文件组件 或 现代浏览器) 中，您还可以在表达式中使用 ES2015/ES6 解构： 123&lt;child&gt; &lt;span slot-scope=\"&#123; text &#125;\"&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;&lt;/child&gt;","tags":[]},{"title":"vue.js--[ 父子组件传值，非父子组件传值，兄弟姐妹传值]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/{ vue.js 框架 }-传值/","text":"一、前言vue.js 框架中组件之间的传值方法。 1.prop 属性 父传【值】给子组件 在父组件的子组件标签中 设置 prop 属性，名称可以不是 props2.emit 事件 子传【值】给父组件3.eventBus 各个组件之间传【值】【方法】调用 （订阅模式 $emit 负责发布消息， $on 负责消费消息）4.url 路由 路由传值，页面传值5.Storage 缓存传值6.vuex 状态管理器 共同使用的数据保存在 store 中7.this.$root.xxx 获取根组件的实例方法属性 （所有父组件） this.$parent.xxx 获取 父 组件的实例方法属性 传【值】【方法】给子组件 （直接父组件） this.$ref.refName.xxx 获取 孙子 组件的实例方法属性 传【值】【方法】给父组件 （所有子组件+孙子组件） this.$children.xxx 获取 子 组件的实例方法属性 传【值】【方法】给父组件 （直接子组件） 不保证顺序，不是响应式的8.slot 插槽传值 在子组件中设置 prop 属性，名称一定是 props ，它代表的是 传了一个 slot 插槽 文本对象，可以获取对应值 二、prop（父-子）2.1 父组件传递 prop 各种数据类型的传递（数字，字符串，布尔值，对象，数组）其中，对象与数组是特殊的。注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。 所以不要试图在子组件去修改父组件传递过来的 prop 属性值。 如果传递的参数很多，推荐使用 json 数组 {} 的形式？？？？？比如说例子的 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 父组件 --&gt;&lt;!-- 不管传递的是静态值还是动态值，都要使用 ：绑定 ！！！！！！！！！！！！！！！！！！！！！！！！！！！！--&gt;&lt;template&gt; &lt;div class=\"home\"&gt; &lt;blog-post v-bind:likes=\"42\"&gt;&lt;/blog-post&gt; &lt;blog-post :likes=\"42\"&gt;&lt;/blog-post&gt; &lt;!-- 省略写法！！！！！！！！！！！！！！！！！！！！！！！！！！--&gt; &lt;blog-post v-bind:likes=\"post.likes\"&gt;&lt;/blog-post&gt; &lt;!-- 用一个变量进行动态赋值。--&gt; &lt;blog-post is-published&gt;&lt;/blog-post&gt; &lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt; &lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt; &lt;blog-post v-bind:is-published=\"false\"&gt;&lt;/blog-post&gt;&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。 就是说这里传递过去的是 false 布尔值--&gt; &lt;blog-post v-bind:is-published=\"post.isPublished\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt; &lt;blog-post v-bind:comment-ids=\"[234, 266, 273]\"&gt;&lt;/blog-post&gt; &lt;blog-post v-bind:comment-ids=\"post.commentIds\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt; &lt;blog-post v-bind=\"postobj\"&gt;&lt;/blog-post&gt;&lt;!-- 传递的是对象的话，这样来传递 --&gt; &lt;blog-post v-bind:id=\"post.id\" v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Children from '@/components/commons/children'export default &#123; name: 'Home', components: &#123; 'blog-post': Children// 当然标签其实是不能重复的，html中的写法也是错误的，但是这里就不修正了。文章太长。 &#125;, data () &#123; return &#123; post:&#123; likes:42, isPublished:false, commentIds:[234, 266, 273] &#125;, postobj:&#123; id: 1, title: 'My Journey with Vue' &#125; &#125; &#125;&#125;&lt;/script&gt; 2.2 子组件接受 prop（可以设置接受的要求）如果不考虑数据类型，直接 props:[&quot;number&quot;,&quot;string&quot;] 就可以了,中括号包裹，多个值使用，分隔。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=\"children\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'Children', // ① 简单接收值，数组 props:[\"likes\",\"is-published\"]/* 如果不考虑数据类型，直接 数组接收就可以了,中括号包裹，多个值使用，分隔。 数组中的字符串就是父组件中绑定 ： 后面的名称 */ /* 子组件通过 props 获取父组件传递过来的值。props 中可以定义能接收的数据类型，如果不符合会报错。 */ /* 这样写的话冒号前面是父组件中定义的名称，后面是数据类型，或者是检查函数 */ // ② 复杂检查接收值，对象 props: &#123; // 基础的类型检查 (`null` 匹配任何类型) likes: Number, // 多个可能的类型 likes: [String, Number], // 必填的字符串 likes: &#123; type: String, required: true &#125;, // 带有默认值的数字 likes: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 postobj: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; /* 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： props: ['initialCounter'], data() &#123; return &#123; counter: this.initialCounter &#125; &#125; */ /* 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值： props: ['size'], computed: &#123; normalizedSize: function () &#123; return this.size.trim().toLowerCase() &#125; &#125;, */&#125;&lt;/script&gt; 2.3 假如接收的参数 是动态的，比如 input输入的内容 v-model的形式传递的参数名称 支持驼峰命名 12345678910111213141516&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div class=\"parent \"&gt; &lt;input type=\"text\" v-model=\"inputText\"&gt; &lt;children :input-val='inputText'&gt;&lt;/children&gt; &lt;!-- :input-val 这里只能用连字符号，不能驼峰 那就不要连字都不要驼峰不就别这么麻烦了 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import children f rom 'components/children' export default&#123; components:&#123; Children &#125; &#125; 12345678910111213&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=\"children \"&gt; &#123;&#123;inputVal&#125;&#125; 显示这里用驼峰 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props:&#123; 'input-val':[String] &#125; &#125;&lt;/script&gt; 2.4 父子组件传值，数据是异步请求，有可能数据渲染时报错原因：异步请求时，数据还没有获取到但是此时已经渲染节点了解决方案：可以在 父组件需要传递数据的节点加上 v-if = false，异步请求获取数据后，v-if = true ？？？？？？？？看不动什么意思？？？ 2.5 .sync 异步（实现 prop 传值 父子组件的 MVVM ：但是这样并不好，所以不建议使用）不要试图在子组件中修改从父组件中获取的 prop 值，这样会报错的。可以使用下面的获取实例方法的办法来替代 prop 传值。 this.$root.xxx 获取根组件的实例方法属性 （所有父组件） this.$parent.xxx 获取 父 组件的实例方法属性 传【值】【方法】给子组件 （直接父组件） this.$ref.refName.xxx 获取 孙子 组件的实例方法属性 传【值】【方法】给父组件 （所有子组件+孙子组件） this.$children.xxx 获取 子 组件的实例方法属性 传【值】【方法】给父组件 （直接子组件） 三、$emit （子 =&gt; 父）（在父组件自定义事件 触发传值）这里使用的是 v-on 自定义事件（省略写法 @）当然想在组件根元素上使用原生事件，可以使用 .native 修饰符。？？？？不懂 另外子组件调用父组件事件则可以使用 $parent 或者 $root 3.1 例子一12345678910111213141516171819202122&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div class=\"parent\"&gt; &lt;children @child-event='parentEvent'&gt;&lt;/children&gt;&lt;!-- 在这里传的值不需要 显性的写出来！！！！！！！！！！！！！！！ &lt;!-- child-event 这里是子组件 methods 中定义的方法名（要一致）， 就是监听子组件数据变化执行的父组件函数的。（parentEvent 这里是触发的父组件的函数方法） 这里只能用连字符号，不能驼峰。那就不要连字都不要驼峰不就别这么麻烦了 --&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import children f rom 'components/children' export default&#123; components:&#123; Children &#125;, methods:&#123; parentEvent(data)&#123; /* data 就是子组件传递过来的数据 */ console.log(data) &#125; &#125; &#125; 123456789101112131415&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=\"children \"&gt; &lt;button @click=\"toParent\"&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; methods:&#123; toParent()&#123; this.$emit('child-event',\"我是 子组件 传给 父组件 的内容\") &#125; &#125; &#125;&lt;/script&gt; 3.2 例子二123456789101112131415161718192021222324252627&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;div class=\"parent\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;!--父组件通过 v-on 在子组件使用的地方监听子组件触发的事件： increment 是子组件中的事件，意思就是在子组件中 increment 执行的时候，执行父组件中的 incrementTotal 方法 --&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import children f rom 'components/children' export default&#123; data()&#123; return&#123; total: 0 &#125; &#125;, components:&#123; Children &#125;, methods:&#123; incrementTotal(arg) &#123; this.total += 1 &#125; &#125; &#125; 1234567891011121314151617181920212223&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;div class=\"children \"&gt; &lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; counter: 0 &#125; &#125;, methods:&#123; increment() &#123; this.counter += 1 this.$emit('increment')//子组件中使用 $emit() 主动抛出事件 //传递参数 //this.$emit('increment',arg) &#125; &#125; &#125;&lt;/script&gt; 四、路由传值 url 带参数 【适用于所有组件之间】3.1 &lt;router-link&gt; 标签传参（写在 html 中）123456789101112131415161718192021&lt;!-- A 组件 --&gt;&lt;template&gt; &lt;div class=\"app_page\"&gt; &lt;h1&gt;从这个路由传参到别的路由&lt;/h1&gt; &lt;router-link :to=\"&#123; name:'/conponentsB',params: &#123; id: status ,id2: status3&#125;,query: &#123; queryId: status2 &#125;&#125;\" &gt; router-link 跳转 /conponentsB &lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app_page', data () &#123; return &#123; status:110, status2:120, status3:119 &#125; &#125;,&#125;&lt;/script&gt; 123456789101112&lt;!-- B 组件 --&gt;&lt;!-- 获取路由上面的参数，用的是 $route，后面没有 r。 --&gt;&lt;template&gt; &lt;div class=\"router1\"&gt; &lt;h1&gt;接收参数的路由&lt;/h1&gt; &lt;h1&gt; params.id：&#123;&#123; $route.params &#125;&#125;&lt;/h1&gt; &lt;h1&gt; query.status:&#123;&#123; $route.query.queryId &#125;&#125;&lt;/h1&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 3.2 编程式传参（写在 JS 中）1234// A 组件this.$router.push(&#123; path: '/conponentsB', query: &#123; orderId: 123 &#125; &#125;)// 跳转到Bthis.$router.push(&#123; name:'/conponentsB',params: &#123; id: status ,id2: status3&#125;,query: &#123; orderId: status2 &#125;&#125;); // 跳转到B//编程跳转写在一个函数里面，通过 click 等方法来触发 123//B 组件// 获取路由上面的参数，用的是 $route，后面没有 r。this.$route.query.orderId 编程式导航，可以用来做判断跳转，比如是否授权，是否登录，等等状态，这种办法会比较好，并且是写在 js 里面，而不是 html 里面。 3.3 params 与 query 传参3.3.1 params、query 是什么params：/conponentsB/:id ，/conponentsB/123，/conponentsB/789 ,这里的 id 叫做 paramsquery：/conponentsB?id=123 ,/conponentsB?id=456 ,这里的 id 叫做 query。 3.3.2 router.js 路由设置文件设置问题123456789101112131415161718192021222324252627//router.jslimport Vue from' vue'import Router from' vue router'Vue. use(Router);export default new Router ( &#123; mode: 'history', routes: [ &#123; path:' /', redirect:' /app', &#125;, &#123; path:'/app', name:' app', component: resolve =&gt; System import('./page/app page') &#125;, &#123; path:'/app/conponentsA',//将要从这个路由跳转过去 name:'conponentsA',//这里是路由的名字，建议大家每个路由都加一个名字，这样跳转的时候比较方便 component: resolve =&gt; System import('./page/app page') &#125; &#123; path:'/app/conponentsB/:id' , //接收参数的路由，使用params传参要加参数名，这里的 id 就是参数名 // 如果使用 params 传参，这里必须先这是好 :id 否则在 html 中写了传参也不会正确 name:'conponentsB', component: resolve =&gt; System imort( '. /page/app_ level/conponentsB' )//这种写法是路由懒加载的写法 &#125; 3.3.3 params、query 传参区别 当你使用 params 方法传参的时候，要在路由后面加参数名，并且传参的时候，参数名要跟路由后面设置的参数名对应。使用query方法，就没有这种限制，直接在跳转里面用就可以。 params 是路由的一部分,必须要有。params 一旦设置在路由，params 就是路由的一部分，如果这个路由有 params 传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。query 是拼接在 url 后面的参数，没有也没关系。 query 不设置也可以传参，但是 params 不设置的时候，刷新页面或者返回参数会丢失，query 并不会出现这种情况， 123&lt;!-- 跳转/conponentsB/:id --&gt;&lt;router-link :to=\"&#123; name:'conponentsB',params: &#123; id: status&#125;&#125;\" &gt;正确，路由中写的是 id 不是 id2，要一致&lt;/router-link&gt;&lt;router-link :to=\"&#123; name:'conponentsB',params: &#123; id2: status&#125;&#125;\"&gt;错误，路由中写的是 id 不是 id2，要一致&lt;/router-link&gt; 1234567891011&#123; path:'/app/conponentsA', name:'conponentsA', component: resolve =&gt; System import('./page/app page')&#125;&#123; path:'/app/conponentsB/:id' , //接收参数的路由，使用params传参要加参数名，这里的 id 就是参数名 // 如果使用 params 传参，这里必须先这是好 :id 否则在 html 中写了传参也不会正确 name:'conponentsB', component: resolve =&gt; System imort( '. /page/app_ level/conponentsB' )&#125; 五、Storage 缓存传值 【适用于所有组件之间】Storage，学习 Session Storage（程序退出销毁） 和 Local Storage（长期保存） 的区别。 123// A 组件const orderData = &#123; 'orderId': 123, 'price': 88 &#125;sessionStorage.setItem('缓存名称', JSON.stringify(orderData)) // 保存值 12// B 组件onst dataB = JSON.parse(sessionStorage.getItem('缓存名称')) // 取值 六、eventBus.js （貌似这个办法并不 ok？？？？）兄弟姐妹 &amp; 父子 通通可用（小项目少页面用 事件巴士 eventBus，大项目多页面使用 vuex） 目前中央通信是解决兄弟间通信，祖父祖孙间通信的最佳方法，当然兄弟姐妹都可以的话，肯定不仅限于此，也可以解决父组件子组件间的相互通信的啦。 6.1 例子一（订阅模式 $emit 负责发布消息， $on 负责消费消息） 创建一个 eventBus.js 文件来 定义一个新的vue实例专门用于传递数据，并导出 123/* eventBus.js 的内容如下即可，网上有很复杂的，*/import Vue from 'vue'export default new Vue() 12// 也可以在 main.js 中写Vue.prototype.$eventBus = new Vue() 12//还看到有这样在 main.js 使用的，看不懂window.eventBus = new Vue() 发送事件的组件：组件 A 使用 eventBus.js 给组件 B 传值 123456789101112131415161718&lt;!-- componentA.vue --&gt;&lt;template&gt; &lt;div class=\"componenA\"&gt; &lt;!-- 组牛 A 点击按钮往组件 B 传递数据 --&gt; &lt;button @click=\"emitToB\"&gt;按钮点钮传递数据给兄弟组件B&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入 eventBus,其实就是引入另一个 vue 实例import eventBus from 'common/js/eventBus.js'// 两个组件都要引入这个 新的 eventBus 实例export default&#123; methods: &#123; emitToB()&#123; eventBus.$emit('eventFromA', '我是 组件A 传递给 组件B 的数据')//定义方法名，以及传输的数据 //定义传递的方法名和传输内容，点击事件 methods 中或 钩子函数触发 eventBus.$emit 事件 &#125; &#125;&#125;&lt;/script&gt; 组件内监听事件：enentBus 是一个另一个新的 Vue 实例，区分两个 this 所代表得 vue 实例 123456789101112131415161718192021222324252627282930&lt;!-- componentB.vue --&gt;&lt;template&gt; &lt;div class=\"componenB\"&gt; &lt;!-- 接收组件 A 传来的数据 --&gt; &#123;&#123;title&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//引入 eventBus,其实就是引入另一个 vue 实例import eventBus from 'common/js/eventBus.js' // 两个组件都要引入这个 新的 eventBus 实例export default&#123; data()&#123; return&#123; title:'' &#125; &#125;, mounted()&#123; this.getEventData() &#125; methods: &#123; getEventData()&#123; const that = this // 这个 this 是 vue 实例的 this 用 that 保存，避免作用域的改变导致找不到原值 //避免与 eventBus 实例 冲突 eventBus.$on(\"eventFromA\", function(val) &#123; that.title = val //this.title = val 这里的 this 指的是 eventBus 的 this &#125;) &#125; &#125;&#125;&lt;/script&gt; 6.2 eventBus 传值遇到的问题6.2.1 如果使用 eventBus 传值，并且路由有变化就会发现自己获取到的值无法渲染到页面上（eventBus传值问题，可以控制台打印，但是无法渲染）1234567891011121314151617181920212223242526//A.vue 传值//编辑商品 beforeCreate() &#123; console.log(\"A beforeCreate\"); &#125;, created() &#123; console.log(\"A created\"); &#125;, beforeMount() &#123; console.log(\"A beforeMount\"); &#125;, mounted() &#123; console.log(\"A mounted\"); &#125;, beforeDestroy() &#123; console.log(\"A beforeDestroy\"); &#125;, destroyed() &#123; console.log(\"A destroyed\"); &#125;, methods: &#123; toUserPage() &#123; this.$router.push(\"/users\");// 注意到这里的路由发生变化，就是跳转到 B 页面去了！！！！！！！！！！！非常的重要 eventBus.$emit(\"postData\", \"dataFromA-&gt;B\");//这里 dataFromA-&gt;B 是传过去的数据 &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;div&gt;&#123;&#123;eventBusData&#125;&#125;&lt;/div&gt;//B.vue 接受值 data()&#123; return&#123; eventBusData:'这里是原来 B 原来的值，我看能不能传过来了' &#125; &#125; beforeCreate() &#123; console.log(\"B beforeCreate\"); &#125;, created() &#123; console.log(\"B created\"); this.getDataFromA() &#125;, beforeMount() &#123; console.log(\"B beforeMount\"); &#125;, mounted() &#123; console.log(\"B mounted\"); &#125;, beforeDestroy() &#123; console.log(\"B beforeDestroy\"); &#125;, destroyed() &#123; console.log(\"B destroyed\"); &#125;, methods: &#123; getDataFromA() &#123; var that = this; eventBus.$on(\"postData\", val =&gt; &#123; that.eventBusData = val; console.log(that.eventBusData, \"这个 this.eventBusData 是函数里的\"); // 会发现这个都没有在控制台打印出来，根本不执行啊 console.log(val, \"这个 val 是函数里的\"); // 这个也不执行啊 &#125;); console.log(that.eventBusData, \"这个 this.eventBusData 是函数外面的\"); // 这个可以执行， 但是值是 B 页面的 data 值 &#125; &#125; 上面我们可以看出，我们的值是传到了需要接受值的页面了没有错，确实是可以 console.log 出来了，但是呢却又发现自己没法使用传过来的值。值是传成功了，console.log 打印出来也是正确的，只是在 eventBus.$on 监听里面可以用，外面就无法使用了，更不要说是在 mounted 与 created 中 log 了。错误了，无法渲染到页面上，页面获取不到数据。 123456789101112131415// 得到的结果是// A beforeCreate// A created// A beforeMount// A mounted// 在这里从 A 跳转到 B 页面// B beforeCreate// B created// 这里是原来 B 原来的值，我看能不能传过来了 这个 this.eventBusData 是函数外面的// B beforeMount// A beforeDestroy// A destroyed// B mounted// 页面渲染的是 这里是原来 B 原来的值，我看能不能传过来了,并不是我们传过来的值。不是我们希望的 错误原因如下：就是 vue 生命周期的问题在 A.vue 中的那两行代码，首先用 eventBus 传值，随后跳转路由，值是传过去了，但是路由的跳转使得页面重新渲染了一下，一夜回到解放前，值就没有了。因为vue-router在切换时，先加载新的组件，等新的组件渲染好但是还没挂在前，销毁旧的组件，然后再挂载组件。 解决办法：在组件销毁之前将 数据传递出去。在已經用到 vue-router 並且需要跨组件传值的情境，還是用 vuex 好。在这里就说一下方法好了。 1234567891011121314151617181920212223242526272829// A 组件修改如下 beforeCreate() &#123; console.log(\"A beforeCreate\"); &#125;, created() &#123; console.log(\"A created\"); &#125;, beforeMount() &#123; console.log(\"A beforeMount\"); &#125;, mounted() &#123; console.log(\"A mounted\"); &#125;, beforeDestroy() &#123; console.log(\"A beforeDestroy\"); eventBus.$emit(\"postData\", \"dataFromA-&gt;B\");// 在销毁之前将触发事件，将数据传递出去，但是这样是不是不好呀？z // 这样一来只要离开这个 页面组件， 就会触发传值，性能怎么样？ &#125;, destroyed() &#123; console.log(\"A destroyed\"); &#125;, components: &#123; // HelloWorld &#125;, methods: &#123; toUserPage() &#123; this.$router.push(\"/users\"); &#125; &#125; 123456789101112131415// 这样之后得到的结果// A beforeCreate// A created// A beforeMount// A mounted// B beforeCreate// B created// 这里是原来 B 原来的值，我看能不能传过来了 这个 this.eventBusData 是函数外面的// B beforeMount// A beforeDestroy// dataFromA-&gt;B 这个 this.eventBusData 是函数里的// dataFromA-&gt;B 这个 val 是函数里的// A destroyed// B mounted 问题：看上面的周期执行，不是先到 B created 之后 A 才会 destroyed 销毁么？为什么直接在 methods 里面触发就不行？？？传值就不成功呢？？？奇怪了呢？？？， 是因为原来就是因为 B 组件实在 mounted 才会渲染完成么？一定要在别的地方触发，那这样一来，页面传值一大堆，性能不是就受到影响了么？？？？好吧就不要用这个方式传值好了，太难了吧？？关键点： 现在穿的是一个字符串，如果要传的是列表中的一个数据，要对应起来的，用这个方法就传递不了对应的数据了呢？？？就是说这个方法不适用。 6.5 例子二(这个其实是 this.$root 的方法，不是 eventBus 模式）123456789101112131415161718192021222324//一般在 vue 的开发中都是模块化开发，所以当涉及到兄弟组件之间的通信的时候，我们可以在入口文件中事先声明一个全局的事件巴士（即一个全局的供 vue 实例），// 然后通过他来传导数据。// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue';import App from './App';import FastClick from 'fastclick';import router from './router';import Vue_resource from 'vue-resource';import axios from 'axios';import './common/style/index.less';Vue.config.productionTip = false;FastClick.attach(document.body);Vue.prototype.$http = axios;/* eslint-disable no-new */new Vue(&#123; el: '#app', router, render: h =&gt; h(App), data: &#123; eventHub: new Vue() &#125;&#125;);router.push('/goods'); 1234567//全局的使用该实例，进行数据的传输//在组件a中触发事件add，并且传递参数1this.$root.eventHub.$emit('add',1);//在组件b中监听事件的触发，并处理参数this.$root.eventHub.$on('add',function(data) &#123; //...&#125;) 七、vuex 状态管理传值 兄弟姐妹 &amp; 父子 通通可用（小项目少页面用eventBus，大项目多页面使用 vuex）(就是解决多页面使用同一个值的问题的)父子组件传值可以很容易办到 props 就可以解决，但是兄弟组件间传值（兄弟组件下又有父子组件），或者大型 spa 单页面框架项目，页面多并且一层嵌套一层的传值，异常麻烦，用 vuex 来维护共有的状态或数据会显得得心应手。因为vuex 主要就是做数据交互。对于大型应用，用 vuex 再方便不过了。 需求：两个组件 A 和 B，vuex 维护的公共数据是 餐馆的名称 resturantName,默认餐馆名称是 飞歌餐馆，那么现在A和B页面显示的就是飞歌餐馆。如果A修改餐馆名称 为 A 餐馆，则 B 页面显示的将会是 A 餐馆，反之 B 修改同理。这就是 vuex 维护公共状态或数据的魅力，在一个地方修改了数据，在这个项目的其他页面都会变成这个数据。 6.1 创建 store 在 vue-cli 脚手架创建的项目中，如果创建的时候勾选了 vuex ，那么我们的项目目录会有 sotre 文件夹 123456789// store.js 原始的文件内容如下，import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123;&#125;&#125;) 原始的内容如上面，但是这样不便于维护，我们同上是分为四个文件来维护。分开维护 actions mutations getters，以及原始的 index.js。 下面列举的是的使用 vuex 传值的方法，具体的是 如果使用 vuex 可以去学习 vuex 123456789101112131415161718192021222324//store/index.jsimport Vue from 'vue'import Vuex from 'vuex'import * as getters from './getters' // 导入响应的模块，*相当于引入了这个组件下所有导出的事例import * as actions from './actions'import * as mutations from './mutations'Vue.use(Vuex)// 首先声明一个需要全局维护的状态 state,比如 我这里举例的resturantNameconst state = &#123; resturantName: '飞歌餐馆' // 默认值 // id: xxx 如果还有全局状态也可以在这里添加 // name:xxx&#125;// 注册上面引入的各大模块const store = new Vuex.Store(&#123; state, // 共同维护的一个状态，state里面可以是很多个全局状态 getters, // 获取数据并渲染 actions, // 数据的异步操作 mutations // 处理数据的唯一途径，state的改变或赋值只能在这里&#125;)export default store // 导出store并在 main.js中引用注册。 1234567891011// actions.js// 给action注册事件处理函数。当这个函数被触发时候，将状态提交到mutations中处理export function modifyAName(&#123;commit&#125;, name) &#123; // commit 提交；name即为点击后传递过来的参数，此时是 'A餐馆' return commit ('modifyAName', name)&#125;export function modifyBName(&#123;commit&#125;, name) &#123; return commit ('modifyBName', name)&#125;// ES6精简写法// export const modifyAName = (&#123;commit&#125;,name) =&gt; commit('modifyAName', name) 12345678//mutations.js// 提交 mutations是更改Vuex状态的唯一合法方法export const modifyAName = (state, name) =&gt; &#123; // A组件点击更改餐馆名称为 A餐馆 state.resturantName = name // 把方法传递过来的参数，赋值给state中的resturantName&#125;export const modifyBName = (state, name) =&gt; &#123; // B组件点击更改餐馆名称为 B餐馆 state.resturantName = name&#125; 123// geter.JS// 获取最终的状态信息export const resturantName = state =&gt; state.resturantName 6.2 引入 store1234567891011121314//main.jsimport Vue from 'vue'import App from './App'import router from './router'import store from './store'//导入 storeVue.config.productionTip = falsenew Vue(&#123; el: '#app', router, store, // 全局注册 store 这样就能全局使用 vuex 了 components: &#123; App &#125;, template: '&lt;App/&gt;' 6.3 使用 store…mapactions 和 …mapgetters 都是 vuex 提供的语法糖，在底层已经封装好了，拿来就能用，简化了很多操作。 …mapActions([‘clickAFn’]) 相当于 this.$store.dispatch(&#39;clickAFn&#39;，{参数})mapActions中只需要指定方法名即可，参数省略。 …mapGetters([‘resturantName’])相当于 this.$store.getters.resturantName 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- componentA.vue --&gt;&lt;!-- 在组件A中，定义点击事件，点击 修改 餐馆的名称，并把餐馆的名称在事件中用参数进行传递 --&gt;&lt;template&gt; &lt;div class=\"componentsA\"&gt; &lt;P class=\"title\"&gt;组件A&lt;/P&gt; &lt;P class=\"titleName\"&gt;餐馆名称：&#123;&#123;resturantName&#125;&#125;&lt;/P&gt; &lt;div&gt; &lt;button class=\"btn\" @click=\"modifyAName('A餐馆')\"&gt;修改为A餐馆&lt;/button&gt;&lt;!-- 点击修改 为 A 餐馆 --&gt; &lt;/div&gt; &lt;div class=\"marTop\"&gt; &lt;button class=\"btn\" @click=\"trunToB\"&gt;跳转到B页面&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapActions, mapGetters&#125; from 'vuex'export default &#123; name: 'A', data () &#123; return &#123; &#125; &#125;, methods:&#123; ...mapActions( // 语法糖 ['modifyAName'] // 相当于this.$store.dispatch('modifyName'),提交这个方法 ), trunToB () &#123; this.$router.push(&#123;path: '/componentsB'&#125;) // 路由跳转到B &#125; &#125;, computed: &#123; ...mapGetters(['resturantName']) // 动态计算属性，相当于this.$store.getters.resturantName &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- componentB.vue --&gt;&lt;template&gt; &lt;div class=\"componentsB\"&gt; &lt;P class=\"title\"&gt;组件B&lt;/P&gt; &lt;P class=\"titleName\"&gt;餐馆名称：&#123;&#123;resturantName&#125;&#125;&lt;/P&gt; &lt;div&gt; &lt;!-- 点击修改 为 B 餐馆 --&gt; &lt;button class=\"btn\" @click=\"modifyBName('B餐馆')\"&gt;修改为B餐馆&lt;/button&gt; &lt;/div&gt; &lt;div class=\"marTop\"&gt; &lt;button class=\"btn\" @click=\"trunToA\"&gt;跳转到A页面&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;mapActions, mapGetters&#125; from 'vuex'export default &#123; name: 'B', data () &#123; return &#123; &#125; &#125;, methods:&#123; ...mapActions( // 语法糖 ['modifyBName'] // 相当于this.$store.dispatch('modifyName'),提交这个方法 ), trunToA () &#123; this.$router.push(&#123;path: '/componentsA'&#125;) // 路由跳转到A &#125; &#125;, computed: &#123; ...mapGetters(['resturantName']) // 动态计算属性，相当于this.$store.getters.resturantName &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 八、root、parent、ref、children 传递实例方法属性 this.$root.xxx 获取根组件的实例方法属性 （所有父组件） this.$parent.xxx 获取 父 组件的实例方法属性 传【值】【方法】给子组件 （直接父组件） this.$ref.refName.xxx 获取 孙子 组件的实例方法属性 传【值】【方法】给父组件 （所有子组件+孙子组件） this.$children.xxx 获取 子 组件的实例方法属性 传【值】【方法】给父组件 （直接子组件） 8.1 this.$root8.2 this.$parent8.3 this.$ref尽管存在 prop 和事件，prop 父传子，事件 子传父。有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 ref 特性为这个子组件赋予一个 ID 引用。例如： 123456789101112131415161718&lt;!-- 父组件 --&gt;&lt;base-input ref=\"usernameInput\"&gt;&lt;/base-input&gt;&lt;script&gt; export default &#123; name:'', data()&#123; return&#123; // &#125; &#125;, methods:&#123; getFromChild()&#123; this.$refs.usernameInput.xxxx()// 获取到子组件实例 的某个方法 this.$refs.usernameInput.name// 获取到子组件实例 的某个 数据 &#125; &#125; &#125;&lt;/script&gt; 12345678910111213141516&lt;!-- 子组件 --&gt;&lt;script&gt; export default &#123; name: \"baseinput\", data()&#123; return&#123; name:'' &#125; &#125;, methods:&#123; xxxx()&#123; // &#125; &#125; &#125;&lt;/script&gt; 8.4 this.$children父组件可以通过 $children，获取到所有的直接子组件，不包括孙组件；需要注意 $children 并不保证顺序，也不是响应式的。？？？？？什么意思，没有看懂 九 、slot 传值","tags":[]},{"title":"react.js--API","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑤ -【react.js 框架 】-API/","text":"一、前言二、React 对象不用 函数创建小组件了么？？？？？？ 2.1 React.Component 创建带 state 的组件12345class Greeting extends React.Component &#123;// 组件使用 React.Component 这个 API 来创建，但是这面的App 也是组件怎么不一样呢？？ render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; // props 是隐式传来的。 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'; // 默认导出 React，命名导出 Component//Component是一个命名导出。例如，它必须用&#123;&#125;进行解构。相当于下面，所以这些直接使用 Component// import React from 'react'// let Component = React.Componentimport logo from './logo.svg';import './App.css';class App extends Component &#123; render() &#123; return ( // 注意到这里， 它的类 class 写成 className 因为这里是 JS 在 ES6 中 class 为保留字 具体去看 2.4 DOM 元素 章节学习 // className 后面跟着的名称 还是大写开头的？？？？ // 同样还有一个 for 写成 htmlFor，因为 for 是个保留字 &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; ); &#125;&#125;export default App; 2.2 React.PureComponent 创建组件React.PureComponent 与 React.Component 几乎完全相同， 区别：React.Component 它没有实现shouldComponentUpdate()，？？？？？？？React.PureComponent 通过\b prop 和 state 的 浅对比 来实现 shouldComponentUpate()。？？？？？？？？？？？？？？？？？？？？？？如果 React 组件的 render() 函数在给定相同的 props 和 state 下渲染为相同的结果，在某些场景下你可以使用 React.PureComponent 来提升性能。？？？？？？？ 注意React.PureComponent shouldComponentUpdate()只是浅析对象。如果这些包含复杂的数据结构，则可能会产生错误的负面因素，从而产生更深层 只有 PureComponent 在您希望拥有简单的道具和状态时才会扩展，或者 forceUpdate() 在您知道深层数据结构发生变化时使用。或者，考虑使用不可变对象来促进嵌套数据的快速比较。 此外，React.PureComponent 的 shouldComponentUpdate() 跳过整个组件树道具更新。确保所有 子组件也“纯净”。 2.3 React.memo 创建组件123const MyComponent = React.memo(function MyComponent(props) &#123; /* render using props */&#125;); React.memo 是一个 更高阶的组件。它类似于 React.PureComponent 功能组件而 不是类。 如果你的 函数组件在给定相同的道具的情况下呈现相同的结果，则可以 React.memo 通过记忆结果将其包装在一些调用中以提高性能。这意味着React 将跳过渲染组件，并重用最后渲染的结果。 默认情况下，它只会 浅显 比较 props 对象中的复杂对象。如果要控制比较，还可以提供自定义比较功能作为第 2 个参数。 123456789101112function MyComponent(props) &#123; /* render using props */&#125;function areEqual(prevProps, nextProps) &#123; /* return true if passing nextProps to render would return the same result as passing prevProps to render, otherwise return false */&#125;export default React.memo(MyComponent, areEqual);//此方法仅作为性能优化存在。不要依赖它来“防止”渲染，因为这会导致错误。 注意 与 shouldComponentUpdate() 类组件上的方法不同，如果道具相等且道具不相等，则 areEqual 函数返回。这是相反的。truefalseshouldComponentUpdate 2.4 React.createElement()12345678910React.createElement( type, [props], [...children])//创建并返回 给定类型 的新 React元素。// type 参数可以是标记名称字符串（如 'div' or 'span'），React 组件类型（类或函数）或 React 片段类型。//用 JSX 编写的代码将转换为使用 React.createElement()。// React.createElement() 如果您使用的是 JSX，通常不会直接调用。请参阅 React Without JSX 以了解更多信息。 2.5 React.createFactory()1234React.createFactory(type)// 返回一个生成 给定类型 的 React 元素 的函数。// 例如 React.createElement()，type 参数可以是标记名称字符串（例如 'div' or 'span'），// React 组件类型（类或函数）或 React 片段类型。 这个帮助程序被认为是遗留的，我们建议您使用 JSX 或 React.createElement() 直接使用。 React.createFactory() 如果您使用的是 JSX，通常不会直接调用。请参阅 React Without JSX 以了解更多信息。 2.6 React.cloneElement()1234567React.cloneElement( element, [props], [...children])//克隆并返回一个新的 React 元素 element 作为起点。// 结果元素 将具有 原始元素 的道具，新道具以浅层方式合并。新的孩子将取代现有的孩子。key 并 ref 保留原始元素。 React.cloneElement() 几乎相当于： &lt;element.type {...element.props} {...props}&gt;{children}&lt;/element.type&gt;但是，它也保留了refs。这意味着如果你的孩子上面有一个孩子 ref，你就不会意外地从你的祖先那里偷走它。您将获得与 ref 新元素相同的附加内容。 引入此 API 作为已弃用的替代品 React.addons.cloneWithProps()。 2.7 React.isValidElement()12React.isValidElement(object)// 验证 对象 是否为 React元素。返回 true 或 false。 2.8 React.ChildrenReact.Children 提供用于处理 this.props.children 不透明数据结构的实用程序。 2.8.1 React.Children.map1React.Children.map(children, function[(thisArg)]) 上调用包含在每一个直系子的功能 children 与 this 设置为 thisArg。如果 children 是一个数组，它将被遍历，并且将为数组中的每个子节点调用该函数。如果孩子是 null 或者 undefined，这个方法将返回 null 或者 undefined 不是数组。 注意 如果 children 是 a Fragment，它将被视为 单个孩子 而 不是被遍历。 2.8.2 React.Children.forEach12React.Children.forEach(children, function[(thisArg)])// 喜欢 React.Children.map() 但不返回数组。 2.8.3 React.Children.count12React.Children.count(children)// 返回组件的总数 children，等于回调传递给 map 或 forEach 将被调用的次数。 2.8.4 React.Children.only12345React.Children.only(children)// 验证 children 只有一个子节点（React 元素）并返回它。否则此方法会引发错误。//注意：//React.Children.only() 不接受返回值，React.Children.map() 因为它是一个数组而不是一个 React 元素。 2.8.5 React.Children.toArray1234567React.Children.toArray(children)// 将 children 不透明数据结构作为平面数组返回，并为每个子项分配键。// 如果要在渲染方法中操作子集合，则非常有用，尤其是在要将其 this.props.children 传递之前重新排序或切片时。//注意：//React.Children.toArray() 在展平子项列表时更改键以保留嵌套数组的语义。// 也就是说，toArray 在返回的数组中为每个键添加前缀，以便每个元素的键的范围限定为包含它的输入数组。 2.9 React.Fragment1234567891011//该 React.Fragment 组件允许您在 render() 方法中 返回多个元素，而无需创建其他 DOM 元素：render() &#123; return ( &lt;React.Fragment&gt; Some text. &lt;h2&gt;A heading&lt;/h2&gt; &lt;/React.Fragment&gt; );&#125;// 您也可以使用简写 &lt;&gt;&lt;/&gt; 语法来使用它。有关更多信息，请参阅 React v16.2.0：改进对片段的支持。 2.10 React.forwardRef1234567891011121314151617181920// React.forwardRef 创建一个 React 组件，它将它接收的 ref 属性转发到树下面的另一个组件。这种技术不常见，但在两种情况下特别有用：//转发引用 DOM 组件//转发更高阶组件的 refs//React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 ref 作为两个参数调用此函数。此函数应返回 React 节点。const FancyButton = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"FancyButton\"&gt; &#123;props.children&#125; &lt;/button&gt;));// You can now get a ref directly to the DOM button:const ref = React.createRef();&lt;FancyButton ref=&#123;ref&#125;&gt;Click me!&lt;/FancyButton&gt;;// 在上面的示例中，React ref 将给定 &lt;FancyButton ref=&#123;ref&#125;&gt; 元素作为第二个参数传递给 React.forwardRef 调用内的呈现函数。//此渲染函数将元素传递 ref 给 &lt;button ref=&#123;ref&#125;&gt; 元素。// 因此，在 React 附加 ref 之后，ref.current 将直接指向 &lt;button&gt;DOM 元素实例。// 有关更多信息，请参阅转发引用。 1234567891011121314151617181920function enhance(Component) &#123; class Enhanced extends React.Component &#123; // ... render() &#123; const &#123;forwardedRef, ...rest&#125; = this.props; // Assign the custom prop \"forwardedRef\" as a ref return &lt;Component ref=&#123;forwardedRef&#125; &#123;...rest&#125; /&gt;; &#125; &#125; // Intercept the \"ref\" and pass it as a custom prop, e.g. \"forwardedRef\" function enhanceForwardRef(props, ref) &#123; return &lt;Enhanced &#123;...props&#125; forwardedRef=&#123;ref&#125; /&gt;; &#125; // These next lines are not necessary, // But they do give the component a better display name in DevTools, // e.g. \"ForwardRef(withTheme(MyComponent))\" const name = Component.displayName || Component.name; enhanceForwardRef.displayName = `enhance($&#123;name&#125;)`; return React.forwardRef(enhanceForwardRef);&#125; 2.11 React.createRef12345678910111213141516// React.createRef 创建一个裁判可以附着经由 ref 属性反应的元素。class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.inputRef = React.createRef(); &#125; render() &#123; return &lt;input type=\"text\" ref=&#123;this.inputRef&#125; /&gt;; &#125; componentDidMount() &#123; this.inputRef.current.focus(); &#125;&#125; 2.12 React.lazyReact.lazy() 允许您定义动态加载的组件。这有助于减少包大小以延迟加载在初始渲染期间未使用的组件。 您可以从我们的代码拆分文档中学习如何使用它。您可能还想查看本文，详细说明如何使用它。 123// This component is loaded dynamicallyconst SomeComponent = React.lazy(() =&gt; import('./SomeComponent'));//请注意，渲染 lazy 组件要求 &lt;React.Suspense&gt; 渲染树中有一个更高的组件。这是您指定加载指示器的方式。 2.13 React.SuspenseReact.Suspense 让你指定加载指示器，以防它下面的树中的某些组件尚未准备好渲染。今天，延迟加载组件是唯一支持的用例 &lt;React.Suspense&gt;： 12345678910111213// This component is loaded dynamicallyconst OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( // Displays &lt;Spinner&gt; until OtherComponent loads &lt;React.Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt; &lt;div&gt; &lt;OtherComponent /&gt; &lt;/div&gt; &lt;/React.Suspense&gt; );&#125; 它在我们的代码拆分指南中有记录。请注意，lazy 组件可以位于 Suspense 树的深处- 它不必包装它们中的每一个。最佳做法是将 &lt;Suspense&gt; 您想要查看加载指示符的位置放置在您想要进行 lazy() 代码拆分的任何位置。 虽然今天不支持，但未来我们计划 Suspense 处理更多场景，例如数据获取。您可以在我们的路线图中了解这一点。 注意： React.lazy() 并且 &lt;React.Suspense&gt; 尚未得到支持 ReactDOMServer。这是一个已知的限制，将来会解决。 三、 ReactDOM 对象3.1 ReactDOM.render() 渲染函数：将 react 元素渲染到 html 中是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。 12345678ReactDOM.render( element, container, [callback]//回调函数是可选的。如果你提供了，程序会在渲染或更新之后执行这个函数。)// 渲染一个 React 元素，添加到位于提供的 container 里的 DOM 元素中，并返回这个组件的一个 引用 (或者对于无状态组件返回 null ).// 如果这个 React 元素 之前 已经 被渲染到 container 里去了，这段代码就会进行一次 更新 ，// 并且只会改变那些反映元素最新状态所必须的 DOM 元素。 3.2 ReactDOM.unmountComponentAtNode() 移除渲染的 组件123ReactDOM.unmountComponentAtNode(container)// 从 DOM 元素中移除已挂载的 React 组件，清除它的事件处理器和 state。// 如果容器内没有挂载任何组件，这个函数什么都不会干。 有组件被卸载的时候返回 true，没有组件可供卸载时返回 false。 3.3 ReactDOM.findDOMNode() 在大部分情况下都 不提倡 使用这个方案，因为它破坏了组件的抽象化。12345ReactDOM.findDOMNode(component)// 如果这个组件已经被挂载到 DOM 中，函数会返回对应的浏览器中生成的 DOM 元素 。// 当你需要从 DOM 中读取值时，比如表单的值，或者计算 DOM 元素的尺寸，这个函数会非常有用。// 大多数情况下，你可以添加一个指向 DOM 节点的引用，从而完全避免使用 findDOMNode 这个函数.// 当 render 返回 null 或者 false 时, findDOMNode 也返回 null. 3.4 实例1234567ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;,// element 这个是 react 元素 document.getElementById('example')// container 容器);//上面代码将一个 h1 标题，插入 example 节点ReactDOM.unmountComponentAtNode(document.getElementById('example')) 四、ReactDOMServer 对象4.1 ReactDOMServer.renderToString() 服务端使用/ReactDOMServer.renderToStaticMarkup()123456ReactDOMServer.renderToString(element) //把一个 Reac t元素渲染为原始的HTML。 这个方法最好 只在服务端使用!!!!!!!!!!!! //React 将会返回一段 HTML 字符串。你可以用这个方法在服务端生成 HTML，并根据初始请求发送标记来加快页面的加载速度， //同时让搜索引擎可以抓取你的页面来达到优化 SEO 的目的ReactDOMServer.renderToStaticMarkup(element) //类似 renderToString，但是不会创建额外的 DOM 属性，例如 data-reactid 这些仅在 React 内部使用的属性。 // 如果你希望把 React 当作一个简单的静态页面生成器来使用，这很有用，因为去掉额外的属性可以节省很多字节。 五、 DOM 元素（与 html 的 DOM 有区别）React 实现了一套与浏览器无关的 DOM 系统，兼顾了性能和跨浏览器的兼容性。借此机会，我们清理了浏览器 DOM 实现中一些不一致的问题。 5.1 命名规则在 React 中，所有的 DOM 特性和属性 包括事件处理函数 都是 小驼峰命名法命名。（因为它们是 JS 拓展代码，而不是 html）比如说，① tabindex 属性对应的 React 实现命名则是 tabIndex。？？？？？ 属性名是驼峰形式② className=”App-header”,为什么首字母要大写？？？？？？？，这个是 create-react-app 初始化项目来的。 className属性值首字母大写么？ 在 JS 中 className 是大小写敏感的哦。③ aria- 和 data- 属性是例外的，一律使用小写字母命名。 12345678910111213141516&lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt;&lt;/div&gt; 5.2 React 和 HTML 的 DOM 属性的区别有许多的属性在React和Html之间行为是不一样的： 5.2.1 checked 属性??????????&lt;input&gt;标签 type 属性值为 checkbox 或 radio 时，支持 checked 属性。这对于构建受控组件很有用。与之相对 defaultChecked 这是非受控组件的属性，用来设定对应组件首次加载时是否选中状态。 5.2.2 类名属性 className (特殊情况还是使用 class)在 React 中，使用 className 属性指定一个 CSS 类 (class) 。这个特性适用于所有的常规 DOM 节点和 SVG 元素，比如 &lt;div&gt;，&lt;a&gt; 和其它的元素。 特殊情况:如果你在 React 中使用 Web 组件（这是一种不常见的使用方式），请使用 class 属性。 5.2.3 dangerouslySetInnerHTML 函数(react DOM 获取标签/组件 内内容)12345678910111213// dangerouslySetInnerHTML 是 React 提供的替换浏览器 DOM 中的 innerHTML 接口的一个函数。//一般而言，使用 JS 代码设置 HTML 文档的内容是危险的，因为这样很容易把你的用户信息暴露给跨站脚本攻击.//所以，你虽然可以直接在 React 中设置 html 的内容，但你要使用 dangerouslySetInnerHTML 并向该函数传递一个含有 __html 键的对象，//用来提醒你自己这样做很危险。例如：function createMarkup() &#123; return &#123;__html: 'First &amp;middot; Second'&#125;;// &amp;middot; 在中间的一个句号&#125;function MyComponent() &#123; return &lt;div dangerouslySetInnerHTML=&#123;createMarkup()&#125; /&gt;;&#125; 5.3 htmlFor因为在 javascript 中 for 是一个保留字，所以 React 元素使用 htmlFor 代替。 1&lt;label htmlFor=&#123;this.props.forId&#125;&gt;&lt;/label&gt; 5.4 onChange 函数onChange 事件处理函数的表现正如你所期望的：无论 form 表单何时发生变化，这个事件都会被触发。我们特意不使用浏览器已有的默认行为，因为onChange 在浏览器中的表现和这个名字不相称，而且 React 真实依靠这个事件实现了对用户输入的实时响应处理。 5.5 selected组件支持 selected 属性。你可以使用该属性设定组件是否选中的状态。这对构建受控组件很有用。 5.6 style属性style 属性接受一个键为 小驼峰命名法命名的 javascript 对象作为值，而不是像 css 字符串。这和 DOM 中 style 属性接受 javascript 对象对象 key 的命名方式保持一致性，更高效而且能够防止跨站脚本（XSS）的安全漏洞。例如： 12345678910111213141516171819const divStyle = &#123; color: 'blue', backgroundImage: 'url(' + imgUrl + ')',&#125;;function HelloWorldComponent() &#123; return &lt;div style=&#123;divStyle&#125;&gt;Hello World!&lt;/div&gt;;&#125;// 要注意，样式属性不会自动补齐前缀的。为了支持旧的浏览器，你需要手动支持相关的样式特性：像下面一样const divStyle = &#123; WebkitTransition: 'all', // note the capital 'W' here msTransition: 'all' // 'ms' is the only lowercase vendor prefix&#125;;function ComponentWithTransition() &#123; return &lt;div style=&#123;divStyle&#125;&gt;This should work cross-browser&lt;/div&gt;;&#125; 样式 key 使用 小驼峰命名法 是为了和 JS 访问 DOM 特性对对象的处理保持一致性（例如 node.style.backgroundImage）。浏览器后缀除了 ms 以外，都应该以 大写字母开头。这就是为什么 WebkitTransition 有一个大写字母 W 。 5.7 suppressContentEditableWarning一般来说，当一个拥有子节点的元素被标记为 contentEditable 时，React 会发出一个警告信息，因为此时 contentEditable 是无效的。这个属性会触发这样的警告信息。一般不要使用这个属性，除非你要构建一个类似 Draft.js 这样需要手动处理 contentEditable 属性的库。 5.8 value&lt;input&gt; 和 &lt;textarea&gt; 组件都支持 value 属性。你可以使用该属性设置组件的值。这对构建受控组件非常有用。defaultValue 属性对应的是非受控组件的属性，用来设置组件第一次加载时的值。 5.9 react 所有受支持的 HTML 属性5.9.1 React 支持以下所有的属性，同时也支持所有的 data- 和 aria- 属性：12345678910111213141516classID className style # 样式属性selected value form formAction formEncType formMethod # 表单accept acceptCharset accessKey action allowFullScreen allowTransparency altasync autoComplete autoFocus autoPlay capture cellPadding cellSpacing challengecharSet checked cite colSpan cols content contentEditablecontextMenu controls coords crossOrigin data dateTime default defer dirdisabled download draggable encType formNoValidate formTarget frameBorder headers height hidden high href hrefLanghtmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind labellang list loop low manifest marginHeight marginWidth max maxLength mediamediaGroup method min minLength multiple muted name noValidate nonce openoptimum pattern placeholder poster preload profile radioGroup readOnly relrequired reversed role rowSpan rows sandbox scope scoped scrolling seamlessshape size sizes span spellCheck src srcDoc srcLang srcSet start stepsummary tabIndex target title type useMap width wmode wrap 5.9.2 React 也支持以下这些 RDFa 属性（有几个 RDFa 属性 和 HTML 属性重叠，所以不包含在以下列表中）：而且，React也支持下列非标准属性： autoCapitalize autoCorrect for Mobile Safari.color for in Safari.itemProp itemScope itemType itemRef itemID for HTML5 microdata.security for older versions of Internet Explorer.unselectable for Internet Explorer.results autoSave for WebKit/Blink input fields of type search. 5.10 所有受支持的SVG属性12345678910111213141516171819202122232425262728293031323334accentHeight accumulate additive alignmentBaseline allowReorder alphabeticamplitude arabicForm ascent attributeName attributeType autoReverse azimuthbaseFrequency baseProfile baselineShift bbox begin bias by calcMode capHeightclip clipPath clipPathUnits clipRule colorInterpolationcolorInterpolationFilters colorProfile colorRendering contentScriptTypecontentStyleType cursor cx cy d decelerate descent diffuseConstant directiondisplay divisor dominantBaseline dur dx dy edgeMode elevation enableBackgroundend exponent externalResourcesRequired fill fillOpacity fillRule filterfilterRes filterUnits floodColor floodOpacity focusable fontFamily fontSizefontSizeAdjust fontStretch fontStyle fontVariant fontWeight format from fx fyg1 g2 glyphName glyphOrientationHorizontal glyphOrientationVertical glyphRefgradientTransform gradientUnits hanging horizAdvX horizOriginX ideographicimageRendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLengthkerning keyPoints keySplines keyTimes lengthAdjust letterSpacing lightingColorlimitingConeAngle local markerEnd markerHeight markerMid markerStartmarkerUnits markerWidth mask maskContentUnits maskUnits mathematical modenumOctaves offset opacity operator order orient orientation origin overflowoverlinePosition overlineThickness paintOrder panose1 pathLengthpatternContentUnits patternTransform patternUnits pointerEvents pointspointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnitsr radius refX refY renderingIntent repeatCount repeatDur requiredExtensionsrequiredFeatures restart result rotate rx ry scale seed shapeRendering slopespacing specularConstant specularExponent speed spreadMethod startOffsetstdDeviation stemh stemv stitchTiles stopColor stopOpacitystrikethroughPosition strikethroughThickness string stroke strokeDasharraystrokeDashoffset strokeLinecap strokeLinejoin strokeMiterlimit strokeOpacitystrokeWidth surfaceScale systemLanguage tableValues targetX targetY textAnchortextDecoration textLength textRendering to transform u1 u2 underlinePositionunderlineThickness unicode unicodeBidi unicodeRange unitsPerEm vAlphabeticvHanging vIdeographic vMathematical values vectorEffect version vertAdvYvertOriginX vertOriginY viewBox viewTarget visibility widths wordSpacingwritingMode x x1 x2 xChannelSelector xHeight xlinkActuate xlinkArcrolexlinkHref xlinkRole xlinkShow xlinkTitle xlinkType xmlns xmlnsXlink xmlBasexmlLang xmlSpace y y1 y2 yChannelSelector z zoomAndPan","tags":[]},{"title":"编辑器默认格式化， ESlint 扩展格式化，vetur 扩展格式化，三者之间的冲突 关闭令人抓狂的ESlint 语法检测配置方法","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑩ - 【命令-工具】编辑器==ESlint-vscode㉖/","text":"一、前言在使用 vue-cli 创建项目的使用，命令行就让我们选择是否使用 ESlint 来优化我们的代码。如果我们是自己一个人的项目可以不使用，但是在一个公司一个团队协作上，项目都是需要有个代码的统一格式化风格的，因此 ESlint 是有必要的，即使一个项目不使用 ESlint 应该也会选择其他的插件来统一优化代码。 VS code 插件非常之多，各种格式化的插件也是非常的多，插件大多不是官方的，固然会出现冲突的时候。这个冲突会让我们在代码编辑的时候非常的头疼。 现在就来解决一下 vue 项目中的代码保存冲突问题。 vscode 编辑器默认格式化， ESlint 扩展格式化，vetur 扩展格式化，三者之间的冲突 微软：Visual Studio code jetbrains公司:WebStorm 二、冲突表现（坑）在说这些坑之前，我们先来了解一下 vscode 与它的插件。 ①vscode：微软公司的 vscode 编辑器本身自带一个格式化风格，也就是文件→首选项→设置 中默认的代码格式化 ②vetur 扩展：是用来格式化 vue.js 代码的。Vue tooling for VS Code, powered by vue-language-server. ③ESlint 扩展：Integrates ESLint JavaScript into VS Code. Beautify 扩展：Beautify javascript, JSON, CSS, Sass, and HTML in Visual Studio Code. 2.1 坑一：使用官网组件的时候 .vue 文件报错。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;!-- 这个 class 与 script 中的 name 没有关系，原 class 为 hello --&gt; &lt;div class=\"layout\"&gt; &lt;Layout&gt; &lt;Header&gt; &lt;Menu mode=\"horizontal\" theme=\"dark\" active-name=\"1\"&gt; &lt;div class=\"layout-logo\"&gt;&lt;/div&gt; &lt;div class=\"layout-nav\"&gt; &lt;MenuItem name=\"1\"&gt; &lt;Icon type=\"ios-navigate\"&gt;&lt;/Icon&gt; Item 1 &lt;/MenuItem&gt; &lt;MenuItem name=\"2\"&gt; &lt;Icon type=\"ios-keypad\"&gt;&lt;/Icon&gt; Item 2 &lt;/MenuItem&gt; &lt;MenuItem name=\"3\"&gt; &lt;Icon type=\"ios-analytics\"&gt;&lt;/Icon&gt; Item 3 &lt;/MenuItem&gt; &lt;MenuItem name=\"4\"&gt; &lt;Icon type=\"ios-paper\"&gt;&lt;/Icon&gt; Item 4 &lt;/MenuItem&gt; &lt;/div&gt; &lt;/Menu&gt; &lt;/Header&gt; &lt;Content :style=\"&#123;padding: '0 50px'&#125;\"&gt; &lt;Breadcrumb :style=\"&#123;margin: '20px 0'&#125;\"&gt; &lt;BreadcrumbItem&gt;Home&lt;/BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Components&lt;/BreadcrumbItem&gt; &lt;BreadcrumbItem&gt;Layout&lt;/BreadcrumbItem&gt; &lt;/Breadcrumb&gt; &lt;Card&gt; &lt;div style=\"min-height: 200px;\"&gt; Content &lt;/div&gt; &lt;/Card&gt; &lt;/Content&gt; &lt;Footer class=\"layout-footer-center\"&gt;2011-2016 &amp;copy; TalkingData&lt;/Footer&gt; &lt;/Layout&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', // 这里是组件名称，给 template 中的 class 没有关系，原名为 HelloWorld data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125;&lt;/script&gt;&lt;!-- Add \"scoped\" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; 如上面的代码段，命名跟着 iview 官网拷贝过来的，怎么就出错了呢？？一直提示错误： 12345[eslint]Parsing error: x-invalid-end-tag.(vue/no-parsing-error)[eslint-plugin-vue][vue/no-parsing-error]Parsing error: x-invalid-end-tag. 首先 vscode 编辑器是自带一个默认格式化风格的。 然后再这里使用了 ESlint 的风格，二者会导致冲突， 如果 vscode 还安装了 vetur 插件就又多了一个冲突。 三、填坑-解决冲突3.1 步骤①：vscode 设置页面设置需要使用 ESlint 的格式化，就要将 vscode 编辑器默认的格式化去掉、把 vetur 插件的格式化改写 12345678910111213141516\"vetur.validation.template\": false // 把 vetur 扩展的 template 格式化去掉 \"editor.formatOnSave\": false, // 去掉 vscode 自带的自动保存 ，vscode 默认也是 false //的，如果要用 eslint 格式化，默认的格式化就不能开启\"eslint.enable\": true, // eslint 格式化的配置\"eslint.autoFixOnSave\": true,\"eslint.run\": \"onType\",\"eslint.options\": &#123; \"extensions\": [\".js\",\".vue\"]&#125;,\"eslint.validate\": [\"javascript\",&#123; \"language\": \"vue\", \"autoFix\": true,&#125;,\"html\",\"vue\"], 3.2 vue-cli 搭建的项目中，.eslintrc.js 文件中设置这个文件就是用于配置当前项目的 ESlint 格式化规则，可以根据团队项目的要求设置格式化规则 1234567extends: # 增加如下两行 \"eslint:recommended\", \"plugin:vue/recommended\"rules: # 增加如下两行 \"vue/no-parsing-error\": [2, &#123; \"x-invalid-end-tag\": false &#125;] 三、解析.eslintrc.js 文件中的配置项：1234567891011121314151617181920212223242526272829303132333435363738module.exports = &#123; root: true, parser: 'babel-eslint', parserOptions: &#123; //设置 \"script\"（默认）或 \"module\" 如果你的代码是在 ECMAScript 中的模块。 sourceType: 'module' &#125;, env: &#123; browser: true, &#125;, // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style extends: 'standard', // required to lint *.vue files plugins: [ 'html' ], // add your custom rules here 'rules': &#123; // allow paren-less arrow functions 'arrow-parens': 0, // allow async-await 'generator-star-spacing': 0, // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, \"no-unused-vars\": [2, &#123; // 允许声明未使用变量 \"vars\": \"local\", // 参数不检查 \"args\": \"none\" &#125;], // 关闭语句强制分号结尾 \"semi\": [0], //空行最多不能超过 100 行 \"no-multiple-empty-lines\": [0, &#123;\"max\": 100&#125;], //关闭禁止混用 tab 和空格 \"no-mixed-spaces-and-tabs\": [0], &#125;&#125; 配置参数 123rules: &#123; &quot;规则名&quot;: [规则值, 规则配置]&#125; 规则值： 123&quot;off&quot;或者0 //关闭规则&quot;warn&quot;或者1 //在打开的规则作为警告（不影响退出代码）&quot;error&quot;或者2 //把规则作为一个错误（退出代码触发时为 1 ） 常见规则列表: “no-alert”: 0,//禁止使用alert confirm prompt “no-array-constructor”: 2,//禁止使用数组构造器 “no-bitwise”: 0,//禁止使用按位运算符 “no-caller”: 1,//禁止使用arguments.caller或arguments.callee “no-catch-shadow”: 2,//禁止catch子句参数与外部作用域变量同名 “no-class-assign”: 2,//禁止给类赋值 “no-cond-assign”: 2,//禁止在条件表达式中使用赋值语句 “no-console”: 2,//禁止使用console “no-const-assign”: 2,//禁止修改const声明的变量 “no-constant-condition”: 2,//禁止在条件中使用常量表达式 if(true) if(1) “no-continue”: 0,//禁止使用continue “no-control-regex”: 2,//禁止在正则表达式中使用控制字符 “no-debugger”: 2,//禁止使用debugger “no-delete-var”: 2,//不能对var声明的变量使用delete操作符 “no-div-regex”: 1,//不能使用看起来像除法的正则表达式/=foo/ “no-dupe-keys”: 2,//在创建对象字面量时不允许键重复 {a:1,a:1} “no-dupe-args”: 2,//函数参数不能重复 “no-duplicate-case”: 2,//switch中的case标签不能重复 “no-else-return”: 2,//如果if语句里面有return,后面不能跟else语句 “no-empty”: 2,//块语句中的内容不能为空 “no-empty-character-class”: 2,//正则表达式中的[]内容不能为空 “no-empty-label”: 2,//禁止使用空label “no-eq-null”: 2,//禁止对null使用==或!=运算符 “no-eval”: 1,//禁止使用eval “no-ex-assign”: 2,//禁止给catch语句中的异常参数赋值 “no-extend-native”: 2,//禁止扩展native对象 “no-extra-bind”: 2,//禁止不必要的函数绑定 “no-extra-boolean-cast”: 2,//禁止不必要的bool转换 “no-extra-parens”: 2,//禁止非必要的括号 “no-extra-semi”: 2,//禁止多余的冒号 “no-fallthrough”: 1,//禁止switch穿透 “no-floating-decimal”: 2,//禁止省略浮点数中的0 .5 3. “no-func-assign”: 2,//禁止重复的函数声明 “no-implicit-coercion”: 1,//禁止隐式转换 “no-implied-eval”: 2,//禁止使用隐式eval “no-inline-comments”: 0,//禁止行内备注 “no-inner-declarations”: [2, “functions”],//禁止在块语句中使用声明（变量或函数） “no-invalid-regexp”: 2,//禁止无效的正则表达式 “no-invalid-this”: 2,//禁止无效的this，只能用在构造器，类，对象字面量 “no-irregular-whitespace”: 2,//不能有不规则的空格 “no-iterator”: 2,//禁止使用iterator 属性 “no-label-var”: 2,//label名不能与var声明的变量名相同 “no-labels”: 2,//禁止标签声明 “no-lone-blocks”: 2,//禁止不必要的嵌套块 “no-lonely-if”: 2,//禁止else语句内只有if语句 “no-loop-func”: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以） “no-mixed-requires”: [0, false],//声明时不能混用声明类型 “no-mixed-spaces-and-tabs”: [2, false],//禁止混用tab和空格 “linebreak-style”: [0, “windows”],//换行风格 “no-multi-spaces”: 1,//不能用多余的空格 “no-multi-str”: 2,//字符串不能用\\换行 “no-multiple-empty-lines”: [1, {“max”: 2}],//空行最多不能超过2行 “no-native-reassign”: 2,//不能重写native对象 “no-negated-in-lhs”: 2,//in 操作符的左边不能有! “no-nested-ternary”: 0,//禁止使用嵌套的三目运算 “no-new”: 1,//禁止在使用new构造一个实例后不赋值 “no-new-func”: 1,//禁止使用new Function “no-new-object”: 2,//禁止使用new Object() “no-new-require”: 2,//禁止使用new require “no-new-wrappers”: 2,//禁止使用new创建包装实例，new String new Boolean new Number “no-obj-calls”: 2,//不能调用内置的全局对象，比如Math() JSON() “no-octal”: 2,//禁止使用八进制数字 “no-octal-escape”: 2,//禁止使用八进制转义序列 “no-param-reassign”: 2,//禁止给参数重新赋值 “no-path-concat”: 0,//node中不能使用dirname或filename做路径拼接 “no-plusplus”: 0,//禁止使用++，– “no-process-env”: 0,//禁止使用process.env “no-process-exit”: 0,//禁止使用process.exit() “no-proto”: 2,//禁止使用proto属性 “no-redeclare”: 2,//禁止重复声明变量 “no-regex-spaces”: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/ “no-restricted-modules”: 0,//如果禁用了指定模块，使用就会报错 “no-return-assign”: 1,//return 语句中不能有赋值表达式 “no-script-url”: 0,//禁止使用javascript:void(0) “no-self-compare”: 2,//不能比较自身 “no-sequences”: 0,//禁止使用逗号运算符 “no-shadow”: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名 “no-shadow-restricted-names”: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用 “no-spaced-func”: 2,//函数调用时 函数名与()之间不能有空格 “no-sparse-arrays”: 2,//禁止稀疏数组， [1,,2] “no-sync”: 0,//nodejs 禁止同步方法 “no-ternary”: 0,//禁止使用三目运算符 “no-trailing-spaces”: 1,//一行结束后面不要有空格 “no-this-before-super”: 0,//在调用super()之前不能使用this或super “no-throw-literal”: 2,//禁止抛出字面量错误 throw “error”; “no-undef”: 1,//不能有未定义的变量 “no-undef-init”: 2,//变量初始化时不能直接给它赋值为undefined “no-undefined”: 2,//不能使用undefined “no-unexpected-multiline”: 2,//避免多行表达式 “no-underscore-dangle”: 1,//标识符不能以_开头或结尾 “no-unneeded-ternary”: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false; “no-unreachable”: 2,//不能有无法执行的代码 “no-unused-expressions”: 2,//禁止无用的表达式 “no-unused-vars”: [2, {“vars”: “all”, “args”: “after-used”}],//不能有声明后未被使用的变量或参数 “no-use-before-define”: 2,//未定义前不能使用 “no-useless-call”: 2,//禁止不必要的call和apply “no-void”: 2,//禁用void操作符 “no-var”: 0,//禁用var，用let和const代替 “no-warning-comments”: [1, { “terms”: [“todo”, “fixme”, “xxx”], “location”: “start” }],//不能有- 警告备注 “no-with”: 2,//禁用with “array-bracket-spacing”: [2, “never”],//是否允许非空数组里面有多余的空格 “arrow-parens”: 0,//箭头函数用小括号括起来 “arrow-spacing”: 0,//=&gt;的前/后括号 “accessor-pairs”: 0,//在对象中使用getter/setter “block-scoped-var”: 0,//块语句中使用var “brace-style”: [1, “1tbs”],//大括号风格 “callback-return”: 1,//避免多次调用回调什么的 “camelcase”: 2,//强制驼峰法命名 “comma-dangle”: [2, “never”],//对象字面量项尾不能有逗号 “comma-spacing”: 0,//逗号前后的空格 “comma-style”: [2, “last”],//逗号风格，换行时在行首还是行尾 “complexity”: [0, 11],//循环复杂度 “computed-property-spacing”: [0, “never”],//是否允许计算后的键名什么的 “consistent-return”: 0,//return 后面是否允许省略 “consistent-this”: [2, “that”],//this别名 “constructor-super”: 0,//非派生类不能调用super，派生类必须调用super “curly”: [2, “all”],//必须使用 if(){} 中的{} “default-case”: 2,//switch语句最后必须有default “dot-location”: 0,//对象访问符的位置，换行的时候在行首还是行尾 “dot-notation”: [0, { “allowKeywords”: true }],//避免不必要的方括号 “eol-last”: 0,//文件以单一的换行符结束 “eqeqeq”: 2,//必须使用全等 “func-names”: 0,//函数表达式必须有名字 “func-style”: [0, “declaration”],//函数风格，规定只能使用函数声明/函数表达式 “generator-star-spacing”: 0,//生成器函数*的前后空格 “guard-for-in”: 0,//for in循环要用if语句过滤 “handle-callback-err”: 0,//nodejs 处理错误 “id-length”: 0,//变量名长度 “indent”: [2, 4],//缩进风格 “init-declarations”: 0,//声明时必须赋初值 “key-spacing”: [0, { “beforeColon”: false, “afterColon”: true }],//对象字面量中冒号的前后空格 “lines-around-comment”: 0,//行前/行后备注 “max-depth”: [0, 4],//嵌套块深度 “max-len”: [0, 80, 4],//字符串最大长度 “max-nested-callbacks”: [0, 2],//回调嵌套深度 “max-params”: [0, 3],//函数最多只能有3个参数 “max-statements”: [0, 10],//函数内最多有几个声明 “new-cap”: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用 “new-parens”: 2,//new时必须加小括号 “newline-after-var”: 2,//变量声明后是否需要空一行 “object-curly-spacing”: [0, “never”],//大括号内是否允许不必要的空格 “object-shorthand”: 0,//强制对象字面量缩写语法 “one-var”: 1,//连续声明 “operator-assignment”: [0, “always”],//赋值运算符 += -=什么的 “operator-linebreak”: [2, “after”],//换行时运算符在行尾还是行首 “padded-blocks”: 0,//块语句内行首行尾是否要空行 “prefer-const”: 0,//首选const “prefer-spread”: 0,//首选展开运算 “prefer-reflect”: 0,//首选Reflect的方法 “quotes”: [1, “single”],//引号类型 “” ‘’ “quote-props”:[2, “always”],//对象字面量中的属性名是否强制双引号 “radix”: 2,//parseInt必须指定第二个参数 “id-match”: 0,//命名检测 “require-yield”: 0,//生成器函数必须有yield “semi”: [2, “always”],//语句强制分号结尾 “semi-spacing”: [0, {“before”: false, “after”: true}],//分号前后空格 “sort-vars”: 0,//变量声明时排序 “space-after-keywords”: [0, “always”],//关键字后面是否要空一格 “space-before-blocks”: [0, “always”],//不以新行开始的块{前面要不要有空格 “space-before-function-paren”: [0, “always”],//函数定义时括号前面要不要有空格 “space-in-parens”: [0, “never”],//小括号里面要不要有空格 “space-infix-ops”: 0,//中缀操作符周围要不要有空格 “space-return-throw-case”: 2,//return throw case后面要不要加空格 “space-unary-ops”: [0, { “words”: true, “nonwords”: false }],//一元运算符的前/后要不要加空格 “spaced-comment”: 0,//注释风格要不要有空格什么的 “strict”: 2,//使用严格模式 “use-isnan”: 2,//禁止比较时使用NaN，只能用isNaN() “valid-jsdoc”: 0,//jsdoc规则 “valid-typeof”: 2,//必须使用合法的typeof的值 “vars-on-top”: 2,//var必须放在作用域顶部 “wrap-iife”: [2, “inside”],//立即执行函数表达式的小括号风格 “wrap-regex”: 0,//正则表达式字面量用小括号包起来 “yoda”: [2, “never”]//禁止尤达条件 2.2 坑二：使用 console.log 调试错误 如上错误是 ESlint 的限制。[eslint] Unexpected console statement.(no-console)，就是 eslint 不允许使用这个 console.log() 语句，如果调试需要使用这个语句的话，要修改 eslint 的限制。 填坑： 在2.1中已经列举出来很多 .eslintrc.js 中 rules 常见规则列表:，可以根据这些规则来设置 eslint.js 配置文件。给 rules 添加此行：”no-console”: 0, 即可避免这个错误，但是需要知道的是生产阶段需要记得把这些后台输出语句删除。或者直接选择其他的调试方式。 1234设置为 \"no-console\": 2 （也就是 error ，就是说不能出现 console，出现就会报错） 可以在项目完成之后，设置为 2 ，快速的找到删除这些不必要的 console设置为 \"no-console\": 1 （也就是 warn ，就是说可以 console，只是会警告，console 下面会是绿色波浪线）设置为 \"no-console\": 20（也就是 无规则，不开启这个规则判断，就不会有任何报错了）","tags":[{"name":"ESlint之坑","slug":"ESlint之坑","permalink":"https://liuxmoo.com/tags/ESlint之坑/"}]},{"title":"node.js--[小白入门版]","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】-rumen/","text":"一、什么是 node.jsJavaScript 是脚本语言，脚本语言都需要一个解析器才能运行。对于写在 HTML 页面里的 JS，浏览器充当了解析器的角色。而对于需要独立运行的 JS，NodeJS 就是一个解析器。简单的说 Node.js 就是运行在服务端的 JavaScript。 每一种解析器都是一个运行环境，不但允许 JS 定义各种数据结构，进行各种计算，还允许 JS 使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的 JS 的用途是操作 DOM，浏览器就提供了 document 之类的内置对象。而运行在 NodeJS 中的 JS 的用途是操作磁盘文件或搭建 HTTP 服务器，NodeJS 就相应提供了fs、http 等等内置对象（API接口）。 官方中文网，官网英文网 Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。 node.js 可以解析 JS 代码（没有浏览器安全级的限制） 提供系统级别的 API：文件的读写，进程的管理，网络通信等等 学习 node.js 可以使用的几个网站： node.js 官网：官方中文网，官网英文网 github官网源码托管 npm论坛 stackoverflow技术问答社区 二、node.js的安装不同版本的 API 接口可能不同，使用的规范也会不同。一定要注意自己使用的 node.js 版本。 node.js官网官网网址：旧版本node.js 官网中偶数位为稳定的版本，奇数为不稳定的版本，选择偶数版本来使用。 三、node.js 创建一个 web 服务器 Node.js 应用是由哪几部分组成的： 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。 1234567891011121314//我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 httpvar http = require('http'); //这里是 Commonjs 规范http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');&#125;).listen(8888); //这里使用的是链式语法// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 在 8888 这个端口监听到一个请求之后，就会去调用匿名回调函数 function (request, response){} 用命令行运行代码： cd 到相应的项目目录， node server.js server.js代码解析： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。分析Node.js 的 HTTP 服务器： 第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。 四、NPM4.1 什么是NPMNPM 是随同 NodeJS 一起安装的包管理工具，能解决 NodeJS 代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从 NPM 服务器下载别人编写的第三方包到本地使用。 允许用户从 NPM 服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用。 4.2 NPM的安装新版的 nodejs 已经集成了 npm，安装了新版的 node.js，npm 也就一同安装上了。不需要再次安装。 查看版本：可以用命令行 npm -v查看安装的版本。 升级版本:Window 系统：npm install npm -g 4.3 NPM的功能 安装模块 卸载模块 搜索模块 更新模块 创建模块 模块分类：npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g 而已。 全局安装： 指的是将模块安装在计算机系统，此后在任何一个磁盘，创建的任何一个项目都可以直接使用这个模块，不需要再次安装。通俗的说就是公有的。大家用使用。 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 本地安装： 指的是将模块安装在相应的项目目录下，仅仅是这个项目可以使用，后期在其他盘，或者文件下创建项目，需要使用到这个模块的话，需要再次安装的。通俗的说就是各管各的。我有的是私有的。 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 下面将以 express 模块全局安装来解析 NPM 功能，也可以以之间的 vue.js 系列来学习本节。 ①安装express模块 123npm install express -g//也可以使用 cnpm 淘宝镜像，还可以使用 pnpm//安装淘宝镜像：npm install -g cnpm --registry=https://registry.npm.taobao.org npm list 模块名 可以用来查看某个模块的版本号，也可以使用模块名 -v/-V 来查看模块小单版本号npm list -g 可以用来查看全局安装的所有模块，也可以在 package.json 文件中查看安装的模块信息。 ②卸载模块 12npm uninstall express//卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用命令 `npm ls` 查看 ③更新模块 12npm update express//或者使用命令 `express -v`查看更新后的版本 ④搜索模块 1npm search express ⑤创建模块 12345//以下命令创建模块提供他人使用npm init 生成 package.json 文件npm adduser 在 npm 资源库中注册用户（使用邮箱注册）npm publish 发布模块//后续可以使用 npm 装这个模块，跟其他他人创建好的模块一样的方法下载安装使用 package.json解析package.json 位于模块的目录下，用于定义包的属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168//下面是 express 包的 package.json 文件，位于 node_modules/express/package.json 内容&#123; \"name\": \"express\", \"description\": \"Fast, unopinionated, minimalist web framework\", \"version\": \"4.13.3\", \"author\": &#123; \"name\": \"TJ Holowaychuk\", \"email\": \"tj@vision-media.ca\" &#125;, \"contributors\": [ &#123; \"name\": \"Aaron Heckmann\", \"email\": \"aaron.heckmann+github@gmail.com\" &#125;, &#123; \"name\": \"Ciaran Jessup\", \"email\": \"ciaranj@gmail.com\" &#125;, &#123; \"name\": \"Douglas Christopher Wilson\", \"email\": \"doug@somethingdoug.com\" &#125;, &#123; \"name\": \"Guillermo Rauch\", \"email\": \"rauchg@gmail.com\" &#125;, &#123; \"name\": \"Jonathan Ong\", \"email\": \"me@jongleberry.com\" &#125;, &#123; \"name\": \"Roman Shtylman\", \"email\": \"shtylman+expressjs@gmail.com\" &#125;, &#123; \"name\": \"Young Jae Sim\", \"email\": \"hanul@hanul.me\" &#125; ], \"license\": \"MIT\", \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/strongloop/express.git\" &#125;, \"homepage\": \"http://expressjs.com/\", \"keywords\": [ \"express\", \"framework\", \"sinatra\", \"web\", \"rest\", \"restful\", \"router\", \"app\", \"api\" ], \"dependencies\": &#123; \"accepts\": \"~1.2.12\", \"array-flatten\": \"1.1.1\", \"content-disposition\": \"0.5.0\", \"content-type\": \"~1.0.1\", \"cookie\": \"0.1.3\", \"cookie-signature\": \"1.0.6\", \"debug\": \"~2.2.0\", \"depd\": \"~1.0.1\", \"escape-html\": \"1.0.2\", \"etag\": \"~1.7.0\", \"finalhandler\": \"0.4.0\", \"fresh\": \"0.3.0\", \"merge-descriptors\": \"1.0.0\", \"methods\": \"~1.1.1\", \"on-finished\": \"~2.3.0\", \"parseurl\": \"~1.3.0\", \"path-to-regexp\": \"0.1.7\", \"proxy-addr\": \"~1.0.8\", \"qs\": \"4.0.0\", \"range-parser\": \"~1.0.2\", \"send\": \"0.13.0\", \"serve-static\": \"~1.10.0\", \"type-is\": \"~1.6.6\", \"utils-merge\": \"1.0.0\", \"vary\": \"~1.0.1\" &#125;, \"devDependencies\": &#123; \"after\": \"0.8.1\", \"ejs\": \"2.3.3\", \"istanbul\": \"0.3.17\", \"marked\": \"0.3.5\", \"mocha\": \"2.2.5\", \"should\": \"7.0.2\", \"supertest\": \"1.0.1\", \"body-parser\": \"~1.13.3\", \"connect-redis\": \"~2.4.1\", \"cookie-parser\": \"~1.3.5\", \"cookie-session\": \"~1.2.0\", \"express-session\": \"~1.11.3\", \"jade\": \"~1.11.0\", \"method-override\": \"~2.3.5\", \"morgan\": \"~1.6.1\", \"multiparty\": \"~4.1.2\", \"vhost\": \"~3.0.1\" &#125;, \"engines\": &#123; \"node\": \"&gt;= 0.10.0\" &#125;, \"files\": [ \"LICENSE\", \"History.md\", \"Readme.md\", \"index.js\", \"lib/\" ], \"scripts\": &#123; \"test\": \"mocha --require test/support/env --reporter spec --bail --check-leaks test/ test/acceptance/\", \"test-ci\": \"istanbul cover node_modules/mocha/bin/_mocha --report lcovonly -- --require test/support/env --reporter spec --check-leaks test/ test/acceptance/\", \"test-cov\": \"istanbul cover node_modules/mocha/bin/_mocha -- --require test/support/env --reporter dot --check-leaks test/ test/acceptance/\", \"test-tap\": \"mocha --require test/support/env --reporter tap --check-leaks test/ test/acceptance/\" &#125;, \"gitHead\": \"ef7ad681b245fba023843ce94f6bcb8e275bbb8e\", \"bugs\": &#123; \"url\": \"https://github.com/strongloop/express/issues\" &#125;, \"_id\": \"express@4.13.3\", \"_shasum\": \"ddb2f1fb4502bf33598d2b032b037960ca6c80a3\", \"_from\": \"express@*\", \"_npmVersion\": \"1.4.28\", \"_npmUser\": &#123; \"name\": \"dougwilson\", \"email\": \"doug@somethingdoug.com\" &#125;, \"maintainers\": [ &#123; \"name\": \"tjholowaychuk\", \"email\": \"tj@vision-media.ca\" &#125;, &#123; \"name\": \"jongleberry\", \"email\": \"jonathanrichardong@gmail.com\" &#125;, &#123; \"name\": \"dougwilson\", \"email\": \"doug@somethingdoug.com\" &#125;, &#123; \"name\": \"rfeng\", \"email\": \"enjoyjava@gmail.com\" &#125;, &#123; \"name\": \"aredridel\", \"email\": \"aredridel@dinhe.net\" &#125;, &#123; \"name\": \"strongloop\", \"email\": \"callback@strongloop.com\" &#125;, &#123; \"name\": \"defunctzombie\", \"email\": \"shtylman@gmail.com\" &#125; ], \"dist\": &#123; \"shasum\": \"ddb2f1fb4502bf33598d2b032b037960ca6c80a3\", \"tarball\": \"http://registry.npmjs.org/express/-/express-4.13.3.tgz\" &#125;, \"directories\": &#123;&#125;, \"_resolved\": \"https://registry.npmjs.org/express/-/express-4.13.3.tgz\", \"readme\": \"ERROR: No README data found!\"&#125; Package.json 属性说明 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。 keywords - 关键字 4.4 NPM常用命令NPM 常用命令：除了本章介绍的部分外，NPM还提供了很多功能，package.json 里也有很多其它有用的字段。也可以去查看：NPM官方文档 使用npm help 可查看某条命令的详细帮助，例如 npm help install。在package.json所在目录下使用 npm install . -g 可先在本地安装当前命令行程序，可用于发布前的本地测试。使用npm update 可以把当前目录下 node_modules 子目录里边的对应模块更新至最新版本。使用npm update -g 可以把全局安装的对应命令行程序更新至最新版。使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 五、REPL(交互式解释器)5.1 什么是REPL？REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 Node 自带了交互式解释器 .REPL 可以执行以下任务,可以很好的调试 Javascript 代码。 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 REPL 1234567891011121314151617181920212223node //启动 Node 的终端,命令行变成了三角符号&gt; 1 + ( 2 * 3 ) - 4 //简单表示式输入计算3&gt;x = 10 //变量声明：没有使用关键字 var ,然后值会被直接打印出来10&gt; var y = 10//变量声明：有使用关键字 var ,值不会被打印出来，而是打印了 undefinedundefined&gt; x + y20&gt; console.log(\"Hello World\") //可以打印Hello World&gt;var c = 0 undefined&gt; do &#123; //多行表达式...这个符号是 node 自己判断为多行语句后自己添加的，回车即可... c++;... console.log(\"c: \" + c);... &#125; while ( c &lt; 5 );c: 1c: 2c: 3c: 4c: 5undefined 1234567891011&gt; var x = 10undefined&gt; var y = 20undefined&gt; x + y30&gt; var sum = _ //使用下划线(_)获取上一个表达式的运算结果：undefined&gt; console.log(sum)30undefined REPL 命令 ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 六、回调函数Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口 (Node.js 几乎每一个 API 都是支持回调函数的)，通过这些接口可以处理大量的并发，所以性能非常高。 Node.js 异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。 回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 回调函数一般作为参数的最后一个参数出现：function func1(name, age, callback) { }function func2(value, callback1, callback2) { } 单线程阻塞代码 与 单线程阻异步编程 创建一个文件 input.txt 1名字：liuxmoo 123456789//单线程阻塞代码：顺序执行var fs = require(\"fs\");var data = fs.readFileSync('input.txt');console.log(data.toString()); console.log(\"ok\"); //这句会等待上面一句执行完毕后才开始执行//代码执行结果//名字：liuxmoo//ok 1234567891011//单线程阻异步编程：不需要按顺序执行var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(\"ok\"); //上面那个函数没有执行完全，这个语句就执行完毕了//代码执行结果//ok//名字：liuxmoo 第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。如果需要处理回调函数的参数，写在回调函数内。","tags":[]},{"title":"render 渲染函数","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】-render-渲染函数/","text":"一、前言在 jquery 中我们使用 js 集合 jquery 的 API 方法 动态的生成 一些 DOM 元素。 那么在 vue ，wepy，mpvue 双向绑定的框架中，我们使用的是 render 来动态生成 DOM 元素。 在 vue 官方文档有这么一段话：Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，在这种场景中使用 template 并不是最好的选择：首先代码冗长，为了在不同级别的标题中插入锚点元素，我们需要重复地使用 &lt;slot&gt;&lt;/slot&gt;。虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 render 函数，这时你可以用 render 函数，它比 template 更接近编译器。就是说在一个 负载的 html 元素中，就比如表格，我们不是用 html 代码去编辑的，而是通过 render 函数来生成 虚拟 DOM 元素 ，通过 js 代码来放置到 DOM 中去的。 vue 的 render 二、Node 节点 与 VNode 虚拟节点2.1 普通 DOM 节点与 虚拟 DOM 节点123456&lt;!-- 普通 DOM --&gt;&lt;div id=\"main\"&gt; &lt;p&gt;111&lt;/p&gt; &lt;p&gt;222&lt;/p&gt; 333&lt;/div&gt; 123456789101112/* 虚拟 DOM */var vnode=&#123; tag:'div', attributes:&#123; id:'main' &#125;, children:[ &#123;tag:'p','111'&#125;, &#123;tag:'p','222'&#125;, '333' ],&#125; 2.2 vue 中的 vnode 虚拟节点tag：当前节点的标签名data：当前节点的数据对象（下⼀页）children：⼦节点，数组，也是 VNode 类型text：当前节点的⽂本，⼀般⽂本节点或注释节点会有该属性elm：当前虚拟节点对应的真实的 DOM 节点ns：节点的 namespacecontent：编译作⽤域functionalContext： 函数化组件的作⽤域key：节点的key属性，⽤于作为节点的标识，有利于 patch 的优化componentOptions：创建组件实例时会⽤到的选项信息child：当前节点对应的组件实例parent：组件的占位节点raw：原始 htmlisStatic：静态节点的标识isRootInsert：是否作为根节点插被 &lt;transition&gt; 包裹的节点，该属性的值为falseisComment：当前节点是否是注释节点isCloned：当前节点是否为克隆节点isOnce：当前节点是否有 v-once 指令 123456789101112131415161718192021/* 源码中 VNode 的定义 */export interface VNode&#123; tag：//当前节点的标签名 data：//当前节点的数据对象（下一页） children//节点，数组，也是 VNode 类型 text：//当前节点的文本，一般文本节点或注释节点会有该属性 elm：//当前虚拟节点对应的真实的 DOM 节点 ns：//节点的 namespace content：//编译作用域 functionalContext： //函数化组件的作⽤域 key：//节点的key属性，用于作为节点的标识，有利于 patch 的优化 componentOptions：//创建组件实例时会用到的选项信息 child：//当前节点对应的组件实例 parent：//组件的占位节点 raw：//原始 html isStatic：//静态节点的标识 isRootInsert：//是否作为根节点插入，被 &lt;transition&gt; 包裹的节点， 该属性的值为false isComment：//当前节点是否是注释节点 isCloned：//当前节点是否为克隆节点 isOnce：//当前节点是否有 v-once 指令&#125; 三、普通 组件 与 render 函数组件1234567891011121314151617//普通 组件vue.component('ele',&#123; template:`\\ &lt;div id='element' :class='&#123;show:show&#125;'\\ @click='handleClick'&gt;文本内容&lt;/div&gt;`, data:function()&#123; return&#123; show:true &#125; &#125;, methods:&#123; handleClick()&#123; // &#125; &#125;&#125;) 12345678910111213141516171819202122232425262728293031//render 函数组件vue.component('ele',&#123; render:function(createElement)&#123; return createElement( 'div', &#123; class:&#123; 'show':this.show &#125;, attrs:&#123; 'id':'element', style: \"margin-bottom:10px\" &#125;, on:&#123; click:this.handleClick &#125; &#125;, '文本内容' ) &#125;, data:function()&#123; return&#123; show:true &#125; &#125;, methods:&#123; handleClick()&#123; // &#125; &#125;&#125;) 四、render /渲染函数 的使用4.1 为什么要用 render 函数普通组件在该场景下的问题 • 代码冗长 • template 中大部分代码是相同的 • 外层必须包含以一个无用的 &lt;div&gt; （vue 中），或者是 &lt;view&gt;(小程序中) 4.2 工作原理/流程render 函数:生成虚拟节点 =&gt;createElement():基于虚拟节点创建 DOM 节点 =&gt;diff: 状态更新后，进行对比，生成补丁对象 =&gt;patch:遍历补丁对象生成 DOM 节点 4.3 render 函数使用方法4.3.1 createElement(tag,dataObj,children/text) 函数第 1 个参数必选，可以是 1 个 HTML 标签，也可以是 1 个组件或函数；第 2 个是可选参数，数据对象第 3 个是子节点，也是可选， 简单来说 第 1 个参数是 标签，第 2 个参数是属性与特性，事件等等，第 3 个参数是标签内的内容（文本或者是子标签） 12345678910111213141516171819202122232425262728293031323334createElement( 'div',//第 1 个参数必选，可以是 1 个 HTML 标签，也可以是 1 个组件或函数； &#123; // 第 2 个参数数据对象，可选参数 class:&#123; show:this.show &#125;,//v-bind:class style:&#123; // &#125;,//v-bind:style attrs:&#123; id:'idName' &#125;,//一般的 HTML 属性，比如 id props:&#123; someProp:'foo' &#125;,//props on:&#123; click:this.handleClick &#125;,//自定义定义事件 nativeOn:''//原生事件，比如 click // 当然这里不只是这些，还有很多属性，参照 3.3.3 节 &#125;, [ // 第 3 个是子节点，子节点 array 数组，可选参数，也是用 createElement() 函数构造的 createElment('h1','hello world'), createElment(MyComponent,&#123; props:&#123; someProp:'foo' &#125; &#125;), 'bar'// 这个是什么子节点啊 指的是&lt;div&gt;&lt;/div&gt; 中的内容，文本，或者是其他的子标签 // 这里的意思是 div 标签中有 一个 h1 标签，一个 MyComponent 子组件 还有直接文本 bar ]) 123456&lt;!-- 得到的普通 DOM 效果如下代码--&gt;&lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;MyComponent :someProp='foo'&gt;&lt;/MyComponent&gt; bar&lt;/div&gt; 4.3.2 createElement() 函数第 1 个参数（必填）12'div' # 一个 div 元素'h' + this.level # 若 level 为 1 则是 h1 标签 4.3.3 createElement() 函数第 2 个参数（可选） 【源码中 VNodeData 的定义】1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 源码中 VNode 的定义 */export interface VNodeData&#123; key:'myKey' , //string | number //节点的 key 属性，用于作为节点的标识，有利于 patch 的优化 slot:'name-of-slot', //string 如果组件是其他组件的子组件，需为插槽指定名称 scopedSlots:&#123; // 作用域插槽格式 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; default: props =&gt; createElement('span', props.text)//&#123;[key:string],ScopedSlot&#125; &#125;, ref:'myRef',//如果你在渲染函数中向多个元素都应用了相同的 ref 名，那么 `$refs.myRef` 会变成一个数组 refInFor: true, tag:'',//当前节点的标签名 staticClass:'', class:&#123; //和`v-bind:class`一样的 API，接收一个字符串、对象或字符串和对象组成的数组 foo: true,// 任何类型数据 bar: false &#125;, staticStyles:&#123;&#125;,//&#123;[key:string],any&#125; style:&#123; //和`v-bind:style`一样的 API，接收一个字符串、对象或对象组成的数组 color: 'red', fontSize: '14px'// object[],object &#125;, props:&#123; someProp:'foo'//&#123;[key:string],any&#125; 组件 props &#125;, attrs:&#123; id:'idName',//&#123;[key:string],any&#125; 普通的 HTML 特性 name: headingId, href: '#' + headingId &#125;, domProps:&#123; // DOM 属性 innerHTML: 'baz'//&#123;[key:string],any&#125; &#125;, hook:&#123;&#125;,//&#123;[key:string],func&#125; on:&#123; //事件监听器基于 `on`，所以不再支持如 `v-on:keyup.enter` 修饰器，需要手动匹配 keyCode。 click: this.clickHandler//&#123;[key:string],func,func[]&#125; &#125;, nativeOn:&#123; //仅用于组件，用于监听原生事件，而不是组件内部使用，`vm.$emit` 触发的事件。 click: this.nativeClickHandler//&#123;[key:string],func,func[]&#125; &#125;, transition:object, show:true,// boolean inlineTemplate:&#123; render:function()&#123;&#125;, staticRenderFns:function[] &#125;, directives: [ // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` 赋值，因为 Vue 已经自动为你进行了同步。 //VNodeDirective[] &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], keepAlive:true //boolean&#125; 4.3.4 createElement() 函数第 3 个参数（可选）1234[ createElement(tag,dataObj,children/text), // 子元素, createElement(tag,dataObj,children/text), //子元素, ''//标签中的文本内容 ] 4.3.5 完整示例12345678910111213141516171819202122232425262728293031323334353637var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join('')&#125;Vue.component('anchored-heading', &#123; render: function (createElement) &#123; // 创建 kebab-case 风格的ID var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^\\-|\\-$)/g, '') //返回一个 createElement 构建的虚拟 DOM return createElement( 'h' + this.level,//第一个参数 [//第二个参数 createElement('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 4.4.6 createElement 用 h 来替代 !!!!!!!!!!!!!!!!!!!!!!!!!将 h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的，如果在作用域中 h 失去作用，在应用中会触发报错。 1234567891011121314151617181920212223242526272829Vue.component('anchored-heading', &#123; render: function (h) &#123; // 创建 kebab-case 风格的ID var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^\\-|\\-$)/g, '') //返回一个 h 构建的虚拟 DOM return h( 'h' + this.level,//第一个参数 [//第二个参数 h('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 六、约束6.1 VNodes 必须唯一所有的组件树中，如果 VNode 是组件，或含有组件的 slot，那 VNode 必须唯一 6.2 组件的复用123456789101112131415161718//局部声明组件,&lt;div id=\"app\"&gt; &lt;ele&gt;&lt;/ele&gt;&lt;/div&gt;var Child=&#123; render:function(createElement)&#123; return createElement('p','text') &#125;&#125;vue.component('ele',&#123; render:function(createElement)&#123; var ChildNode = createElement(Child) return createElement('div', ChildNode, //这里的做法是错误，因为组件重复了xxxxxxxxxxxxx ChildNode ) &#125;&#125;) 1234567891011121314151617//局部声明组件，我们可以哟弄 map 遍历的办法var Child=&#123; render:function(createElement)&#123; return createElement('p','text') &#125;&#125;vue.component('ele',&#123; render:function(createElement)&#123; return createElement('div', Array.apply(null,&#123; // 对的，√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√ length:5 &#125;).map(function()&#123; return createElement(Child) &#125;) ) &#125;&#125;) Array.apply() 函数与 ES6 的 Array.from() 有点类似.apply() 的第一个参数是对象，第二个参数是数组，作为参数列表。{length: 5} 就可以看作一个类数组对象，长度是 5，每个元素，比如 v[0]是 undefined。所以Array.apply(null, { length: 5}) 相当于Array(undefined, undefined, undefined, undefined, undefined) 既然已经到了 ES6 了，那么我们还是用 Array.from() 方法比较好, Array.from() 123456Array.from(&#123; length: 3 &#125;); //[ undefined, undefined, undefined ]// 这个方案只需要一个参数就可以了，不需要再用 null 了，//当然Array.from() 方法可以有第 2 个参数，就是对 第一个参数中 的每个值进行遍历。就类似 .map Array.from(arrayLike, x =&gt; x * x); // Array.from() 方法的 第 2 个参数Array.from(arrayLike).map(x =&gt; x * x); // 数组的 map() 方法 如果用的是 Array.from 上面的 render 函数可以修改如下。 12345678910111213//局部声明组件，我们可以哟弄 map 遍历的办法var Child=&#123; render:function(createElement)&#123; return createElement('p','text') &#125;&#125;vue.component('ele',&#123; render:function(createElement)&#123; return createElement('div', Array.from(&#123;length:5&#125;,()=&gt;createElement(Child))// 对的，√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√ ) &#125;&#125;) 6.3 slot 的克隆1234567891011121314151617181920212223242526272829 &lt;!-- 错误做法,因为 slot 包含了组件，并且重复了 --&gt;&lt;div id='app'&gt; &lt;ele&gt; &lt;div&gt; &lt;Child&gt;&lt;/Child&gt; &lt;/div&gt; &lt;/ele&gt;&lt;div&gt;&lt;script&gt; // 全局 vue.component('Child',&#123; // 错的 render:function(createElement)&#123; return createElement('p','text') &#125; &#125;) vue.component('ele',&#123; render:function(createElement)&#123; return createElement('div', [ this.$slots.defalut,// 错的 this.$slots.defalut ] ) &#125; &#125;) var app = new Vue(&#123; el:'#app' &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233// 正确的做法vue.component('ele',&#123; render:function(createElement)&#123; // 克隆 slot 的节点方法 function cloneVNode(VNode)&#123; // 递归遍历所有的子节点并且克隆 const clonedChildren = VNode.children &amp;&amp; VNode.children.map(function(vnode)&#123; return cloneVNode(vnode) &#125;) const cloned = createElement( vnode.tag, vnode.data, clonedChildren ) cloned.text = vnode.text //当前节点的文本，一般文本节点或注释节点会有该属性 cloned.isComment= vnode.isComment////当前节点是否是注释节点 cloned.componentOptions= vnode.componentOptions//创建组件实例时会用到的选项信息 cloned.elm= vnode.elm//当前虚拟节点对应的真实的 DOM 节点 cloned.context= vnode.context cloned.ns= vnode.ns//节点的 namespace cloned.isStatic= vnode.isStatic//静态节点的标识 cloned.key= vnode.key//节点的key属性，用于作为节点的标识，有利于 patch 的优化 return cloned &#125; const vNodes = this.$slots.default const clonedVNnodes = vNodes.map(function(vNode)&#123; return createElement('div',[ vNodes, clonedVNnodes ]) &#125;) &#125;&#125;) 七、 使用 js 代替模板功能在 Render 函数中，没有指令，一切都可以⽤用 JS 来实现。就是说 v-if，v-else，wx-if，wx-for 这样的指令在 render 函数中是不存在的，v-if，v-else，wx-if ：在 render 函数中 js 代码就是 if…else 语句来的，v-for，wx-for：在 render 函数中 js 代码就是 map 遍历来做的 7.1 v-if，v-else，wx-if123456789101112131415161718192021222324252627282930&lt;div id='app'&gt; &lt;ele :show='show'&gt;&lt;/ele&gt; &lt;!-- 这里是 ele 子组件 --&gt; &lt;button @click='show = !show'&gt;切换 show&lt;/button&gt;&lt;div&gt;&lt;script&gt;//在 ele 这个组件中创建 子组件 vue.component('ele',&#123; render:function(createElement)&#123; if(this.show)&#123; return createElement('p','show 的值为 true') &#125;else&#123; return createElement('p','show 的值为 false') &#125; &#125;, props:&#123; // 这是从 app 组件传来的 show 值 props 传值 show:&#123; type:Boolean, defalut:false &#125; &#125; &#125;) var app = new Vue(&#123; el:'#app', data:&#123; show:&#123; show:false &#125; &#125; &#125;)&lt;/script&gt; 7.2 v-for,wx-for1234567891011121314151617181920212223242526&lt;div id='app'&gt; &lt;ele :list='list'&gt;&lt;/ele&gt; &lt;!-- 这里是 ele 子组件 --&gt;&lt;div&gt;&lt;script&gt; vue.component('ele',&#123; render:function(createElement)&#123; var nodes = [] var n = this.list.length for(var i =0;i&lt;n;i++)&#123; nodes.push(createElement('p',this.list[i]) &#125; return createElement('div',nodes) &#125;, props:&#123; // 这是从 app 组件传来的 show 值 props 传值 list:&#123; type:Array, &#125; &#125; &#125;); var app = new Vue(&#123; el:'#app', data:&#123; list:['xiaomi','liuliu','meimei'] &#125; &#125;)&lt;/script&gt; 7.3 v-if 与 for 结合1234567891011121314151617181920212223242526272829303132&lt;div id='app'&gt; &lt;ele :list='list'&gt;&lt;/ele&gt; &lt;!-- 这里是 ele 子组件 --&gt;&lt;div&gt;&lt;script&gt;//在 ele 这个组件中创建 子组件 vue.component('ele',&#123; render:function(createElement)&#123; var n = this.list.length if(n)&#123; return createElement('ul',this.list.map(function(item)&#123; return createElement('li',item) &#125;)) &#125;else&#123; return createElement('p','列表为空') &#125; &#125;, props:&#123; // 这是从 app 组件传来的 show 值 props 传值 list:&#123; type:Array, defalut:function()&#123; return [] &#125; &#125; &#125; &#125;); var app = new Vue(&#123; el:'#app', data:&#123; list:['xiaomi','liuliu','meimei'] &#125; &#125;)&lt;/script&gt; 7.4 v-model1234567891011121314151617181920212223vue.component('ele',&#123; render:function(createElement)&#123; var that = this return createElement('div',[ createElement('input',&#123; domProps:[ value:this.value ], on:&#123; input:function(e)&#123; than.value = e.target.value &#125; &#125; &#125;), createElement('p','value:'+ this.value) ]) &#125;, data:function()&#123; return:&#123; value:'' &#125; &#125; &#125;) 八、render 事件修饰符123456.stop =&gt; event.stopPropagation().prevent =&gt; event.preventDefault().self =&gt; if(event.target !== event.currentTarget) return.enter / .13 =&gt; if(event.keyCode !== 13) return # 替代 13 位 需要的 keyCode.ctrl/.alt/.shift/.mata =&gt; if(!event.ctrlKey) return# 根据需要替换 ctrlKey 为 ctrlKey 或 altKey 又或者 shiftKey ，再或者 mataKey 8.1 事件修饰前缀123.capture =&gt; !.once =&gt; ~.capture.once/.once.capture =&gt; ~! 12345on:&#123; '!click':this.doThisInCapturingMode, // 发生在捕获阶段的事件函数 '~keyup':this.doThisOnce,//按键执行一次 '~!mouseover':this.doThisOnce,//鼠标经过捕获阶段执行一次&#125; 九、插槽 slot插槽分为， 单个插槽 ：内容由父组件决定 （不传值） 静态插槽 &lt;Child&gt;333333&lt;/Child&gt; ` &lt;slot&gt;&lt;/slot&gt; ` 具名插槽 ：内容由父组件决定 （不传值） 静态插槽 111 222 333 ` &lt;slot name=&apos;header&apos;&gt;&lt;/slot&gt; &lt;slot name=&apos;body&apos;&gt;&lt;/slot&gt; &lt;slot name=&apos;footer&apos;&gt;&lt;/slot&gt; ` 作用域插槽：内容由子组件决定（子组件绑定传值给父组件） 作用域插槽 &lt;Child scoped-slot=&#39;props&#39;&gt;&lt;/Child&gt; ` &lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt; ` 9.1 this.$slots 访问 静态插槽 的内容可以通过 this.$slots 访问 静态插槽 的内容，得到的是一个 VNodes 数组： 1234567render: function (createElement) &#123; //返回 `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement( 'div', this.$slots.default )&#125; 9.2 this.$scopedSlots 访问作用域插槽 scoped-slot = ‘props’this.$scopedSlots 访问 作用域插槽，得到的是一个返回 VNodes 的函数： 123456789101112props: ['message'],render: function (createElement) &#123; //返回 `&lt;div&gt;&lt;slot :text=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement( 'div', [ this.$scopedSlots.default(&#123; text: this.message &#125;) ] )&#125; 123456789101112131415161718192021222324252627282930//用 渲染函数 向子组件 中 传递作用域插槽 参见 4.3.4render: function (createElement) &#123; return createElement( 'div', [ createElement( 'child', &#123; // 在数据对象中传递 `scopedSlots` // 格式：&#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement( 'span', props.text ) &#125; &#125; &#125; ) ] )&#125;//上面返回的 html 如下&lt;div&gt; &lt;child scoped-slot='props'&gt; &lt;span&gt;&#123;&#123;props.text&#125;&#125;&lt;/span&gt; &lt;/child&gt;&lt;/div&gt; 9.3 slot 默认内容this.$slot.default = undefined,说明父组件中没有定义 slot ，这时可以自定义显示的内容。 123456789101112131415161718192021&lt;div id='app'&gt; &lt;ele :list='list'&gt;&lt;/ele&gt; &lt;ele&gt; &lt;p&gt;slot 的内容，这里 ele 组件插槽里面是有这段 p 标签的内容的&lt;/p&gt; &lt;/ele&gt;&lt;div&gt;&lt;script&gt;//在 ele 这个组件中创建 子组件 vue.component('ele',&#123; render:function(createElement)&#123; if(this.$slot.default)&#123; return createElement('div','没有使用 slot 时 显示的文本') &#125;else&#123; return createElement('div','this.$slot.default') &#125; &#125; &#125;); var app = new Vue(&#123; el:'#app' &#125;)&lt;/script&gt; 十、函数式组件Vue.js 提供了 1 个 functional 的布尔值选项，设置为 true 可以使组件无状态和无实例，也就是没有data 和 this 上下文，这样用render 函数返回虚拟节点可以更容易渲染，因为函数化组件只是 1 个函数，渲染开销要⼩很多。 使用函数化组件时，Render 函数提供了第 2 个参数 context 来提供临时上下文，组件需要的 data、props、slots、children、parent 都是通过这个上下文 来传递，比如 this.level 要改写为context.props.level，而 this.$slots.default 改写为 context.children。 十二、vue.js 中 的 render1234567891011121314151617181920212223242526272829303132333435363738394041424344// 直接使用 h() 方法构建 虚拟 DOMrender: (h, params) =&gt; &#123; return h(\"ButtonGroup\", [ h( \"Button\", &#123; props: &#123; type: \"info\", icon: \"ios-analytics\" &#125;, on: &#123; click: () =&gt; &#123; this.showDetail(params.index); &#125; &#125; &#125;, \"详情\" ), h( \"Button\", &#123; props: &#123; type: \"error\", icon: \"ios-trash\" &#125;, on: &#123; click: () =&gt; &#123; this.remove(params.index); &#125; &#125; &#125;, \"删除\" ) ]);&#125;// 直接使用 h() 方法构建 虚拟 DOM// 触发事件/*on: &#123; click: () =&gt; &#123; this.showDetail(params.index); &#125;&#125;*/ 12345678910111213141516171819202122232425// return 中写的是 html 片段render: (h, params) =&gt; &#123; return ( &lt;ButtonGroup size=\"default\"&gt; &lt;Button type=\"success\" icon=\"md-create\" onClick=&#123;() =&gt; &#123; this.handleClickEditRobot(params.row) &#125;&#125;&gt;&lt;/Button&gt; &lt;Button type=\"warning\" disabled=&#123;params.row.status === '掉线'&#125; icon=&#123;params.row.status === '运行中' ? 'ios-pause' : 'ios-play'&#125; onClick=&#123;() =&gt; &#123; this.handleClickPlayOrPause(params.row) &#125;&#125;&gt;&lt;/Button&gt; &lt;Button type=\"error\" icon=\"ios-trash\" onClick=&#123;() =&gt; &#123; this.handleClickDelete(params.row) &#125;&#125;&gt;&lt;/Button&gt; &lt;/ButtonGroup&gt; )&#125;// return 中写的是 html 片段// 触发事件/*onClick=&#123;() =&gt; &#123; this.handleClickEditRobot(params.row)&#125;&#125; */// 通过一对花括号来写一个函数片段在里面!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!值得学习。","tags":[]},{"title":"Chrome 开发者工具的使用详解","date":"2018-08-19T15:57:28.000Z","path":"2018/08/19/⑧-【JS 工具集-拓展语言】开发者工具使用/","text":"一、Chrome 开发者工具在编写代码时，少不了需要调试代码，调试样式，检查 bug 等等,肯定要把开发者工具学会。 谷歌开发者工具中文文档PHP网站中文开发者文档,这个php 网站的说得非常的好，还是看这个好了，非常的全，不仅说了浏览器的调试问题，还有其他的问题的调试。 二、面板基础了解 Elements(元素面板)： 使用“元素”面板可以通过自由操纵 DOM 和 CSS 来重演您网站的布局和设计。 Console(控制台面板)： 在开发期间，可以使用控制台面板记录诊断信息。或者使用它作为 shell,在页面上与 JavaScript 交互。 Sources(源代码面板)：断点调试 JS（就是 debugger 调试） 在“源代码”面板中，可以断点调试 JavaScript 。或者通过 Workspaces（工作区）连接本地文件，使用开发者工具实时编辑。 Network(网络面板) 使用“网络”面板了解请求和下载的资源文件，并优化您的网页加载性能。 Performace【原 Timeline (时间轴面板)】 使用时间轴面板，可以通过记录录像提高页面的运行时性能。并探索网站生命周期内发生的各种事件。 Memory【 Profiles(分析面板)】 如果你需要比时间轴面板提供的更多信息，请使用“配置”面板，例如以跟踪内存泄漏。 Application(资源面板) 使用“资源”面板检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie，应用程序缓存，图像，字体和样式表。 Security(安全面板) 使用安全面板调试混入内容问题，您的证书的安全隐患及更多。 Audits 对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的 CSS 文件等。 Vue：vue-develop 开发插件 三、打开开发者工具 在 Chrome 菜单中选择 更多工具 &gt; 开发者工具。 在页面元素上右键点击，选择 “检查”。 使用快捷键 Ctrl+Shift+I (Windows) 或者 Cmd+Opt+I (Mac)。 四、Elements(元素面板)php 网站文档与视频 一些使用技巧： 在 DOM 树中，按住 alt 键去点击一个节点，可以将它的所有子节点全都展开。选择DOM元素和在带有剪头的地点按住Alt +点击鼠标左键，可以展开所有子节点 在 dom 中，我们可以选中一行dom元素，然后在右键，选择 break on ，可以看到，到这里就会有断点发生。DOM BreakPoints 点击右键之后，这里有很多选项都是之前很少用但是非常有用的，比如编辑、copy、hide（这样就不用自己设置 display：none 了） 还有测试 force state (active、hover、focus、visited)的情况，这样就不用我们每次亲自去测试了。另外， 包括断点中的内部节点发生变化、属性发生变化、断点要移除之后都会出现断点的情况。可以多多利用之。 查找不生效的样式： 在样式中，如果我们看到某个样式是划横线，并且前面有个换色三角形的标志，说明这个属性是不存在的，其实就是我们在编辑 css 文件的时候写错了，然后这个属性不能生效，比如说在尺寸属性的时候写 px 成了 xp 就不会生效了。 增加一个 class 样式： 在 style 的模块中，有一个 + 号，点击这里可以增加样式。然后编辑样式属性与值 还可以直接在 DOM 中选中元素，然后右键 edit as html 就可以像是在编辑器中那样去编辑了 颜色的选择： 如果 ui 不是 ui 设计师设计，而是我们自己做的，希望选择自己喜欢的颜色的时候，在编辑器去调颜色是很麻烦的，直接在 浏览器中去点击色块就可以调颜色。 选中 DOM 之后右键copy 可以去复制浏览器中的 html 代码，复制到我们的 编辑器中去使用 某些交互动画的 DOM 查找 有的是 hover 啊，或是交互才会显示出来的元素，我们通过箭头去是找不到对应的 DOM 的，太难了。这个时候我们应该在显示页面中去右键-&gt; 审查，这样就会跳转到对应的 DOM 节点元素上了。（这个时候鼠标不要再移动到显示页面了，否则又会恢复到原来的样子，我们需要调试的 DOM 节点就又找不到了） 4.1 style 模块（查看属性继承至哪里）从上往下是元素继承来的样式，一直继承自 html，这个继承顺序是按照嵌套顺序来排列的。在这里可以修改样式来及时的观察页面显示。 Styles(样式)窗格允许您以尽可能多的方式更改本地 CSS，包括编辑现有样式，添加新样式，添加样式规则。这个只是在浏览器修改了没有在编辑器中改。如果你想要样式持久（他们页面重新加载而丢失），您需要将它们持久化到您的开发工作区？什么意思没有看懂，还是在自己的编辑器中去修改就好了，不要搞这种不必要的麻烦，以后熟悉的了话可以学习。 4.2 computed 模块（该节点的所有样式/盒子模型）这个元素的盒模型，盒模型的下方是这个元素的所有属性，我们可以通过代码其来判定我们写的代码存在的问题。可以快速找到需要查看的样式，点击之后跳转到 style 模块去修改调试 4.3 Event Listeners 事件监听模块我们选择的元素中被绑定的事件都会在这里显示。我们可以通过查看该事件来查看作用域链。 五、 Console(控制台面板)文档与视频 5.1 console 命令输出 123456// 上面图片中的 console.log 输出，我们可以做成这样拥有样式的，可以让我们在使用 console 命令调试的时候快速的找到目标，也不再显得单调console.log('%c我%c爱%c你','font-size:60px;color:red','font-size:40px;color:blue','font-size:20px;color:green')// 用 %c 符号来分开字符串，然后分别修饰 后面是 css 修饰// %s 还有 %d 啊等等，这些其实都是可以使用在 console 输出命令中的。// 但是应该没有这么必要，我们最终的目的只是为了调试代码，又不搞什么花样。 六、 Sources(源代码面板) 断点调试在编写 JavaScript 代码时，如果出现了 bug，就要不断的去找错误，如果 console 控制台中提示还好说，可是没有提示恐怕就要费一番周折了。但是有了 chrome 这个浏览器，我们通过开发者工具就可以很好的实现调试了。这里我们要学习的就是这个 sources 页面资源面板，通过这个模块，我们可以找到任何我们需要的页面资源。 设置断点文档与视频官网文档都看不懂，这里有篇非常仔细的文档 6.1 在 sources 面板快速找到对应的文件 从其他面板直接跳转过来，console 面板，element 面板，等等 跳过 js 文件 在 sources 面板 手动的找到文件，但是这个太麻烦了 在 sources 面板 使用快捷键， ctrl + p 如果代码是压缩的，点击花括号可以展开代码。 sources 调试 JS 代码视频学习,这个视频调试说得还不错. 6.1 调试面板的了解 断点：在代码中输入 debugger; 那么就会在运行中自动在这里打一个断点， 但是这样很麻烦，我们直接在 source 面板中中设置断点要好很多，后期还不用删代码。可以在代码的左边打断点，蓝色代码所在行表示目前代码的执行阶段，深蓝色代表将要执行但还未执行的代码。而浅蓝色代表已经执行过了的代码。 我们把鼠标停留在 变量中可以显示变量的值。如果希望得到一个变量的计算值，就选中那个算式，即可显示当前结果值。 6.1.1 代码的暂停与开启执行 :`pause script excution`。,暂停 js 代码运行，如果有定时器就会定格在定时器。没有就是当前执行到哪里就停止在哪里。 :`resume script excution`。恢复 js 代码的执行，点击就可以恢复代码的执行。 6.1.2 断点测试① 先设置断点② 在显示页面操作，触发事件，触发这个我们设置了断点的 ui 页面的按钮啊，或者其他的什么乱七八糟的元素！！！！！！！原来是这样触发的啊！！！！！！那么多次学习就是这个点没有找到！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 这时候我们可以看到断点之上的语句结果已经被执行出来的，接下来就是看我们希望如何去操作了，利用好 4 个断点调试的操作③ 点击下面的按钮来操作代码的执行（下面 4 个选项操作）④ 代码被执行完了，没有错误肯定就会一直执行下去了,如果有页面跳转啊什么的,页面都不一样的,(没错肯定也就不调试了.) 有错误啊还要观察，点击 ，来恢复执行 :`step over next function`, **over 也就是跨函数方法运行，它不会进入到函数内部，而是直接给出方法执行之后的结果** 直接跳到下一个函数。即如果遇到一个函数，它会直接执行完这个函数，直接执行函数进入下一步，不显示函数执行的细节。 :`step into next function`, **into 也就是进入函数方法去运行。可以在函数方法里面一步步执行来观察结果** 进入函数。即如果遇到一个函数，它不会一下运行完这个函数，而是进入函数内部，一步一步地执行，这样，我们可以更清楚地观察执行过程。 恢复执行之后,如果后面有断点,它就会又停下来的.所以我们设置多个断点调试完全 ok . 恢复执行之后,如果后面没有代码了,它就会跑到第一个断点处,让我们可以再次快速定位去调试. :`step out of current function`, **out of current 就是退出函数函数方法的运行，与 into 是配套的呀** 前面函数内部，但是我们现在不希望一步步执行了，希望尽快退出这个函数。点击这个按钮可以结束这个函数的步骤执行。 我们可以通过此功能来一下执行完函数内部剩下的代码。其实也就是让他从进入可以一步步执行的状态,转成![2](http://liuxmoo.foryung.com/222222222222222222222222222222222.png)这个一步执行完成的状态,不要浪费时间. :`step` **step 就是一步步的执行** 6.1.3 禁用断点 : Deactivate breakpoints 停用断点 在我们调试的时候不可能都是只用一个断点,很多时候我们打了多个断点,这样一样,代码就是老是会暂停,我们不得不一次次的恢复代码执行,这个是很烦的,但是我们又不希望去取消我们设置好的断点,我们调试需要的呀, 那么这个 停止断点使用的按钮就是拿来解决这个问题用的。 activate breakpoints 恢复使用断点 当然如果不是需要关闭恢复所有的断点，可以使用 breakpoints 中的勾选来挑选暂停使用与恢复使用。 使用中的断点是深蓝色的，禁用的是浅色的 : pause on exceptions 遇到异常就暂停 运行代码的时候，将这个打开，勾选功能。这样运行的时候，遇到异常的话，代码就会在这里停下来，比如变量没有定义就是用。打开这个也方便我们找到问题代码。 6.2 watch 的使用 利用鼠标：在设置断点的片段代码中我们可以得知其中变量的当前值，或者几个变量的计算值。 watch：这个方法更加直观的去观察我们变量计算 如果在代码中 b = a - 1 的值对我们十分重要，我们把它加入到 watch 中去调试① 选中 b = a - 1 代码② 然后在点击最后一个选项 Add selected text to watches, 然后注意观察右上角的 watch③ 在执行过程中，表达式的值有改变，可以在 watch 中可以看到。Watch 下面的表达式会立即更新，这对于我们监控起来还是非常方便的。 1234567891011121314151617Array.prototype.binary_search = function (low, high, key) &#123; if (low &gt; high) &#123; return -1; &#125; // 注意： 这里是两者相加，如果是相减，明显就是错的，实践出真知~ var mid = parseInt((high + low) / 2); if (key &lt; this[mid]) &#123; // 如果需要观察 this[mid] 的值，就必须使用 watch ，使用鼠标就没得到这样的变量的值 return this.binary_search(low, mid - 1, key); &#125; else if (key &gt; this[mid]) &#123; return this.binary_search(mid + 1, high, key); &#125; else &#123; // return this[key]; // 最后返回key也是可以的。 return this[mid]; &#125;&#125;var arr = [15, 18, 25, 45, 56, 59, 78, 83];console.log(arr.binary_search(0, arr.length - 1, 56)); 6.3 call stack 的使用先来读懂代码错误的位置吧，如果错误提示在 console 面板中的话，都会告诉我们错误是在哪里的（庆幸 console 面板 有提示错误吧，没有提示错误的 bug 绝对难找）。 12345test.html:15 Uncaught ReferenceError: a is not defined test.html:15 # 这里提示在 test.html 文件的第 15 行中有错误，变量 a 没有定义 at test.html:15 # ① 错误在 test.html 文件的第 15 行 （因为它处在一个匿名函数中，所以 at 就没有说明具体的环境，程序在这里停止了，当前栈的环境在第 15 行） at aa (test.html:17) # ② at aa 这是一个函数，即如果退出当前栈环境后所在的环境，那显然就是在函数 aa 的环境之下了（也就是提示我们 ① 如果得到执行， # 下一步即将进入的环境应该是 17 行的坏境，也就是 aa 函数环境） at test.html:19 # ③ 如果第 ② 步能够执行完，即将进入的是 19 行的环境 上面错误提示是 console 面板直接告诉我们的错误。其实 sources 面板中的 call stack 就是这个错误的就是这么一个由当前错误退出栈的一个过程。 核心问题就在当前错误上。后面指定的位置时行数。一句话：call stack 的顺序是由当前到原来的一个栈的退出的过程 6.4 scope 变量的作用域6.5 breakpoints 断点点击勾选可以关闭或者是选用需要调试的断点。使用中的断点是深蓝色的，禁用的是浅蓝色的。右键可以对断点进行操作，取消断点等等。 6.6 DOMpoints DOM 断点6.7 XHRpoints XHR 断点6.8 Event Listener breakpoints 事件监听断点当我们需要看某个元素，例如按钮的是如何执行哪些事件的，我们使用 element 面板来看，看到的对应的 DOM ，但是上面没有任何的 js，也没有显示的绑定事件。这个使用，我们就只能使用这个 Event Listener breakpoints 事件监听断点。勾选我们需要调试的事件，比如说勾选上 mouse-click 点击事件，然后再去 页面去点击这个按钮，然后就可以跳转到对应的这个按钮的点击事件函数里面去了，然后就可以对这个函数进行断点调试了。 12345678910111213141516171819202122232425`OPTIONS http://hete-api.gofoer.com/v1/user/session net::ERR_CONNECTION_RESET xhr.js?d13b:178`dispatchXhrRequest @ xhr.js?d13b:178xhrAdapter @ xhr.js?d13b:12dispatchRequest @ dispatchRequest.js?875c:59Promise.then (async)request @ Axios.js?7d5c:51wrap @ bind.js?4514:9Login @ login.vue?cef9:69click @ login.vue?7853:93invoker @ vue.esm.js?3bbd:2128fn._withTask.fn._withTask @ vue.esm.js?3bbd:1913`GET http://hete-api.gofoer.com/v1/result net::ERR_CONNECTION_RESET xhr.js?d13b:178` # 链接重置# 浏览器控制台错误 101 (net::ERR_CONNECTION_RESET) 的本身含义就是这个网站存在故障暂时无法访问，# 也就是说这个网站服务器被关闭或者是你的网络提供商将这个网站 IP 屏蔽，可以尝试刷新这个页面，或者搜索这个网站以方便寻找更多的访问途径。# 本机和测试环境都是 OK 的。但是一到线上就报错；可能原因总结如下，# 1、可能是服务器限制了文件上传的权限。解决方法：开通了文件上传权限。# 2、也许导致这种错误的方式有很多，可能是因为 post 请求时提交的数据过多而导致的。解决办法：修改 tomcat 的配置文件 server.xml# 3、服务器未开启；如静态文件运行时没有开启静态资源服务器就会报这个错误，文件上传功能。# 4、跨域请求的问题；如上传 excel 表格时，打开 FQ 就可以进行上传，否则会报 net::ERR_CONNECTION_RESET`GET http://hete-api.gofoer.com/v1/xxxx.png net::ERR_BLOCKED_BY_CLIENT xhr.js?d13b:178` # 客户端的网络问题# 如果遇到这个问题，我们复制网址可以打开的，遇到这类情况，一般都是浏览器安装的某个第三方扩展程序已阻止对此网页的访问。# 对服务器的请求已遭到某个扩展程序的阻止。# 可以通过以下办法解决：点击浏览器上的“工具”》“选项”》“广告过滤”》“拦截模式”》把拦截模式等级调低，比如原来是选第三个，现在可以更改为第二或第一个，那样就能解决这个问题了。其他浏览器应该也是广告拦截的缘故， 6.9 Event Listener 事件监听七、 Network(网络面板)文档与视频 ,看到这样的错误的话，如果没有前端发送的请求是没有问题的，那么就是后端的代码出现的 bug，让测试人员去找后端同事。 八、 Performace【原 Timeline (时间轴面板)】文档与视频 九、Memory【 Profiles(分析面板)】文档与视频 十、Application(资源面板)文档与视频 十一、Security(安全面板)文档与视频 十二、Security(安全面板)文档与视频 十三、Audits(安全面板)文档与视频 十四、移动设备模拟器点击面板的手机标识，就可以转化成移动设备模式，这个是开发移动端使用的调试模式。 下图为手机端下的显示模块。","tags":[]},{"title":"CSS3 深入理解--[transform 转换/变形]","date":"2018-08-19T14:57:27.000Z","path":"2018/08/19/[html-css]-css3-特效属性 transform 转换变形/","text":"一、前言 ①gradients 渐变：2 种或者两种背景色的线性/径向(角度) 渐变出来的效果，这个是静态的。 ②transform 转换：2D 转换与 3D 转换:移动、缩放、转动、拉长或拉伸，是动态的。 ③transition 过渡： 过渡是元素从一种样式逐渐改变为另一种的效果，也就是两种样式的过渡效果。通过过渡transition，可以让 web 前端开发人员不需要 javascript 就可以实现简单的动画交互效果，它是动态的但还不是动画。 ④animation 动画：这个是真正的动画。 本章学习 transform 转换/变形 二、前置属性2.1 transform-origin 更改转换元素的位置。（在子元素上面使用）123456789101112131415161718192021222324252627282930313233343536373839# 定义视图被置于 X Y Z 轴的何处（XYZ轴的正向分别是往右，往下，靠近用户眼睛。反之为反向）transform-origin: 50% 50% 0; # 默认值，元素的正中心。值都表示一个偏移量！！！！！！！！！！！！！！！# 第一个参数, 是二维的取值可以是 left center right length % 这 5 种写法# left center right ：相对应的变形中心偏移# length % ：定义变形中心距离盒模型的 左侧 的 &lt;length&gt; 或 &lt;percentage&gt; 偏移值# left =&gt; 0%# center =&gt; 50%# right =&gt; 100%# 第二个参数, 是二维的取值可以是 top center bottom length % 这 5 种写法# top center bottom ：相对应的变形中心偏移# length % ：定义变形中心距离盒模型的 顶部 的 &lt;length&gt; 或 &lt;percentage&gt; 偏移值# top =&gt; 0%# center =&gt; 50%# bottom =&gt; 100%# 第三个参数，表示的是三维的，取值只能是长度值 length，也就是 30px; 0; 这样的# length ：定义变形中心距离 用户视线（z=0处）就是屏幕的地方咯 的 &lt;length&gt;（不能是 &lt;percentage&gt;）偏移值。# 这个属性的可以有 1 个，2个，3个值都可以。# 1 个值，没有设置的值就是原始默认值transform-origin: 2px;transform-origin: center;transform-origin: left;transform-origin: bottom;transform-origin: inherit; # 继承父元素transform-origin: initial; # 原始值transform-origin: unset; # 不设置# 2 个值，就是 前面两个值transform-origin: 3cm 2px;transform-origin: left 2px;transform-origin: right top;transform-origin: top right;transform-origin: 2px 30% 10px;transform-origin: left 5px -3px;transform-origin: right bottom 2cm;transform-origin: bottom right 2cm; 1234567891011121314151617181920212223242526272829#div1&#123; /* 父元素 */ position: relative; height: 200px; width: 200px; margin: 100px; padding:10px; border: 1px solid black;&#125;#div2&#123; /* 子元素 */ padding:50px; position: absolute; border: 1px solid black; background-color: red; transform: rotate(45deg); /* 子元素需要旋转，不需要在父元素做什么操作 */ -ms-transform: rotate(45deg); /* IE 9 */ -webkit-transform: rotate(45deg); /* Safari and Chrome */ transform-origin:20% 40%;/* 子元素希望改变自己的圆心的位置， 其实就是在父元素中移动位置，将中心位置移到父元素中别的位置，完全可以使用 transform:translate()来替代的 */ -ms-transform-origin:20% 40%; /* IE 9 */ -webkit-transform-origin:20% 40%; /* Safari and Chrome */&#125;&lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt;HELLO&lt;/div&gt;&lt;/div&gt; 注意 transform-origin 指定变形中心点对 translate 位移没有影响，translate 位移始终相对于 元素正中心 进行位移 1234567891011/* 其实transform-origin只是一个语法糖而已，你总是可以用 translate 来代替它。每个transform-origin都可以被两个 translate 模拟出来（by CSS变形规范的编辑Aryeh Gregor）。例如： */transform: rotate(30deg);transform-origin: 200px 300px;/* 等价于 */transform: translate(200px, 300px) rotate(30deg) translate(-200px, -300px);transform-origin: 0 0; 2.2 transform-style 确定元素的子元素 是否位于3D空间中。使用在【父元素】上。还是在该元素所在的平面内被扁平化，如果被扁平化，则子元素不会独立的存在于三维空间。因为该属性不会被（自动）继承，所以必须为元素所有非叶子后代节点设置该属性。 123transform-style: preserve-3d; /* 让子元素处于 三维空间 3D */transform-style: flat; /* 子元素位于此元素所在平面内 2D 。这个是默认值!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */transform-style: inherit; /* 继承父元素 */ 左图的父 div 没有设 transform-style 默认是 flat，因此元素不会在Z轴展开（translateZ(16px) 失效），只能呈现 2D 效果。右图的父 div 上设了 transform-style: preserve-3d;，因此呈现了 3d 效果。 1234567891011121314.div1 &#123; float: left; background-color: red; transform: perspective(200px) rotateY(45deg);&#125;.div1 img&#123; transform: translateZ(16px);&#125;.p3d &#123; transform-style: preserve-3d;&#125;&lt;div class=\"div1\"&gt;&lt;img src=\"head75.png\" /&gt;&lt;/div&gt;&lt;div class=\"div1 p3d\"&gt;&lt;img src=\"head75.png\" /&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839#div1&#123; /* 父元素 */ position: relative; height: 200px; width: 200px; margin: 100px; padding:10px; border: 1px solid black;&#125;#div2&#123; /* 子元素 */ padding:50px; position: absolute; border: 1px solid black; background-color: red; transform: rotateY(60deg); /* 子元素需要围绕着 Y 轴旋转 3D 旋转 ，不需要在它的父元素做什么操作就可以做到*/ -webkit-transform: rotateY(60deg); /* Safari and Chrome */ transform-style: preserve-3d; /* 希望它的子元素（也就是孙子元素）处理 3D 空间,在这里设置 */ -webkit-transform-style: preserve-3d; /* Safari and Chrome */&#125;#div3&#123; /* 孙子元素 */ /* 希望自己不处理父元素（也就是上面的 div2）的平面，那么需要在其父元素设置 transform-style */ padding:40px; position: absolute; border: 1px solid black; background-color: yellow; transform: rotateY(-60deg); /* 孙子元素希望围绕着 Y 轴旋转，这个不需要在其父元素做什么操作 */ -webkit-transform: rotateY(-60deg); /* Safari and Chrome */&#125;&lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt;HELLO &lt;div id=\"div3\"&gt;YELLOW&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 查看上面的效果 注意!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 如果同时设了 transform-style: preserve-3d; 和 overflow: hidden;，3D 效果将失效，等价于 transform-style: flat;。如果你发现 3D 效果没有像预想地那样出现，可以检查一下（包括祖先元素）是否有 overflow: hidden;，该属性将 flatten everything… 2.3 perspective 指定 3D 的视距。表示的是 3D 效果离眼睛的距离。使用在【父元素】上。也可以在子元素调用变形函数来使用。perspective 属性指定了观察者与 z=0 平面的距离(电脑设备屏幕))，使具有三维位置变换的元素产生透视效果。z&gt;0 的三维元素比正常大，而 z&lt;0 时则比正常小，大小程度由该属性的值决定。 1234567/* length ,指定观察者距离 z=0 平面的距离，为元素及其内容应用透视变换。当值为 0 或 负值 时，无透视变换。*/perspective: none; /* 默认值 ,表示无 3D 效果，即 2D 扁平化。*/perspective: 20px; perspective: 3.5em;perspective: inherit;perspective: initial;perspective: unset; 123456789101112131415/* 图中 d 就是 perspective 视距(其实就是人的观察者离屏幕的距离？？)，Z就是translateZ轴的位移。Z 轴正向位移时，3D 舞台将放大。反之，Z 轴负向位移时，3D 舞台将缩小。上图 Z 是 d 的一半，因此 3D 舞台上的元素将是原来的 2 倍。下图 Z 同样是 d 的一半，但由于是 负值，所以 3D 舞台上的元素将缩小 三分之一。 */.x &#123; transform: perspective(200px) rotateX(60deg);&#125;.y &#123; transform: perspective(200px) rotateY(60deg);&#125;.z &#123; transform: perspective(200px) rotateZ(60deg);&#125;&lt;img class=\"x\" src=\"head75.png\" /&gt;&lt;img class=\"y\" src=\"head75.png\" /&gt;&lt;img class=\"z\" src=\"head75.png\" /&gt; 123456789101112131415161718192021222324252627282930313233.divsp &#123; display: inline-block; border: 1px blue dashed; margin-left: 30px; perspective: 100px; /* 父元素设置 视距 为 100px, 表示 3D 舞台距离你的眼睛 100px。 */&#125;.z1 &#123; transform: translateZ(-75px); /* 原始图片为 75px，缩小到 42.85px， */&#125;.z2 &#123; transform: translateZ(0px); /* Z 轴没有位移，因此仍旧是原始大小 */&#125;.z3 &#123; transform: translateZ(25px); /* 原始图片为 75px，放大后的图片为 100px。 */&#125;.z4 &#123; transform: translateZ(101px); /* 图片消失了，因为 3D 舞台距离你眼睛 100px，而图片从舞台往Z轴正向位移 101px，图片到了你脑袋后面自然什么都看不见。 如果是 100px 相当于图片紧贴着你的眼睛，所以全屏都是图片。 */&#125;&lt;div class=\"divsp\"&gt; &lt;img class=\"z1\" src=\"head75.png\" /&gt;&lt;/div&gt;&lt;div class=\"divsp\"&gt; &lt;img class=\"z2\" src=\"head75.png\" /&gt;&lt;/div&gt;&lt;div class=\"divsp\"&gt; &lt;img class=\"z3\" src=\"head75.png\" /&gt;&lt;/div&gt;&lt;div class=\"divsp\"&gt; &lt;img class=\"z4\" src=\"head75.png\" /&gt;&lt;/div&gt; 注意 这个属性我们是这样写的 perspective: 100px;，但是也会看到这样写的 transform: perspective(200px) rotateX(60deg);两种方法都是可以的，可以这样来理解perspective: 100px; 是属性写法，指定用于 3D 舞台，即 3D 舞台的视距，里面的 子元素 共享这个视距transform: perspective(200px) rotateX(60deg); 调用函数的写法，perspective() 函数指定只针对当前变形元素， 需要和 transform 其他函数一起使用，仅表示当前变形元素的视距。 3.4 perspective-origin 设置视距的基点。使用在【父元素】上。属性指定了观察者的位置，在属性 perspective 中被用作消失点。 1234567891011perspective-origin:50% 50%; # 默认值,也可以简写为 center。表示视距基点在中心点不进行任何位移。# 第一个参数 &lt;percentage&gt; 百分比，相对于元素宽度，可为负值。# &lt;length&gt; 长度值，可为负值。# left =&gt; 0# center=&gt; 50%# right =&gt; 100%# 第二个参数 &lt;percentage&gt; 百分比，相对于元素高度，可为负值。# &lt;length&gt; 长度值，可为负值。# top =&gt; 0# center=&gt; 50%# bottom =&gt; 100% 123456789101112131415161718192021222324252627282930#div1&#123; /* 这里是父元素 */ position: relative; height: 150px; width: 150px; margin: 50px; padding:10px; border: 1px solid black; perspective:150; /* 这个透视属性用在父元素上，当然也直接的在子元素上调用函数的方式使用 */ perspective-origin: 10% 10%;/* 这个透视属性用在父元素上*/ -webkit-perspective:150; /* Safari and Chrome */ -webkit-perspective-origin: 10% 10%; /* Safari and Chrome */&#125;#div2&#123; /* 这里是子元素 */ padding:50px; position: absolute; border: 1px solid black; background-color: red; transform: rotateX(45deg);/* transform 这个变形函数属性直接使用在需要转换变形的 元素/子元素上 */ -webkit-transform: rotateX(45deg); /* Safari and Chrome */&#125;&lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt;HELLO&lt;/div&gt;&lt;/div&gt; 2.5 backface-visibility 当元素背面朝向观察者时是否可见（使用在子元素-不需要父元素设置）属性指定当元素背面朝向观察者时是否可见。元素的背面总是透明的，当其朝向观察者时，显示正面的镜像。在某些情况下，我们不希望元素内容在背面可见，比如实现翻牌效果。 12backface-visibility: visible; # 默认值，表示背面可见，允许显示正面的镜像。backface-visibility: hidden; # 表示背面不可见。 12345678910111213141516171819202122div&#123; position:relative; height:60px; width:60px; background-color:red; transform:rotateY(180deg); -webkit-transform:rotateY(180deg); /* Chrome and Safari */ -moz-transform:rotateY(180deg); /* Firefox */&#125;#div1&#123; -webkit-backface-visibility:hidden; -moz-backface-visibility:hidden; -ms-backface-visibility:hidden; &#125;#div2&#123; -webkit-backface-visibility:visible; -moz-backface-visibility:visible; -ms-backface-visibility:visible;&#125;&lt;div id=\"div1\"&gt;DIV 1&lt;/div&gt;&lt;div id=\"div2\"&gt;DIV 2&lt;/div&gt; 三、transform 属性【使用在子元素】CSS 里 transform 变形这个属性有点学习难度，尤其在 CSS3 里加上了 3D 效果之后，2 维变 3 维学习成本更是成倍提高。 transform 本质上是 一系列变形函数 &lt;transform-function&gt;，分别是① perspective 透视② translate 位移③ scale 缩放④ rotate 旋转⑤ skew 扭曲⑥ matrix 矩阵 注意这个 transform 属性对 块级元素 有效，如果是行内元素需要使用到 display:inline-block; 使得它保留了原有 行内元素属性，也有了块级元素的属性。 12transform-origin:50%; =&gt; transform: translateX(50%);？？？？？？ 这个是不是也是这样对应的呀perspective:200px; =&gt; transform: perspective(200px); 可以是 1 个值，可以是多个值，这个属性写法就像是调用其他属性的函数 &lt;transform-function&gt;值 变换函数 一样的写法 。就是上面的 6 中值中的任意组合。变换函数按从 左到右 的顺序相乘，这意味着复合变换按从 右到左 ？？？？ 的顺序有效地应用。 3.1 transform: none; 默认值 不进行转换3.2 transform: matrix(); transform: matrix3d(); 矩阵转换 [基本上就不会使用这个属性]矩阵转换变形是 所有变形的 本质，所有的变形效果都可以用矩阵来实现。但是这个需要使用到数学的矩阵来计算，这个太难了，可以使用其他 5 种属性值来达到的效果，就不要使用这个来慢慢的计算了吧，给自己搞什么麻烦。www 12345678910111213# 值为 number# 2D 转换，使用 6 个值的矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵。transform: matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);matrix(1,0,0,1,50,100); # 等价于 translate(50px, 100px); 也就是说最后的 5,6 两个值是 位移值matrix(0.5,0,0,1.5,0,0); # 等价于 scale(0.5, 1.5); 也就是说 第 1,4 两个值是 缩放系数，默认值为 1 不做缩放matrix(1, 0, 1, 1, 0, 0);# 等价于 skew(45deg); 也就是说 第 2,3 个值是倾斜值# 3D 转换，使用 16 个值的 4x4 矩阵。transform: matrix3d(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0);transform: matrix(1.06,1.84,0.54,2.8,466px,482px);# 等价于transform: rotate(15deg) translate(230) scale(1.5,2.6) skew(220deg,-150deg) translate(230px);# 看这里的结论就是这个太难了，矩阵数学什么的就不要用了，谁有时间为了写一个属性慢慢的在这里做什么计算的。 3.2 transform: translate(); 位移转换注意不要用 position 来替代这个属性哦，position 做不到这个属性的要求 1234567891011transform: translate(12px, 50%); # 2D 转换# X,Y轴位移： 第 1,2 个参数 length，% # 如果只是设置了一个参数，那么表示 X,Y 方向按照同样的参数位移。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!transform: translate3d(12px, 50%, 3em); # 3D 转换# X,Y轴位移：第 1,2 个参数 length，% 如果只是设置了 2 个参数，那么就是 Z 方向没有发生位移，等同于 2D 转换的效果。!!!!!!!!!!!!!!# Z 轴位移： 第 3 个参数 length ，只能是长度值,Z 轴的值越大表示离眼睛越近，元素就越大，但当值大于 perspective 视距时元素将消失，# 因为眼睛无法看见眼睛背后的东西，transform: translateX(x); # 转换，只是用 X 轴的值。transform: translateX(2em);transform: translateY(y); # 转换，只是用 Y 轴的值。transform: translateY(3in);transform: translateZ(z); # 转换，只是用 Z 轴的值。transform: translateZ(2px); 3.3 transform: scale(); 缩放 转换变形12345678910111213# 根据中心原点对对象进行缩放。默认值为 1，小于1 为 缩小，大于 1 为放大，负值就是垂直方向反转之后缩放# 2D 缩放转换。transform: scale(2, 0.5);transform: scale(.5); # 缩小一倍，如果只有一个参数，那么 x,y 轴上缩放的系数是一样的!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!transform: scale(2); # 放大一倍transform: scale(-.5, -1.5); # 设负数，负数会先将元素 垂直方向反转再缩放，当然可以用 rotate 实现反转更好# 3D 缩放转换。transform: scale3d(2.5, 1.2, 0.3);transform: scaleX(x); # 通过设置 X 轴的值来定义缩放转换。 transform: scaleX(2);transform: scaleY(y); # 通过设置 Y 轴的值来定义缩放转换。 transform: scaleY(0.5);transform: scaleZ(z); # 通过设置 Z 轴的值来定义 3D 缩放转换。transform: scaleZ(0.3); 3.4 transform: rotate(); 旋转 转换变形3.4.1 先来了解一下角度单位 deg deg =&gt; ° 一共是 360°，也就是 360deg， 围绕 X 轴，【上内】旋转是 正值 围绕 Y 轴，【右内】旋转是 正值 围绕 Z 轴，【顺时针】 是 正值 90deg = 100grad = 0.25turn ≈ 1.570796326794897rad grad 梯度（Gradians）。一个圆共400梯度 rad 弧度（Radians）。一个圆共 2π 弧度 turn 转、圈（Turns）。一个圆共1圈 3.4.2 旋转属性简单使用1234567891011121314151617181920212223# 2D 旋转transform: rotate(0.5turn); # 顺时针半圈 # 如果这个值为 【正值】，元素相对 【原点中心】【顺时针】旋转；# 如果这个值为 【负值】，元素相对 【原点中心】【逆时针】旋转；transform: rotate(30deg); # 顺时针 30°# 3D 旋转transform: rotate3d(x,y,z,angle);# x y z 的取值为 0～1 为各轴的 旋转矢量值。angle 为 3D舞台上旋转的角度，正角度表示顺时针旋转，负角度表示逆时针旋转角度。# 但是这个 0～1 的值也太难计算了吧？？？？？？？一般人会使用这个来做为 css 样式来打代码么？？？？？？？？？？？？？transform: rotate3d(1, 2.0, 3.0, 10deg);transform: rotateX(angle); # 3D 旋转。沿着 X 轴的 3D 旋转。transform: rotateX(10deg); # 沿着 X 轴 向上内转 10 deg# 就是围绕着 通过元素原点中线的【水平线】旋转 angle 角度，转角为 90° 的话视图就看不见了transform: rotateY(angle); # 3D 旋转。沿着 Y 轴的 3D 旋转。transform: rotateY(10deg); # 沿着 Y 轴向右内转 10 deg# 就是围绕着 通过元素原点中线的【垂直线】旋转 angle 角度，转角为 90° 的话视图就看不见了transform: rotateZ(angle); # 3D 旋转。沿着 Z 轴的 3D 旋转。transform: rotateZ(10deg); # 沿着 Z 轴顺时针 10deg# 这个效果就是类似于 2D 旋转了，是围绕着 Z 轴来旋转的 123456789101112.x &#123; transform: perspective(200px) rotateX(60deg);&#125;.y &#123; transform: perspective(200px) rotateY(60deg);&#125;.z &#123; transform: perspective(200px) rotateZ(60deg);&#125;&lt;img class=\"x\" src=\"head75.png\" /&gt;&lt;img class=\"y\" src=\"head75.png\" /&gt;&lt;img class=\"z\" src=\"head75.png\" /&gt; 3.5 transform: skew(); 倾斜 转换变形1234567# 2D 倾斜。transform: skew(30deg, 20deg); # 2D 倾斜。沿着 X 和 Y 轴的 2D 倾斜转换。# 相对于元素原点中心倾斜，如果只提供第一个参数，那么第二个参数就是 0 值。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 第 1 个参数：上边和下边 与水平线 X 轴的夹角（顺时针方向的夹角）!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 第 2 个参数：左边和右边 与垂直线 Y 轴的夹角（逆时针方向的夹角）!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!transform: skewX(angle); # 2D 倾斜。沿着 X 轴的 2D 倾斜转换。水平方向倾斜。transform: skewX(30deg);transform: skewY(angle); # 2D 倾斜。沿着 Y 轴的 2D 倾斜转换。垂直方向倾斜。transform: skewY(1.07rad); 3.6 transform: perspective(length); 透视 转换变形123# 3D 透视transform: perspective(length); # 3D 透视。# 为 3D 转换元素定义透视视图。transform: perspective(17px); 3.7 transform 属性多个 变形函数12transform: translateX(10px) rotate(10deg) translateY(5px);# 变换函数按从 左到右 的顺序相乘，这意味着复合变换按从 右到左 ？？？？ 的顺序有效地应用。 四、使用的例子4.1 简单的鼠标滑过缩放12345678910111213141516171819202122232425262728.wrapper &#123; width: 200px; height: 200px; border:2px dashed red; margin: 100px auto;&#125;.wrapper div &#123; width: 200px; height: 200px; line-height: 200px; background: orange; text-align: center; color: #fff;&#125;.wrapper div:hover &#123; opacity: .5; -webkit-transform:scale(.8); -moz-transform:scale(.8); transform: scale(.8);&#125;&lt;div class=\"wrapper\"&gt; &lt;div&gt;我将缩小0.8&lt;/div&gt;&lt;/div&gt;/* 鼠标滑过时 让容器状态缩小0.8。 */ 4.2 简单旋转123456789101112131415161718192021222324252627282930.wrapper &#123; margin: 100px auto; width: 300px; height: 200px; border: 2px dotted blue; div&#123; width: 300px; height: 200px; line-height: 200px; text-align: center; background: green; color: #fff; -webkit-transform: rotate(-20deg); -moz-transform: rotate(-20deg); transform:rotate(-20deg); span &#123; display:block; -webkit-transform: rotate(20deg); -moz-transform: rotate(20deg); transform:rotate(20deg); &#125; &#125;&#125;&lt;div class=\"wrapper\"&gt; &lt;div&gt;&lt;span&gt;我不想旋转(^_^)&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;/* 上面做的就是 div 逆时针旋转 20°，然后文本不旋转 */ 4.3 简单的倾斜12345678910111213141516171819202122232425262728293031.wrapper &#123; width: 300px; height: 100px; border: 2px dotted red; margin: 30px auto;&#125;.wrapper div &#123; width: 300px; height: 100px; line-height: 100px; text-align: center; color: #fff; background: orange; -webkit-transform:skew(45deg);/* 只有一个参数的话就是 X轴方向倾斜， Y 轴方向的值为 0 就是不发生倾斜 */ -moz-transform:skew(45deg); transform:skew(45deg);&#125;.wrapper span &#123; display:block; -webkit-transform:skew(-45deg); -moz-transform:skew(-45deg); transform:skew(-45deg);&#125;&lt;div class=\"wrapper\"&gt; &lt;div&gt;&lt;span&gt;我不想被扭曲\\倾斜(^_^)&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;/* 图形扭曲，而文字不扭曲。使得一个 长方形 倾斜为 平行四边形 */","tags":[{"name":"transform 转换/变形","slug":"transform-转换-变形","permalink":"https://liuxmoo.com/tags/transform-转换-变形/"}]},{"title":"CSS3 深入理解--[transition 过渡]","date":"2018-08-19T14:57:27.000Z","path":"2018/08/19/[html-css]-css3-特效属性 transition 过渡/","text":"一、前言 ①gradients 渐变：2 种或者两种背景色的线性/径向(角度) 渐变出来的效果，这个是静态的。 ②transform 转换：2D 转换与 3D 转换:移动、缩放、转动、拉长或拉伸，是动态的。 ③transition 过渡： 过渡是元素从一种样式逐渐改变为另一种的效果，也就是两种样式的过渡效果。 通过过渡 transition，可以让 web 前端开发人员不需要 javascript 就可以实现简单的动画交互效果，它是动态的但还不是动画。 ④animation 动画：这个是真正的动画。 本节学习的是这几个属性中的 过渡 transition 属性 transition 从效果上看是一种平滑过渡的动画，本质上是在线性时间内将属性从开始值过渡到结束值。例如获得焦点，点击鼠标等动作导致CSS属性值的变化是瞬间完成的，感觉有点生硬。用 transition 可以指定在某时间段内将属性值 平滑过渡，增强用户体验。 二、transition 过渡2.1 单一属性网址 1234567891011121314151617181920212223242526transition:transition-property，transition-duration，transition-timing-function，transition-delay;# 需要设置过渡的 CSS 属性 过渡效耗时 指定transition效果的转速曲线 延迟时间（指定秒或毫秒数之前要等待切换效果开始transition-property:width;# 指定需要过渡的属性。并不是所有属性都能过渡的，只有能数字量化的CSS属性才能过渡。# ① 颜色系：color，background-color，border-color，outline-color 等等# ② 数字系：width，height，top，right，bottom，left，zoom，opacity，line-height，background-position，word-spacing，# font-weight，vertical-align，outline-outset，z-index 等等# ③ 01 系：visibility（0表示隐藏，1表示显示）# ④ all ： 表示所有的属性都设置过渡# ⑤ none ：没有属性会获得过渡效果。transition-duration:5s; # 默认值是 0 意味着不会有效果。取值：（以秒或毫秒计）。# 也就是从 属性旧值 过渡到 属性新值 花费的时间长度# 贝赛尔曲线transition-timing-function:ease; # 默认值为 ease# linear 匀速过渡: 规定以相同速度开始至结束的过渡效果 等价于 cubic-bezier(0,0,1,1)# ease 先快再慢: 规定慢速开始，然后变快，然后慢速结束的过渡效果 等价于 cubic-bezier(0.25,0.1,0.25,1)# ease-in 加速冲刺: 规定以慢速开始的过渡效果 等价于 cubic-bezier(0.42,0,1,1)。# ease-out 减速到停止: 规定以慢速结束的过渡效果 等价于 cubic-bezier(0,0,0.58,1)）。# ease-in-out 先加速后减速: 规定以慢速开始和结束的过渡效果 等价于 cubic-bezier(0.42,0,0.58,1)）。# cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。transition-delay: 2s; # 默认值是 0 也即是过渡效果没有延迟就开始过渡了 2.2 transition 简写属性1transition:all 0 ease 0; /* 这个就是默认值，默认值是没有任何效果的，因为过渡时间是 0s */ 1234567891011div&#123; width:100px; height:100px; background:red; transition:width 2s; /* 简写属性, 过渡的是属性是 宽度值，过渡时间为 2s */ -webkit-transition:width 2s; /* Safari */ &amp;:hover&#123; width:300px; &#125;&#125;&lt;div&gt;&lt;/div&gt; 三、触发过渡的方式需要产生过渡了，是有触发方式的，话句话其实就是说在 过渡方式==什么场合，就是在什么时候我们可能会使用到过渡这个特性。下面就是我们有可能会使用到这个特性的情况。 伪类触发 :hover，:focus，:active，:checked 等。`a:link{color:blue;} a:visited {color:blue;} a:hover{color:red;}a:active{color:yellow;}` 还有例如 @media 媒体查询**，根据设备大小，横屏竖屏切换时触发 还有如 click，keydown 等 JS 事件触发。 页面加载也可能需要。 四、transitionend 事件transition 既然涉及时间，自然就有事件。参照 MDN 有 transitionend 事件，顾名思义就是 过渡结束时触发该事件。 1234567891011121314151617181920/* 但该事件比较坑。例如过渡 padding 时 */#tempDiv &#123; padding: 1px; transition-property: padding; /* 这样会导致事件被执行 4 次 */ transition-property: all;/* 这样会导致事件被执行 4 次 */ transition-property: padding-top; /* 修改成这样才是正确的，就只会执行 1 次了 但是这样就只会过渡 1 条边，也不符合我们的要求呢，其他的边没有得到过渡 类似这样的属性就不要使用过渡事件了 padding，margin，border 这些有 4 边的都不要使用过渡事件*/ transition-duration: 1s;&#125;#tempDiv:hover &#123; padding: 5px;&#125;function showMessage() &#123; console.log('finished'); //过渡结束时触发打印 log,在这里会被执行 4 次&#125;var element = document.getElementById(\"tempDiv\");element.addEventListener(\"transitionend\", showMessage, false);/* 过渡属性指定的是 padding，所以在 padding-top，padding-right，padding-bottom，padding-left 过渡结束时均触发了 transitionend 事件。因此 log 被打印了 4 次。 */ 五、（计算属性的）隐式过渡transition 过渡时有时会出现一些比较模糊的情形，比如设成 em 的属性，如你所知 em 是根据 font-size 来计算的。类似还有 rem，vh，vw 等都是 根据另一个属性的值来计算得到它的值。 1234padding:2em;font-size:12px;/* 如果 font-size 被改变了，此时 padding 的“书面值”不变，仍旧是 2em，但“实际值”将会发生变化并触发 transition 过渡。这被称作 “隐式过渡”。多数浏览器会实现隐式过渡，IE 貌似没有，它很特别。 */ 六、开关过渡 和 永久过渡开关过渡：顾名思义就是触发源的事件结束后会恢复到原始状态。例如当鼠标 hover 事件结束后，图片恢复原始尺寸。永久过渡：就是过渡后不恢复到原始状态。鼠标 hover 事件结束后，图片仍旧保持放大后的尺寸。 123456789/* 开关过渡 */.transition &#123; transition: all 1s ease-in-out;&#125;.transition:hover &#123; transform: scale(1.5);&#125;/* 永久过渡 */ 七、auto 过渡通常我们属性过渡时，都是定值到定值的过渡，例如 width:100px 过渡到 200px。但要过渡到 width:auto 就不行了。就算你指定 transition: width 1s linear;会发现根本不会有 1 秒的平滑的过渡效果，而是瞬间完成过渡 1234567891011.div1 &#123; background-color: red; width: 100px; height: 50px; transition: width 1s linear; /* 这个过渡 1s 的时间设置了也没有效果，因为 过渡到的是 width: auto; */ &amp;:hover &#123; width: auto; &#125;&#125;&lt;div id=\"box1\" class=\"div1\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 用 JS 来修改这个 auto 变成具体的值就可以正常的过渡了。&lt;div id=\"box2\" class=\"div1\"&gt;&lt;/div&gt;window.onload = function()&#123; var box = document.getElementById(\"box2\"), originWidth = box.clientWidth, width2AutoLater = null, width2OriginLater = null; var width2Auto = function(element, time) &#123; if (typeof window.getComputedStyle == \"undefined\") return; var width = window.getComputedStyle(element).width; element.style.width = \"auto\"; var targetWidth = window.getComputedStyle(element).width; element.style.width = width; setTimeout(function() &#123; element.style.transition = \"width \"+ time +\"ms linear\"; element.style.width = targetWidth; &#125;, 10); &#125;; var width2Origin = function(element, time) &#123; setTimeout(function() &#123; element.style.transition = \"width 0s linear\"; element.style.width = originWidth + \"px\"; &#125;, 10); &#125;; function callLater(func, paramA, paramB)&#123; return function()&#123; func.call(this, paramA, paramB); &#125;; &#125; width2AutoLater = callLater(width2Auto, box, 1000); width2OriginLater = callLater(width2Origin, box, 1000); box.addEventListener(\"mouseenter\", width2AutoLater); box.addEventListener(\"mouseleave\", width2OriginLater);&#125;// 给 div 注册了mouseenter 和 mouseleave 事件来模拟 hover 效果// mouseenter 绑定 width2Auto 函数，函数里临时将 div 的 width 设为 auto 后，// 用 getComputedStyle 得到宽度值，将该宽度值和 transition 设进该 div 的 style 里。// mouseleave 绑定 width2Origin 函数，函数里将 div 的 width 改回初始值。// 因为注册事件的函数 addEventListener 的第二个参数是回调函数名，不能给回调函数传参数。// 因此使用闭包的特性，定义了 callLater 中间函数，函数里通过 call 调用上述两个函数。","tags":[{"name":"transition 过渡","slug":"transition-过渡","permalink":"https://liuxmoo.com/tags/transition-过渡/"}]},{"title":"CSS3 深入理解--[animation 动画]","date":"2018-08-19T14:57:27.000Z","path":"2018/08/19/[html-css]-css3-特效属性 animations 动画/","text":"一、前言 ①gradients 渐变：2 种或者两种背景色的线性/径向(角度) 渐变出来的效果，这个是静态的。 ②transform 转换：2D 转换与 3D 转换:移动、缩放、转动、拉长或拉伸，是动态的。 ③transition 过渡： 过渡是元素从一种样式逐渐改变为另一种的效果，也就是两种样式的过渡效果。通过过渡transition，可以让 web 前端开发人员不需要 javascript 就可以实现简单的动画交互效果，它是动态的但还不是动画。 ④animation 动画：这个是真正的动画。 这几个特性中最炫的当然还是这个真正的做成动画的特性 animation，本章就是来学习这个特性的。使用这个CSS3特性，我们可以创建动画，它可以取代许多网页动画图像，Flash 动画，和 JavaScripts。animation 属性和传统的动画制作一样，能控制帧的每一步，制作出更强大的动画效果。 MDN 二、animation 动画2.1 @keyframes 关键帧Keyframes 被称为关键帧，其类似于 Flash 中的关键帧。在 CSS3 中其主要以 “@keyframes” 开头，后面紧跟着是动画名称加上一对花括号“{…}”，括号中就是一些不同时间段样式规则。 12345678910111213141516171819@keyframes changecolor&#123; 0%&#123; background: red; &#125; /* 这个中间可以有多个百分比,设置多组状态*/ 100%&#123; background: green; &#125;&#125;/* 也可以使用 from....to....关键字来写 */@keyframes changecolor&#123; from&#123; background: red; &#125; to&#123; background: green; &#125;&#125; 12345678910111213141516171819202122232425262728&lt;div&gt;鼠标放到我身上&lt;/div&gt;@keyframes wobble &#123; 0% &#123; margin-left: 100px; background:green; &#125; 40% &#123; margin-left:150px; background:orange; &#125; 60% &#123; margin-left: 75px; background: blue; &#125; 100% &#123; margin-left: 100px; background: red; &#125;&#125;div &#123; width: 100px; height: 100px; background:red; color: #fff;&#125;div:hover&#123; animation: wobble 5s ease .1s;&#125; 2.1 from…to 关键字123456789101112131415161718192021222324252627282930@keyframes xxxxx &#123; 0% &#123; margin-left: 100px; background:green; &#125; 50% &#123; margin-left: 75px; background: blue; &#125; 100% &#123; margin-left: 100px; background: red; &#125;&#125;/* 等价于 */@keyframes xxxxx &#123; from &#123; margin-left: 100px; background:green; &#125; 50% &#123; margin-left: 75px; background: blue; &#125; to &#123; margin-left: 100px; background: red; &#125;&#125; 2.2 animation-play-state 动画的状态 (不在 animation 属性里面!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1)12345/* 指定动画是否正在运行或已暂停，这个不在 animation 属性里面。 */animation-play-state:running; /* 默认值 ,表示正在播放动画*/animation-play-state:paused; /* 表示暂停动画 *//* 通常在 JS 端使用该属性 object.style.animationPlayState=\"paused\" 来暂停动画。 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@keyframes move &#123;/* 0%&#123; transform: translateY(90px); &#125; 关键字 from 对应的是 0%*/ from&#123; transform: translateY(90px); &#125; 15%&#123; transform: translate(90px,90px); &#125; 30%&#123; transform: translate(180px,90px); &#125; 45%&#123; transform: translate(90px,90px); &#125; 60%&#123; transform: translate(90px,0); &#125; 75%&#123; transform: translate(90px,90px); &#125; 90%&#123; transform: translate(90px,180px); &#125; /* 100%&#123; 关键字 to 对应的是 100%， 在 from.....to 中间可以插入其他的百分比 */ to&#123; transform: translate(90px,90px); &#125;&#125;div &#123; width: 200px; height: 200px; border: 1px solid red; margin: 20px auto;&#125;span &#123; display: inline-block; width: 20px; height: 20px; background: orange; transform: translateY(90px); /* animation-name: move; animation-duration: 10s; animation-timing-function: ease-in; animation-delay: .2s; animation-iteration-count:infinite; animation-direction:alternate; */ animation:move 10s ease-in .2s infinite alternate; animation-play-state:paused; /* 这个属性不在 animation 简写里面 */&#125;div:hover span &#123; animation-play-state:running;&#125;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 2.3 animation 简写属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263animation:name/duration timing-function animation-delay iteration-count direction play-state fill-mode;# ① 动画名字 ②动画耗时 ③ 动画曲线 ④ 延迟执行时间 ⑤ 动画执行次数 ⑥ 单程还是往返 ⑦ ⑧ 动画结束的样式① animation-name # 指定要绑定到选择器的关键帧的名称# 指定 @keyframes 关键帧的名称 。CSS 加载时会应用该名字的 @keyframes 规则来实现动画# 注意名称是区分大小写！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！② animation-duration # 动画指定需要多少秒或毫秒完成 默认值：0s，表示无动画，单位可以设s秒或ms毫秒③ animation-timing-function # 动画播放方式 默认值：ease# linear 匀速过渡: 动画从头到尾的速度是相同的 等价于 cubic-bezier(0,0,1,1)# ease 先快再慢: 默认。动画以低速开始，然后加快，在结束前变慢。 等价于 cubic-bezier(0.25,0.1,0.25,1)# ease-in 加速冲刺: 动画以低速开始。 等价于 cubic-bezier(0.42,0,1,1)# ease-out 减速到停止: 动画以低速结束。 等价于 cubic-bezier(0,0,0.58,1)# ease-in-out 先加速后减速: 动画以低速开始和结束。 等价于 cubic-bezier(0.42,0,0.58,1)# cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值。# step-start; 一步到位 等价于 steps(1, start)# step-end; 延迟到位 等价于 steps(1, end)# 对于只有0%,100%或from, to两个关键时间帧的动画，step-start和step-end是 没有任何 需要使用的理由的。# 如果是非等分，无法过渡的阶梯动画，则有使用价值# steps(4, end); 逐步运动，断续的动画# frames(10); 这个属性值，目前的浏览器都没有实现# ease, step-start, cubic-bezier(0.1, 0.7, 1.0, 0.1); 多值④ animation-delay # 延迟开始动画的时间。 默认值：0s，表示不延迟，立即播放动画。⑤ animation-iteration-count # 定义动画的播放次数。 默认值：1次# 默认值 1 次，即 放完一遍后不循环播放。# n =&gt; 播放n次# infinite =&gt; 表示无限循环播放。⑥ animation-direction # 指定是否应该轮流反向播放动画。动画播放的方向 默认值：normal# normal 默认值。正向播放。# reverse 动画 反向播放。# alternate 动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。 可以平滑的动画# alternate-reverse 动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。 可以平滑的动画⑦ animation-fill-mode # 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。 默认值：none# none 默认值。动画 在动画 执行之前 和 之后 不会应用任何样式到目标元素。# 动画播完后，元素恢复到初始状态。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# forwards 翻译为，向前，最后# 在动画结束后（由 animation-iteration-count 决定），动画将应用该属性值!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 保持 @keyframes 里最后一帧的属性。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# backwards 翻译为，后退，最前，第一# 在 animation-delay 的时间里 元素的样式使用的是 动画的第一次迭代的关键帧中定义的属性值。# 这些都是 from 关键帧中的值（当 animation-direction 为 \"normal\" 或 \"alternate\" 时）# 或 to 关键帧中的值（当 animation-direction 为 \"reverse\" 或 \"alternate-reverse\" 时# 应用 @keyframes 里第一帧的属性!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 动画结束之后，元素不会使用 动画中的样式，会回到元素本身的样式# both 动画遵循 forwards 和 backwards 的规则。也就是说，动画会在两个方向上扩展动画属性。# 动画结束后，第一帧、最后一帧 都应用到元素上!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!###### 简单来说就是 forwards 就是动画结束后，元素的样式变成 动画最后一帧的样式###### 简单来说就是 backwards 动画延迟执行的时间内，元素的样式变成 动画第一帧的样式，动画结束之后，会回到元素本身的样式###### 简单来说就是 both 延迟的时候就用第一帧的样式了，并且动画结束后，元素的样式变成 动画最后一帧的样式!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!简写属性！！！！！！！！！！！！！！！！！！！！！！！！！！animation: moveten 1s step(10,end) infinite alternate 3s backwards;# 动画名称 耗时 动画方式 动画次数 往返方式 延迟 最后样式# 简写属性没有顺序的要求，也没有要求全部设置，但是如果只有一个值的话，默认的是 耗时，也即是说延迟没有设置，没有延迟。# 因为有 animation-duration 和 animation-delay 都是时间，浏览器会根据先后顺序，# 将第一个时间认作为 animation-duration，第二个时间认作为 animation-delay。animation: moveten1 1s ease .5s, moveten2 2s ease 1s forwards; #多动画!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# 动画名称 耗时 方式 延迟,动画名称2 耗时 方式 耗时 样式 2.3.1 搞懂 step() 断续（不连续）网址 类似的 steps(number, position) 可以分解为 step-start和step-end 这两种关键字number：表示我们把动画分成几段/几部分position： start 表示直接开始。也就是时间才开始，就已经执行了一个距离段。 起始点被忽略，因为时间一开始直接就到了第二个点， 分段结束的时候，时间才开始走。于是，动画执行的5个分段点是后5个点 end 表示戛然而止。是默认值。也就是时间一结束，当前距离位移就停止。 结束点被忽略，因为等要执行结束点的时候已经没时间了， 分段开始的时候，时间跟着一起走。于是，动画执行的5个分段点是前5个点 记住position参数的含义: 牢记这么一句话：一切都是反的！start不是开始，而是结束；end不是结束，而是开始。 2.3.2 搞懂 animation-fill-mode 的属性值 forwards 与 backwards12345678910111213141516171819.myDiv2 &#123; width: 75px; height: 75px; background-color: red; position:relative; animation:mymove 5s 1 2s;&#125;@keyframes mymove &#123; from &#123;left:0px; background-color:green;&#125; to &#123;left:200px; background-color: blue;&#125;&#125;.forwards &#123; animation-fill-mode:forwards; &#125;.bkforwards &#123; animation-fill-mode:backwards; &#125;.both &#123; animation-fill-mode:both; &#125;&lt;div class=\"myDiv2\"&gt;&lt;/div&gt; /* 最终是红色 */&lt;div class=\"myDiv2 forwards\"&gt;&lt;/div&gt; /* 最终是 蓝色 */&lt;div class=\"myDiv2 bkforwards\"&gt;&lt;/div&gt; /* 最终是红色 */&lt;div class=\"myDiv2 both\"&gt;&lt;/div&gt; /* 最终是 蓝色 */ 2.4 transition 与 animation 的区别如何区别：@keyframes 动画帧就是区别 animation 和 transition 的关键。在 transition 中是无法更细致地控制时间段内执行的动作的，而在 animation 中用 @keyframes 可以细致地指定第一帧要干什么，第二帧要干什么。 2.5 区别 @keyframes 与 animation@keyframes 只是定义了一个动画效果，但要使动画生效，必须用 animation 属性将动画绑定到具体某 DOM 元素上才行。 三、动画应用实例3.1 简单动画123456789101112131415161718192021div&#123; width:100px; height:100px; background:red; animation:myfirst 5s; /* 用 animation 将 myfirst 样式绑定到这个div上面, 把 \"myfirst\" 动画捆绑到 div 元素，时长：5 秒： */ -webkit-animation:myfirst 5s; /* Safari and Chrome */&#125;@keyframes myfirst&#123; from &#123;background:red;&#125; to &#123;background:yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; from &#123;background:red;&#125; to &#123;background:yellow;&#125;&#125; 3.2 多个状态动画任意多的样式任意多的次数。请用百分比来规定变化发生的时间，或用关键词 “from” 和 “to”，等同于 0% 和 100%。0% 是动画的开始，100% 是动画的完成。","tags":[{"name":"animation 动画","slug":"animation-动画","permalink":"https://liuxmoo.com/tags/animation-动画/"}]},{"title":"CSS3 深入理解--[gradients 线性]","date":"2018-08-19T14:57:27.000Z","path":"2018/08/19/[html-css]-css3-特效属性 gradients 线性变化/","text":"一、前言","tags":[{"name":"gradients 线性","slug":"gradients-线性","permalink":"https://liuxmoo.com/tags/gradients-线性/"}]},{"title":"weui-wxss 组件库","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】 weui-wxss 组件库.1/","text":"一、前言为了方便使用，小程序与 web 端一样，有官方或者是其他开发的 ui 组件库，方便开发者直接使用。WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含 button、cell、dialog、 progress、 toast、article、actionsheet、icon 等各式元素。 二、we-ui组件库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we-ui：web 端 需要注意的是 we-ui 最开始是 web 端的，小程序版的是 weui-wxss。如果我是需要在小程序中使用的话一定要使用 weui-wxss。两者区别：github 网址 github 网址 we-uigithub 网址 we-ui 文档we-ui 效果图 web MINA 项目框架中使用 weui-wxss 组件库：小程序端 github 网址 weui-wxssweui-wxss 效果图：与 web 版一致（可以下载文件之后在开发者工具模拟器查看效果）。或者使用开发者工具打开 dist 文件夹，就可以看到效果。再或者在微信查看 weui 小程序。 三、weui-wxss 使用3.1 引入 weui-wxss3.1.1 CDN 引入微信官方、BootCDN 和 cdnjs 为 WeUI 提供了 CDN 链接，推荐使用，链接如下： CDN 链接地址 其中，1.0.0是目前 WeUI 最新的版本号，代码命名有较大的改变，因此保留0.4.2的CDN。以上链接，均支持 http 和 https 协议，均包含未压缩版 weui.css 和压缩版 weui.min.css 。 12345&lt;!-- 在 index.tempalate.html 中引入 --&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;link rel=\"stylesheet\" href=\"//res.wx.qq.com/open/libs/weui/1.1.3/weui.min.css\"&gt;&lt;title&gt;数独&lt;/title&gt; 3.1.2 npm 或 yarn 或 bower 安装123$ bower install --save weui# 或$ npm install --save weui 3.1.3 下载文件使用（不推荐）可以在 https://github.com/weui/weui/releases 处，直接下载最新发布的版本。github 提供了 zip 和 tar.gz 两种格式的包，选择其中一种下载，解压后引用 dist/style/weui.css 文件即可。 也可以在 WeUI 的 github 主页，右上角的“Download ZIP”按钮，点击下载仓库中最新的代码，解压。注意： 该方式获取的是 WeUI 最新的、未经发布的代码，可能不稳定，不推荐通过此方式获取 WeUI 用于生产环境。 12&lt;!-- 然后再 html 文件中引入文件即可，路径根据自己的项目而定，但是不建议使用这样下载的方式--&gt;&lt;link rel=\"stylesheet\" href=\"path/to/weui/dist/style/weui.min.css\"/&gt; 3.2 在 wxml 中使用组件：1&lt;button class=\"weui-btn\" type=\"primary\"&gt;页面主操作 Normal&lt;/button&gt; 预览所有组件 ①微信中搜索小程序：weui ②开发者工具打开下载的 dist 文件夹 ③本文余下部分有各个组件的示意图 源代码：examples 目录中 3.2 布局3.2.1 Layout flex布局123456789101112131415161718192021222324&lt;!-- .wxml --&gt;&lt;view class=\"weui-flex\"&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-flex\"&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-flex\"&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-flex\"&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-flex\"&gt; &lt;view&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view class=\"weui-flex__item\"&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt; &lt;view&gt;&lt;view class=\"placeholder\"&gt;weui&lt;/view&gt;&lt;/view&gt;&lt;/view&gt; 12345678910&lt;!-- .wxss --&gt;.placeholder&#123; margin: 5px; padding: 0 10px; text-align: center; background-color: rgb(221, 182, 182); height: 2.3em; line-height: 2.3em; color: #000000;&#125; 预览图 3.2.2 Grid 宫格123456789&lt;!-- .wxml --&gt;&lt;view class=\"weui-grids\"&gt; &lt;block wx:for=\"&#123;&#123;grids&#125;&#125;\" wx:key=\"*this\"&gt; &lt;navigator url=\"\" class=\"weui-grid\" hover-class=\"weui-grid_active\"&gt; &lt;image class=\"weui-grid__icon\" src=\"../images/icon_tabbar.png\"/&gt; &lt;view class=\"weui-grid__label\"&gt;Grid&lt;/view&gt; &lt;/navigator&gt; &lt;/block&gt;&lt;/view&gt;123456&lt;!-- .js --&gt;Page(&#123; data: &#123; grids: [0, 1, 2, 3, 4, 5, 6, 7, 8] &#125;&#125;); 预览图 3.2.3 Panel 面板预览图1预览图2预览图3预览图4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!-- .wxml --&gt;&lt;view class=\"weui-panel weui-panel_access\"&gt; &lt;view class=\"weui-panel__hd\"&gt;图文组合列表&lt;/view&gt; &lt;view class=\"weui-panel__bd\"&gt; &lt;navigator url=\"\" class=\"weui-media-box weui-media-box_appmsg\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-media-box__hd weui-media-box__hd_in-appmsg\"&gt; &lt;image class=\"weui-media-box__thumb\" src=\"&#123;&#123;icon60&#125;&#125;\" /&gt; &lt;/view&gt; &lt;view class=\"weui-media-box__bd weui-media-box__bd_in-appmsg\"&gt; &lt;view class=\"weui-media-box__title\"&gt;标题一&lt;/view&gt; &lt;view class=\"weui-media-box__desc\"&gt;由各种物质组成的巨型球状天体，叫做星球。&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-media-box weui-media-box_appmsg\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-media-box__hd weui-media-box__hd_in-appmsg\"&gt; &lt;image class=\"weui-media-box__thumb\" src=\"&#123;&#123;icon60&#125;&#125;\" /&gt; &lt;/view&gt; &lt;view class=\"weui-media-box__bd weui-media-box__bd_in-appmsg\"&gt; &lt;view class=\"weui-media-box__title\"&gt;标题二&lt;/view&gt; &lt;view class=\"weui-media-box__desc\"&gt;由各种物质组成的巨型球状天体，叫做星球。&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;view class=\"weui-panel__ft\"&gt; &lt;view class=\"weui-cell weui-cell_access weui-cell_link\"&gt; &lt;view class=\"weui-cell__bd\"&gt;查看更多&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-panel weui-panel_access\"&gt; &lt;view class=\"weui-panel__hd\"&gt;文字组合列表&lt;/view&gt; &lt;view class=\"weui-panel__bd\"&gt; &lt;view class=\"weui-media-box weui-media-box_text\"&gt; &lt;view class=\"weui-media-box__title weui-media-box__title_in-text\"&gt;标题一&lt;/view&gt; &lt;view class=\"weui-media-box__desc\"&gt;由各种物质组成的巨型球状天体，叫做星球。&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-media-box weui-media-box_text\"&gt; &lt;view class=\"weui-media-box__title weui-media-box__title_in-text\"&gt;标题二&lt;/view&gt; &lt;view class=\"weui-media-box__desc\"&gt;由各种物质组成的巨型球状天体，叫做星球。&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-panel__ft\"&gt; &lt;view class=\"weui-cell weui-cell_access weui-cell_link\"&gt; &lt;view class=\"weui-cell__bd\"&gt;查看更多&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-panel\"&gt; &lt;view class=\"weui-panel__hd\"&gt;小图文组合列表&lt;/view&gt; &lt;view class=\"weui-panel__bd\"&gt; &lt;view class=\"weui-media-box weui-media-box_small-appmsg\"&gt; &lt;view class=\"weui-cells weui-cells_in-small-appmsg\"&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;image src=\"&#123;&#123;icon20&#125;&#125;\" style=\"width: 20px;height: 20px;margin-right: 5px\" /&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd weui-cell_primary\"&gt; &lt;view&gt;文字标题&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;image src=\"&#123;&#123;icon20&#125;&#125;\" style=\"width: 20px;height: 20px;margin-right: 5px\" /&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd weui-cell_primary\"&gt; &lt;view&gt;文字标题&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-panel\"&gt; &lt;view class=\"weui-panel__hd\"&gt;文字列表附来源&lt;/view&gt; &lt;view class=\"weui-panel__bd\"&gt; &lt;view class=\"weui-media-box weui-media-box_text\"&gt; &lt;view class=\"weui-media-box__title weui-media-box__title_in-text\"&gt;标题一&lt;/view&gt; &lt;view class=\"weui-media-box__desc\"&gt;由各种物质组成的巨型球状天体，叫做星球。&lt;/view&gt; &lt;view class=\"weui-media-box__info\"&gt; &lt;view class=\"weui-media-box__info__meta\"&gt;文字来源&lt;/view&gt; &lt;view class=\"weui-media-box__info__meta\"&gt;时间&lt;/view&gt; &lt;view class=\"weui-media-box__info__meta weui-media-box__info__meta_extra\"&gt;其它信息&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910/* .JS */var base64 = require(\"../images/base64\");Page(&#123; onLoad: function()&#123; this.setData(&#123; icon20: base64.icon20, icon60: base64.icon60 &#125;); &#125;&#125;); 3.2.4 Gallery 画廊(就是展示图片用的)建议采用小程序原生的 wx.previewImage 来实现。 3.2.5 List 列表预览图1 预览图2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!-- .wxml --&gt;&lt;view class=\"weui-cells__title\"&gt; 带说明的列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell\"&gt; &lt;view class=\"weui-cell__bd\"&gt;标题文字&lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt;说明文字&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;带图标、说明的列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;image src=\"&#123;&#123;icon&#125;&#125;\" style=\"margin-right: 5px;vertical-align: middle;width:20px; height: 20px;\"&gt; &lt;/image&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt;标题文字&lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt;说明文字&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;image src=\"&#123;&#123;icon&#125;&#125;\" style=\"margin-right: 5px;vertical-align: middle;width:20px; height: 20px;\"&gt; &lt;/image&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt;标题文字&lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt;说明文字&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;带跳转的列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt;cell standard&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt;cell standard&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;带说明、跳转的列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt;cell standard&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;说明文字&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt;cell standard&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;说明文字&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;带图标、说明、跳转的列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;image src=\"&#123;&#123;icon&#125;&#125;\" style=\"margin-right: 5px;vertical-align: middle;width:20px; height: 20px;\"&gt; &lt;/image&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt;cell standard&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;说明文字&lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell weui-cell_access\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;image src=\"&#123;&#123;icon&#125;&#125;\" style=\"margin-right: 5px;vertical-align: middle;width:20px; height: 20px;\"&gt; &lt;/image&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt;cell standard&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;说明文字&lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; 123456789/* .JS */var base64 = require(\"../images/base64\");Page(&#123; onLoad: function()&#123; this.setData(&#123; icon: base64.icon20 &#125;); &#125;&#125;); 3.2.6 Card 卡片3.2.6 底部链接copyright12345678910111213141516171819202122232425&lt;view class=\"weui-footer\"&gt; &lt;view class=\"weui-footer__text\"&gt;Copyright © 2008-2016 weui.io&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-footer\"&gt; &lt;view class=\"weui-footer__links\"&gt; &lt;navigator url=\"\" class=\"weui-footer__link\"&gt;底部链接&lt;/navigator&gt; &lt;/view&gt; &lt;view class=\"weui-footer__text\"&gt;Copyright © 2008-2016 weui.io&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-footer\"&gt; &lt;view class=\"weui-footer__links\"&gt; &lt;navigator url=\"\" class=\"weui-footer__link\"&gt;底部链接&lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-footer__link\"&gt;底部链接&lt;/navigator&gt; &lt;/view&gt; &lt;view class=\"weui-footer__text\"&gt;Copyright © 2008-2016 weui.io&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-footer weui-footer_fixed-bottom\"&gt; &lt;view class=\"weui-footer__links\"&gt; &lt;navigator url=\"\" class=\"weui-footer__link\"&gt;WeUI首页&lt;/navigator&gt; &lt;/view&gt; &lt;view class=\"weui-footer__text\"&gt;Copyright © 2008-2016 weui.io&lt;/view&gt;&lt;/view&gt;预览图 123456.weui-footer&#123; margin-bottom: 50px;&#125;.weui-footer_fixed-bottom&#123; margin-bottom: 0;&#125; 3.3 基础3.3.1 按钮/Button1234567891011121314151617181920212223242526272829303132&lt;button class=\"weui-btn\" type=\"primary\"&gt; 页面主操作 Normal&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"primary\" disabled=\"true\"&gt; 页面主操作 Disabled&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"default\"&gt; 页面次要操作 Normal&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"default\" disabled=\"true\"&gt; 页面次要操作 Disabled&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"warn\"&gt;警告类操作 Normal&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"warn\" disabled=\"true\"&gt; 警告类操作 Disabled&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"primary\" plain=\"true\"&gt;按钮&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"primary\" disabled=\"true\" plain=\"true\"&gt;按钮&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"default\" plain=\"true\"&gt;按钮&lt;/button&gt;&lt;button class=\"weui-btn\" type=\"default\" disabled=\"true\" plain=\"true\"&gt;按钮&lt;/button&gt;&lt;button class=\"weui-btn mini-btn\" type=\"primary\" size=\"mini\"&gt;按钮&lt;/button&gt;&lt;button class=\"weui-btn mini-btn\" type=\"default\" size=\"mini\"&gt;按钮&lt;/button&gt;&lt;button class=\"weui-btn mini-btn\" type=\"warn\" size=\"mini\"&gt;按钮&lt;/button&gt;123.mini-btn&#123; margin-right: 5px;&#125; 预览图 3.3.2 Color 色彩3.3.3 Icon 图标123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;view class=\"icon-box\"&gt; &lt;icon type=\"success\" size=\"93\"&gt;&lt;/icon&gt; &lt;view class=\"icon-box__ctn\"&gt; &lt;view class=\"icon-box__title\"&gt;成功&lt;/view&gt; &lt;view class=\"icon-box__desc\"&gt;用于表示操作顺利达成&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"icon-box\"&gt; &lt;icon type=\"info\" size=\"93\"&gt;&lt;/icon&gt; &lt;view class=\"icon-box__ctn\"&gt; &lt;view class=\"icon-box__title\"&gt;提示&lt;/view&gt; &lt;view class=\"icon-box__desc\"&gt; 用于表示信息提示；也常用于缺乏条件的操作拦截，提示用户所需信息 &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"icon-box\"&gt; &lt;icon type=\"warn\" size=\"93\" color=\"#FFBE00\"&gt;&lt;/icon&gt; &lt;view class=\"icon-box__ctn\"&gt; &lt;view class=\"icon-box__title\"&gt;普通警告&lt;/view&gt; &lt;view class=\"icon-box__desc\"&gt; 用于表示操作后将引起一定后果的情况 &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"icon-box\"&gt; &lt;icon type=\"warn\" size=\"93\"&gt;&lt;/icon&gt; &lt;view class=\"icon-box__ctn\"&gt; &lt;view class=\"icon-box__title\"&gt;强烈警告&lt;/view&gt; &lt;view class=\"icon-box__desc\"&gt; 用于表示操作后将引起严重的不可挽回的后果的情况 &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"icon-box\"&gt; &lt;icon type=\"waiting\" size=\"93\"&gt;&lt;/icon&gt; &lt;view class=\"icon-box__ctn\"&gt; &lt;view class=\"icon-box__title\"&gt;等待&lt;/view&gt; &lt;view class=\"icon-box__desc\"&gt;用于表示等待&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"icon_sp_area\"&gt; &lt;icon type=\"success\" size=\"23\"&gt;&lt;/icon&gt; &lt;icon type=\"success_no_circle\" size=\"23\"&gt;&lt;/icon&gt; &lt;icon type=\"circle\" size=\"23\"&gt;&lt;/icon&gt; &lt;icon type=\"warn\" size=\"23\" color=\"#F43530\"&gt;&lt;/icon&gt; &lt;icon type=\"download\" size=\"23\"&gt;&lt;/icon&gt; &lt;icon type=\"info_circle\" size=\"23\"&gt;&lt;/icon&gt; &lt;icon type=\"cancel\" size=\"23\"&gt;&lt;/icon&gt; &lt;icon type=\"search\" size=\"20\"&gt;&lt;/icon&gt;&lt;/view&gt;预览图 1234567891011121314151617181920212223icon&#123; margin-right: 13px;&#125;.icon-box&#123; margin-bottom: 25px; display: flex; align-items: center;&#125;.icon-box__ctn&#123; flex-shrink: 100;&#125;.icon-box__title&#123; font-size: 20px;&#125;.icon-box__desc&#123; margin-top: 6px; font-size: 12px; color: #888888;&#125;.icon_sp_area &#123; margin-top: 10px; text-align: left;&#125; 3.4 导航3.4.0 Navbar 导航栏/像 tabs 标签页123456789101112131415161718192021222324252627&lt;!-- wxml --&gt;&lt;view class=\"page\"&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-tab\"&gt; &lt;view class=\"weui-navbar\"&gt; &lt;block wx:for=\"&#123;&#123;tabs&#125;&#125;\" wx:key=\"*this\"&gt; &lt;view id=\"&#123;&#123;index&#125;&#125;\" class=\"weui-navbar__item &#123;&#123;activeIndex == index ? 'weui-bar__item_on' : ''&#125;&#125;\" bindtap=\"tabClick\"&gt; &lt;view class=\"weui-navbar__title\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;!-- 这为了展示有空格，使用时记得删掉 --&gt; &lt;view class=\"weui-navbar__slider\" style=\"left: &#123;&#123;sliderLeft&#125;&#125;px; transform: translateX(&#123;&#123;sliderOffset&#125;&#125;px); -webkit-transform: translateX(&#123;&#123;sliderOffset&#125;&#125;px);\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-tab__panel\"&gt; &lt;view class=\"weui-tab__content\" hidden=\"&#123;&#123;activeIndex != 0&#125;&#125;\"&gt;选项一的内容&lt;/view&gt; &lt;view class=\"weui-tab__content\" hidden=\"&#123;&#123;activeIndex != 1&#125;&#125;\"&gt;选项二的内容&lt;/view&gt; &lt;view class=\"weui-tab__content\" hidden=\"&#123;&#123;activeIndex != 2&#125;&#125;\"&gt;选项三的内容&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213/* wxss */page,.page,.page__bd&#123; height: 100%;&#125;.page__bd&#123; padding-bottom: 0;&#125;.weui-tab__content&#123; padding-top: 60px; text-align: center;&#125;预览图 123456789101112131415161718192021222324252627/* js */var sliderWidth = 96; // 需要设置 slider 的宽度，用于计算中间位置Page(&#123; data: &#123; tabs: [\"选项一\", \"选项二\", \"选项三\"], activeIndex: 1, sliderOffset: 0, sliderLeft: 0 &#125;, onLoad: function () &#123; var that = this; wx.getSystemInfo(&#123; success: function(res) &#123; that.setData(&#123; sliderLeft: (res.windowWidth / that.data.tabs.length - sliderWidth) / 2, sliderOffset: res.windowWidth / that.data.tabs.length * that.data.activeIndex &#125;); &#125; &#125;); &#125;, tabClick: function (e) &#123; this.setData(&#123; sliderOffset: e.currentTarget.offsetLeft, activeIndex: e.currentTarget.id &#125;); &#125;&#125;); 3.4.1 TabBar 标签栏底部导航，建议采用小程序原生的 tabbar，通过设置 app.json 来实现。详情请看小程序文档。 3.4.2 Tabs 标签页/可以参考 navbar 导航栏3.4.3 Drawer 抽屉3.4.4 Page 分页3.4.5 Steps 步骤条3.4.6 NoticeBar 通告栏3.4.7 Index 索引选择器3.4.7 SearchBar 搜索栏123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- wxml --&gt;&lt;view class=\"weui-search-bar\"&gt; &lt;view class=\"weui-search-bar__form\"&gt; &lt;view class=\"weui-search-bar__box\"&gt; &lt;icon class=\"weui-icon-search_in-box\" type=\"search\" size=\"14\"&gt;&lt;/icon&gt; &lt;input type=\"text\" class=\"weui-search-bar__input\" placeholder=\"搜索\" value=\"&#123;&#123;inputVal&#125;&#125;\" focus=\"&#123;inputShowed&#125;&#125;\" bindinput=\"inputTyping\" /&gt; &lt;view class=\"weui-icon-clear\" wx:if=\"&#123;&#123;inputVal.length &gt; 0&#125;&#125;\" bindtap=\"clearInput\"&gt; &lt;icon type=\"clear\" size=\"14\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;label class=\"weui-search-bar__label\" hidden=\"&#123;&#123;inputShowed&#125;&#125;\" bindtap=\"showInput\"&gt; &lt;icon class=\"weui-icon-search\" type=\"search\" size=\"14\"&gt;&lt;/icon&gt; &lt;view class=\"weui-search-bar__text\"&gt;搜索&lt;/view&gt; &lt;/label&gt; &lt;/view&gt; &lt;view class=\"weui-search-bar__cancel-btn\" hidden=\"&#123;&#123;!inputShowed&#125;&#125;\" bindtap=\"hideInput\"&gt;取消&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells searchbar-result\" wx:if=\"&#123;&#123;inputVal.length &gt; 0&#125;&#125;\"&gt; &lt;navigator url=\"\" class=\"weui-cell\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view&gt;实时搜索文本&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view&gt;实时搜索文本&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view&gt;实时搜索文本&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;navigator url=\"\" class=\"weui-cell\" hover-class=\"weui-cell_active\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view&gt;实时搜索文本&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; 1234567891011/* WXSS */.searchbar-result&#123; margin-top: 0; font-size: 14px;&#125;.searchbar-result:before&#123; display: none;&#125;.weui-cell&#123; padding: 12px 15px 12px 35px;&#125;预览图 12345678910111213141516171819202122232425262728/* js */Page(&#123; data: &#123; inputShowed: false, inputVal: \"\" &#125;, showInput: function () &#123; this.setData(&#123; inputShowed: true &#125;); &#125;, hideInput: function () &#123; this.setData(&#123; inputVal: \"\", inputShowed: false &#125;); &#125;, clearInput: function () &#123; this.setData(&#123; inputVal: \"\" &#125;); &#125;, inputTyping: function (e) &#123; this.setData(&#123; inputVal: e.detail.value &#125;); &#125;&#125;); 3.4.8 Sticky 吸顶容器3.5 操作反馈3.5.1 ActionSheet 动作面板123&lt;view class=\"weui-btn-area\"&gt; &lt;button type=\"default\" bindtap=\"open\"&gt;ActionSheet&lt;/button&gt;&lt;/view&gt; 123456789101112Page(&#123; open: function()&#123; wx.showActionSheet(&#123; itemList: ['A', 'B', 'C'], success: function(res) &#123; if (!res.cancel) &#123; console.log(res.tapIndex) &#125; &#125; &#125;); &#125;&#125;); 3.5.2 Toast 轻提示123456789101112&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Toast&lt;/view&gt; &lt;view class=\"page__desc\"&gt;弹出式提示，采用小程序原生的 toast&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openToast\"&gt;成功提示&lt;/button&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openLoading\"&gt;加载中提示&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516Page(&#123; openToast: function () &#123; wx.showToast(&#123; title: '已完成', icon: 'success', duration: 3000 &#125;); &#125;, openLoading: function () &#123; wx.showToast(&#123; title: '数据加载中', icon: 'loading', duration: 3000 &#125;); &#125;&#125;); 3.5.3 Modal/dailog 对话框/弹出框预览图1预览图2 12345678&lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openConfirm\"&gt; Confirm Dialog &lt;/button&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openAlert\"&gt; Alert Dialog &lt;/button&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829Page(&#123; openConfirm: function () &#123; wx.showModal(&#123; title: '弹窗标题', content: '弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内', confirmText: \"主操作\", cancelText: \"辅助操作\", success: function (res) &#123; console.log(res); if (res.confirm) &#123; console.log('用户点击主操作') &#125;else&#123; console.log('用户点击辅助操作') &#125; &#125; &#125;); &#125;, openAlert: function () &#123; wx.showModal(&#123; content: '弹窗内容，告知当前状态、信息和解决方法，描述文字尽量控制在三行内', showCancel: false, success: function (res) &#123; if (res.confirm) &#123; console.log('用户点击确定') &#125; &#125; &#125;); &#125;&#125;); 3.5.4 Message/msg 全局提醒/提醒页1234&lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openSuccess\"&gt;成功提示页&lt;/button&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openFail\"&gt;失败提示页&lt;/button&gt;&lt;/view&gt; 123456789101112Page(&#123; openSuccess: function () &#123; wx.navigateTo(&#123; url: 'msg_success' &#125;) &#125;, openFail: function () &#123; wx.navigateTo(&#123; url: 'msg_fail' &#125;) &#125;&#125;); 1234567891011121314151617181920212223242526&lt;!-- 失败提示页面 --&gt;&lt;view class=\"page\"&gt; &lt;view class=\"weui-msg\"&gt; &lt;view class=\"weui-msg__icon-area\"&gt; &lt;icon type=\"warn\" size=\"93\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;view class=\"weui-msg__text-area\"&gt; &lt;view class=\"weui-msg__title\"&gt;操作失败&lt;/view&gt; &lt;view class=\"weui-msg__desc\"&gt;内容详情，可根据实际需要安排，如果换行则不超过规定长度，居中展现&lt;navigator url=\"\" class=\"weui-msg__link\"&gt;文字链接&lt;/navigator&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-msg__opr-area\"&gt; &lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"primary\"&gt;推荐操作&lt;/button&gt; &lt;button class=\"weui-btn\" type=\"default\"&gt;辅助操作&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-msg__extra-area\"&gt; &lt;view class=\"weui-footer\"&gt; &lt;view class=\"weui-footer__links\"&gt; &lt;navigator url=\"\" class=\"weui-footer__link\"&gt;底部链接文本&lt;/navigator&gt; &lt;/view&gt; &lt;view class=\"weui-footer__text\"&gt;Copyright © 2008-2016 weui.io&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526&lt;!-- 成功页面 --&gt;&lt;view class=\"page\"&gt; &lt;view class=\"weui-msg\"&gt; &lt;view class=\"weui-msg__icon-area\"&gt; &lt;icon type=\"success\" size=\"93\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;view class=\"weui-msg__text-area\"&gt; &lt;view class=\"weui-msg__title\"&gt;操作成功&lt;/view&gt; &lt;view class=\"weui-msg__desc\"&gt;内容详情，可根据实际需要安排，如果换行则不超过规定长度，居中展现&lt;navigator url=\"\" class=\"weui-msg__link\"&gt;文字链接&lt;/navigator&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-msg__opr-area\"&gt; &lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"primary\"&gt;推荐操作&lt;/button&gt; &lt;button class=\"weui-btn\" type=\"default\"&gt;辅助操作&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-msg__extra-area\"&gt; &lt;view class=\"weui-footer\"&gt; &lt;view class=\"weui-footer__links\"&gt; &lt;navigator url=\"\" class=\"weui-footer__link\"&gt;底部链接文本&lt;/navigator&gt; &lt;/view&gt; &lt;view class=\"weui-footer__text\"&gt;Copyright © 2008-2016 weui.io&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 3.5.5 Spin/loadmore 加载中/加载更多1234567891011&lt;view class=\"weui-loadmore\"&gt; &lt;view class=\"weui-loading\"&gt;&lt;/view&gt; &lt;view class=\"weui-loadmore__tips\"&gt;正在加载&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-loadmore weui-loadmore_line\"&gt; &lt;view class=\"weui-loadmore__tips weui-loadmore__tips_in-line\"&gt;暂无数据&lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-loadmore weui-loadmore_line weui-loadmore_dot\"&gt; &lt;view class=\"weui-loadmore__tips weui-loadmore__tips_in-line weui-loadmore__tips_in-dot\"&gt; &lt;/view&gt;&lt;/view&gt; 3.5.6 Swipeout 滑动菜单3.5.7 Picker 选择器12345678910111213141516171819&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Picker&lt;/view&gt; &lt;view class=\"page__desc\"&gt;选择器，这里使用小程序原生的picker。&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-btn-area\"&gt; &lt;picker bindchange=\"bindPickerChange\" value=\"&#123;&#123;index&#125;&#125;\" range=\"&#123;&#123;array&#125;&#125;\"&gt; &lt;button type=\"default\"&gt;单列选择器&lt;/button&gt; &lt;/picker&gt; &lt;picker class=\"weui-btn\" mode=\"time\" value=\"&#123;&#123;time&#125;&#125;\" start=\"09:01\" end=\"21:01\" bindchange=\"bindTimeChange\"&gt; &lt;button type=\"default\"&gt;时间选择器&lt;/button&gt; &lt;/picker&gt; &lt;picker class=\"weui-btn\" mode=\"date\" value=\"&#123;&#123;date&#125;&#125;\" start=\"2015-09-01\" end=\"2017-09-01\" bindchange=\"bindDateChange\"&gt; &lt;button type=\"default\"&gt;日期选择器&lt;/button&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324Page(&#123; data: &#123; array: ['美国', '中国', '巴西', '日本'], index: 0, date: '2016-09-01', time: '12:01' &#125;, bindPickerChange: function(e) &#123; console.log('picker 发送选择改变，携带值为', e.detail.value) this.setData(&#123; index: e.detail.value &#125;) &#125;, bindDateChange: function(e) &#123; this.setData(&#123; date: e.detail.value &#125;) &#125;, bindTimeChange: function(e) &#123; this.setData(&#123; time: e.detail.value &#125;) &#125;&#125;); 3.5.8 toast 弹出式提示1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;.page&#123; background-color: #FFFFFF;&#125;&lt;/style&gt;&lt;template&gt; &lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Toast&lt;/view&gt; &lt;view class=\"page__desc\"&gt;弹出式提示，采用小程序原生的toast&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openToast\"&gt;成功提示&lt;/button&gt; &lt;button class=\"weui-btn\" type=\"default\" bindtap=\"openLoading\"&gt;加载中提示&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; openToast: function () &#123; wx.showToast(&#123; title: '已完成', icon: 'success', duration: 3000 &#125;); &#125;, openLoading: function () &#123; wx.showToast(&#123; title: '数据加载中', icon: 'loading', duration: 3000 &#125;); &#125;&lt;/script&gt; 3.6 视图3.6.1 Badge 徽章12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;view class=\"weui-cells__title\"&gt;新消息提示跟摘要信息后，统一在列表右侧&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_access\"&gt; &lt;view class=\"weui-cell__bd\"&gt;单行列表&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\" style=\"font-size: 0\"&gt; &lt;view style=\"display: inline-block;vertical-align:middle; font-size: 17px;\"&gt; 详细信息 &lt;/view&gt; &lt;view class=\"weui-badge weui-badge_dot\" style=\"margin-left: 5px;margin-right: 5px;\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;未读数红点跟在主题信息后，统一在列表左侧&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell\"&gt; &lt;view class=\"weui-cell__hd\" style=\"position: relative;margin-right: 10px;\"&gt; &lt;image src=\"../images/pic_160.png\" style=\"width: 50px; height: 50px; display: block\" /&gt; &lt;view class=\"weui-badge\" style=\"position: absolute;top: -.4em;right: -.4em;\"&gt;8&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view&gt;联系人名称&lt;/view&gt; &lt;view style=\"font-size: 13px;color: #888888;\"&gt;摘要信息&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_access\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view style=\"display: inline-block; vertical-align: middle\"&gt;单行列表&lt;/view&gt; &lt;view class=\"weui-badge\" style=\"margin-left: 5px;\"&gt;8&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_access\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view style=\"display: inline-block; vertical-align: middle\"&gt;单行列表&lt;/view&gt; &lt;view class=\"weui-badge\" style=\"margin-left: 5px;\"&gt;8&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;详细信息&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_access\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view style=\"display: inline-block; vertical-align: middle\"&gt;单行列表&lt;/view&gt; &lt;view class=\"weui-badge\" style=\"margin-left: 5px;\"&gt;New&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-access\"&gt;&lt;/view&gt; &lt;/view&gt; 3.6.2 Alert 警告提示3.6.3 Tag 标签3.6.4 Progress 进度条12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Progress&lt;/view&gt; &lt;view class=\"page__desc\"&gt;进度条，这里采用小程序原生的 progress&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd page__bd_spacing\"&gt; &lt;view class=\"weui-progress\"&gt; &lt;view class=\"weui-progress__bar\"&gt; &lt;progress percent=\"0\" stroke-width=\"3\" /&gt; &lt;/view&gt; &lt;view class=\"weui-progress__opr\"&gt; &lt;icon type=\"cancel\" size=\"22\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-progress\"&gt; &lt;view class=\"weui-progress__bar\"&gt; &lt;progress percent=\"50\" stroke-width=\"3\" /&gt; &lt;/view&gt; &lt;view class=\"weui-progress__opr\"&gt; &lt;icon type=\"cancel\" size=\"22\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-progress\"&gt; &lt;view class=\"weui-progress__bar\"&gt; &lt;progress percent=\"80\" stroke-width=\"3\" /&gt; &lt;/view&gt; &lt;view class=\"weui-progress__opr\"&gt; &lt;icon type=\"cancel\" size=\"22\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-progress\"&gt; &lt;view class=\"weui-progress__bar\"&gt; &lt;progress percent=\"&#123;&#123;progress&#125;&#125;\" stroke-width=\"3\" /&gt; &lt;/view&gt; &lt;view class=\"weui-progress__opr\"&gt; &lt;icon type=\"cancel\" size=\"22\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"upload\" disabled=\"&#123;&#123;disabled&#125;&#125;\"&gt;上传&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123.weui-progress&#123; margin-bottom: 24px;&#125; 12345678910111213141516171819202122232425262728293031function _next()&#123; var that = this; if(this.data.progress &gt;= 100)&#123; this.setData(&#123; disabled: false &#125;); return true; &#125; this.setData(&#123; progress: ++this.data.progress &#125;); setTimeout(function()&#123; _next.call(that); &#125;, 20);&#125;Page(&#123; data: &#123; progress: 0, disabled: false &#125;, upload: function()&#123; if(this.data.disabled) return; this.setData(&#123; progress: 0, disabled: true &#125;); _next.call(this); &#125;&#125;); 3.6.5 Avatar 头像3.6.6 Collapse 折叠面板3.6.7 CountDown 倒计时3.6.8 Divider 分隔符3.6.9 LoadMore 页底提示3.7 表单3.7.1 Input 输入框预览图1预览图2预览图3预览图4预览图5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189&lt;view class=\"weui-toptips weui-toptips_warn\" wx:if=\"&#123;&#123;showTopTips&#125;&#125;\"&gt; 错误提示&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;单选列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;radio-group bindchange=\"radioChange\"&gt; &lt;label class=\"weui-cell weui-check__label\" wx:for=\"&#123;&#123;radioItems&#125;&#125;\" wx:key=\"value\"&gt; &lt;radio class=\"weui-check\" value=\"&#123;&#123;item.value&#125;&#125;\" checked=\"&#123;&#123;item.checked&#125;&#125;\" /&gt; &lt;view class=\"weui-cell__bd\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;view class=\"weui-cell__ft weui-cell__ft_in-radio\" wx:if=\"&#123;&#123;item.checked&#125;&#125;\"&gt; &lt;icon class=\"weui-icon-radio\" type=\"success_no_circle\" size=\"16\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/label&gt; &lt;/radio-group&gt; &lt;view class=\"weui-cell weui-cell_link\"&gt; &lt;view class=\"weui-cell__bd\"&gt;添加更多&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;复选列表项&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;checkbox-group bindchange=\"checkboxChange\"&gt; &lt;label class=\"weui-cell weui-check__label\" wx:for=\"&#123;&#123;checkboxItems&#125;&#125;\" wx:key=\"value\"&gt; &lt;checkbox class=\"weui-check\" value=\"&#123;&#123;item.value&#125;&#125;\" checked=\"&#123;&#123;item.checked&#125;&#125;\" /&gt; &lt;view class=\"weui-cell__hd weui-check__hd_in-checkbox\"&gt; &lt;icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"&#123;&#123;!item.checked&#125;&#125;\"&gt; &lt;/icon&gt; &lt;icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\" wx:if=\"&#123;&#123;item.checked&#125;&#125;\"&gt; &lt;/icon&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; &lt;/label&gt; &lt;/checkbox-group&gt; &lt;view class=\"weui-cell weui-cell_link\"&gt; &lt;view class=\"weui-cell__bd\"&gt;添加更多&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;表单&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;qq&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;input class=\"weui-input\" placeholder=\"请输入qq\" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input weui-cell_vcode\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;手机号&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;input class=\"weui-input\" placeholder=\"请输入手机号\" /&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt; &lt;view class=\"weui-vcode-btn\"&gt;获取验证码&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;日期&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;picker mode=\"date\" value=\"&#123;&#123;date&#125;&#125;\" start=\"2015-09-01\" end=\"2017-09-01\" bindchange=\"bindDateChange\"&gt; &lt;view class=\"weui-input\"&gt;&#123;&#123;date&#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;时间&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;picker mode=\"time\" value=\"&#123;&#123;time&#125;&#125;\" start=\"09:01\" end=\"21:01\" bindchange=\"bindTimeChange\"&gt; &lt;view class=\"weui-input\"&gt;&#123;&#123;time&#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input weui-cell_vcode\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;验证码&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;input class=\"weui-input\" placeholder=\"请输入验证码\" /&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt; &lt;image class=\"weui-vcode-img\" src=\"../images/vcode.jpg\" style=\"width: 108px\"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__tips\"&gt;底部说明文字底部说明文字&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;表单报错&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_input weui-cell_warn\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;卡号&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;input class=\"weui-input\" placeholder=\"请输入卡号\" /&gt; &lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt; &lt;icon type=\"warn\" size=\"23\" color=\"#E64340\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;开关&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_switch\"&gt; &lt;view class=\"weui-cell__bd\"&gt;标题文字&lt;/view&gt; &lt;view class=\"weui-cell__ft\"&gt; &lt;switch checked /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;文本框&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;input class=\"weui-input\" placeholder=\"请输入文本\" /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;文本域&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;textarea class=\"weui-textarea\" placeholder=\"请输入文本\" style=\"height: 3.3em\" /&gt; &lt;view class=\"weui-textarea-counter\"&gt;0/200&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;选择&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_select\"&gt; &lt;view class=\"weui-cell__hd\" style=\"width: 105px\"&gt; &lt;picker bindchange=\"bindCountryCodeChange\" value=\"&#123;&#123;countryCodeIndex&#125;&#125;\" range=\"&#123;&#123;countryCodes&#125;&#125;\"&gt; &lt;view class=\"weui-select\"&gt;&#123;&#123;countryCodes[countryCodeIndex]&#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd weui-cell__bd_in-select-before\"&gt; &lt;input class=\"weui-input\" placeholder=\"请输入号码\" /&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=\"weui-cells__title\"&gt;选择&lt;/view&gt;&lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_select\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;picker bindchange=\"bindAccountChange\" value=\"&#123;&#123;accountIndex&#125;&#125;\" range=\"&#123;&#123;accounts&#125;&#125;\"&gt; &lt;view class=\"weui-select\"&gt;&#123;&#123;accounts[accountIndex]&#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_select\"&gt; &lt;view class=\"weui-cell__hd weui-cell__hd_in-select-after\"&gt; &lt;view class=\"weui-label\"&gt;国家/地区&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;picker bindchange=\"bindCountryChange\" value=\"&#123;&#123;countryIndex&#125;&#125;\" range=\"&#123;&#123;countries&#125;&#125;\"&gt; &lt;view class=\"weui-select weui-select_in-select-after\"&gt;&#123;&#123;countries[countryIndex]&#125;&#125;&lt;/view&gt; &lt;/picker&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;checkbox-group bindchange=\"bindAgreeChange\"&gt; &lt;label class=\"weui-agree\" for=\"weuiAgree\"&gt; &lt;view class=\"weui-agree__text\"&gt; &lt;checkbox class=\"weui-agree__checkbox\" id=\"weuiAgree\" value=\"agree\" checked=\"&#123;&#123;isAgree&#125;&#125;\" /&gt; &lt;view class=\"weui-agree__checkbox-icon\"&gt; &lt;icon class=\"weui-agree__checkbox-icon-check\" type=\"success_no_circle\" size=\"9\" wx:if=\"&#123;&#123;isAgree&#125;&#125;\"&gt;&lt;/icon&gt; &lt;/view&gt; 阅读并同意 &lt;navigator url=\"\" class=\"weui-agree__link\"&gt;《相关条款》&lt;/navigator&gt; &lt;/view&gt; &lt;/label&gt;&lt;/checkbox-group&gt;&lt;view class=\"weui-btn-area\"&gt; &lt;button class=\"weui-btn\" type=\"primary\" bindtap=\"showTopTips\"&gt;确定&lt;/button&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106Page(&#123; data: &#123; showTopTips: false, radioItems: [ &#123;name: 'cell standard', value: '0'&#125;, &#123;name: 'cell standard', value: '1', checked: true&#125; ], checkboxItems: [ &#123;name: 'standard is dealt for u.', value: '0', checked: true&#125;, &#123;name: 'standard is dealicient for u.', value: '1'&#125; ], date: \"2016-09-01\", time: \"12:01\", countryCodes: [\"+86\", \"+80\", \"+84\", \"+87\"], countryCodeIndex: 0, countries: [\"中国\", \"美国\", \"英国\"], countryIndex: 0, accounts: [\"微信号\", \"QQ\", \"Email\"], accountIndex: 0, isAgree: false &#125;, showTopTips: function()&#123; var that = this; this.setData(&#123; showTopTips: true &#125;); setTimeout(function()&#123; that.setData(&#123; showTopTips: false &#125;); &#125;, 3000); &#125;, radioChange: function (e) &#123; console.log('radio发生change事件，携带value值为：', e.detail.value); var radioItems = this.data.radioItems; for (var i = 0, len = radioItems.length; i &lt; len; ++i) &#123; radioItems[i].checked = radioItems[i].value == e.detail.value; &#125; this.setData(&#123; radioItems: radioItems &#125;); &#125;, checkboxChange: function (e) &#123; console.log('checkbox发生change事件，携带value值为：', e.detail.value); var checkboxItems = this.data.checkboxItems, values = e.detail.value; for (var i = 0, lenI = checkboxItems.length; i &lt; lenI; ++i) &#123; checkboxItems[i].checked = false; for (var j = 0, lenJ = values.length; j &lt; lenJ; ++j) &#123; if(checkboxItems[i].value == values[j])&#123; checkboxItems[i].checked = true; break; &#125; &#125; &#125; this.setData(&#123; checkboxItems: checkboxItems &#125;); &#125;, bindDateChange: function (e) &#123; this.setData(&#123; date: e.detail.value &#125;) &#125;, bindTimeChange: function (e) &#123; this.setData(&#123; time: e.detail.value &#125;) &#125;, bindCountryCodeChange: function(e)&#123; console.log('picker country code 发生选择改变，携带值为', e.detail.value); this.setData(&#123; countryCodeIndex: e.detail.value &#125;) &#125;, bindCountryChange: function(e) &#123; console.log('picker country 发生选择改变，携带值为', e.detail.value); this.setData(&#123; countryIndex: e.detail.value &#125;) &#125;, bindAccountChange: function(e) &#123; console.log('picker account 发生选择改变，携带值为', e.detail.value); this.setData(&#123; accountIndex: e.detail.value &#125;) &#125;, bindAgreeChange: function (e) &#123; this.setData(&#123; isAgree: !!e.detail.value.length &#125;); &#125;&#125;); 3.7.2 Radio 单选3.7.3 Checkbox 复选3.7.4 Switch 开关3.7.0 Slider 滑块1234567891011&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Slider&lt;/view&gt; &lt;view class=\"page__desc\"&gt;滑块，这里采用小程序原生的slider。&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd page__bd_spacing\"&gt; &lt;slider/&gt; &lt;slider show-value value=\"50\"/&gt; &lt;/view&gt;&lt;/view&gt; 123slider&#123; margin-bottom: 30px;&#125; 3.7.5 Rate 评分3.7.6 InputNumber 数字输入框3.7.0 Uploader 上传组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Uploader&lt;/view&gt; &lt;view class=\"page__desc\"&gt;上传组件&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-cells\"&gt; &lt;view class=\"weui-cell\"&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;view class=\"weui-uploader\"&gt; &lt;view class=\"weui-uploader__hd\"&gt; &lt;view class=\"weui-uploader__title\"&gt;图片上传&lt;/view&gt; &lt;view class=\"weui-uploader__info\"&gt;&#123;&#123;files.length&#125;&#125;/2&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-uploader__bd\"&gt; &lt;view class=\"weui-uploader__files\" id=\"uploaderFiles\"&gt; &lt;block wx:for=\"&#123;&#123;files&#125;&#125;\" wx:key=\"*this\"&gt; &lt;view class=\"weui-uploader__file\" bindtap=\"previewImage\" id=\"&#123;&#123;item&#125;&#125;\"&gt; &lt;image class=\"weui-uploader__img\" src=\"&#123;&#123;item&#125;&#125;\" mode=\"aspectFill\" /&gt; &lt;/view&gt; &lt;/block&gt; &lt;view class=\"weui-uploader__file\"&gt; &lt;image class=\"weui-uploader__img\" src=\"../images/pic_160.png\" mode=\"aspectFill\" /&gt; &lt;/view&gt; &lt;view class=\"weui-uploader__file\"&gt; &lt;image class=\"weui-uploader__img\" src=\"../images/pic_160.png\" mode=\"aspectFill\" /&gt; &lt;/view&gt; &lt;view class=\"weui-uploader__file\"&gt; &lt;image class=\"weui-uploader__img\" src=\"../images/pic_160.png\" mode=\"aspectFill\" /&gt; &lt;/view&gt; &lt;view class=\"weui-uploader__file weui-uploader__file_status\"&gt; &lt;image class=\"weui-uploader__img\" src=\"../images/pic_160.png\" mode=\"aspectFill\" /&gt; &lt;view class=\"weui-uploader__file-content\"&gt; &lt;icon type=\"warn\" size=\"23\" color=\"#F43530\"&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-uploader__file weui-uploader__file_status\"&gt; &lt;image class=\"weui-uploader__img\" src=\"../images/pic_160.png\" mode=\"aspectFill\" /&gt; &lt;view class=\"weui-uploader__file-content\"&gt;50%&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-uploader__input-box\"&gt; &lt;view class=\"weui-uploader__input\" bindtap=\"chooseImage\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324Page(&#123; data: &#123; files: [] &#125;, chooseImage: function (e) &#123; var that = this; wx.chooseImage(&#123; sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) &#123; // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片 that.setData(&#123; files: that.data.files.concat(res.tempFilePaths) &#125;); &#125; &#125;) &#125;, previewImage: function(e)&#123; wx.previewImage(&#123; current: e.currentTarget.id, // 当前显示图片的 http 链接 urls: this.data.files // 需要预览的图片 http 链接列表 &#125;) &#125;&#125;); 3.7.0 Preview 表单预览123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Preview&lt;/view&gt; &lt;view class=\"page__desc\"&gt;表单预览&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-form-preview\"&gt; &lt;view class=\"weui-form-preview__hd\"&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;付款金额&lt;/view&gt; &lt;view class=\"weui-form-preview__value_in-hd\"&gt;¥2400.00&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__bd\"&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;商品&lt;/view&gt; &lt;view class=\"weui-form-preview__value\"&gt;电动打蛋机&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;标题标题&lt;/view&gt; &lt;view class=\"weui-form-preview__value\"&gt;名字名字名字&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;标题标题&lt;/view&gt; &lt;view class=\"weui-form-preview__value\"&gt;很长很长的名字很长很长的名字很长很长的名字很长很长的名字很长很长的名字&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__ft\"&gt; &lt;navigator url=\"\" class=\"weui-form-preview__btn weui-form-preview__btn_primary\" hover-class=\"weui-form-preview__btn_active\"&gt;操作&lt;/navigator&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview\"&gt; &lt;view class=\"weui-form-preview__hd\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;付款金额&lt;/view&gt; &lt;view class=\"weui-form-preview__value_in-hd\"&gt;¥2400.00&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__bd\"&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;商品&lt;/view&gt; &lt;view class=\"weui-form-preview__value\"&gt;电动打蛋机&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;标题标题&lt;/view&gt; &lt;view class=\"weui-form-preview__value\"&gt;名字名字名字&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__item\"&gt; &lt;view class=\"weui-form-preview__label\"&gt;标题标题&lt;/view&gt; &lt;view class=\"weui-form-preview__value\"&gt;很长很长的名字很长很长的名字很长很长的名字很长很长的名字很长很长的名字&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-form-preview__ft\"&gt; &lt;navigator class=\"weui-form-preview__btn weui-form-preview__btn_default\" hover-class=\"weui-form-preview__btn_active\"&gt;辅助操作&lt;/navigator&gt; &lt;navigator class=\"weui-form-preview__btn weui-form-preview__btn_primary\" hover-class=\"weui-form-preview__btn_active\"&gt;操作&lt;/navigator&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123.weui-form-preview&#123; margin-bottom: 25px;&#125; 3.8 文章123456789101112131415161718192021222324252627282930313233343536&lt;view class=\"page\"&gt; &lt;view class=\"page__hd\"&gt; &lt;view class=\"page__title\"&gt;Article&lt;/view&gt; &lt;view class=\"page__desc\"&gt;文章&lt;/view&gt; &lt;/view&gt; &lt;view class=\"page__bd\"&gt; &lt;view class=\"weui-article\"&gt; &lt;view class=\"weui-article__h1\"&gt;大标题&lt;/view&gt; &lt;view class=\"weui-article__section\"&gt; &lt;view class=\"weui-article__title\"&gt;章标题&lt;/view&gt; &lt;view class=\"weui-article__section\"&gt; &lt;view class=\"weui-article__h3\"&gt;1.1 节标题&lt;/view&gt; &lt;view class=\"weui-article__p\"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. &lt;/view&gt; &lt;view class=\"weui-article__p\"&gt; &lt;image class=\"weui-article__img\" src=\"../images/pic_article.png\" mode=\"aspectFit\" style=\"height: 180px\" /&gt; &lt;image class=\"weui-article__img\" src=\"../images/pic_article.png\" mode=\"aspectFit\" style=\"height: 180px\" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-article__section\"&gt; &lt;view class=\"weui-article__h3\"&gt;1.2 节标题&lt;/view&gt; &lt;view class=\"weui-article__p\"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123456page&#123; background-color: #FFFFFF;&#125;image&#123; margin: 4px 0;&#125;","tags":[]},{"title":"Normalize.css 一个很小的 CSS 文件","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-normalize.css 兼容浏览器/","text":"一、前言Normalize 翻译：规格化，正常化。 Normalize.css 只是一个很小的 CSS 文件，但它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案。Normalize.css 现在已经被用于 Twitter, Bootstrap,HTML5,Boilerplate,GOV.UK,Rdio,CSS, Tricks 以及许许多多其他框架、工具和网站上。 Normalize.css 是一种 CSS reset 的替代方案。经过 @necolas 和 @jon_neal 花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样。 英文官网Normalize.css 项目 gitHub 地址Normalize.css 在 GitHub 上的源码 二、normalize.css 用处/特点我们创造 normalize.css 有下面这几个目的 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分 HTML 元素提供 修复浏览器自身的 bug 并保证各浏览器的一致性 优化 CSS 可用性：用一些小技巧 解释代码：用注释和详细的文档来 Normalize.css 支持包括 手机浏览器 在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。 三、Normalize vs Reset 之前的区别知道 Normalize.css 和传统 Reset 的区别是非常有价值的。无论从适用范畴还是实施上，Normalize.css 与 Reset 都有极大的不同。尝试一下这两种方法并看看到底哪种更适合你的开发偏好是非常值得的。 3.1 Normalize.css 保护了有价值的默认值Reset 通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css 保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css 会力求让这些样式保持一致并尽可能与现代标准相符合。 3.2 Normalize.css 修复了浏览器的 bug它修复了常见的 桌面端 和 移动端浏览器的 bug。这往往超出了 Reset 所能做到的范畴。关于这一点，Normalize.css 修复的问题包含了 HTML5 元素的显示设置、预格式化文字的 font-size 问题、在 IE9 中 SVG 的溢出、许多出现在各浏览器和操作系统中的与表单相关的 bug。 12345678910111213141516171819202122/* 下面的例子，看看对于 HTML5 中新出现的 input 类型 search，Normalize.css 是如何保证跨浏览器的一致性的。 *//** * 1. Addresses appearance set to searchfield in S5, Chrome * 2. Addresses box-sizing set to border-box in S5, Chrome (include -moz to future-proof) */input[type=\"search\"] &#123; -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box;&#125;/** * Removes inner padding and search cancel button in S5, Chrome on OS X */input[type=\"search\"]::-webkit-search-decoration,input[type=\"search\"]::-webkit-search-cancel-button &#123; -webkit-appearance: none;&#125; 3.3 Normalize.css 不会让你的调试工具变的杂乱使用 Reset 最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链，如下图所示。在 Normalize.css 中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。 3.4 Normalize.css 是模块化的这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。 3.5 Normalize.css 拥有详细的文档Normalize.css 的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在 Github Wiki 中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。 这个项目的目标是帮助人们了解浏览器默认是如何渲染元素的，同时也让人们很容易地明白如何改进浏览器渲染。 四、使用 Normalize.css4.1 安装导入 Normalize.css4.1.1 npm 安装方法1$ npm install normalize.css 4.1.2 下载独立文件引用gitHub 下载地址 有两种主要途径去使用它策略一：将 normalize.css 作为你自己项目的基础 CSS，自定义样式值以满足设计师的需求。策略二：引入 normalize.css 源码并在此基础上构建，在必要的时候用你自己写的 CSS 覆盖默认值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css *//* Document ========================================================================== *//** * 1. Correct the line height in all browsers. * 2. Prevent adjustments of font size after orientation changes in iOS. */html &#123; line-height: 1.15; /* 1 */ -webkit-text-size-adjust: 100%; /* 2 */&#125;/* Sections ========================================================================== *//** * Remove the margin in all browsers. */body &#123; margin: 0;&#125;/** * Render the `main` element consistently in IE. */main &#123; display: block;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/* Grouping content ========================================================================== *//** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */pre &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/* Text-level semantics ========================================================================== *//** * Remove the gray background on active links in IE 10. */a &#123; background-color: transparent;&#125;/** * 1. Remove the bottom border in Chrome 57- * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Remove the border on images inside links in IE 10. */img &#123; border-style: none;&#125;/* Forms ========================================================================== *//** * 1. Change the font styles in all browsers. * 2. Remove the margin in Firefox and Safari. */button,input,optgroup,select,textarea &#123; font-family: inherit; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * Correct the inability to style clickable types in iOS and Safari. */button,[type=\"button\"],[type=\"reset\"],[type=\"submit\"] &#123; -webkit-appearance: button;&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type=\"button\"]::-moz-focus-inner,[type=\"reset\"]::-moz-focus-inner,[type=\"submit\"]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type=\"button\"]:-moz-focusring,[type=\"reset\"]:-moz-focusring,[type=\"submit\"]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Correct the padding in Firefox. */fieldset &#123; padding: 0.35em 0.75em 0.625em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; vertical-align: baseline;&#125;/** * Remove the default vertical scrollbar in IE 10+. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10. * 2. Remove the padding in IE 10. */[type=\"checkbox\"],[type=\"radio\"] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type=\"number\"]::-webkit-inner-spin-button,[type=\"number\"]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type=\"search\"] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding in Chrome and Safari on macOS. */[type=\"search\"]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;/* Interactive ========================================================================== *//* * Add the correct display in Edge, IE 10+, and Firefox. */details &#123; display: block;&#125;/* * Add the correct display in all browsers. */summary &#123; display: list-item;&#125;/* Misc ========================================================================== *//** * Add the correct display in IE 10+. */template &#123; display: none;&#125;/** * Add the correct display in IE 10. */[hidden] &#123; display: none;&#125;","tags":[]},{"title":"redux 状态容器 在 wepy 框架使用","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-状态管理器==-redux/","text":"一、前言在学习 wepy-redux 状态管理器之前，先学习一下 redux 。 redux 中文文档英文原版Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 (如果你需要一个 WordPress 框架，请查看 Redux Framework。)可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 Redux 除了和 React 一起用外（react-redux），还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。wepy-redux 就是其中一个，在小程序中我们需要学习的。 二、redux 的含义Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 (如果你需要一个 WordPress 框架，请查看 Redux Framework) 可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 Redux 除了和 React 一起用外，还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。 三、redux 安装1npm install --save redux 附加包多数情况下，你还需要使用 React 绑定库和开发者工具。 npm install –save react-reduxnpm install –save-dev redux-devtools需要提醒的是，和 Redux 不同，很多 Redux 生态下的包并不提供 UMD 文件，所以为了提升开发体验，我们建议使用像 Webpack 和 Browserify 这样的 CommonJS 模块打包器。 四、redux 学习使用4.1 state应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers。 action 就像是描述发生了什么的指示器。最终，为了把 action 和 state 串起来，开发一些函数，这就是 reducer。再次地，没有任何魔法，reducer 只是一个接收 state 和 action，并返回新的 state 的函数。 简单来说就是 type： 表示将要执行的动作state： 状态—–存储在 store 中的状态action 对象： 异步方法-被触发时候改变 state 状态树 （actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。）reducers：描述 action 如何改变 state 树 （指定了应用状态的变化如何响应） 4.1.1 state 含义随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。 管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。 我们总是将两个难以理清的概念混淆在一起：变化和异步。 如果把二者分开，能做的很好，但混到一起，就变得一团糟。 4.1.2 三大原则：单一数据源，State 是只读的，使用纯函数来执行修改 单一数据源：整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，你可以把应用的 state 保存在本地，从而加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。 State 是只读的：唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。 这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心 race condition 的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。 使用纯函数来执行修改：为了描述 action 如何改变 state tree ，需要编写 reducers。 Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分，因为 reducer 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 reducer 来处理一些通用任务，如分页器。 4.2 Action 修改 state 状态Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。 英文翻译：dispatch 派送，发送。 4.2.1 type 表示 action 要执行的动作12345&#123; type: TOGGLE_TODO, index: 5 //我们应该尽量减少在 action 中传递的数据。传递 index 就比把整个任务对象传过去要好。&#125; 1234&#123; type: SET_VISIBILITY_FILTER, //最后，再添加一个 action type 来表示当前的任务展示选项。 filter: SHOW_COMPLETED&#125; 4.2.2 Action 创建函数，dispatch() 方法12345678910111213// Action 创建函数 就是生成 action 的方法。“action” 和 “action 创建函数” 这两个概念很容易混在一起，使用时最好注意区分。//在 Redux 中的 action 创建函数只是简单的返回一个 action://这样做将使 action 创建函数更容易被移植和测试。function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;dispatch(addTodo(text))dispatch(completeTodo(index))//Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。 123456//或者创建一个 被绑定的 action 创建函数 来自动 dispatch：const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index))//然后直接调用它们：boundAddTodo(text);boundCompleteTodo(index); 4.2.3 connect() 帮助器store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的 connect() 帮助器来调用。bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。 Action 创建函数也可以是异步非纯函数。你可以通过阅读 高级教程 中的 异步 action章节，学习如何处理 AJAX 响应和如何把 action 创建函数组合进异步控制流。因为基础教程中包含了阅读高级教程和异步 action 章节所需要的一些重要基础概念, 所以请在移步异步 action 之前, 务必先完成基础教程。 4.3 ReducerReducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。 4.3.1 设计 State 结构在 Redux 应用中，所有的 state 都被保存在一个单一对象中。 建议在写代码前先想一下这个对象的结构。如何才能以最简的形式把应用的 state 用对象描述出来？ 以 todo 应用为例，需要保存两种不同的数据： 当前选中的任务过滤条件； 完整的任务列表。 通常，这个 state 树还需要存放其它一些数据，以及一些 UI 相关的 state。这样做没问题，但尽量把这些数据与 UI 相关的 state 分开 1234567891011121314// ?????这里是在说什么啊？？&#123; visibilityFilter: 'SHOW_ALL', todos: [ &#123; text: 'Consider using Redux', completed: true, &#125;, &#123; text: 'Keep all state in a single tree', completed: false &#125; ]&#125; 处理 Reducer 关系时的注意事项开发复杂的应用时，不可避免会有一些数据相互引用。建议你尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据。把应用的 state 想像成数据库。这种方法在 normalizr 文档里有详细阐述。例如，实际开发中，在 state 里同时存放 todosById: { id -&gt; todo } 和 todos: array 是比较好的方式，本文中为了保持示例简单没有这样处理。 4.3.2 Action 处理现在我们已经确定了 state 对象的结构，就可以开始开发 reducer。reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。(previousState, action) =&gt; newState 之所以将这样的函数称之为reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue) 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。 永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 在高级篇里会介绍如何执行有副作用的操作。现在只需要谨记 reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。 1234567891011121314// actions&#123; visibilityFilter: 'SHOW_ALL', todos: [ &#123; text: 'Consider using Redux', completed: true, &#125;, &#123; text: 'Keep all state in a single tree', completed: false &#125; ]&#125; 123456789101112131415161718192021222324// reducersimport &#123; VisibilityFilters &#125; from './actions'const initialState = &#123; visibilityFilter: VisibilityFilters.SHOW_ALL, todos: []&#125;;// ① ES5function todoApp(state, action) &#123; if (typeof state === 'undefined') &#123; return initialState &#125; // 这里暂不处理任何 action， // 仅返回传入的 state。 return state&#125;//② ES6 参数默认值语法 来精简代码。function todoApp(state = initialState, action) &#123; // 这里暂不处理任何 action， // 仅返回传入的 state。 return state&#125; 现在可以处理 SET_VISIBILITY_FILTER。需要做的只是改变 state 中的 visibilityFilter。 12345678910111213141516171819202122232425262728// reducerimport &#123; VisibilityFilters &#125; from './actions'const initialState = &#123; visibilityFilter: VisibilityFilters.SHOW_ALL, todos: []&#125;;function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) // ES6 Object.assign 方法可以很方便地一次向类添加多个方法。 /* class Point &#123; constructor()&#123; // ... &#125; &#125; Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125; &#125;); */ default: return state &#125;&#125; 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, { visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { …state, …newState } 达到相同的目的。 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。 Object.assign 须知Object.assign() 是 ES6 特性，但多数浏览器并不支持。你要么使用 polyfill，Babel 插件，或者使用其它库如 _.assign() 提供的帮助方法。 switch 和样板代码须知switch 语句并不是严格意义上的样板代码。Flux 中真实的样板代码是概念性的：更新必须要发送、Store 必须要注册到 Dispatcher、Store 必须是对象（开发同构应用时变得非常复杂）。为了解决这些问题，Redux 放弃了 event emitters（事件发送器），转而使用纯 reducer。 很不幸到现在为止，还有很多人存在一个误区：根据文档中是否使用 switch 来决定是否使用它。如果你不喜欢 switch，完全可以自定义一个 createReducer 函数来接收一个事件处理函数列表，参照”减少样板代码”。 4.3.3 处理多个 action还有两个 action 需要处理。就像我们处理 SET_VISIBILITY_FILTER 一样，我们引入 ADD_TODO 和 TOGGLE_TODO 两个actions 并且扩展我们的 reducer 去处理 ADD_TODO. 1234567891011121314151617181920212223242526272829303132333435363738394041// reducer 处理多个 actionsimport &#123; ADD_TODO,//引进 action 状态名 type acton.type TOGGLE_TODO,//引进 action 状态名 type acton.type SET_VISIBILITY_FILTER,//引进 action 状态名 type acton.type VisibilityFilters//引进 acton.js&#125; from './actions'// action 处理function todoApp(state = initialState, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: // 处理 SET_VISIBILITY_FILTER return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) case ADD_TODO: // 处理 ADD_TODO return Object.assign(&#123;&#125;, state, &#123; todos: [ ...state.todos, &#123; text: action.text, completed: false &#125; ] &#125;) case TOGGLE_TODO: // 处理 TOGGLE_TODO 翻译：toggle 切换 return Object.assign(&#123;&#125;, state, &#123; todos: state.todos.map((todo, index) =&gt; &#123; if (index === action.index) &#123; return Object.assign(&#123;&#125;, todo, &#123; completed: !todo.completed &#125;) &#125; return todo &#125;) &#125;) default: // 默认返回 return state &#125;&#125; 如上，不直接修改 state 中的字段，而是返回新对象。新的 todos 对象就相当于旧的 todos 在末尾加上新建的 todo。而这个新的 todo 又是基于 action 中的数据创建的。 最后，TOGGLE_TODO 的实现也很好理解：case ADD_TODO我们需要修改数组中指定的数据项而又不希望导致突变, 因此我们的做法是在创建一个新的数组后, 将那些无需修改的项原封不动移入, 接着对需修改的项用新生成的对象替换。(译者注：Javascript 中的对象存储时均是由值和指向值的引用两个部分构成。此处突变指直接修改引用所指向的值, 而引用本身保持不变。) 如果经常需要这类的操作，可以选择使用帮助类 React-addons-update，updeep，或者使用原生支持深度更新的库 Immutable。最后，时刻谨记永远不要在克隆 state 前修改它。 4.3.4 拆分 Reducer4.3.3 节的代码看起来有些冗长： 能否变得更通俗易懂？这里的 todos 和 visibilityFilter 的更新看起来是相互独立的。有时 state 中的字段是相互依赖的，需要认真考虑，但在这个案例中我们可以把 todos 更新的业务逻辑拆分到一个单独的函数里： 4.4 store123456// store 文件夹目录下的 index.jsindex.jsimport &#123; createStore &#125; from 'redux'import todoApp from './reducers'let store = createStore(todoApp) action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。 Store 就是把它们联系到一起的对象。Store 有以下职责： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 再次强调一下 Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。 十、完整的 todolist 的运用 （这了是与 react 的结合使用）12345678910111213141516171819202122├── components/ #| ├── Todo.js| ├── TodoList.js #| ├── Link.js| ├── Footer.js| └── App.js #|├── containers/| ├── VisibleTodoList.js| ├── FilterLink.js #| └── AddTodo.js #|├── store/ #| ├── actions/ #| | └── index.js| || ├── reducers/| | ├── todos.js # 拆分 reducers| | ├── visibilityFilter.js # 拆分 reducers| | └── index.js #| || └── index.js # 入口文件 10.1 入口文件 index.js123456789101112131415import React from 'react'import &#123; render &#125; from 'react-dom'import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 10.2 actions/index.js12345678910111213141516171819202122let nextTodoId = 0export const addTodo = text =&gt; &#123; return &#123; type: 'ADD_TODO', id: nextTodoId++, text &#125;&#125;export const setVisibilityFilter = filter =&gt; &#123; return &#123; type: 'SET_VISIBILITY_FILTER', filter &#125;&#125;export const toggleTodo = id =&gt; &#123; return &#123; type: 'TOGGLE_TODO', id &#125;&#125; 10.3 reducers/todos.js reducers/visibilityFilter.js123456789101112131415161718192021222324//reducers/todos.jsconst todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case 'ADD_TODO': return [ ...state, &#123; id: action.id, text: action.text, completed: false &#125; ] case 'TOGGLE_TODO': return state.map(todo =&gt; (todo.id === action.id) ? &#123;...todo, completed: !todo.completed&#125; : todo ) default: return state &#125;&#125;export default todos 12345678910//reducers/visibilityFilter.jsconst visibilityFilter = (state = 'SHOW_ALL', action) =&gt; &#123; switch (action.type) &#123; case 'SET_VISIBILITY_FILTER': return action.filter default: return state &#125;&#125;export default visibilityFilter 12345678910// reducers/index.jsimport &#123; combineReducers &#125; from 'redux'import todos from './todos'import visibilityFilter from './visibilityFilter'const todoApp = combineReducers(&#123; todos, visibilityFilter&#125;)export default todoApp 10.4 components/Todo.js123456789101112131415161718192021import React from 'react'import PropTypes from 'prop-types'const Todo = (&#123; onClick, completed, text &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123; &#123; textDecoration: completed ? 'line-through' : 'none' &#125; &#125; &gt; &#123;text&#125; &lt;/li&gt;)Todo.propTypes = &#123; onClick: PropTypes.func.isRequired, completed: PropTypes.bool.isRequired, text: PropTypes.string.isRequired&#125;export default Todo 12345678910111213141516171819202122232425components/TodoList.jsimport React from 'react'import PropTypes from 'prop-types'import Todo from './Todo'const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; ( &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; ))&#125; &lt;/ul&gt;)TodoList.propTypes = &#123; todos: PropTypes.arrayOf( PropTypes.shape(&#123; id: PropTypes.number.isRequired, completed: PropTypes.bool.isRequired, text: PropTypes.string.isRequired &#125;).isRequired ).isRequired, onTodoClick: PropTypes.func.isRequired&#125;export default TodoList 12345678910111213141516171819202122// components/Todo.jsimport React from 'react'import PropTypes from 'prop-types'const Todo = (&#123; onClick, completed, text &#125;) =&gt; ( &lt;li onClick=&#123;onClick&#125; style=&#123; &#123; textDecoration: completed ? 'line-through' : 'none' &#125; &#125; &gt; &#123;text&#125; &lt;/li&gt;)Todo.propTypes = &#123; onClick: PropTypes.func.isRequired, completed: PropTypes.bool.isRequired, text: PropTypes.string.isRequired&#125;export default Todo 12345678910111213141516171819202122232425// components/TodoList.jsimport React from 'react'import PropTypes from 'prop-types'import Todo from './Todo'const TodoList = (&#123; todos, onTodoClick &#125;) =&gt; ( &lt;ul&gt; &#123;todos.map(todo =&gt; ( &lt;Todo key=&#123;todo.id&#125; &#123;...todo&#125; onClick=&#123;() =&gt; onTodoClick(todo.id)&#125; /&gt; ))&#125; &lt;/ul&gt;)TodoList.propTypes = &#123; todos: PropTypes.arrayOf( PropTypes.shape(&#123; id: PropTypes.number.isRequired, completed: PropTypes.bool.isRequired, text: PropTypes.string.isRequired &#125;).isRequired ).isRequired, onTodoClick: PropTypes.func.isRequired&#125;export default TodoList 1234567891011121314151617181920212223242526272829components/Link.jsimport React from 'react'import PropTypes from 'prop-types'const Link = (&#123; active, children, onClick &#125;) =&gt; &#123; if (active) &#123; return &lt;span&gt;&#123;children&#125;&lt;/span&gt; &#125; return ( &lt;a href=\"\" onClick=&#123;e =&gt; &#123; e.preventDefault() onClick() &#125; &#125; &gt; &#123;children&#125; &lt;/a&gt; )&#125;Link.propTypes = &#123; active: PropTypes.bool.isRequired, children: PropTypes.node.isRequired, onClick: PropTypes.func.isRequired&#125;export default Link 1234567891011121314151617181920212223components/Footer.jsimport React from 'react'import FilterLink from '../containers/FilterLink'const Footer = () =&gt; ( &lt;p&gt; Show: &#123;' '&#125; &lt;FilterLink filter=\"SHOW_ALL\"&gt; All &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=\"SHOW_ACTIVE\"&gt; Active &lt;/FilterLink&gt; &#123;', '&#125; &lt;FilterLink filter=\"SHOW_COMPLETED\"&gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)export default Footer 123456789101112131415//components/App.jsimport React from 'react'import Footer from './Footer'import AddTodo from '../containers/AddTodo'import VisibleTodoList from '../containers/VisibleTodoList'const App = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;)export default App 10.5 容器组件，其他组件12345678910111213141516171819202122232425262728293031323334353637// containers/VisibleTodoList.jsimport &#123; connect &#125; from 'react-redux'import &#123; toggleTodo &#125; from '../actions'import TodoList from '../components/TodoList'const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case 'SHOW_COMPLETED': return todos.filter(t =&gt; t.completed) case 'SHOW_ACTIVE': return todos.filter(t =&gt; !t.completed) case 'SHOW_ALL': default: return todos &#125;&#125;const mapStateToProps = state =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; onTodoClick: id =&gt; &#123; dispatch(toggleTodo(id)) &#125; &#125;&#125;const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList)export default VisibleTodoList 12345678910111213141516171819202122232425//containers/FilterLink.jsimport &#123; connect &#125; from 'react-redux'import &#123; setVisibilityFilter &#125; from '../actions'import Link from '../components/Link'const mapStateToProps = (state, ownProps) =&gt; &#123; return &#123; active: ownProps.filter === state.visibilityFilter &#125;&#125;const mapDispatchToProps = (dispatch, ownProps) =&gt; &#123; return &#123; onClick: () =&gt; &#123; dispatch(setVisibilityFilter(ownProps.filter)) &#125; &#125;&#125;const FilterLink = connect( mapStateToProps, mapDispatchToProps)(Link)export default FilterLink 123456789101112131415161718192021222324252627282930313233343536//其他组件// containers/AddTodo.jsimport React from 'react'import &#123; connect &#125; from 'react-redux'import &#123; addTodo &#125; from '../actions'let AddTodo = (&#123; dispatch &#125;) =&gt; &#123; let input return ( &lt;div&gt; &lt;form onSubmit=&#123;e =&gt; &#123; e.preventDefault() if (!input.value.trim()) &#123; return &#125; dispatch(addTodo(input.value)) input.value = '' &#125; &#125; &gt; &lt;input ref=&#123;node =&gt; &#123; input = node &#125; &#125; /&gt; &lt;button type=\"submit\"&gt; Add Todo &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; )&#125;AddTodo = connect()(AddTodo)export default AddTodo 十一、 高级 action11.1 异步 action简单的 todo 应用。它只有同步操作。每当 dispatch action 时，state 会被立即更新。 下面，我们将开发一个不同的，异步的应用。它将使用 Reddit API 来获取并显示指定 subreddit 下的帖子列表。那么 Redux 究竟是如何处理异步数据流的呢？ Action： 当调用异步 API 时，有两个非常关键的时刻：发起请求的时刻，和接收到响应的时刻（也可能是超时）。这两个时刻都可能会更改应用的 state；为此，你需要 dispatch 普通的同步 action。一般情况下，每个 API 请求都需要 dispatch 至少三种 action： 一种通知 reducer 请求开始的 action。 对于这种 action，reducer 可能会切换一下 state 中的 isFetching 标记。以此来告诉 UI 来显示加载界面。 一种通知 reducer 请求成功的 action。 对于这种 action，reducer 可能会把接收到的新数据合并到 state 中，并 重置 isFetching。UI 则会隐藏加载界面，并显示接收到的数据。 一种通知 reducer 请求失败的 action。 对于这种 action，reducer 可能会重置 isFetching。另外，有些 reducer 会保存这些失败信息，并在 UI 里显示出来。 为了区分这三种 action，可能在 action 里添加一个专门的 status 字段作为标记位： 12345678910&#123; type: 'FETCH_POSTS' &#125;&#123; type: 'FETCH_POSTS', status: 'error', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS', status: 'success', response: &#123; ... &#125; &#125;// 或者定义不懂的 type&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125;// 这两种都是可以的，关键是要看团队是如何选择的。一定要在整个应用中保持统一。 11.2 同步 Action 创建函数（Action Creator）11.3 异步 action 创建函数","tags":[]},{"title":"less 基础入门","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-less 入门/","text":"一、前言Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。Less 可以运行在 Node 或浏览器端。 css 的选择器非常复杂冗乱，尤其是后代选择器，写起来一长串，还考虑各种权重的问题，使用 LESS 简化层叠样式表（CSS）的编写。 CSS（层叠样式表）是一门历史悠久的标记性语言，同 HTML 一道，被广泛应用于万维网（World Wide Web）中。HTML 主要负责文档结构的定义，CSS 负责文档表现形式或样式的定义。 作为一门标记性语言，CSS 的语法相对简单，对使用者的要求较低，但同时也带来一些问题：CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用，尤其对于非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码，造成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。 less中文网：网址，less中文网：网址 注意一点是，如果是要在 vue 项目中使用 less，不只是需要安装 less，还需要安装 less-loader。 二、LESS 原理及使用方式2.1 原理本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。下面是一个简单的例子： 12345678910111213141516// less@color: #4D926F;#header &#123;color: @color;&#125;h2 &#123;color: @color;&#125;//上面的 less 对应的 css 如下，//css#header &#123;color: #4D926F;&#125;h2 &#123;color: #4D926F;&#125; 这里就是 less 中的变量使用。 2.2 使用方式LESS 可以直接在客户端使用，也可以在服务器端使用。在实际项目开发中，我们更推荐使用第三种方式，将 LESS 文件编译生成静态 CSS 文件，并在 HTML 文档中应用。 服务器端LESS 在服务器端的使用主要是借助于 LESS 的编译器，将 LESS 源文件编译生成最终的 CSS 文件，目前常用的方式是利用 node 的包管理器 (npm) 安装 LESS，安装成功后就可以在 node 环境中对 LESS 源文件进行编译。 在项目开发初期，我们无论采用客户端还是服务器端的用法，我们都需要想办法将我们要用到的 CSS 或 LESS 文件引入到我们的 HTML 页面或是桥接文件中，LESS 提供了一个我们很熟悉的功能— Importing。我们可以通过这个关键字引入我们需要的 .less 或 .css 文件。 如： @import “variables.less”; .less 文件也可以省略后缀名，像这样： @import “variables”; 引入 CSS 同 LESS 文件一样，只是 .css 后缀名不能省略。 使用编译生成的静态 CSS 文件我们可以通过 LESS 的编译器，将 LESS 文件编译成为 CSS 文件，在 HTML 文章中引入使用。这里要强调的一点，LESS 是完全兼容 CSS 语法的，也就是说，我们可以将标准的 CSS 文件直接改成 .less 格式，LESS 编译器可以完全识别。 三、LESS 语法(重点，重点，重点，重点!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!)3.1 嵌套在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式。在 LESS 中我们可以这样写： 12345678&lt;!-- HTML --&gt;&lt;div id=\"home\"&gt; &lt;div id=\"top\"&gt;top&lt;/div&gt; &lt;div id=\"center\"&gt; &lt;div id=\"left\"&gt;left&lt;/div&gt; &lt;div id=\"right\"&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* LESS */#home&#123; color : blue; width : 600px; height : 500px; border:outset; #top&#123; border:outset; width : 90%; &#125; #center&#123; border:outset; height : 300px; width : 90%; #left&#123; border:outset; float : left; width : 40%; &#125; #right&#123; border:outset; float : left; width : 40%; &#125; &#125;&#125;/* css */ #home &#123; color: blue; width: 600px; height: 500px; border: outset; &#125; #home #top &#123; border: outset; width: 90%; &#125; #home #center &#123; border: outset; height: 300px; width: 90%; &#125; #home #center #left &#123; border: outset; float: left; width: 40%; &#125; #home #center #right &#123; border: outset; float: left; width: 40%; &#125; 3.1.1 伪类-嵌套123456789101112131415161718/* LESS */ a &#123; color: red; text-decoration: none; &amp;:hover &#123;// 有 &amp; 时解析的是同一个元素或此元素的伪类，没有 &amp; 解析是后代元素 color: black; text-decoration: underline; &#125; &#125;/* css */ a &#123; color: red; text-decoration: none; &#125; a:hover &#123; color: black; text-decoration: underline; &#125; 从上面的代码中我们可以看出，LESS 的嵌套规则的写法是 HTML 中的 DOM 结构相对应的，这样使我们的样式表书写更加简洁和更好的可读性。同时，嵌套规则使得对伪元素的操作更为方便。 3.2 变量LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单。我们只需要修改变量就可以了，而不需要在样式定义中一个个的去修改。 从上面的代码中我们可以看出，变量是 VALUE（值）级别的复用，可以将相同的值定义成变量统一管理起来。 该特性适用于定义主题，我们可以将背景颜色、字体颜色、边框属性等常规样式进行统一定义，这样不同的主题只需要定义不同的变量文件就可以了。当然该特性也同样适用于 CSS RESET（重置样式表），在 Web 开发中，我们往往需要屏蔽浏览器默认的样式行为而需要重新定义样式表来覆盖浏览器的默认行为，这里可以使用 LESS 的变量特性，这样就可以在不同的项目间重用样式表，我们仅需要在不同的项目样式表中，根据需求重新给变量赋值即可。 1234567891011121314151617// less@color: #4D926F;#header &#123;color: @color;&#125;h2 &#123;color: @color;&#125;//上面的 less 对应的 css 如下，less 中我们需要修改颜色该变量即可//css#header &#123;color: #4D926F;&#125;h2 &#123;color: #4D926F;&#125;//css 中我们需要对应的一个个去修改颜色 3.2.1 变量作用域（全局变量）与（局部变量）LESS 中的变量和其他编程语言一样，可以实现值的复用，同样它也有生命周期，也就是 Scope（变量范围，开发人员惯称之为作用域），简单的讲就是局部变量还是全局变量的概念，查找变量的顺序是先在局部定义中找，如果找不到，则查找上级定义，直至全局。下面我们通过一个简单的例子来解释 Scope。 12345678910111213141516171819// less@width : 20px;//全局变量#homeDiv &#123; @width : 30px;//局部变量 #centerDiv&#123; width : @width;// 此处应该取最近定义的变量 width 的值 30px &#125;&#125;#leftDiv &#123; width : @width; // 此处应该取最上面定义的变量 width 的值 20px&#125;//上面的 less 对应的 css 如下//css#homeDiv #centerDiv &#123; width: 30px;&#125;#leftDiv &#123; width: 20px;&#125; 3.3 混入Mixins（混入）功能对用开发者来说并不陌生，很多动态语言都支持 Mixins（混入）特性，它是多重继承的一种实现，在 LESS 中，混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样。 1234567891011121314151617181920212223242526// less// 定义一个样式选择器.roundedCorners(@radius:5px) &#123; -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius;&#125;// 在另外的样式选择器中使用#header &#123; .roundedCorners;&#125;#footer &#123; .roundedCorners(10px);&#125;//上面的 less 对应的 css 如下//css#header &#123; -moz-border-radius:5px; -webkit-border-radius:5px; border-radius:5px;&#125;#footer &#123; -moz-border-radius:10px; -webkit-border-radius:10px; border-radius:10px;&#125; 从上面的代码我们可以看出：Mixins 其实是一种嵌套，它允许将一个类嵌入到另外一个类中使用，被嵌入的类也可以称作变量，简单的讲，Mixins 其实是规则级别的复用。 Mixins 还有一种形式叫做 Parametric Mixins（混入参数），LESS 也支持这一特性： 3.3.1 还如-变量默认值12345678910111213141516171819// less// 定义一个样式选择器// 定义一个样式选择器.borderRadius(@radius:5px)&#123; -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius;&#125;// 使用已定义的样式选择器.btn &#123; .borderRadius;&#125;//上面的 less 对应的 css 如下//css.btn &#123; -moz-border-radius:5px; -webkit-border-radius:5px; border-radius:5px;&#125; 3.3.2 混入-变量传值123456789101112131415161718192021222324252627// less// 定义一个样式选择器// 定义一个样式选择器.borderRadius(@radius)&#123; -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius;&#125;// 使用已定义的样式选择器#header &#123; .borderRadius(10px); // 把 10px 作为参数传递给样式选择器&#125;.btn &#123; .borderRadius(3px);// // 把 3px 作为参数传递给样式选择器&#125;//上面的 less 对应的 css 如下//css#header &#123; -moz-border-radius:10px; -webkit-border-radius:10px; border-radius:10px;&#125;#footer &#123; -moz-border-radius:3px; -webkit-border-radius:3px; border-radius:3px;&#125; 3.3.3 混入-对象变量传值像 JavaScript 中 arguments 一样，Mixins 也有这样一个变量：@arguments。@arguments 在 Mixins 中具是一个很特别的参数，当 Mixins 引用这个参数时，该参数表示所有的变量，很多情况下，这个参数可以省去你很多代码。 123456789101112131415161718// less// 定义一个样式选择器// 定义一个样式选择器.boxShadow(@x:0,@y:0,@blur:1px,@color:#000)&#123; -moz-box-shadow: @arguments; -webkit-box-shadow: @arguments; box-shadow: @arguments;&#125;#header &#123; .boxShadow(2px,2px,3px,#f36);&#125;//上面的 less 对应的 css 如下//css#header &#123; -moz-box-shadow: 2px 2px 3px #FF36; -webkit-box-shadow: 2px 2px 3px #FF36; box-shadow: 2px 2px 3px #FF36;&#125; 3.3.4 混入-命名空间？？？Mixins 是 LESS 中很重要的特性之一，我们这里也写了很多例子，看到这些例子你是否会有这样的疑问：当我们拥有了大量选择器的时候，特别是团队协同开发时，如何保证选择器之间重名问题？如果你是 java 程序员或 C++ 程序员，我猜你肯定会想到命名空间 Namespaces，LESS 也采用了命名空间的方法来避免重名问题，于是乎 LESS 在 mixins 的基础上扩展了一下，看下面这样一段代码： 1234#mynamespace &#123; .home &#123;...&#125; .user &#123;...&#125;&#125; 这样我们就定义了一个名为 mynamespace 的命名空间，如果我们要复用 user 这个选择器的时候，我们只需要在需要混入这个选择器的地方这样使用就可以了。#mynamespace &gt; .user。 3.4 运算及函数在我们的 CSS 中充斥着大量的数值型的 value，比如 color、padding、margin 等，这些数值之间在某些情况下是有着一定关系的，那么我们怎样利用 LESS 来组织我们这些数值之间的关系呢？我们来看这段代码： 1234567891011// less@init: #111111;@transition: @init*2;.switchColor &#123; color: @transition;&#125;//上面的 less 对应的 css 如下//css.switchColor &#123; color: #222222;&#125; 上面的例子中使用 LESS 的 operation 是 特性，其实简单的讲，就是对数值型的 value（数字、颜色、变量等）进行加减乘除四则运算。同时 LESS 还有一个专门针对 color 的操作提供一组函数。下面是 LESS 提供的针对颜色操作的函数列表： 12345678lighten(@color, 10%); // return a color which is 10% *lighter* than @colordarken(@color, 10%); // return a color which is 10% *darker* than @colorsaturate(@color, 10%); // return a color 10% *more* saturated than @colordesaturate(@color, 10%);// return a color 10% *less* saturated than @colorfadein(@color, 10%); // return a color 10% *less* transparent than @colorfadeout(@color, 10%); // return a color 10% *more* transparent than @colorspin(@color, 10); // return a color with a 10 degree larger in hue than @colorspin(@color, -10); // return a color with a 10 degree smaller hue than @color","tags":[]},{"title":"所有遍历方法详解","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[Javascript]-js-所有的遍历方法详解/","text":"一、前言所有的遍历方法的详解。 二、数组/字符串–所有的遍历方法2.1 for 循环遍历1# 最简单的遍历,可以遍历字符串,变量是索引值 12345678910111213141516171819let arr = [1, 2, 3, 4, 5]let n = arr.lengthfor (let i = 0; i &lt; n; i++) &#123; arr[i] = arr[i] * 10&#125;console.log(arr);//[ 10, 20, 30, 40, 50 ]//遍历字符串let str = 'xiaomi'let n = str.lengthfor (let i = 0; i &lt; n; i++) &#123; console.log(str[i]); // x // i // a // o // m // i &#125; 2.2 for….in 遍历(不推荐用在数组)12345# 枚举遍历，变量是索引值# 缺点：只能获得对象的键名，不能直接获取键值。# for-in 循环实际是为循环 ”enumerable“ 对象而设计的，# for in 也可以循环数组，但是不推荐这样使用，for–in 是用来循环带有字符串 key 的对象的方法。看第 三 章 123456789let arr = [1, 2, 3, 4, 5]for (let i in arr) &#123; console.log(`$&#123;i&#125;:$&#123;arr[i]&#125;`) // 0:1 // 1:2 // 2:3 // 3:4 // 4:5&#125; 2.3 for….of 遍历123456# 可以中途停止遍历,可以遍历字符串，变量是索引，值 都可以的# for of 为 ES6 提供，具有 iterator 接口，就可以用 for of 循环遍历它的成员。# 也就是说，for of 循环内部调用的是数据结构的 Symbol.iterator 方法。# for of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。# 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 123456789101112131415161718192021222324252627282930313233let arr = [1, 2, 3, 4, 5]for (let val of arr) &#123; if (val == 3) &#123; break; &#125; else &#123; console.log(val); //1, 2 &#125;&#125;for (let value of Object.values(arr)) &#123; console.log(value) // 1 // 2 // 3 // 4 // 5&#125;for (let key of Object.keys(arr)) &#123; console.log(key) // 0 // 1 // 2 // 3 // 4&#125;for (let [key, value] of Object.entries(arr)) &#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`) // 0:1 // 1:2 // 2:3 // 3:4 // 4:5&#125; 1234567891011//遍历字符串，let str = 'xiaomi'for (let s of str) &#123; console.log(s); // x // i // a // o // m // i&#125; 2.4 forEach 遍历123456# 只能遍历数组# 不可中途停止遍历# 没有返回值，遍历每项# 原数组会被改变，如果对第 3 参数操作就会被改变的吧# 优点：代码简介。# 缺点：无法使用 break，return 等终止循环。 12345678910let arr = [1, 2, 3, 4, 5]let res = arr.forEach((val, index, arr) =&gt; &#123; // val 为数组的每项 // index 索引 不需要的话就不写 // arr 为原始数组，不需要就不写 //数组中有几项，那么传递进去的匿名回调函数就需要执行几次 arr[index] = val * 10&#125;)console.log(arr);//[ 10, 20, 30, 40, 50 ]，原数组会被改变console.log(res);//undefined，因为没有返回值 123456789let arr = [1, 2, 3, 4, 5]arr.forEach((val) =&gt; &#123; if (val == 3) &#123; return false; &#125; else&#123; console.log(val); //1, 2, 3, 4, 5 即使我们使用了条件，但是 forEach 不能停止下来，还是继续的输出 &#125;&#125;) 2.5 map 遍历1234# 只能遍历数组# 遍历每项# 有返回值！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 所有 v=&gt;&#123; return v.xxxxxmsns 乱变&#125;# 原数组不会被改变(如果对第三个参数-原始数组进行操作就可能会改变了) 12345678910let arr = [1, 2, 3, 4, 5]let res = arr.map((val, index, arr) =&gt; &#123; return val * 10 // val 每项的值 // index 索引 // arr 原始数组 // arr[index] = arr[index] * 10 当然如果我么对第三个参数进行操作，原数组就会被改变了&#125;)console.log(arr); //[1, 2, 3, 4, 5] 原数组不变console.log(res); //[ 10, 20, 30, 40, 50 ] 有返回值 2.6 filter12# 返回一个符合条件的新数组# 原数组不变，如果对第三个参数-原始数组进行操作，肯定会改变，arr[index] = arr[index] + 1 123456let arr = [1, 2, 3, 4, 5]let res = arr.filter((val, index, arr) =&gt; &#123; return val &gt; 3&#125;)console.log(arr); //[1, 2, 3, 4, 5] 原数组不变console.log(res); //[ 4, 5 ] 有返回值 2.7 some1# 返回一个 boolean，判断是否有元素符合条件的值，如果有一个元素符合条件的值，则循环会终止。 1234567let arr = [1, 2, 3, 4, 5]let res = arr.some((val, index, arr) =&gt; &#123; arr[index] = arr[index] + 1//[ 2, 3, 4, 5, 5 ] return val &gt; 3&#125;)console.log(arr); //[ 2, 3, 4, 5, 5 ] 前面的项执行了操作，后面被 return 了无法执行console.log(res); // true 2.8 every1# 返回一个 boolean，判断是否 所有 元素符合条件的值，如果 所有 元素符合条件的值，返回 true 否则返回 false 1234567let arr = [1, 2, 3, 4, 5]let res = arr.every((val, index, arr) =&gt; &#123; arr[index] = arr[index] + 1//[ 2, 3, 4, 5, 5 ] return val &gt; 3&#125;)console.log(arr); //[ 2, 2, 3, 4, 5 ] 前面的项执行了操作，后面被 return 了无法执行console.log(res); // false 三、对象–的所有遍历方法3.1 for…in1# 枚举遍历，变量是 key 值 12345678910111213let obj = &#123; name:'xiaomi', age:18, sex:'female', hobby:['math','shopping','singing']&#125;for (let key in obj) &#123; console.log(`$&#123;key&#125;:$&#123;obj[key]&#125;`) // name:xiaomi // age:18 // sex:female // hobby:math,shopping,singing&#125; 3.2 for…of123456789101112131415161718192021222324252627282930``````JSlet obj = &#123; name: 'xiaomi', age: 18, sex: 'female', hobby: ['math', 'shopping', 'singing']&#125;for (let value of Object.values(obj)) &#123; console.log(value) // xiaomi // 18 // female // [ 'math', 'shopping', 'singing' ]&#125;for (let key of Object.keys(obj)) &#123; console.log(key) // name // age // sex // hobby &#125;for (let [key, value] of Object.entries(obj)) &#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`) // name:xiaomi // age:18 // sex:female // hobby:math,shopping,singing&#125; 四、set/map–的遍历方法4.1 for…of 遍历 map12345678910111213141516171819202122//任何部署了 Iterator 接口的对象，都可以用 for...of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// \"F\" \"no\"// \"T\" \"yes\" 4.1 for…of 遍历 set1234const s = new Set([1, 2, 3, 4, 4]);for (let value of s) &#123; console.log(value);&#125; 12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] 4.1 forEach 遍历 set","tags":[]},{"title":"MINA 框架 入门学习","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-MINA-原生框架/","text":"一、前言在我们使用官网微信小程序开发工具，创建空项目的时候，可以选择快读启动模板。这个开发者工具就是官方使用了一个MINA框架使其得以工作。 小程序提供的开发框架为 MINA 框架，它类似于 淘宝 Weex 框架、Vue 框架。MINA 框架通过封装微信客户端提供的文件系统、网络通信、任务管理、数据安全等基础功能，对上层提供一整套 JavaScript API,让开发者能够非常方便地使用微信客户端提供的各种基础功能与能力，快速构建一个应用。 二、MINA框架结构&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 怎么去了解一个程序的架构呢，一般都是以 hello world 示例来解析的。 一级目录下的四个文件为全局文件。 pages文件夹为页面设计 utils文件夹为模块设计 也就是一级目录是小程序注册 js 文件，全局配置 json，全局样式 wxss。还有 g 开发者工具的配置。页面在 pages 文件夹中，每个页面由 4 种文件构成，json 配置，wxml 页面结构，wxss 页面样式，js页面交互 四、MINA框架的工作原理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序入口文件为 app.js，也就是小程序的注册文件。 五、各个文件解析5.1 【JSON 配置文件】小程序中，包含唯一的全局配置文件 app.json，以及每个页面的配置文件 page.json。每单页页面相应的 JSON 文件会覆盖与 app.json 相同的配置项。 6.1.1 全局配置文件app.json官网app.json地址 app.json 件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。注意事项： ①下面是有注释的，实际使用的时候删除项目中 json 文件的注释， json 文件是不支持注释的。 ②颜色大多有要求，官方文档有说明，比如&quot;navigationBarTextStyle&quot;只有两种颜色black/white ③其他带 color 的属性需要设置颜色，均采用 rgb 格式，颜色名称无法正确解读。 1234567891011121314151617181920212223242526272829303132333435\"pages\": [ //设置页面的路径 \"pages/index/index\", //写在第一个的默认为首页 \"pages/logs/logs\" //不需要写 index.wxml,index.js,index,wxss,框架会自动寻找并整合 ],\"window\": &#123; //设置默认窗口的表现形式 \"navigationBarBackgroundColor\": \"#ffffff\", //顶部导航栏背景色 \"navigationBarTextStyle\": \"black\", //顶部导航文字的颜色 black/white \"navigationBarTitleText\": \"微信接口功能演示\", //顶部导航的显示文字 \"backgroundColor\": \"#eeeeee\", //窗口的背景色 \"backgroundTextStyle\": \"light\", //下拉背景字体、loading 图的样式，仅支持 dark/light \"enablePullDownRefresh\": false //是否支持下拉刷新 ，不支持的话就直接不写！&#125;,\"tabBar\": &#123; //底部 tab 或者顶部 tab 的表现，是个数组，最少配置 个，最多 5 个 \"list\": [&#123; //设置 tab 的属性，最少 2 个，最多 5 个 \"pagePath\": \"pages/index/index\", //点击底部 tab 跳转的路径 \"text\": \"首页\", //tab 按钮上的文字 \"iconPath\": \"../img/a.png\", //tab图片的路径 \"selectedIconPath\": \"../img/a.png\" //tab 在当前页，也就是选中状态的路径 &#125;, &#123; \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" &#125;], \"color\": \"red\", //tab 的字体颜色 \"selectedColor\": \"#673ab7\", //当前页 tab 的颜色，也就是选中页的 \"backgroundColor\": \"#2196f3\", //tab 的背景色 \"borderStyle\": \"white\", //边框的颜色 black/white \"position\": \"bottom\" //tab处于窗口的位置 top/bottom &#125;,\"networkTimeout\": &#123; //默认都是 60000 秒一分钟 \"request\": 10000, //请求网络超时时间 10000 秒 \"downloadFile\": 10000， //链接服务器超时时间 10000 秒 \"uploadFile\": \"10000\", //上传图片 10000 秒 \"downloadFile\": \"10000\" //下载图片超时时间 10000 秒 &#125;,\"debug\": true //调试，项目上线后，建议关闭此项，或者不写此项 7.1.2 页面配置文件 pages.json，eg：index.json、logs.json每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。只是多了一项&quot;disableScroll&quot;: true,页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 官网pages.json地址 12345678910\"window\": &#123; //设置默认窗口的表现形式 \"navigationBarBackgroundColor\": \"#ffffff\", //顶部导航栏背景色 \"navigationBarTextStyle\": \"black\", //顶部导航文字的颜色 black/white \"navigationBarTitleText\": \"微信接口功能演示\", //顶部导航的显示文字 \"backgroundColor\": \"#eeeeee\", //窗口的背景色 \"backgroundTextStyle\": \"light\", //下拉背景字体、loading 图的样式，仅支持 dark/light \"enablePullDownRefresh\": false, //是否支持下拉刷新 ，不支持的话就直接不写！ \"disableScroll\": true// 设置 true 不能上下滚动，true/false， //注意 disableScroll 只能在 page.json 中有效，无法在 app.json 中设置该项。&#125; 7.1.3 开发工具配置文件 project.config.json7.2 【JS 逻辑层】小程序的逻辑层由 JavaScript 语言完成。但因为小程序不在浏览器中运行，所以 JS 在 web 浏览器中的一些函数不能用，如 document、window 等。app.js 有全局的小程序生命周期，page.js 有自己本页面的生命周期。 7.2.1 注册小程序 app.js官网app.js地址 这一步骤，有这几个需要注意的地方： 必须在 app.js 中，使用 app() 函数注册微信小程序。全局小程序中，只能注册一次； 不能在 app() 内的函数中调用 getApp()（小程序实例），使用 this 就可以拿到小程序的实例； 不要在 onLaunch 的时候 getCurrentPage()，因为此时 page 还没有生成； 通过其他子页面调用 getApp() 获取实例后，不要私自调用小程序全局的生命周期方法； 可以通过 var app=getApp() 获取小程序的实例。 12345678910111213141516app ( &#123; // 小程序生命周期的各个阶段 onLaunch: function()&#123;&#125;,//当小程序初始化完成时，会触发 onLaunch（全局只触发一次） onShow: function()&#123;&#125;,//当小程序启动，或从后台进入前台显示，会触发 onShow onHide: function()&#123;&#125;,//当小程序从前台进入后台隐藏，会触发 onHide onError: function()&#123;&#125;,//当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 onPageNotFound:function()&#123;&#125;, globalData: &#123; //全局数据，pages 页面调用 app.js 全局数据方式看下面 userInfo: null // 自定义，用 this可以访问 &#125;, getName:function()&#123; return '这里是app.js里面的自定义方法' // 自定义函数与属性，用 this 可以访问 &#125;&#125;) pages页面调用app.js全局数据方式 12345678App(&#123;// app.js globalData: 1&#125;)// 某 page.jsconsole.log(getApp().globalData)//事实上不是这样，pages 页面都会先实例化 app.js 的。//const app=getApp()//获取数据只需要 app.globalData 7.2.2 注册小程序页面 page.js eg：index.js 还有其他新建的页面官网pages.js地址 Page() 用来注册一个页面，维护该页面的生命周期以及数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Page(&#123; data: &#123; //页面的初始数据,第一次渲染的数据，后面会根据下面的方法/事件得以改变 text: 'init data',//调用：&#123;&#123;text&#125;&#125; array: [&#123; msg: '1' //调用：&#123;&#123;array[0].msg&#125;&#125; &#125;, &#123; msg: '2' &#125;] &#125;, // 页面生命周期的各个阶段 onLoad: function () &#123;&#125;, //生命周期函数--监听页面加载 onShow: function () &#123;&#125;, //生命周期函数--监听页面显示/或者置位前台 onReady: function () &#123;&#125;, //生命周期函数--监听页面初次渲染完成 onHide: function () &#123;&#125;, //生命周期函数--监听页面隐藏 onUnload: function () &#123;&#125;, //生命周期函数--监听页面卸载/销毁（重定向/返回，置为后台） onPullDownRefresh: function () &#123;&#125;, //页面相关事件处理函数。如果需要监听用户下拉动作，需要 在app.json中配置 onReachBottom: function () &#123;&#125;, //页面上拉触底事件的处理函数 onShareAppMessage: function () &#123; //用户点击右上角分享 //需要在 wepy.page 中设置才有效果，在 wepy.component 中设置无效果。 return &#123; title: '自定义分享标题', desc: '自定义分享描述', path: '/page/user?id=123', success(res)&#123; // 转发成功 let shareId = res.shareTickets[0] wepy.getShareInfo(&#123; shareTicket: shareId, success(res)&#123; // var appId = '小程序的appID' var encryptedData = res.encryptedData var iv = res.iv wepy.request(&#123; url: 'http://localhost:3000/api/decode', method: 'post', data: &#123; appId: appId, encryptedData: encryptedData, iv: iv &#125;, success: (info) =&gt; &#123; console.log('info:' + info) &#125;, fail: (info) =&gt; &#123; console.log(info) &#125; &#125;) &#125;, fail(res)&#123; //console.log &#125; &#125;, fail(res)&#123; //转发失败 &#125; &#125; &#125;, onPageScroll: function () &#123;&#125;,//页面滚动触发事件的处理函数 onTabItemTap: function () &#123;&#125;,//当前是 tab 页时，点击 tab 时触发 //上面的是小程序默认存在的函数，我们可以写一下自定义函数/属性 // 自定义函数或者属性如：用于组件事件处理函数，在 .wxml 组件中绑定的自定义名称的函数， //具体可以学习 wxml 的事件函数再明白这里 customData: &#123; hi: 'MINA' &#125;...&#125;) pages页面 初始数据：data 生命周期回调函数：onLoad、onShow、onReady、onHide、onUnload 页面事件处理函数：onPullDownRefresh、onReachBottom 组件事件处理函数：在wxml绑定的自定义的函数 route：this.route 可以获取到当前页面的路径 setData：将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。 页面生命周期:官网地址 组件事件处理函数：在wxml绑定的自定义的函数：官网地址 1&lt;view bindtap=\"viewTap\"&gt; click me &lt;/view&gt; 12345Page(&#123; viewTap: function() &#123; console.log('view tap') &#125;&#125;) setData官网地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//index.jsPage(&#123; data: &#123; msg: 'msg', num: 0, array: [&#123;textArr: 'init data'&#125;], object: &#123; text: 'init data' &#125; &#125;, changeText: function() &#123; // this.data.text = 'changed data' // bad, it can not work，不能这样直接修改，需要使用 setData 来修改才会生效的 this.setData(&#123; msg: 'changed data' &#125;) &#125;, changeNum: function() &#123; this.data.num = 1//遇到需要计算的，就放在 this.setData 外面来计算，this.setData 只能直接赋值，官方中有的地方在 setData 中赋值，那是它没有更新文档，其实是不行的！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ //！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ this.setData(&#123; num: this.data.num &#125;) &#125;, changeItemInArray: function() &#123; // you can use this way to modify a danamic data path // 可以使用字符串的办法去构造 数组 或者 对象中的某个字段，这样做通常比修改整个对象或数组更好 // 当然如果整个数组或者对象都需要修改的话就直接修改整个就 ok） this.setData(&#123; 'array[0].textArr':'changed data'//构造数组中 项 中的 对象下的 textArr 字段 &#125;) &#125;, changeArray:function()&#123; this.setData(&#123; array: newArry//对整个数组的值都需要改变的话，就直接这样改变就好了，对象也是一眼的道理。 &#125;) &#125;, changeItemInObject: function()&#123; this.setData(&#123; 'object.text': 'changed data' // 构造 object 对象中的 text &#125;); &#125;, addNewField: function() &#123; this.setData(&#123; 'newField.text': 'new data' &#125;) &#125;&#125;) log.js场景值页面 这个页面不是我们需要做的展示页面官网地址 7.2.3 公共模块utils.js公共模块方法需要通过 module.exports 对外暴露接口，使用的时候需要利用 require(path)，将文件引入。 1234function sayHello(name) &#123;//公共方法util类 console.log(`Hello $&#123;name&#125; !`)&#125;module.exports.sayHello = sayHello//用module.exports 对外暴露接口 1234567//先引入文件，是新建的一个 utils 包，公共方法在 util.js 里面var util = require('../../utils/util.js')Page(&#123;//调用类 onLoad: function () &#123;// 使用时，用 util 引用名调用，如：util.sayHello() util.sayHello('我是传的值'); &#125;&#125;) 7.2.4 路由MINA 框架不需要我们去设置路由，框架自身完成了路由设置。还提供了API接口官网地址 7.2.5 模块化小程序之所以火，原因之一，因为它小。固然我们代码不能大，微信审核通过的代码不能超过 4M，否则审核不通过。那么如何优化代码是关键，模块化就是其一优化。可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。官网地址，有同步API，异步API供我们直接调用 7.2.6 API小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考 API 文档。官网地址 7.2.4 js文件数据操作setData() 不能直接操作数据，例如 this.data.text=”xxxxx” 就是错误的。你需要在 this.setData () 之中，进行数据的操作。 同时，这里有作用域的问题。比如，需要在局部函数中使用，就需要 .bind(this)。 7.3 【WXML视图层】7.3.1 wxml 的标签/组件-组件对应属性学习者这里的时候应该先去学习 wxml，也就是标签/组件的学习， 以及它的属性，属性值的学习。官网：地址 视图层的数据绑定均来自于 Page 中的 data，想要修改相应值，你需要用到 this.setData。数据绑定使用两对花括号，将变量名包起来。 wxml的内容：官网地址 数据绑定： 列表渲染：&lt;view wx:for=&quot;&quot;&gt; : &lt;/view&gt; 条件渲染：&lt;view wx:elif=&quot;false&quot;&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt; 模板 事件 引用 7.3.2 双花括号：数据绑定1234567891011&lt;!-- .wxml文件 --&gt;&lt;view&gt; &lt;text&gt;&#123;&#123;msg&#125;&#125;绑定文本&lt;text&gt; &lt;text&gt;&#123;&#123;msg+1&#125;&#125;绑定文本表达式&lt;text&gt; &lt;text id=\"id-&#123;&#123;id&#125;&#125;\"&gt;绑定属性&lt;/text&gt; &lt;text data-name=\"&#123;&#123;thename&#125;&#125;\"&gt;绑定属性&lt;/text&gt; &lt;view hidden=\"&#123;&#123;flag&#125;&#125;\"&gt;js中flag为布尔值&lt;/view&gt; &lt;view hidden=\"&#123;&#123;flag?true:false&#125;&#125;\"&gt; 绑定三元表达式属性 &lt;/view&gt;&lt;/view&gt; 12345678&lt;!-- .js文件 --&gt;Page(&#123; data: &#123; msg:18, thename: 'xiaomi', flag: false &#125;&#125;) 7.3.3 条件渲染你可以利用 if 和 else，在视图层上编写在特定情况下，出现的不同的视图结果。 123456789101112&lt;view wx:if=\"&#123;&#123;zhenjiaa=='123'&#125;&#125;\"&gt;123334&lt;/view&gt;&lt;view wx:if=\"&#123;&#123;zhanjia&#125;&#125;\"&gt;123334&lt;/view&gt;&lt;view wx:if=\"&#123;&#123;len &gt; 5&#125;&#125;\"&gt;大于5我就显示了 &lt;/view&gt;&lt;view wx:if=\"&#123;&#123;length &gt; 5&#125;&#125;\"&gt; 1 &lt;/view&gt;&lt;view wx:elif=\"&#123;&#123;length &gt; 2&#125;&#125;\"&gt; 2 &lt;/view&gt;&lt;view wx:else&gt; 3 &lt;/view&gt;&lt;view&gt; &lt;block wx:if=\"&#123;&#123;true&#125;&#125;\"&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt; &lt;/block&gt;&lt;/view&gt; 很多人会将 CSS 中的 display: hidden 属性，将其做一个比较。 微信小程序中的 wx:if 是惰性的。如果不符合渲染条件，它不会渲染相应部分；使用 display: hidden 时，元素始终渲染，只是视图层上没有显示，用户看不见。如果你的小程序有元素显示频繁切换的需求，建议你使用 display: hidden，能够为用户提供能顺畅的使用体验。 7.3.2 列表渲染相当于让 WXML 处理一个循环。 ①数组循环： : 在 WXML 中，你可以这样来建立一个 for 循环：必须是 index 与 item 1&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\"&gt; &#123;&#123;index&#125;&#125;:&#123;&#123;item&#125;&#125; &lt;/view&gt; 然后在相应的 JS 中，新建一个数组： 12345page.jsPage(&#123; data: &#123; array: [1, 2, 3, 4, 5] &#125;&#125;) 需要注意的是，如果列表中的项需要动态添加到列表中，并希望项目保持原有的特征和状态，那么你应该使用 wx:key。wx:key 有两种形式：字符串：wx:key=”unique”,保留关键字：wx:key=”*this” ②对象循环： : 默认的索引值为index，item，也可以自定义，但是好像没有什么意义啊？？？还给自己浪费时间写代码??不是，在复杂数据中这个是很有用的 1&lt;view wx:for=\"&#123;&#123;array&#125;&#125;\" wx:for-index=\"aa\" wx:for-item=\"bb\"&gt; &#123;&#123;aa&#125;&#125;:&#123;&#123;bb&#125;&#125; &lt;/view&gt; 数据嵌套-循环：复杂数循环：表格渲染 12345678910111213141516171819202122page.jsPage(&#123; data: &#123; newlist:[ &#123; 'catename':'国内新闻', list:[ &#123;'title':'这是国内新闻','id':'30'&#125;, &#123;'title':'这是国内新闻','id':'40'&#125;, &#123;'title':'这是国内新闻','id':'50'&#125; ] &#125;, &#123; 'catename':'国际新闻', list:[ &#123;'title':'这是国际新闻','id':'30'&#125;, &#123;'title':'这是国际新闻','id':'40'&#125;, &#123;'title':'这是国际新闻','id':'50'&#125; ] &#125; ] &#125;&#125;) 1234&lt;view wx:for=\"&#123;&#123;newlist&#125;&#125;\"&gt; &lt;text&gt;分类：&#123;&#123;item.catename&#125;&#125;&lt;/text&gt; &lt;text wx:for=\"&#123;&#123;item.list&#125;&#125;\" wx:for-item=\"val\"&gt;新闻：&#123;&#123;val.title&#125;&#125;&lt;/text&gt;&lt;/view&gt; 7.3.3 运算WXML 可以执行简单的运算任务。例如： 123&lt;view&gt; &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d &lt;/view&gt;&lt;view&gt;&#123;&#123;\"hello\" + name&#125;&#125;&lt;/view&gt; &lt;!-- 也可以做到字符串拼接： --&gt;&lt;!-- 甚至，你可以使用 ... 在 WXML 中展开对象。 --&gt; 7.3.4 模板&lt;template&gt;官网地址 WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。name 定义组件模版的名称，引用模版的时候使用 is 属性指定模版的名字，is 可以进行简单的三目运算，需要传入模版需要的 data 数据。 因为模版拥有自己的作用域，所以只能使用 data 传入数据，而不接受双花括号的写法。 123456&lt;template name=\"msgItem\"&gt;&lt;view&gt;&lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;&lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;&lt;/view&gt;&lt;/template&gt; 1&lt;template is=\"msgItem\" data=\"&#123;&#123;...item&#125;&#125;\"/&gt; 7.3.5 公共模块的引用WXML 提供 import 和 include 两种文件引用方式。 import 有作用域的概念，不能多重引用。 12&lt;!-- B.wxml --&gt;&lt;import src=\"a.wxml\"/&gt; 1234&lt;!-- A.wxml --&gt;&lt;template name=\"A\"&gt; &lt;text&gt; A template &lt;/text&gt;&lt;/template&gt; 而 include 就可以多重引用了。 123&lt;!--引用 header、其中 header.wxml 中也引用了 footer.wxml--&gt;&lt;include src=\"header.wxml\"/&gt;&lt;view&gt; body &lt;/view&gt; 123&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt;&lt;include src=\"footer.wxml\"/&gt; 7.3.6 事件官网地址 在 WXML 中，可以使用 dataset 定义 data 中的数据，会通过事件传递。在 event 对象中这些自定义属性：以 data- 开头，多个单词以 - 链接，如 data-a-b。需要注意的是，使用这种方式定义的变量不能有大写。它会自动转成驼峰命名，调取的时候去驼峰命名的名字。 什么是事件事件是视图层到逻辑层的通讯方式。事件可以将用户的行为反馈到逻辑层进行处理。事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。事件对象可以携带额外信息，如 id, dataset, touches。 事件分类事件分为冒泡事件和非冒泡事件： 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。bind 事件绑定不会阻止冒泡事件向上冒泡，catch 事件绑定可以阻止冒泡事件向上冒泡。 WXML的可冒泡事件列表：不希望他们冒泡的话就用 catch 类型 触发条件 最低版本 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发 1.5.0 longtap 手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 touchforcechange 在支持 3D Touch 的 iPhone 设备，重按时会触发 1.9.90 除了以上的事件，其他事件都是非冒泡的。 7.4 【wxss视图层】官网地址 WXSS(WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。 为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。与 CSS 相比，WXSS 扩展的特性有：尺寸单位，样式导入 学习wxss之间需要也是需要熟知wxml组件。 需要注意的是 wxml 与 html 都是页面结构，但是 wxml 与html 是不一样的。wxml 中可以使用div，p 等等，但是它们都变成了行内元素，不 display 改变属性的话，给他们设置宽高是没有用的。display:block。除了div，p 其他的所哟块级元素都没有块级元素的性质。并且微信官网不建议这么使用。并且在使用, wxss 不能使用 #id11 选择到。只能讲 view 替换 div。因此既然做的是微信小程序就要跟着微信要求做，比较不容易出错。微信组件用最多的就是 view，text。这个 view 就是我们小程序的块级标签。 7.4.1 选择器 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element, element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。 12&lt;!-- HTML --&gt;&lt;text id=\"header\"&gt; header &lt;/test&gt; 1234&lt;!-- WXSS --&gt;#header::before&#123; content:&apos;this is&apos;&#125; 12&lt;!-- DOM,这里好像不对，实际情况再修改 --&gt;&lt;text&gt;this is&lt;text/&gt;&lt;text id=\"header\"&gt; header &lt;/test&gt; 如果需要另起一行，可以在 wxss 中添加上 display:block; 7.4.2 像素/尺寸单位rpxGithub转换工具 尺寸单位rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。 设备 rpx换算px (屏幕宽度/750) px换算 rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 规定屏幕宽为 750rpx，这样不管什么设备上面设置了宽高为 rpx，都是相应的，不需要单独为每个设备单独设置 px 宽高。 7.4.3 导入样式@import “xxx.wxss” 一、本文记录开发小程序遇到的错误避免bug 学习积累 文件名不要中文，包括图片名称，会有意想不到的错误发生 细心细心再细心，路径不要老出错 错误修改之后一定要保存，不保存运行调试还是错误的，会误以为没有修改正确 二、官方小程序开发工具MINA框架(快速启动模本)2.1 app.json 文件在设置全局配置的时候遇到错误，首页上实现底部选项卡 tabBar,容易出现错误如下： 1.文件路径出错 2.没有在pages上配置页面 2.1.1 json 注释之后会出错，json 不能写注释刚开始学习的时候我们希望在文件写上注释方便自己的理解，但是在 json 文件中，写//或者是/**/注释，都是不支持的。不仅是小程序，其他的问价的 json 文件都是不支持注释的，虽然网上有偏方写注释，那都违背 json 文件意愿啊。何必为了写注释增加代码的解析难度。 123456789101112131415//在代码中如下写这些代码都是错误的，代码无法得到正确的解析，使用的时候记得把注释删掉\"pages\": [ //设置页面的路径 \"pages/index/index\", //不需要写 index.wxml,index.js,index,wxss,框架会自动寻找并整合 \"pages/logs/logs\"],\"window\": &#123; //设置默认窗口的表现形式 \"navigationBarBackgroundColor\": \"#ffffff\", //顶部导航栏背景色 \"navigationBarTextStyle\": \"black\", //顶部导航文字的颜色 black/white \"navigationBarTitleText\": \"微信接口功能演示\", //顶部导航的显示文字 \"backgroundColor\": \"#eeeeee\", //窗口的背景色 \"backgroundTextStyle\": \"light\", //下拉背景字体、loading 图的样式，仅支持 dark/light \"enablePullDownRefresh\": false, //是否支持下拉刷新 ，不支持的话就直接不写！ \"disableScroll\": true, // 设置true不能上下滚动，true/false， //注意！disableScroll 只能在 page.json 中有效，无法在 app.json 中设置该项。&#125; 报错如下 1Error: Expecting 'STRING','&#125;', got INVALID 2.1.2 设置的 pagePath 路径错误tabBar 就是底部菜单切换，也就是切换页面，其实也就是 page 123456789101112131415161718192021222324\"pages\": [ \"pages/index/index\", \"pages/logs/logs\", \"pages/pomodoro/pommodoro\" ], \"tabBar\": &#123; \"list\": [ &#123; \"pagePath\": \"'pages/logs/logs'\", //这里错误，'pages/logs/logs' 没有在 pages 中出现 \"text\": \"日志\" //这个路径其实就是 pages 里面路径直接复制下来就 ok 了 &#125;, //改为 \"pagePath\": \"pages/logs/logs\", &#123; \"pagePath\": \"pages/pomodoro/pommodoro\", \"text\": \"首页\", \"iconPath\": \"../img/a.png\", \"selectedIconPath\": \"../img/a.png\" &#125; ], \"color\": \"#778899\", \"selectedColor\": \"#673ab7\", \"backgroundColor\": \"#2196f3\", \"borderStyle\": \"white\", \"position\": \"bottom\" &#125; 错误 12Error: tabBar[0].pagePath \"'pages/index/index'\" 需在 pages 数组中tabBar[1].pagePath \"'pages/logs/logs'\" 需在 pages 数组中 2.1.3 设置的 iconPath 路径错误 我们写的图片路径一定要正确， 图片名称不能是中文。 错误 12Error: tabBar.list[0].iconPath 文件不存在tabBar.list[0].selectedIconPath 文件不存在 2.1.4 .json中颜色color的设置错误设置的文字颜色，背景颜色，用手机扫码调试无法展现 ①backgroundTextStyle 与 borderStyle 都有固定的颜色，为颜色名称，使用的时候到官网查看。 ②color 与 backgroundColor 还有 selectedColor，单词带有 color 的一定都用 rgb 格式来写，用颜色名称写的话，开发工具不会报错，但是用手机调试的时候就会发现用颜色名称，比如 red，gary，等等文字与背景都不会得到展示所需要的颜色。 ③border-bottom: 1px solid #778899，边框的颜色也是 rgb 方式来写 在 wxss 中还是与 css 可以用名称来填写的。 2.1.5 导航问题API wx.navigateTo wx.redirectTo wx.switchTab 需要跳转的目标链接在 app.json 中的 tabbar 中选择这个方法 wx.navigateBack wx.reLaunch 1234//链接错误，这样写才是对的，不要写后缀。wx.switchTab(&#123; url: '../add/add' //这里是希望跳到add页面&#125;) ①. wx.navigateTo(OBJECT)—— 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面②. wx.redirectTo(OBJECT)—— 关闭当前页面，跳转到应用内的某个页面③. wx.switchTab(OBJECT)—— 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 2.1.6 列表循环的问题1Now you can provide attr &quot;wx:key&quot; for a &quot;wx:for&quot; to improve performance. 是一个关于性能优化方面的提示. wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt;中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。wx:key 的值以两种形式提供 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this ,代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 如下将 wx:key 绑定数组中对象属性 unique，这个对象属性 unique 在数组中每一项保证是不一样的。 1&lt;switch wx:for=\"&#123;&#123;objectArray&#125;&#125;\" wx:key=\"unique\" style=\"display: block;\"&gt; &#123;&#123;item.id&#125;&#125; &lt;/switch&gt; 123456789101112Page(&#123; data: &#123; objectArray: [ &#123;id: 5, unique: 'unique_5'&#125;, &#123;id: 4, unique: 'unique_4'&#125;, &#123;id: 3, unique: 'unique_3'&#125;, &#123;id: 2, unique: 'unique_2'&#125;, &#123;id: 1, unique: 'unique_1'&#125;, &#123;id: 0, unique: 'unique_0'&#125;, ] &#125;&#125;) 例如在做 todolist 的时候列表项的位置肯定会随着操作有改变的。wx：key 是必要的。 12&lt;!-- 这里给它绑定的是每个事项的开始时间，开始时间使用的是 new Date 函数创建的，保证是不一样的 --&gt;view wx:for=\"&#123;&#123;m1.getTypeList(this.data.todolist)&#125;&#125;\" wx:for-item=\"item\" wx:key=\"startAt\" class=\"weui-cell\"&gt; 2.1.7 事件回调detail使用错误12detail is not defined;at pages/index/index page bindConfirm functionReferenceError: detail is not defined 1234567891011121314bindConfirm: function (e) &#123; console.log(detail)//这里是错误的，detail 是事件参数 e 里面的属性，必须这样使用 console.log(e.detail) //构造待办列表对象 var newTodo = &#123; title: e.detail.value, isFinish: false, startAt: new Date() &#125; this.data.todolist.push(newTodo) this.setData(&#123; inputvalue: '', todolist: this.data.todolist &#125;) &#125; 2.7.1 重设data数据错误page.js 文件中， data 对象中的数据是初始化的数据，后面需要修改数据的话，只能用 this.setData，不能直接给this.data.xxx 赋值，这样是不行的。并且需要注意的是，this.setData 中是键值名的形式出现的。有时候就需要构造key变量了。 12345678910data&#123; name:'xiaomi', goods:[&#123;id:1,name:'bag'&#125;]&#125;this.setData(&#123; name:'lm', goods:[&#123;id:2,name:'cat'&#125;] //goods[0].id:3 这样写是错误的&#125;)//key 不能用 this.data 1234wx.setStorage(&#123; key: 'todolist', data: this.data.todolist.join('') //一定不要修改的值忘记写 this.data&#125;) 这里少写 this.data，弄成 todolist.join(‘’) 会报出下面的错误。因为它根本不知道 todolist 是什么东西 1TypeError: Cannot read property &apos;join&apos; of undefined 2.8.1 事件传参在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以 data- 开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如 data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰 elementType。 所以不要使用连字符号 三、官方weui-wxss组件库四、iview-weapp组件库1Error: wxml 编译错误，错误信息：./pages/index/index.wxml:36:9: expect end-tag `i-cell-group`., near `view` 出现这个错误是标签写错，开标浅语闭标签不匹配，一定要注意标签！！！","tags":[]},{"title":"scss 入门","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-scss/","text":"一、前言CSS预处理器： 定义了一种新的专门的编程语言，编译后成正常的CSS文件。为CSS增加一些编程的特性，无需考虑浏览器的兼容问题，让CSS更加简洁，适应性更强，可读性更佳，更易于代码的维护等诸多好处。 有less，scss（sass） 等。 scss 中文网 二、sass 基本了解通常说 sass 的时候，是包括 scss 的。scss 是 sass 的其一。 2.1 sass 定义Sass 是一个 CSS 的扩展，它在 CSS 语法的基础上，允许您使用变量 (variables), 嵌套规则 (nested rules), 混合 (mixins), 导入 (inline imports) 等功能，令 CSS 更加强大与优雅。使用 Sass 以及 Compass 样式库 有助于更好地组织管理样式文件，以及更高效地开发项目。 2.2 特色 (Features) 完全兼容 CSS3 在 CSS 语言的基础上增加变量(variables)、嵌套 (nesting)、混合 (mixins) 等功能 通过函数进行颜色值与属性值的运算 提供 控制指令等高级功能 自定义输出格式 2.3 sass 语法（现在用的的 scss 就对了）2.3.1 scss 写法（Sass 有两种语法格式 sass 与 scss）首先是 SCSS (Sassy CSS) ,也是本参考资料示例所使用的格式 , 这种格式仅在 CSS3 语法的基础上进行扩展，这意味着每个CSS样式表是一个同等的SCSS文件。此外，SCSS 也支持大多数 CSS hacks 写法 以及浏览器专属前缀语法 (vendor-specific syntax)，例如，IE 古老的 filter 语法。 这种语法的样式表文件需要以 .scss 作为拓展名。 2.3.2 sass 写法（Sass 有两种语法格式 sass 与 scss）最早的语法，被称为缩进语法 (Indented Sass)，或者通常说的 “Sass”，它提供了一种更加简介的方式来书写CSS。它使用缩进而不是花括号来表示选择器的嵌套，用换行而不是分号来分隔属性，一些人认为这样做比 SCSS 更容易阅读，书写也更快速。 缩排语法具有 Sass 的所有特色功能， 虽然有些语法上稍有差异； 具体差异在缩进语法参考中都有描述。 使用此种语法的样式表文件需要以 .sass 作为扩展名。 2.3.3 Sass 和 SCSS 的区别 文件扩展名不同：“.sass” 和 “.scss”； Sass 是以严格缩进式语法规则来书写的，不带大括号和分号；而 SCSS 的语法和 CSS 书写语法类似。scss 更符合我们的习惯 2.3.4 两种格式的文件可以互相导入引用任何一种语法的文件可以直接 import(导入) 到另一种语法的文件中使用，只要使用 sass-convert 命令行工具，就可以将一种语法转换为另一种语法： 12#Convert Sass to SCSS$ sass-convert style.sass style.scss 12# Convert SCSS to Sass$ sass-convert style.scss style.ss # ????这个就是 .ss ？？？错了吧？？？ 但是请注意，此命令 不会 生成CSS文件。要想生成CSS文件，请使用其他地方描述的 sass 命令。 三、sass 的安装引用3.1 在 vue.js 项目使用 scss123# 在 vue 项目中使用 scss$ npm install sass-loader node-sass --save-dev$ yarn add sass-loader node-sass # yarn 的好处 不需要配置了，可以直接使用 vue-loader 已经帮忙配置好了的。 1234&lt;style scoped lang=\"sass\"&gt; xxxx xxxx&lt;/style&gt; 3.2 在 react.js 项目使用 scss这个链接的方法不知道是否正确，没有试过Y 12345678# 在 react.js 项目中使用 scss$ npm install sass-loader node-sass --save-dev # 安装 scss ？？？？？不对$ yarn add sass-loader node-sass # yarn 的好处，怎么群里有人说 node-sass 需要翻墙，不要使用 yarn 不靠谱？？？？好晕# 配置？？？好像又不需要了呀？？？？？# 运行$ npm run eject # 会生成一个 config 文件夹，其实相当于 复制 node_module 中的文件夹，不直接修改 node_module 文件夹避免错误$ yarn eject # 用 yarn 来运行# config 文件夹中的文件配置 3.2.1 eject 注意的问题create-react-app 默认是没有暴露 webpack 配置的，所以需要 eject 一下。 注意如果项目在 git 仓库环境下，先提交代码到 git 仓库，否则会报错 不过什么是 git 仓库环境？？？？？？ 1234567891011121314151617181920212223λ npm run eject&gt; hello-world@0.1.0 eject F:\\qianduan_dir\\00program\\react.js\\hello-world&gt; react-scripts eject? Are you sure you want to eject? This action is permanent. NoClose one! Eject aborted.F:\\qianduan_dir\\00program\\react.js\\hello-world (master -&gt; origin)λ npm run eject&gt; hello-world@0.1.0 eject F:\\qianduan_dir\\00program\\react.js\\hello-world&gt; react-scripts eject? Are you sure you want to eject? This action is permanent. YesThis git repository has untracked files or uncommitted changes:src/App.jsM yarn.lockRemove untracked files, stash or commit any changes, and try again.npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! hello-world@0.1.0 eject: `react-scripts eject`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the hello-world@0.1.0 eject script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\Administrator\\AppData\\Roaming\\npm-cache\\_logs\\2018-12-24T03_53_46_605Z-debug.log 3.2.2 config 文件配置官方 create-react-app 脚手架，原生并不支持 sass，所以需要额外配置。可以参看链接 webpack.config.dev.js: 开发环境 yarn start / npm start 使用 webpack.config.prod.js:开发环境 npm run build / yarn build 使用 四、CSS 拓展4.1 选择器 嵌套Sass 允许将一个 CSS 样式嵌套进另一个样式中，内层样式仅适用于外层样式的选择器范围内,这有助于避免父选择器重复，相对于复杂的CSS布局中多层嵌套的选择器 要简单得多。 4.1.1 后代选择器的嵌套1234567891011121314151617181920/* scss 语法 */#main p &#123; color: #00ff00; width: 97%; .redbox &#123; background-color: #ff0000; color: #000000; &#125;&#125;/* 编译后对应的 css */#main p &#123; color: #00ff00; width: 97%;&#125;#main p .redbox &#123; background-color: #ff0000; color: #000000;&#125; 1234567891011121314151617181920212223/* scss 语法 */#main &#123; width: 97%; p, div &#123; font-size: 2em; a &#123; font-weight: bold; &#125; &#125; pre &#123; font-size: 3em; &#125;&#125;/* 编译后对应的 css */#main &#123; width: 97%;&#125;#main p, #main div &#123; font-size: 2em;&#125;#main p a, #main div a &#123; font-weight: bold;&#125;#main pre &#123; font-size: 3em;&#125; 4.1.2 嵌套引用 父选择器 &amp; 以及伪类嵌套有些时候需要直接使用嵌套外层的父选择器，这个就很有用了，例如，你可能喜欢给选择器指定 hover 样式，或者当 body 元素具有某个样式时，在这些情况下，你可以 &amp; 字符来明确地表示插入指定父选择器。 例如： 12345678910111213141516171819/* scss 语法 */a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125;/* 编译后对应的 css */a &#123; font-weight: bold; text-decoration: none;&#125;a:hover &#123; text-decoration: underline;&#125;body.firefox a &#123; font-weight: normal;&#125; 12345678910111213141516171819202122/* &amp; 将替换为呈现在 CSS 文件中的父选择器。这意味着，如果你有一个多层嵌套的规则，父选择器将在被 &amp; 替换之前完全分解。 例如： *//* scss 语法 */#main &#123; color: black; a &#123; font-weight: bold; &amp;:hover &#123; color: red; &#125; &#125;&#125;/* 编译后对应的 css */#main &#123; color: black;&#125;#main a &#123; font-weight: bold;&#125;#main a:hover &#123; color: red;&#125; 123456789101112131415/* &amp; 必须出现在的选择器的开头位置（也就是作为选择器的第一个字符），父选择器 &amp; 被作为一个后缀的时候，Sass 将抛出一个错误。但可以跟随后缀，将被添加到父选择的后面。 *//* scss 语法 */#main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125;/* 编译后对应的 css */#main &#123; color: black;&#125;#main-sidebar &#123; border: 1px solid;&#125; 4.2 属性 嵌套(有相同的属性前缀)CSS 中有一些属性遵循相同的 “命名空间”；比如，font-family, font-size, 和 font-weight 都在 font 命名空间中。 在 CSS 中，如果你想在同一个命名空间中设置一串属性，你必须每次都输出来。Sass 为此提供了一个快捷方式：只需要输入一次命名空间，然后在其内部嵌套子属性。例如： 123456789101112131415/* scss 语法 */.funky &#123; font: &#123; family: fantasy; size: 30em; weight: bold; &#125;&#125;/* 编译后对应的 css */.funky &#123; font-family: fantasy; font-size: 30em; font-weight: bold;&#125; 12345678910111213/* 命名空间也可以有自己的属性值。 *//* scss 语法 */.funky &#123; font: 20px/24px fantasy &#123; weight: bold; &#125;&#125;/* 编译后对应的 css */.funky &#123; font: 20px/24px fantasy; font-weight: bold;&#125; 4.3 伪类 嵌套12345678910111213141516171819202122/* scss: */.clearfix&#123; &amp;:before, &amp;:after &#123; content:\"\"; display: table; &#125; &amp;:after &#123; clear:both; overflow: hidden; &#125;&#125;/* css: */clearfix:before, .clearfix:after &#123; content: \"\"; display: table;&#125;.clearfix:after &#123; clear: both; overflow: hidden;&#125; 4.4 scss 继承在 sass 中的继承，可以继承类样式块中所有样式代码，而且编译出来的 css 会将选择器合并在一起，形成组合选择器。 123456789101112131415161718192021.btn &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px;&#125;.btn-primary &#123; background-color: #f36; color: #fff; @extend .btn;&#125;/* CSS */.btn, .btn-primary &#123; border: 1px solid #ccc; padding: 6px 10px; font-size: 14px; &#125;.btn-primary &#123; background-color: #f36; color: #fff;&#125; 4.5 占位符选择器 % (需要调用 @extend 达到编译)Sass 支持一种特殊类型的选择器 % ,叫做”占位符选择器” (placeholder selector)。用占位符声明的代码，如果不被 @extend 调用就不会被编译。 通过 @extend 调用的占位符，编译出来的代码会将相同的代码合并在一起，代码变得十分简洁。 1234567891011121314%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; color:red;&#125;/* CSS */.btn &#123; color:red;&#125;/* % 占位符声明的代码没有被编译产生 css 代码 */ 123456789101112131415161718192021222324%mt5 &#123; margin-top: 5px;&#125;%pt5&#123; padding-top: 5px;&#125;.btn &#123; @extend %mt5;/* 使用@extend调用占位符代码 */ @extend %pt5;&#125;.block &#123; @extend %mt5; span &#123; @extend %pt5; &#125;&#125;/* CSS */.btn, .block &#123; margin-top: 5px;&#125;.btn, .block span &#123; padding-top: 5px;&#125; 五、 注释: / / 和 //Sass 支持标准的CSS多行注释以 / / 以及单行注释 //。在尽可能的情况下，多行注释会被保留在输出的 CSS 中，而单行注释会被删除。 /*注释内容*/:会在编译出来的 css 文件中显示 //注释内容 :不会在编译出来的 css 文件中显示 12345678//定义一个占位符%mt5 &#123; margin-top: 5px;&#125;/*调用一个占位符*/.box &#123; @extend %mt5;&#125; 编译出来的css： 1234.box &#123; margin-top: 5px;&#125;/*调用一个占位符*/ 可以看到上面的例子中，单行注释的文本在 编译得到的 css 文件中不存在了。而多行注释存在。 1234567891011121314151617181920212223/* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black; &#125;// These comments are only one line long each.// They won't appear in the CSS output,// since they use the single-line comment syntax.a &#123; color: green; &#125;/* 编译为： *//* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */body &#123; color: black;&#125;a &#123; color: green;&#125; 如果多行注释的第一个字母是 !，那么注释总是会被保留到输出的 CSS 中，即使在压缩输出模式下。这可用于在你生成的 CSS 中添加版权声明。 使用插值语句 (interpolation) ，可以将变量值输出到多行注释中，例如： 12345$version: \"1.2.3\"; /* This CSS is generated by My Snazzy Framework version #&#123;$version&#125;. *//* 编译为： *//* This CSS is generated by My Snazzy Framework version 1.2.3. */ 六、变量6.1 变量声明语法：$+变量名+：+变量值； 1$width:200px; 使用 SassScript 最直截了当的方法是使用变量。变量以美元符号开始，赋值像设置 CSS 属性那样： 12345/* scss */$width: 5em;#main &#123; width: $width;&#125; 6.2 普通变量 与 默认变量 普通变量声明后可以在全局范围内使用； 默认变量仅需在值后面加上!default 即可； 默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式是在默认变量之前重新声明下变量即可。默认变量的价值在进行组件化开发的时候会非常有用。 1234567891011/* SCSS */$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body &#123; line-height: $baseLineHeight;&#125;/* 编译后的CSS代码： */body &#123; line-height:2;&#125; 变量默认 !default （Variable Defaults: !default） 如果分配给变量的值后面添加了 !default 标志 ，这意味着该变量如果已经赋值，那么它不会被重新赋值，但是，如果它尚未赋值，那么它会被赋予新的给定值。 例如: 1234567891011121314$content: \"First content\"; $content: \"Second content?\" !default;$new_content: \"First time reference\" !default;#main &#123; content: $content; new-content: $new_content;&#125;/* 编译为 CSS*/#main &#123; content: \"First content\"; new-content: \"First time reference\";&#125; 1234567891011/* 通过!default赋值的时候，如果变量是 null 值时，将视为未赋值（愚人码头注：所以下面的$content值为 \"Non-null content\"）： */$content: null; $content: \"Non-null content\" !default;#main &#123; content: $content;&#125;/* 编译为： CSS*/#main &#123; content: \"Non-null content\";&#125; 6.3 局部变量 与 全局变量 局部变量：在元素里面声明的变量； 全局变量：在元素外面定义的变量； 全局变量的影子：和全局变量名字相同的局部变量叫做全局变量的影子。 1234567891011121314$color:green;/* 全局变量 */$width:200px;/* 全局变量 */$height:200px;/* 全局变量 */body &#123; background-color:$color;/* 调用全局变量 */&#125;div &#123; $color:yellow;/*定义局部变量，全局变量 $color 的影子 */ .div &#123; background-color:$color;/* 调用局部变量 */ width:$width;/* 调用全局变量 */ height:$height;/* 调用全局变量 */ &#125;&#125; 变量仅在它定义的选择器嵌套层级的范围内可用（可以理解为块级作用域）。 不在任何嵌套选择器内定义的变量则在可任何地方使用（可以理解为全局变量）。定义变量的时候可以后面带上 !global 标志，在这种情况下，变量在任何地方可见（可以理解为全局变量，也可以叫做所用于的提升吧) 12345678910111213141516/* scss */#main &#123; $width: 5em !global;// 在 #main 中定义的变量，在 #sidebar 希望使用的话就 使用 !global 标志。 width: $width;&#125;#sidebar &#123; width: $width;&#125;/* css */#main &#123; width: 5em;&#125;#sidebar &#123; width: 5em;&#125; 12345678910111213/* 使用scss代码： */$font-stack: Helvetica, sans-serif; $primary-color: #333; body &#123; font: 100% $font-stack; color: $primary-color;&#125;/* css代码： */body &#123; font: 100% Helvetica, sans-serif; color: #333;&#125; 6.4 变量中 连字符 与 下划线 没有区分由于历史原因，变量名（以及其他所有 Sass 标识符）可以互换连字符 - 和下划线 _ ,例如，如果你定义了一个名为 $main-width，您可以使用 $main_width 访问它，反之亦然。简单来说就是说，sass 中定义的变量 连字符 与 下划线 没有区分 12$main-width:20px;/* 等价于 */$main_width:20px; 七、数据类型 与 对应的运算7.1 数据类型 分类SassScript 支持 7 种主要的数据类型： 数字 (例如： 1.2, 13, 10px) 文本字符串，带引号字符串和不带引号字符串(例如：”foo”, ‘bar’, baz) 颜色 (例如：blue, #04a3f9, rgba(255, 0, 0, 0.5)) 布尔值 (例如： true, false) 空值 (例如： null) 值列表 (list)，用空格或逗号分隔 (例如： 1.5em 1em 0 2em, Helvetica, Arial, sans-serif) maps ，从一个值映射到另一个 (例如： (key1: value1, key2: value2)) SassScript 也支持其他所有类型的 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而，不会对这些类型的属性值做特殊处理，一律视为不带引号的字符串。 所有数据类型的支持相等运算 (== 和 !=)。此外，每种类型都有其自己特殊的运算方式。 7.2 数字/数值 运算1.2, 13, 10px 等成为数字/数值 ① 加法 + ② 减法 - ③ 乘法 * ④ 除法 / ⑤ 取模 % ⑥ 关系运算符(&lt;, &gt;, &lt;=, &gt;=) ⑦ 相等运算符(==, !=) 7.2.1 数值做 加减法（数值之间的单位需要一致，否则报错）Sass 数学函数在算术运算期间会保留单位。意味着不同单位的数值之间是不能相互运算的，会报错。 注意 + - 运算符的前后都要加上空格符。 1234567891011.box &#123; width: 20px + 8in; /* in 是什么鬼单位，为什么这个又不报错 */ height:20px - 5px; width: ((220px + 720px) - 11 * 20 ) / 12 ; /* 下面混合计算中，这个为什么没错，只有一个有单位的话不错？？？ */&#125;/* 编译出来的css： */.box &#123; width: 788px; height:25px;&#125; 123.box &#123; width: 20px + 1em;/* 不同类型单位不能做加法,文件报错 */&#125; 12345678910$content-width: 720px;$sidebar-width: 220px;$gutter: 20px;.container &#123; width: $content-width + $sidebar-width + $gutter;&#125;/* 编译出来的css： */.container &#123; width: 960px;&#125; 7.2.2 数值做 乘法 （只能有一个数值有单位，两个都有单位就会做平方 报错）两个单位相同的数字相乘将产生单位平方，px * px 是无效的 CSS 单位，Sass 会抛出一个错误，因为你试图在 CSS 中使用无效的单位。 12345678.box &#123; width: 10px * 2;&#125;/* 编译出来的css： */.box &#123; width: 20px;&#125; 123456.box &#123; width:10px * 2px; /* 报错,只能有一个有单位 */&#125;.box &#123; width:10px * 2em; /* 报错，只能有一个有单位，并且两个数值的单位不一致都不能运算的 */&#125; 7.2.3 数值做 除法（注意的问题点很多）如果除式中 没有变量 或者 不是在一个数学表达式中（有 加法减法 等），就要将除式运算用 小括号括起来，否则 “/”不会被当做除号运算。 12345678910111213141516p &#123; font: 10px/8px; /* 原生 CSS，不是除法运算 */ $width: 1000px; width: $width/2; /* 使用了变量，是除法运算 */ width: round(1.5)/2; /* 使用了函数, 作为除法 */ height: (500px/2); /* 使用了括号, 作为除法 */ margin-left: 5px + 8px/2px; /* 使用了 +, 作为除法 */ font: (italic bold 10px/8px); /* 在一个列表（list）中，括号可以被忽略。 */&#125;/* 编译为： */p &#123; font: 10px/8px; /* 这种是无意义的css */ width: 500px; height: 250px; margin-left: 9px;&#125; 12345678/* 除法中相同单位相除不会报错，会产生一个无单位的值： */.box &#123; width: (1000px / 100px);&#125;/* 编译为： */.box &#123; width: 10;&#125; 7.2.8 加减乘除混合运算12345678.box &#123; width: ((220px + 720px) - 11 * 20 ) / 12 ; &#125;/* CSS */.box &#123; width: 60px;&#125; 7.2.9 数值变量 插值运算： #{} 运算纯 CSS 的/ 和变量一起使用（即/不作为除法使用），你可以使用 #{} 插入他们。 12345678910p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;/* 编译为： */p &#123; font: 12px/30px; /* 但是这个不是没有意义的 css ？？？做来干什么 */&#125; 7.3 字符串 运算 不带引号的字符串 sans-serif 或者 bold 带引号（单双引号）的字符串 &quot;Lucida Grande&quot; 或者 &#39;http://sass-lang.com&#39; 7.3.1 不带引号的 字符串 + 连字符运算12345678910/* + 运算可用于连接字符串: *//* SCSS */p &#123; cursor: e + -resize;&#125;/* 编译为：CSS */p &#123; cursor: e-resize;&#125; 7.3.2 带引号的 字符串 + 连字符运算12345678$content: \"Hello\" + \"\" + \"Sass!\";.box:before &#123; content: \" #&#123;$content&#125; \";&#125;/* 编译出来的css： */.box:before &#123; content: \" Hello Sass! \";&#125; 7.3.3 一个不带/一个带 引号的 字符串 + 连字符运算以连字符 + 左边的字符串为准，若带则带，不带则不带 1234567891011/* SCSS */p:before &#123; content: \"Foo \" + Bar; /* \"Foo \" 有引号，结果为有引号 */ font-family: sans- + \"serif\"; /* sans- 无引号，则结果无引号 */&#125;/* 编译为：CSS */p:before &#123; content: \"Foo Bar\"; font-family: sans-serif;&#125; 7.3.3 字符串与 非字符串 运算12345678910/* 默认情况下，运算表达式与其他值连用时，用空格做连接符： *//* SCSS */p &#123; margin: 3px + 4px auto;&#125;/* 编译为：CSS */p &#123; margin: 7px auto;&#125; 7.3.4 字符串 插值 运算在文本字符串中，#{}式插值可以用来在字符串中放置动态值： 1234567891011/* 在字符串插值时，Null值被视为空字符串： *//* SCSS */$value: null; p:before &#123; content: \"I ate #&#123;$value&#125; pies!\";&#125;/* 编译为：CSS */p:before &#123; content: \"I ate pies!\";&#125; 1234567p:before &#123; content: \"I ate #&#123;5 + 10&#125; pies!\";&#125;/* CSS */p:before &#123; content: \"I ate 15 pies!\";&#125; 上面的计算中，在编译输出的 CSS 文件中不会改变 Sass 文档中使用的字符串类型。 有一个例外，当使用 #{} interpolation 时，带引号的字符串将被编译为不带引号的字符串，这样主要是为了便于使用，比如 mixins 中的选择器名称。例如： 1234567891011@mixin firefox-message($selector) &#123; body.firefox #&#123;$selector&#125;:before &#123; content: \"Hi, Firefox users!\"; &#125;&#125;@include firefox-message(\".header\");/* 编译为： */body.firefox .header:before &#123; content: \"Hi, Firefox users!\";&#125; 7.4 颜色运算所有算术运算都支持的颜色值，颜色值的运算是分段进行计算的，也就是，依次计算红（red），绿（green），以及蓝（blue）的成分值。例如： 12345678p &#123; color: #010203 + #040506;&#125;/* 计算 01 + 04 = 05, 02 + 05 = 07, 和 03 + 06 = 09 *//* 编译为： */p &#123; color: #050709;&#125; 123456789/* 通常 color functions(颜色函数)比尝试使用颜色运算更加有用，以达到同样的效果。数字和颜色值之间的算术运算也是分段。例如： */p &#123; color: #010203 * 2;&#125;/* 计算 01 * 2 = 02, 02 * 2 = 04, 和 03 * 2 = 06，并且编译为： */p &#123; color: #020406;&#125; 12345678910/* 需要注意的是，包含 alpha 通道（那些由 rgba 或 hsla 函数创建的）的颜色必须具有相同的 alpha 值，才能进行颜色运算。这样算术不会影响alpha值 */p &#123; color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);&#125;/* &lt;!-- 编译为： --&gt; */p &#123; color: rgba(255, 255, 0, 0.75);&#125; 1234567891011/* 颜色的alpha通道可以使用opacify和transparentize函数进行调整。例如： */$translucent-red: rgba(255, 0, 0, 0.5); p &#123; color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25);&#125;/* 编译为： */p &#123; color: rgba(255, 0, 0, 0.8); background-color: rgba(255, 0, 0, 0.25);&#125; 1234567891011/* IE浏览器的滤镜（filters）要求所有的颜色包括 alpha 层，而且格式必须是固定的 #AABBCCDD ，使用 ie_hex_str 函数可以轻松的将颜色转化为 IE 滤镜所要求的格式。例如： */$translucent-red: rgba(255, 0, 0, 0.5); $green: #00ff00;div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#&#123;ie-hex-str($green)&#125;', endColorstr='#&#123;ie-hex-str($translucent-red)&#125;');&#125;/* 编译为：CSS */div &#123; filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);&#125; 7.5 #### 5.2.4 布尔运算SassScript 支持布尔值的 and, or, 和 not 运算。 12&lt;h3&gt;Example using Boolean Operations&lt;/h3&gt;&lt;p class=\"bool\"&gt;SASS stands for Syntactically Awesome Stylesheet..&lt;/p&gt; 1234567/* SCSS */$age:20;.bool &#123; @if ($age &gt; 10 and $age &lt; 25) &#123; color: green; &#125;&#125; 7.6 空值 运算7.7 列表 运算7.7.1 scss 中的列表定义1234567/* 列表 是指 Sass 如何表示在CSS声明的 */，margin: 10px 15px 0 0;font-face: Helvetica, Arial, sans-serif;/* 列表只是一串其他值，无论是用空格还是用逗号隔开。 */font-size:12px;/* 事实上，独立的值也被视为列表：只包含一个值的列表。 */ 7.7.2 列表计算方法list 函数,以下列举其中几个方法。 123456789101112/* 列表本身没有太多的功能，但 Sass list functions 赋予了数组更多新功能： *//* nth 函数可以直接访问数组中的某一项 */nth($list,$n) /* 返回列表中的特定项。 *//* join 函数可以将多个数组连接在一起 */join($list1,$list2,[$separator,$bracketed]) /* 将两个列表合并为一个。 *//* append 函数可以在数组中添加新值 */append($list1,$val,[$separator])/* 将单个值追加到列表的末尾。 *//* @each 指令能够遍历数组中的每一项。 */ 7.8 Maps 运算7.8.1 scss 中 map 定义123/* Maps 代表一个键和值对集合，其中键用于查找值。他们可以很容易地将值收集到命名组中，并且可以动态地访问这些组。在 CSS 中你找不到和他们类似的值，虽然他们的语法类似于媒体查询表达式： */$map: (key1: value1, key2: value2, key3: value3); 和列表（Lists）不同，Maps 必须始终使用括号括起来，并且必须用逗号分隔。Maps 中的键和值可以是任意的 SassScript 对象。一个 Maps 可能只有一个值与给定的键关联（尽管该值可以是一个列表）。一个给定的值可能与许多键关联。 7.8.2 map 的计函数方法MAP,下面只是列举几个。 12map-get($map,$key)/* 返回与给定键关联的映射中的值。 */map-merge($map1,$map2)/* 将两个地图合并为一个新地图。 */ Maps不能转换为纯CSS。作为变量的值或参数传递给CSS函数将会导致错误。使用inspect($value) 函数以产生输出字符串，这对于调试 maps 非常有用。 5.2.6 圆括号 改变 优先级123456789/* 圆括号可以用来影响运算的顺序(优先级)： */p &#123; width: 1em + (2em * 3);&#125;/* 编译为：CSS */p &#123; width: 7em;&#125; 5.4 函数SassScript定义了一些有用的函数， 这些函数可以像普通 CSS 函数语法一样调用： 1234567p &#123; color: hsl(0, 100%, 50%);&#125;编译为：p &#123; color: #ff0000; &#125; 可用函数的完整列表，请参阅这张页面。 5.5 关键词参数 (Keyword Arguments)Sass 函数允许指定明确的关键词参数 (keyword arguments) 进行调用。 上面的例子也可以改写成： p { color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);}虽然不够简明，但可以让Sass代码阅读起来更加方便。 关键词参数让函数具有更灵活的接口， 即便参数众多，也不会让使用变得困难。 命名参数（named arguments）可以以任意顺序传入，并且，具有默认值的参数可以省略掉。 由于命名参数也是变量名称，因此，下划线、短横线可以互换使用。 完整的 Sass 函数列表和它们的参数名称，以及在 Ruby 里如何定义你自己的函数的步骤，请见 Sass::Script::Functions。 5.6 插值：#{}（Interpolation: #{}）您还可以通过 #{} 插值语法在选择器和属性名中使用 SassScript 变量： 123456789$name: foo; $attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125;/* 编译为： */p.foo &#123; border-color: blue; &#125; 它也可以使用#{}插值语句把 SassScript 插入到属性值中。在大多数情况下，这种做可能还不如使用直接变量来的方便，但使用 #{}意味着靠近它的运算符都将被视为纯CSS（愚人码头注：可以避免各种运算）。 例如： 123456789p &#123; $font-size: 12px; $line-height: 30px; font: #&#123;$font-size&#125;/#&#123;$line-height&#125;;&#125;/* 编译为： */p &#123; font: 12px/30px; &#125; 5.7 SassScript中的&amp;（&amp; in SassScript）就像当它在选择器中使用一样，SassScript中的&amp;指向当前父选择器。下面是一个逗号分隔的列表（list）中包含一个空格的分隔列表（list）。例如： 123.foo.bar .baz.bang, .bip.qux &#123; $selector: &amp;;&#125; $selector 的值是现在 ((“.foo.bar” “.baz.bang”), “.bip.qux”)。这个混合选择器在这里加了引号，以表明他们是字符串，但在现实中，他们将不带引号的。即使选择器不包含逗号或空格，&amp;总会有两个嵌套层次，因此它可以保证访问一致性。 如果没有父选择器，&amp; 的值将是空。这意味着你可以在一个 mixin 中使用它来检测父选择是否存在： 1234567891011@mixin does-parent-exist &#123; @if &amp; &#123; &amp;:hover &#123; color: red; &#125; &#125; @else &#123; a &#123; color: red; &#125; &#125;&#125; 八、ass 插值123456789101112131415$properties: (margin, padding);@mixin set-value($side, $value) &#123; @each $prop in $properties &#123;//对每个在$properties中的$prop,即$properties中的margin、padding #&#123;$prop&#125;-#&#123;$side&#125;: $value;//$prop连接参数$side，值为参数$value &#125;&#125;.login-box &#123; @include set-value(top, 14px);//调用混合宏&#125;/* 编译出来的css： */.login-box &#123; margin-top: 14px; padding-top: 14px;&#125; 12345678910111213/* 可以在使用@extend时使用插值： */%updated-status &#123; margin-top: 20px; background: #F00;&#125;.selected-status &#123; font-weight: bold;&#125;$flag: \"status\";.navigation &#123; @extend %updated-#&#123;$flag&#125;; @extend .selected-#&#123;$flag&#125;;&#125; 以下的用法是不对的 1234567891011121314151617181920/* 下面这样是错误的 */$margin-big: 40px;$margin-medium: 20px;$margin-small: 12px;@mixin set-value($size) &#123; margin-top: $margin-#&#123;$size&#125;;&#125;.login-box &#123; @include set-value(big);&#125;/* 这样也是错误的 */@mixin updated-status &#123; margin-top: 20px; background: #F00;&#125;$flag: \"status\";.navigation &#123; @include updated-#&#123;$flag&#125;;&#125; 八、if 语句：控制指令和表达式九、混入指令:sass 混合宏（需要学习）混入 (mixin) 允许您定义可以在整个样式表中重复使用的样式，而避免了使用无语意的类（class），比如 .float-left。混入 (mixin) 还可以包含所有的 CSS 规则，以及任何其他在 Sass 文档中被允许使用的东西。他们甚至可以带 arguments，引入变量，只需少量的混入 (mixin) 代码就能输出多样化的样式。 9.1 声明混合宏 @mixin xxx{} 与 调用 @include xxx1234567891011121314151617/* @mixin :声明混合宏的关键词；border-radius:混合宏的名称；大括号内：复用的样式代码； */@mixin border-radius&#123; -webkit-border-radius: 3px; border-radius: 3px;&#125;/* 声明混合宏border-radius */button &#123; @include border-radius; /* 调用混合宏border-radius */&#125;/* 编译为CSS： */button &#123; -webkit-border-radius: 3px; border-radius: 3px;&#125; 123456789101112131415161718192021222324/* 混入 (mixin) 通过 @mixin 指令定义。在它后面跟混入的名称和任选的 arguments（参数），以及混入的内容块。 */@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125;/* css */.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px;&#125; 123456789101112/* 混入也可以包含选择器和属性的混合体，选择器中甚至可以包含parent references（父选择器）。 例如： */@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px &#125;&#125; 1234567891011121314/* 混入（mixin）也可以包含在任何规则的外（即，在文档的根）,只要它们不直接定义的任何属性或使用任何父选择器引用 */@mixin silly-links &#123; a &#123; color: blue; background-color: red; &#125;&#125;@include silly-links;/* CSS */a &#123; color: blue; background-color: red;&#125; 12345678910/* 混入（mixin）定义也可以包含其他的混入混入可以包含自己。这行为不同于 Sass 3.3 之前的版本，以前混入递归是被禁止的。只定义后代选择器的混入可以安全地混入到文件的最顶层。*/@mixin compound &#123; @include highlighted-background; @include header-text;&#125;@mixin highlighted-background &#123; background-color: #fc0; &#125;@mixin header-text &#123; font-size: 20px; &#125; 注意：混入的名称没有 连字符 与下划线之分混入（mixin）的名字（和所有其他 Sass 标识符）可以互换连字符和下划线。例如，如果你定义了一个名为add-column的混入，你可以把它作为add_column，反之亦然。 9.3 混合宏的参数混入（mixin）可以用 SassScript 值作为参数，给定的参数被包括在混入（mixin）中并且作为为变量提供给混入（mixin）。 9.3.1 不带任何值的参数1234567@mixin border-radius($radius)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125;/* 声明一个带有参数$radius的混合宏 */.box &#123; @include border-radius(3px);/*调用混合宏并给混合宏传参数“3px” */&#125; 9.3.2 传一个带值参数（传入一个默认值）1234567891011121314151617181920@mixin border-radius($radius:3px)&#123; -webkit-border-radius: $radius; border-radius: $radius;&#125;/*声明一个传入了默认参数值的混合宏 */.btn &#123; @include border-radius;/*使用默认参数值的混合宏 */&#125;.box &#123; @include border-radius(50%);/*可以自己传入参数值 */&#125;/* CSS */.btn &#123; -webkit-border-radius: 3px; border-radius: 3px;&#125;.box &#123; -webkit-border-radius: 50%; border-radius: 50%;&#125; 1234567891011121314151617181920@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125;/* CSS */p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 9.3.3 传多个参数值12345678910111213@mixin size($width,$height)&#123; width: $width; height: $height;&#125;.box-center &#123; @include size(500px,300px);&#125;/* 编译出来的css： */.box-center &#123; width: 500px; height: 300px;&#125; 1234567891011121314151617181920@mixin sexy-border($color, $width: 1in) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue); &#125;h1 &#123; @include sexy-border(blue, 2in); &#125;/* CSS */p &#123; border-color: blue; border-width: 1in; border-style: dashed; &#125;h1 &#123; border-color: blue; border-width: 2in; border-style: dashed; &#125; 9.3.4 关键字参数混入（mixin）在引入（@include指令）的时候也可以使用明确的关键字参数。例如，上面的例子可以写成： 12p &#123; @include sexy-border($color: blue); &#125; h1 &#123; @include sexy-border($color: blue, $width: 2in); &#125; 虽然这是不够简明，但是它可以使样式表更容易阅读。它给函数呈现了更加灵活的接口，它使多参数的混入更加容易调用。命名的参数可以按任何顺序进行传递，有默认值的参数可以省略。由于命名参数是变量名，下划线和连字符可以互换使用。 9.3.5 可变参数有时，不能确定一个混入（mixin）或者一个函数（function）使用多少个参数。例如，用于创建盒子阴影（box-shadow）的一个混入（mixin）可以采取任何数量的box-shadow作为参数。对于这些情况，Sass支持”可变参数”,参数在声明混入（mixin）或函数（function）结束的地方，所有剩余的参数打包成一个列表（list）。参数看起来就像普通参数一样，但后面跟随着…。例如： 12345678910111213141516@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);&#125;/* 编译为： */.shadows &#123; -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999;&#125; 可变参数可以包含任何关键字参数传递给混入（mixin）或者函数（function）。这些可以使用keywords($args)函数 来访问，返回一个map，参数名称字符串（无$）和值的键值对。 可变参数，也可以在调用（@include指令）一个混入（mixin）时使用。使用相同的语法，你可以扩展值的列表（list），以便每个值作为单独的参数传入，或扩展值的map，以使每个键值对作为一个关键字参数处理。例如： 12345678910111213141516171819202122232425262728@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff; .primary &#123; @include colors($values...);&#125;$value-map: (text: #00ff00, background: #0000ff, border: #ff0000); .secondary &#123; @include colors($value-map...);&#125;/* 编译为： */.primary &#123; color: #ff0000; background-color: #00ff00; border-color: #0000ff;&#125;.secondary &#123; color: #00ff00; background-color: #0000ff; border-color: #ff0000;&#125; 你可以同时传递一个列表（list）和一个map参数，只要列表（list）在map上之前，比如@include colors($values…, $map…)。 您可以使用可变参数来包装一个混入（mixin）并且添加额外的样式，而不改变混入（mixin）的参数签名。如果你这样做，关键字参数将通过包装的混入（mixin）直接传递。例如： 123456789@mixin wrapped-stylish-mixin($args...) &#123; font-weight: bold; @include stylish-mixin($args...);&#125;.stylish &#123; // The $width argument will get passed on to \"stylish-mixin\" as a keyword @include wrapped-stylish-mixin(#00ff00, $width: 100px);&#125; 9.4 传递内容块到混入样式内容块可以传递到混入（mixin）包含样式的位置。样式内容块将出现在混入内的任何 @content 指令的位置。这使得可以定义抽象 关联到选择器和指令的解析。 例如： 123456789101112131415@mixin apply-to-ie6-only &#123; * html &#123; @content; &#125;&#125;@include apply-to-ie6-only &#123; #logo &#123; background-image: url(/logo.gif); &#125;&#125;/* 生成: */* html #logo &#123; background-image: url(/logo.gif);&#125; 同样的混入（mixin）可以在.sass 简写语法（@mixin 可以用 = 表示，而 @include 可以用 + 表示）来完成： 1234567=apply-to-ie6-only * html @content+apply-to-ie6-only #logo background-image: url(/logo.gif) 注意： 当@content指令指定多次或在一个循环中指定的时候，样式块将在每次调用中被复制并引用。 9.5 变量的作用域和内容块传递给混入（mixin）的内容块在其被定义的作用域中进行运算，而不是混入（mixin）的作用域。这意味着混入（mixin）的局部变量不能传递给样式块使用，并且变量将解析为全局值： 12345678910111213141516$color: white; @mixin colors($color: blue) &#123; background-color: $color; @content; border-color: $color;&#125;.colors &#123; @include colors &#123; color: $color; &#125;&#125;/* CSS */.colors &#123; background-color: blue; color: white; border-color: blue;&#125; 另外，这清楚地表明，变量和传递到块中使用的混入，指向块定义的周围其他样式。例如： 1234567#sidebar &#123; $sidebar-width: 300px; width: $sidebar-width; @include smartphone &#123; width: $sidebar-width / 3; &#125;&#125; 十、函数指令十一、输出格式十二、扩展 Sass十三 导入：@规则 和 指令 (@-Rules and Directives)","tags":[]},{"title":"mpvue 框架 入门学习","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-mpvue-vue-cli 框架/","text":"一、前言mpvue.js 是美团点评开源的一个使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。使用 mpvue 开发小程序，你将在小程序技术体系的基础上获取到这样一些能力： 彻底的组件化开发能力：提高代码复用性完整的 Vue.js 开发体验方便的 Vuex 数据管理方案：方便构建复杂应用快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload支持使用 npm 外部依赖使用 Vue.js 命令行工具 vue-cli 快速初始化项目H5 代码转换编译成小程序目标代码的能力 已经学会了使用 vue.js 的话，小程序使用 mpvue 来做还是很简答的。 Github：官网 1.1 wepy，mpvue，Taro，开发框架的差别wepy：wepy-cli 基于 vue.js，但是有差异mpvue：vue-cli 类 vue.js，但是有差异Taro：taro-cli 基于 react.js 差异学习网址 二、mpvue.js 框架创建：vue-cli因为 mpvue 是基于 vue.js 的，因为 mpvue 的框架其实也是使用 vue-cli 脚手架来搭建的。 在使用 vue-cli 之前，肯定是要保证电脑安装有 vue-cli 的。 2.1 vue-cli 脚手架工具的安装12345# 下面的步骤可以去看 vue-cli 文件夹下的文章$ node -v # v8.9.0 先检查下 Node.js 是否安装成功$ npm -v # 5.6.0 先检查下 npm 是否安装成功$ npm set registry https://registry.npm.taobao.org/ # 由于众所周知的原因，可以考虑切换源为 taobao 源$ npm install --global vue-cli@2.9 # 一般是要 sudo 权限的 全局安装 vue-cli 前面 vue.js 的时候 web 端项目已经安装过 vue-cli 就不需要安装了。 2.2 vue-cli 脚手架创建项目1234567891011# 创建一个基于 mpvue-quickstart 模板的新项目，注意这里使用的是 mpvue/mpvue-quickstart 不再是 web 项目的 webpack# 它包含了 webpack 打包器$ vue init mpvue/mpvue-quickstart my-project# 注意这里就是复制这一句来操作的，不是有选项， / 这个代表什么？# 这个过程 vue-cli 主要是先从远程的代码仓库中下载了一份注册名为 mpvue/mpvue-quickstart 的模板代码，# 然后根据开发者在命令行提示过程中输入的信息，生成一份经过配置后的代码。# 会提示说 Documentation can be found at http://mpvue.com 这个不是错$ cd my-project$ npm install # 还原依赖，生成 node_moudules 文件夹$ npm run dev# 与 vue 项目一样，运行成功的回显之后，可以看到本地多了个 dist 目录，这个目录里就是生成的小程序相关代码。 2.3 vue-cli 脚手架项目 与 微信开发者工具 配合使用与 官方提供的 wepy 框架一样，我们可以使用 vs-code ，webstorm 或者其他的工具来编辑代码，使用 开发者工具 打开 dist 这个与小程序相关的代码来实时查看编辑的效果。 小程序必须是使用开发者工具来调试的。它与 web ，移动端的区别。注意：开发者工具打开的是与小程序相关的代码，也就是 dist 文件夹中.wxml .wxss .js .json 开发者工具下载网址 12#使用开发者工具打开 dist 文件夹，进行调试$ npm run dev # 新增的页面需要重新运行编译，因为开发者工具就是查看编译后 dist 中的代码 2.4 mpvue.js 框架 各个文件示意123456789101112131415161718192021222324252627282930313233343536373839404142434445464748├──build # 文件夹(生成)：编译功能文件| ├──build.js # 文件(生成)：| ├──check-versions.js # 文件(生成)：| ├──dev-client.js # 文件(生成)：| ├──dev-server.js # 文件(生成)：| ├──utils.js # 文件(生成)：| ├──vue-loader.conf.js # 文件(生成)：| ├──webpack.base.conf.js # 文件(生成)：| ├──webpack.dev.conf.js # 文件(生成)：| └─ webpack.prod.conf.js # 文件(生成)：|├──config # 配置文件夹| ├──dev.env.js # 文件(生成)：| ├──index.js # 文件(生成)：| └─ prod.env.js # 文件(生成)：|├──dist # 文件夹(生成)：编译生成的文件夹| └─ wx/ | ├──common/ # 文件夹(生成)：| ├──compoments/ # 文件夹(生成)：| ├─pages/ # 文件夹(生成)：| ├──app.js # 文件(生成)：| ├──app.js.map # 文件(生成)：| ├──app.json # 文件(生成)| └─ app.wxss #文件(生成)：|├──node_modules # 文件夹(生成)：使用 npm 安装工具产生的文件夹（依赖包）├──src # 文件夹(生成)：原码存放| ├──components/ # 文件夹(生成)：组件存放| ├──pages/ # 文件夹(生成)：页面存放| ├──utils/ # 文件夹(生成)：| ├──app.json # 文件(生成)：| ├──app.vue # 文件(生成)：main.js 对应的 vue 组件| └──main.js # 文件(生成)：入口 js 文件| ├──static # 文件夹(生成)：| └─.gitkeep # 文件(生成)：| ├──.babelrc # 文件(生成)：├──.editorconfig # 文件(生成)：├──.eslintignore # 文件(生成)：├──.eslintrc.js # 文件(生成)：├──.gitignore # 文件(生成)：上传 git 时忽略的文件/文件夹├──.postcssrc.js # 文件(生成)：├──index.html # 文件(生成):hmtl 源码文件，页面结构入口文件├──package.json # 文件(生成)：使用 yarn add 安装工具产生的文件 （项目配置文件）├──project.config.json # 文件(生成)：使用 yarn add 安装工具产生的文件 （项目配置文件）└──README.md # 文件(生成):手动创建的，项目说明文档 2.5 vue-cli 创建项目过程遇到的问题2.5.1 vue-template-compiler 的问题12345678910111213141516171819202122λ cnpm install| [48/53] Installing json-parse-better-errors@^1.0.1platform unsupported babel-loader@7.1.5 › webpack@3.12.0 › watchpack@1.6.0 › chokidar@2.0.4 › fsevents@^1.2.2 Package require os(darwin) not compatible with your platform(win32)[fsevents@^1.2.2] optional install error: Package require os(darwin) not compatible with your platform(win32)√ Installed 53 packages√ Linked 712 latest versions√ Run 1 scriptspeerDependencies link ajv@5.5.2 in F:\\qianduan_dir\\00program\\wechat-mpvue\\suduku\\node_modules\\_ajv-keywords@2.1.1@ajv-keywords unmet with F:\\qianduan_dir\\00program\\wechat-mpvue\\suduku\\node_modules\\ajv(6.5.5)peerDependencies WARNING mpvue-loader@1.1.4 › vue-loader@^13.0.4 requires a peer of vue-template-compiler@^2.0.0 but none was installeddeprecate px2rpx-loader@0.1.10 › px2rpx@0.5.3 › fs-extra@0.16.5 › graceful-fs@^3.0.5 please upgrade to graceful-fs 4 for compatibility withcurrent and future versions of Node.jsdeprecate mpvue-loader@1.1.4 › css-loader@0.28.11 › cssnano@3.10.0 › autoprefixer@6.7.7 › browserslist@^1.7.6 Browserslist 2 could fail onreading Browserslist &gt;3.0 config used in other tools.deprecate eslint@4.19.1 › file-entry-cache@2.0.0 › flat-cache@1.3.2 › circular-json@^0.3.1 CircularJSON is in maintenance only, flatted is its successor.deprecate webpack-bundle-analyzer@2.13.1 › bfj-node4@^5.2.0 Switch to the `bfj` package for fixes and new features!Recently updated (since 2018-11-07): 10 packages (detail see file F:\\qianduan_dir\\00program\\wechat-mpvue\\suduku\\node_modules\\.recently_updates.txt) Today: → mpvue-loader@1.1.4 › js-beautify@1.8.8 › editorconfig@0.15.2 › @types/node@^10.11.7(10.12.7) (03:12:26)√ All packages installed (870 packages installed from npm registry, used 54s(network 49s), speed 293.69kB/s, json 765(7.51MB), tarball 6.55MB) 问题：还有一个没有安装，需要手动的选择版本来安装，peerDependencies WARNING mpvue-loader@1.1.4 › vue-loader@^13.0.4 requires a peer of vue-template-compiler@^2.0.0 but none was installed ：vue-template-compiler解决：vue.js git 解决网址，虽然说试用 npm i vue-template-compiler @^2.0.0--save-dev解决：git 网址解释：默认情况下 vue-template-compiler 是作为 peerDependencies 的，也就是 npm install 的时候是不会自动安装的。在使用 vue 创建项目的时候就需要自己手动的安装。为了保证跟 vue 版本完全一致啊，用 dependencies 是无法保证的，因为 vue 升级 vue-loader 不一定需要升级。 目前 vue-loader 使用时需要配置细节确实很多，诸如 vue-template-compiler 版本号这样的细节，最“傻瓜”且通用的方式毫无疑问就是直接通过 vue-cli 或最新的 @vue/cli 创建了。如果你留意过 vue-loader 文档的 Setting Up a Project 那一页的历史的话就更能体会了，包括你建议的 README 里也做了明确说明。但是小程序这里不是使用 vue-cli 创建的么？ 2.5.2 使用 微信开发者工具打不开 dist 文件夹的问题微信开发者工具提示，请打开一个空目录，或者是含有 app.js ，app.json，app.wxss， 的文件夹。其实是因为，用官方创建的的象奴框架，生成的 dist 文件夹下面不是文件，而是一个 wx 文件夹，我们用开发者工具打开的时候，需要打开 dist 文件夹下的 wx 文件夹。 问题：为什么会还要个文件夹呢，这个不算是一个自我为难么？？？？ 123456789├──dist # 文件夹(生成)：编译生成的文件夹| └─ wx/ | ├──common/ # 文件夹(生成)：| ├──compoments/ # 文件夹(生成)：| ├─pages/ # 文件夹(生成)：| ├──app.js # 文件(生成)：| ├──app.js.map # 文件(生成)：| ├──app.json # 文件(生成)| └─ app.wxss #文件(生成)： 三、生成的框架中各个文件的详细学习。3.1 build &amp; config 文件夹下的文件学习12345678910├──build # 文件夹(生成)：编译功能文件| ├──build.js # 文件(生成)：| ├──check-versions.js # 文件(生成)：| ├──dev-client.js # 文件(生成)：| ├──dev-server.js # 文件(生成)：| ├──utils.js # 文件(生成)：| ├──vue-loader.conf.js # 文件(生成)：| ├──webpack.base.conf.js # 文件(生成)：| ├──webpack.dev.conf.js # 文件(生成)：| └─ webpack.prod.conf.js # 文件(生成)： 3.2 src 文件夹的学习1234567891011121314151617181920├──src # 文件夹(生成)：原码存放| ├──components/ # 文件夹(生成)： 自定义组件| | └──card.vue # 文件(生成)： 单文件组件| ├──pages/ # 文件夹(生成)：页面存放| | ├── counter/ # vuex 演示页面| | | ├── index.vue # 页面模版 + 样式 + 逻辑| | | ├── main.js # 入口文件, 配置 vue + 返回配置| | | └── store.js| | ├── index/ # 首页| | | ├── index.vue| | | └── main.js| | └── logs/ # 日志| | ├── index.vue| | ├── main.js| | └── main.json| ├──utils/ # 文件夹(生成)：工具库| | └── index.js| ├──app.json # 文件(生成)：| ├──app.vue # 文件(生成)：# app.wxss + app.js 生命周期使用 vue 组件| └──main.js # 文件(生成)：入口 js 文件，export 的内容相当于 app.json 3.3 其他文件夹的学习12345678910111213├──static # 文件夹(生成)：| └─.gitkeep # 文件(生成)：| ├──.babelrc # 文件(生成)：├──.editorconfig # 文件(生成)：├──.eslintignore # 文件(生成)：├──.eslintrc.js # 文件(生成)：├──.gitignore # 文件(生成)：上传 git 时忽略的文件/文件夹├──.postcssrc.js # 文件(生成)：├──index.html # 文件(生成):hmtl 源码文件，页面结构入口文件├──package.json # 文件(生成)：├──project.config.json # 文件(生成)：└──README.md # 文件(生成):手动创建的，项目说明文档 3.4 完整项目的解析。vue-cli 生成的框架是单页面框架，它的页面就是 根目录 下的 index.html 文件。也就是框架的 页面入口文件。页面入口文件，对应的 js 动态语言文件在 src 文件夹根目录下的 main.js 文件。main.js 文件对应的 组件为 app.vue 文件。 四、mpvue.js 的生命周期mpvue 继承自 Vue.js，其技术规范和语法特点与 Vue.js 保持一致。 4.1 mpvue.js 框架原理 mpvue 保留了 vue.runtime 核心方法，无缝继承了 Vue.js 的基础能力 mpvue-template-compiler 提供了将 vue 的模板语法转换到小程序的 wxml 语法的能力 修改了 vue 的建构配置，使之构建出符合小程序项目结构的代码格式： json/wxml/wxss/js 文件 4.2 mpvue.js 生命周期12345678910111213141516171819202122232425262728293031beforeCreate//在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。created //在实例创建完成后被立即调用。实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。 //然而，挂载阶段还没开始，$el 属性目前不可见。beforeMount //在挂载开始之前被调用：相关的 render 函数首次被调用。mounted//小程序 onReady 后，才会触发这个周期函数 ，vue mounted 生命周期（el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。//如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。beforeUpdate//数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。updated//由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。//当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。//然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。activated//keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。deactivated//keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。beforeDestroy//实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。destroyed//Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。//该钩子在服务器端渲染期间不被调用。 问题: vue.js 2.5+ 之后还有另外的周期函数，mpvue 是否支持？？？？？ 继承 vue.js 的生命周期，稍微的做些改变，此外 mpvue.js 还加入了小程序的生命周期， 除特殊情况外，不建议使用小程序的生命周期钩子。？？？？？vue.js 生命周期小程序 APP.js 生命周期小程序 pages.js 生命周期 1234567// app.js 的周期onLaunch //生命周期回调—监听小程序初始化 小程序初始化完成时（全局只触发一次）onShow //生命周期回调—监听小程序显示 小程序启动，或从后台进入前台显示时onHide //生命周期回调—监听小程序隐藏 小程序从前台进入后台时onError //错误监听函数 小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息onPageNotFound //页面不存在监听函数 小程序要打开的页面不存在时触发，会带上页面信息回调该函数//其他 //Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问 1234567891011121314// page.js 页面周期data //页面的初始数据onLoad //页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。onShow //页面显示/切入前台时触发。一个页面可以有很多次调用该函数。onReady //页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide //页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。可以摆调用多次onUnload //页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时。onPullDownRefresh //监听用户下拉动作onReachBottom //页面上拉触底事件的处理函数onShareAppMessage //用户点击右上角转发onPageScroll //页面滚动触发事件的处理函数onResize //页面尺寸改变时触发，详见 响应显示区域变化onTabItemTap //当前是 tab 页时，点击 tab 时触发//其他 //Any 开发者可以添加任意的函数或数据到 Object 参数中，在页面的函数中用 this 可以访问 注意点！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ 结合了 vue.js 的 10 个周期函数，还有 小程序的周期函数 vue.js 的 mouted 周期函数有所改变，是 on ready 之后 有的文件内不建议使用某些 小程序的周期函数。 12345678910111213141516//app 部分：onLaunch //初始化，小程序初始化完成时（全局只触发一次）onShow //当小程序启动，或从后台进入前台显示，小程序启动，或从后台进入前台显示时onHide //当小程序从前台进入后台，小程序从前台进入后台时// page 部分：onLoad //监听页面加载onShow //监听页面显示onReady //监听页面初次渲染完成onHide //监听页面隐藏onUnload //监听页面卸载onPullDownRefresh //监听用户下拉动作onReachBottom //页面上拉触底事件的处理函数onShareAppMessage //用户点击右上角分享onPageScroll //页面滚动onTabItemTap // 当前是 tab 页时，点击 tab 时触发 （mpvue 0.0.16 支持） 问题：还有其他的周期函数是没有兼容么？ 五、mpvue.js 模板语法几乎全部支持 vue.js 的语法，但是有部分不能支持，以下是不能支持的部分。 支持 computed 计算属性 支持 v-if，v-else-if，v-else 条件渲染 支持 列表渲染，只是需要注意一点，嵌套列表渲染，必须指定不同的索引！ 5.1 小程序里 不支持 v-html小程序里所有的 BOM／DOM 都不能用，也就是说 v-html 指令不能用。 5.2 不支持部分复杂的 JavaScript 渲染表达式123456789101112&lt;!-- 我们会把 template 中的 &#123;&#123;&#125;&#125; 双花括号的部分，直接编码到 wxml 文件中，由于微信小程序的能力限制(数据绑定)，所以无法支持复杂的 JavaScript 表达式。目前可以使用的有 + - * % ?: ! == === &gt; &lt; [] . 剩下的还待完善。 --&gt;&lt;!-- 这种就不支持，建议写 computed --&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;!-- 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 --&gt;&lt;ul&gt; &lt;li v-for=\"item in list\"&gt; &lt;div @click=\"clickHandle(item, index, $event)\"&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 5.3 不支持过滤器渲染部分会转成 wxml ，wxml 不支持过滤器，所以这部分功能不支持。 5.4 不支持函数 methods 中的函数不支持在 template 内使用 methods 中的函数。 5.5 样式不支持 对象不支持 官方文档：Class 与 Style 绑定 中的 classObject 和 styleObject 语法。 123456789&lt;!-- mpvue 中这样来写 --&gt;&lt;!-- 为节约性能，我们将 Class 与 Style 的表达式通过 compiler 硬编码到 wxml 中，支持语法和转换效果如下： --&gt;&lt;p :class=\"&#123; active: isActive &#125;\"&gt;111&lt;/p&gt;&lt;p class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt;222&lt;/p&gt;&lt;p class=\"static\" :class=\"[activeClass, errorClass]\"&gt;333&lt;/p&gt;&lt;p class=\"static\" v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;444&lt;/p&gt;&lt;p class=\"static\" v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt;555&lt;/p&gt;&lt;p v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;666&lt;/p&gt;&lt;p v-bind:style=\"[&#123; color: activeColor, fontSize: fontSize + 'px' &#125;]\"&gt;777&lt;/p&gt; 123456789101112131415161718192021222324252627&lt;!-- 还可以用 computed 方法生成 class 或者 style 字符串，插入到页面中从性能考虑，建议不要过度依赖此。还是使用上面那样的办法就好了 --&gt;&lt;template&gt; &lt;!-- 支持 --&gt; &lt;div class=\"container\" :class=\"computedClassStr\"&gt;&lt;/div&gt; &lt;div class=\"container\" :class=\"&#123;active: isActive&#125;\"&gt;&lt;/div&gt; &lt;!-- 不支持 --&gt; &lt;div class=\"container\" :class=\"computedClassObject\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; isActive: true &#125; &#125;, computed: &#123; computedClassStr () &#123; return this.isActive ? 'active' : '' &#125;, computedClassObject () &#123; return &#123; active: this.isActive &#125; &#125; &#125; &#125;&lt;/script&gt; 5.6 暂不支持在组件上使用 Class 与 Style 绑定 ？？？？什么意思5.7 列表渲染 li123456789&lt;!-- 嵌套列表渲染，必须指定不同的索引！在这种嵌套循环的时候， index 和 itemIndex 这种索引是必须指定，且别名不能相同，正确的写法如下 --&gt;&lt;template&gt; &lt;ul v-for=\"(card, index) in list\"&gt; &lt;li v-for=\"(item, itemIndex) in card\"&gt; &#123;&#123;item.value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 5.8 事件处理器-几乎全支持","tags":[]},{"title":"JS事件：e.target与e.currentTarget区别","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[Javascript]-js-Target/","text":"一、前言JS 事件：target 与 currentTarget 区别。这里不仅是小程序中的，这个是 js 事件知识点。只是学习到小程序这里的时候需要用到这些绑定事件的传值。dataset 对象。 两者既有区别，也有联系。 二、event.target 与 event.currentTarget 的区别深入了解2.1 event.target 与 event.currentTarget 含义区别 target：一个触发事件的对象的引用,当事件处理程序在事件的冒泡或捕获阶段被调用时。(就是触发事件的元素，事件函数不一定写在它上面，有可能是捕获，冒泡去触发了别的元素上面绑定的事件函数) currentTarget：它指的是当事件遍历 DOM 时，标识事件的当前目标。它总是引用事件处理程序附加到的元素，而不是 event.target，它标识事件发生的元素。(也就是事件函数写在哪个元素就是那个元素) target 在事件流的 目标阶段，也就是执行阶段 currentTarget 在事件流的 捕获，目标及冒泡阶段 只有当事件流处在目标阶段的时候，两个的指向才是一样的。也就是说触发事件函数的元素刚好就是绑定事件函数的元素的时候二者是一样的。 而当处于捕获和冒泡阶段的时候， target 指向被单击的对象 currentTarget 指向当前事件活动的对象（一般为父级）。 12345678910111213141516171819202122232425&lt;div id=\"outer\" style=\"background:#099\"&gt; click outer &lt;p id=\"inner\" style=\"background:#9C0\"&gt;click inner&lt;/p&gt; &lt;br&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; function G(id)&#123; return document.getElementById(id); &#125; function addEvent(obj, ev, handler)&#123; if(window.attachEvent)&#123; obj.attachEvent(\"on\" + ev, handler); &#125;else if(window.addEventListener)&#123; obj.addEventListener(ev, handler, false); &#125; &#125; function test(e)&#123; alert(\"e.target.tagName : \" + e.target.tagName + \"\\n e.currentTarget.tagName : \" + e.currentTarget.tagName); &#125; var outer = G(\"outer\"); var inner = G(\"inner\"); //addEvent(inner, \"click\", test); addEvent(outer, \"click\", test); &lt;/script&gt; 上面的示例中，当在 outer 上点击时，e.target 与 e.currentTarget 是一样的，都是 div； 当在 inner 上点击时，e.target 是 p，而 e.currentTarget 则是 div。 深入理解e.target与e.currentTargethttps://juejin.im/post/59f16ffaf265da43085d4108","tags":[]},{"title":"CSS3 深入了解--[background 属性的全面使用]","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-css3-background背景属性详解/","text":"一、前言CSS3中包含几个新的背景属性，提供更大背景元素控制。 二、backgroundbackground是一个简写属性，可以在一个声明中设置所有的背景属性，可设置的属性如下：效果图参考网址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162background-color #指定要使用的背景颜色|1|（填充：内边距区域 padding 和边框区域 border，border 也可以自己再设置颜色） transparent # 透明，默认值!!!!!!!!!!! named_color #颜色名称，如 red； hex_number #十六进制颜色，如 #fff000； rgb() #rgb代码颜色，如 rgb(0,255,255)； rgba() # 同 hex_number，可是设置透明度，取值0-1，如rgba(0,255,255,.5)； hsl() # 设置色调（0-360）、饱和度（0.0-100.0%）和亮度（0.0-100.0%）； hsla() # 同 rgba() ，可以设置透明值，取值0-1； inherit # 规定应该从父元素继承 background-color 属性的设置。 currentColor # 规定为 color 属性的颜色值background-image #指定要使用的一个或多个背景图像|1| url('URL') # 图像的 URL #这个加不上上引号呢，是个问题，不加上引号也正确，但是有的浏览器比如说老ie不会兼容,所以还是加吧，不要偷懒。 none # 无图像背景会显示。这是默认 inherit # 指定背景图像应该从父元素继承background-position #指定背景图像的位置|1| left top #只写前面一个值，那么第二个值默认为 \"center\" left center #只写前面一个值，那么第二个值默认为 \"center\" left bottom #只写前面一个值，那么第二个值默认为 \"center\" right top #只写前面一个值，那么第二个值默认为 \"center\" right center #只写前面一个值，那么第二个值默认为 \"center\" right bottom #只写前面一个值，那么第二个值默认为 \"center\" center top #只写前面一个值，那么第二个值默认为 \"center\" center center #只写前面一个值，那么第二个值默认为 \"center\" center bottom #只写前面一个值，那么第二个值默认为 \"center\" x% y% # 第一个值是水平位置，第二个值是垂直。左上角是0％0％ 右下角是100％100％ 中间 50% 50%， #如果仅指定了一个值，其他值将是50％。 。默认值为：0％0％ xpos ypos #第一个值是水平位置，第二个值是垂直。左上角是0。单位可以是像素（0px0px）或任何其他 CSS单位。 # 如果仅指定了一个值，其他值将是50％。你可以混合使用％和positions inherit # 指定 background-position 属性设置应该从父元素继承 # CSS3 之后，这个属性的值有 4 个值。 right 50px bottom 50px # 第二 第四个为相对 偏移量background-size #指定背景图片的大小|3| px px # 设置背景图片高度和宽度。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为 auto(自动) % % # 将计算相对于背景定位区域的百分比。第一个值设置宽度，第二个值设置的高度。如果只给出一个值，第二个是设置为\"auto(自动)\" # 50% 50% 占据整个容器的 1/4 cover # 此时会保持图像的纵横比 并 将图像缩放成将完全覆盖背景定位区域的最小大小。（所有的区域都被覆盖了，背景图像有可能超出容器） contain #此时会保持图像的纵横比并将图像缩放成将适合背景定位区域的最大大小。（有的区域可能会没有覆到，背景图像始终被包含在容器内。）background-repeat #指定如何重复背景图像|1| repeat # 背景图像将向垂直和水平方向重复。这是默认值!!!!!!!!!!!!!! repeat-x # 只有水平位置会重复背景图像 repeat-y # 只有垂直位置会重复背景图像 no-repeat # background-image不会重复 inherit # 指定background-repea属性设置应该从父元素继承 round # 背景图像自动缩放直到适应且填充满整个容器。（CSS3） space # 背景图像以相同的间距平铺且填充满整个容器或某个方向。（CSS3） # round和space两个属性值在浏览器的支持和表现情况不太一样，不做探讨。background-origin #指定背景图像的定位区域|3| padding-box # 背景图像填充框的相对位置 (从 padding 区域[含 padding]开始显示背景图像) 默认值？？？？？？ border-box # 背景图像边界框的相对位置 (从 border 区域[含 border]开始显示背景图像) content-box # 背景图像的相对位置的内容框(从 content 区域开始显示背景图像) # js 写法 object.style.backgroundOrigin=\"content-box\"\"background-clip #指定背景图像的绘画区域|3| border-box # 从border区域（不含border）开始向外裁剪背景。默认值!!!!!!!!!!!!!!!!!!!!!!! padding-box # 从padding区域（不含padding）开始向外裁剪背景。 content-box # 从content区域开始向外裁剪背景。 text # 从前景内容的形状（比如文字）作为裁剪区域向外裁剪，如此即可实现使用背景作为填充色之类的遮罩效果。background-attachment #设置背景图像是否固定或者随着页面的其余部分滚动。|1| scroll # 背景图片随页面的其余部分滚动。这是默认值!!!!!!!!!!!!!!!!!!!!!!!! # 背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起滚动 fixed # 背景图像相对于窗体固定 local # 背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像也会跟着滚动，因为背景图像总是要跟着内容。（CSS3） inherit # 指定background-attachment的设置应该从父元素继承 语法:background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; 注意点： 以上的属性顺序是没有要求的。 position/bg-size 同时设置的话，要这样写一个斜杠，如果单位相同，如果只设置一个值，表示的是 position 设置，没有 size bg-origin bg-clip 同时设置，这个不需要斜杠 ，他们的值一样的，如果设置一个值，表示的是 origin 设置，没有 clip 但是大致习惯上说应该有个顺序。就是上面的语法的顺序，因为大家普遍是这样的，要方便大家的习惯。 background: red url(‘#’) left 10px top 10px/cover no-repeat border-box border-box fixed;!!!!!!!!!!!!!!!!!!!!!!!!!!! 以上属性是可选的，不必要全写 background:#FF0000 URL(‘smiley.gif’); 是允许的。 背景属性可以设置多组值123background: url(\"image.png\") 0% 0%/60px 60px no-repeat padding-box, url(\"image.png\") 40px 10px/110px 110px no-repeat content-box, #58a url(\"image.png\") 140px 40px/200px 100px no-repeat content-box; 123/* 可以设置多个背景，然后固定模式也是一一对应的 */background-image: url(\"https://mdn.mozillademos.org/files/12057/starsolid.gif\"),url(\"https://mdn.mozillademos.org/files/12059/startransparent.gif\");background-attachment: fixed, scroll; 注意点： 有背景颜色的组 只有有一个，并且只能放在最后。 如设置的多组属性背景图像之间存在重叠, 则前面的背景图像会覆盖在后面的背景图像上。 三 background-blend-mode 属性定义了背景层的混合模式（图片与颜色）。[这个属性不在简写属性background里面] 值 描述 normal 默认值。设置正常的混合模式。 multiply 正片叠底模式。 screen 滤色模式。 overlay 叠加模式。 darken 变暗模式。 lighten 变亮模式。 color-dodge 颜色减淡模式。 saturation 饱和度模式。 color 颜色模式。 luminosity 亮度模式。","tags":[]},{"title":"WeChat 微信小程序--wepy-redux 状态管理器","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-状态管理器==-vuex && redux && wepy-redux/","text":"一、前言wepy-redux 状态管理器，类似于 vue 中的 vuex 状态管理器。 redux 中文文档Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 (如果你需要一个 WordPress 框架，请查看 Redux Framework。)可以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。不仅于此，它还提供 超爽的开发体验，比如有一个时间旅行调试器可以编辑后实时预览。 Redux 除了和 React 一起用外（react-redux），还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。本章就是我们要学习的与 wepy 结合使用。 wepy-reduxwepy-redux gitHub 仓库 wepy-redux 只能在 wepy 框架使用。（mpvue 使用的是 vue 的 vuex） 二、 wepy-redux 的安装12npm install wepy-redux --save # 安装 wepy-redux# 在用 wepy-cli 创建项目的时候就会选择安装的，不需要额外的安装 2.1 什么时候使用 redux跟 vuex 一样，不是所有的项目都使用状态管理器的。 在大型应用设计上我们用 redux 来管理那些多个页面需要使用到的数据。也就是说小型设计就没有必要用了， app.wpy 就可以解决数据公用问题了。也不是什么数据都放在 redux 来管理， redux 管理的数据越少才越好。 2.2 redux 作用多个组件共享状态时，单向数据流的简洁性很容易被破坏： 多个视图依赖于同一状态。 来自不同视图的行为需要变更同一状态。 对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想。 三、 wepy-redux 的使用123456789101112131415161718192021222324252627# 这里是 wepy-cli 创建的目录中，sore 与 .wpy 文件部分| ├── components # （生成） WePY 组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy # 可复用的 WePY 组件 a| | └── com_b.wpy # 可复用的 WePY 组件 b| || ├── pages # （生成）WePY 页面目录（属于完整页面）| | ├── index.wpy # index 页面（build 后，在 dist 目录下的 pages 目录| | | #生成 index.js、index.json、index.wxml、index.wxss 文件）| | └── other.wpy # other 页面（build 后，在 dist 目录下的 pages 目录）| | # 生成 other.js、other.json、other.wxml和other.wxss文件| || ├── store # （生成） Redux 状态管理器，类似 vue 的 vuex。对于构建大型应用，对里面共享数据、状态的管理非常方便| | ├── actions/ #（生成）| | | └──counter.js #（生成）| | | └──index.js #（生成）| | || | ├── reducers/ # （生成）reducers 文件件存放我们的纯函数，用来更改我们的状态| | | └──counter.js # （生成）定义函数| | | └──index.js # （生成）暴露函数| | || | ├── types/ # （生成）常量定义：用于定义我们要触发的 action 的名称| | | └──counter.js # （生成）定义常量| | | └──index.js # （生成）暴露常量| | || | └──index.js # （生成）入口文件，主要是 初始化 Redux，其中 promiseMiddleware 是一个中间件，方便后面 action 做异步处理| || └──── app.wpy 3.1 store/ =&gt; 编辑 store3.1.1 types 文件夹：用于定义我们要触发的 action 的名称types 用于定义我们要触发的 action 的名称，也就是表示 action 的名称，这里定义了 counter 和 list 两个 types ，内容分别如下： 12345//① store/types/counter.js//定义 action 的名称-类型 typeexport const INCREMENT = 'INCREMENT'export const DECREMENT = 'DECREMENT'export const ASYNC_INCREMENT = 'ASYNC_INCREMENT' 123//② store/types/list.jsexport const ADD = 'ADD'export const REMOVE = 'REMOVE' 123//store/types/index.js 通过 types 文件夹的入口文件 index.js 将他们暴露出去export * from './counter'export * from './list' 3.1.2 actions 文件夹：用于触发的 action1234567891011//① store/actions/counter.jsimport &#123; ASYNC_INCREMENT &#125; from '../types/counter'import &#123; createAction &#125; from 'redux-actions'export const asyncInc = createAction(ASYNC_INCREMENT, () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1) &#125;, 1000) &#125;)&#125;) 12//store/actions/index.js 通过 actions 文件夹的入口文件 index.js 将他们暴露出去export * from './counter' 3.1.3 reducers 文件夹：123456789101112131415161718192021222324252627//① store/reducers/counter.jsimport &#123; handleActions &#125; from 'redux-actions' //引入了 handleActions 方法用来创建 actionsimport &#123; INCREMENT, DECREMENT, ASYNC_INCREMENT &#125; from '../types/counter'export default handleActions(&#123; [INCREMENT] (state) &#123; return &#123; ...state, num: state.num + 1 &#125; &#125;, [DECREMENT] (state) &#123; return &#123; ...state, num: state.num - 1 &#125; &#125;, [ASYNC_INCREMENT] (state, action) &#123; return &#123; ...state, asyncNum: state.asyncNum + action.payload //payload 是传来的参数 action 带来的，调用的时候要给这属性 &#125; &#125;&#125;, &#123; num: 0, asyncNum: 0&#125;) 12345678910111213141516171819202122232425//② store/reducers/list.jsimport &#123; handleActions &#125; from 'redux-actions'import &#123; ADD , REMOVE &#125; from '../types/list'const defaultState = [ &#123; title : '吃饭' , text : '今天我要吃火锅' &#125;, &#123; title : '工作' , text : '今天我要学习Redux' &#125;]export default handleActions(&#123; [ADD]( state , action )&#123; state.push(action.payload) return [...state] &#125;, [REMOVE]( state , action )&#123; state.splice( action.payload , 1 ); return [ ...state ] &#125;&#125;,defaultState) 123456789//store/reducers/index.js 通过 actions 文件夹的入口文件 index.js 将他们暴露出去import &#123; combineReducers &#125; from 'redux'import counter from './counter' // 导入 counterimport list from './list' // 导入 listexport default combineReducers(&#123; counter, list&#125;) 3.2 store/index.js =&gt; 初始化 store12345678910111213// store/index.jsimport &#123; createStore, applyMiddleware &#125; from 'redux' // 导入 reduximport promiseMiddleware from 'redux-promise'import rootReducer from './reducers'export default function configStore () &#123; const store = createStore(rootReducer, applyMiddleware(promiseMiddleware)) return store&#125;//使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。 Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的// promiseMiddleware 是一个中间件，方便后面 action 做异步处理~ reducers 是一个纯函数，// 用于接受 Action 和当前 State 作为参数，返回一个新的 State 3.3 app.wpy =&gt; 获取 sotre1234567891011121314// app.wpyimport wepy from 'wepy'import 'wepy-async-function'import &#123; setStore &#125; from 'wepy-redux' // 导入 wepy-redux 赋予对象 setStoreimport configStore from './store' // 从 store 仓库 导入 wepy-redux 状态管理器 对象 命名 为configStoreconst store = configStore() // 调用 状态管理器对象 configStore 的函数 configStore() 返回值赋值给 storesetStore(store) // set!! 设置初始化 storeexport default class extends wepy.app &#123; config = &#123;&#125; globalData = &#123;&#125;&#125; 3.4 pages.wpy &amp;&amp; common.wpy =&gt; 使用 sotre3.4.1 store 的方法Store 有以下职责： 维持应用的 state； 记住在 store 中 state 是树结构的 对象 提供 getState() 方法获取 state; wepy.$store.getState().xxxxName 提供 dispatch(action) 方法更新 state； wepy.$store.dispatch({ type : &#39;REMOVE&#39; , payload : index }) 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!-- index.wpy --&gt;&lt;template lang=\"wxml\"&gt; &lt;view class=\"container\"&gt; &lt;text&gt;同步&#123;&#123; num &#125;&#125;&lt;/text&gt; &lt;text&gt;异步&#123;&#123; asyncNum &#125;&#125;&lt;/text&gt; &lt;button @tap=\"increment\" type=\"primary\"&gt;加一&lt;/button&gt; &lt;button @tap=\"decrement\" type=\"primary\"&gt;减一&lt;/button&gt; &lt;button @tap=\"asyncIncrement\" type=\"primary\"&gt;异步加一&lt;/button&gt; &lt;button @tap=\"addList\"&gt;添加&lt;/button&gt; &lt;view class=\"box\"&gt; &lt;view class=\"item\" wx:for-items=\"&#123;&#123; todoList &#125;&#125;\" wx:key=\"index\"&gt; &lt;view class=\"title\"&gt;&#123;&#123; item.title &#125;&#125;&lt;/view&gt; &lt;view class=\"content\"&gt;&#123;&#123; item.text &#125;&#125;&lt;/view&gt; &lt;button type=\"primary\" class=\"delete\" @tap=\"delete(&#123;&#123;index&#125;&#125;)\"&gt;删除&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import wepy from 'wepy'import &#123; connect &#125; from 'wepy-redux' // 导入链接辅助器 connectimport &#123; INCREMENT , DECREMENT &#125; from '../store/types/counter' // 导入 types 下？？？import &#123; asyncInc &#125; from '../store/actions' // 导入 actions 下？？？？ @connect(&#123; stateNum (state) &#123; // 创建一个数据 stateNum 它是获取 store 中的 state.counter.num return state.counter.num &#125;,/* num (state) &#123; // 创建一个数据 num 它是获取 store 中的 state.counter.num （与上面的是一样的啦） return state.counter.num // 所以名字是自己去的，用来在 template 中 &#123;&#123;num&#125;&#125; 做数据绑定使用的。 &#125;, */ asyncNum (state) &#123; // 创建一个数据 asyncNum 它是获取 store 中的 state.counter.asyncNum return state.counter.asyncNum &#125;, sumNum (state) &#123; // 创建一个数据 sumNum 它是获取 store 中的 state.counter.num return state.counter.num + state.counter.asyncNum//与 state.counter.asyncNum 只和 &#125; &#125;, &#123; incNum: INCREMENT, //？？？？ decNum: DECREMENT,//？？？？ asyncInc //？？？？？ &#125;) //connect() 函数,它接收一个配置对象config， // 当 num 被 wepy.$store.dispatch() // 然后，stateNum 会自动执行，返回一个对象，返回的对象属性会自动注入到组件的 data 中，从而更新视图。 export default class Index extends wepy.page &#123; components = &#123;&#125; computed = &#123; todoList()&#123; return wepy.$store.getState().list; &#125; &#125; methods = &#123; delete(index)&#123; wepy.$store.dispatch(&#123; type : 'REMOVE' , payload : index &#125;) &#125;, addList()&#123; wepy.$store.dispatch(&#123; type : 'ADD' , payload : &#123; title : '学习' , text : '好好学习' &#125;&#125;) &#125; &#125; onLoad () &#123; console.log(wepy.$store.getState()) &#125; &#125;&lt;/script&gt; &lt;style lang=\"less\"&gt; text&#123; display: block; text-align: center; margin: 10px auto; &#125; button&#123; width: 90%; display: block; margin: 10px auto; &#125; .item&#123; display: flex; align-items: center; text-align: center; padding: 0 15px; .title&#123; font-size: 14px; line-height: 20px; margin: 10px auto; &#125; .content&#123; font-size: 15px; flex: 1; &#125; .delete&#123; width: 70px; height: 40px; line-height: 40px; &#125; &#125; &lt;/style&gt;","tags":[]},{"title":"WeChat 微信小程序【11】--[wxml 与 html 的区别使用]","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ -【小程序】wxml 与 html 的区别使用/","text":"一、前言wxml 与html 都是页面结构，但是 wxml 组件与 html 的区别还是很大的。 二、区别2.1 空格输入&amp;nbsp;html 中是需要使用&amp;nbsp;,在小程序 wxml 中直接使用&amp;nbsp;会出错。微信小程序中在 text 中写空格。&lt;text decode=&quot;nbsp&quot;&gt;㊣&amp;nbsp;&amp;nbsp;&lt;/text&gt; 使用\\t在 view 中也可以使用\\t，但是不管用多少个\\t只会起到一个\\t的作用。","tags":[]},{"title":"MINA 框架 路由","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-MINA-原生框架 路由/","text":"一、前言官网路由文档地址 二、页面下的 route12345Page(&#123; onShow() &#123; console.log(this.route) &#125;&#125;)","tags":[]},{"title":"本地缓存之 同步缓存&&异步缓存","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-wx.huancun/","text":"一、前言Synchronize 翻译：同步。因此带有 sync 是同步的意思。Asynchronize 翻译：不同步，异步。因此带有 async 是异步的意思。 以 Sync（同步，同时）结尾的都是都是同步缓存，二者的区别是，异步不会阻塞当前任务，同步缓存直到同步方法处理完才能继续往下执行。 二、小程序：数据缓存官方网址 ①wx.setStorage：异步保存 key 的数据 ②wx.setStorageSync：同步保存 key 的数据 ③wx.getStorage：异步获取 ④wx.getStorageSync：同步获取 ⑥wx.getStorageInfo：异步获取当前 storage 的相关信息 ⑦wx.getStorageInfoSync：同步获取当前 storage 的相关信： ⑧wx.removeStorage：异步移除指定 key ⑨wx.removeStorageSync：同步移除指定 key ⑩wx.clearStorage ⑪wx.clearStorageSync 2.1 同步与异步的选择？举例说明一下，比如要请求用户信息的时候，需要从缓存中获取 iduser 这个变量，那只有获取到这个变量才能进行下一步。那就应该使用 wx.getStorageSync。这样能确保一定能获取到这个变量。这个时候就不能使用异步，我还没有获取到变量怎么进行下一步的工作。","tags":[]},{"title":"iview-weapp  小程序 ui 组件库","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-MINA 框架-iview-weapp 组件库/","text":"一、前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;github网址iview-weapp官网地址效果图：扫描官网右侧提供的二维码即可查看。这个框架是 vue.js 的组件库，iview-ui 组件库的作者所出。但是现在这个组件库的 bug真是的不要太多！！！ iview-weapp 可以用在 mpvue.js 框架中，也可以在 wepy 框架中使用。 二、","tags":[]},{"title":"wepy-cli 框架 入门学习","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】-wepy 框架/","text":"一、wepy-cli 类 vue-cli 脚手架：组件化开发框架 wepyWePY 是一款让小程序支持组件化开发的框架，通过预编译的手段让开发者可以选择自己喜欢的开发风格去开发小程序。框架的细节优化，Promise，Async Functions 的引入都是为了能让开发小程序项目变得更加简单，高效。特性： 类 Vue 开发风格支持自定义组件开发支持引入 NPM 包支持 Promise支持 ES2015+ 特性，如 Async Functions支持多种编译器，Less/Sass/Styus、Babel/Typescript、Pug支持多种插件处理，文件压缩，图片压缩，内容替换等支持 Sourcemap，ESLint 等小程序细节优化，如请求列队，事件优化等 Github地址:官网首页官网使用文档 二、wepy 与 vue 的异同wepy 和 vue 主要区别1.二者均支持 props、data、computed、components、methods、watch（wepy 中是 watcher）， 但 wepy 中的 methods 仅可用于页面事件绑定，其他自定义方法都要放在外层，而 vue 中所有方法均放在 methods 下 2.wepy 中 props 传递需要加上 .sync 修饰符（类似VUE1.x）才能实现 props 动态更新，并且父组件再 变更传递给子组件 props 后要执行this.$apply() 方法才能更新 3.wepy支持数据双向绑定，子组件在定义props时加上twoway:true属性值即可实现子组件修改父组 件数据 4.VUE2.x推荐使用eventBus方式进行组件通信，而在wepy中是通过broadcast，broadcast，emit，$invoke 三种方法实现通信 二、wepy-cli 的安装 与使用2.1 全局安装 wepy-cli1npm install wepy-cli -g 2.2 使用 wepy-cli 初始化项目，类似 vue-cli1234567wepy init standard myproject (1.7.0之后的版本)初始化项目 ，还可以使用 wepy list 查看项目模板cd myproject #切换至项目目录npm install #安装依赖wepy build --watch #开启实时编译，微信开发者工具 打开 dist 文件夹，注意把 设置改为 false，如下图# 两种办法， npm run dev 是简写，是 package.json 中设置的(好像没有设置好，用 npm run dev 没有出来哦)# 问题：如果是 yarn 怎么做？ 12#完成项目之后打包npm run build #打包项目 project.config.json 项目配置文件，与MINA框架的项目配置文件一样的，只是几个值一定要设置为 false，其实在开发者工具中右边就是项目配置项，一个是可视化的，一个是文件的xnia形式，可视化的是这台电脑的开发者工具的设置。文件是这个项目的设置，走到哪里，这个小程序项目的设置都是不会变的。 2.2.1 注意事项使用微信开发者工具新建项目，本地开发选择dist目录。 微信开发者工具–&gt;项目–&gt;关闭ES6转ES5。重要：漏掉此项会运行报错。 微信开发者工具–&gt;项目–&gt;关闭上传代码时样式自动补全 重要：某些情况下漏掉此项会也会运行报错。 微信开发者工具–&gt;项目–&gt;关闭代码压缩上传 重要：若开启，会导致真机computed, props.sync 等等属性失效。 本地项目根目录运行wepy build –watch，开启实时编译。 2.3 安装过程中的问题2.3.1 安装过程中版本支持问题解决12345678910111213λ cnpm install√ Installed 23 packages√ Linked 286 latest versions√ Run 0 scripts`deprecate eslint@3.19.0 › file-entry-cache@2.0.0 › flat-cache@1.3.4 › circular-json@^0.3.1 CircularJSON is in maintenance only, flatted is its successor.` #deprecate 弃用 flatted 分层`deprecate wepy-compiler-less@1.3.12 › less@2.7.3 › request@2.81.0 › hawk@3.1.3 › cryptiles@2.x.x This version is no longer maintained. Please upgrade to the latest version.` # 此版本不再维护，请更新最近的版本。`deprecate wepy-compiler-less@1.3.12 › less@2.7.3 › request@2.81.0 › hawk@3.1.3 › boom@2.x.x This version is no longer maintained. Please upgrade to the latest version.``deprecate wepy-compiler-less@1.3.12 › less@2.7.3 › request@2.81.0 › hawk@3.1.3 › hoek@2.x.x This version is no longer maintained. Please upgrade to the latest version.`Recently updated (since 2018-11-08): 2 packages (detail see file F:\\qianduan_dir\\00program\\wechat-wepy\\suduku\\node_modules\\.recently_updates.tt) Today: → eslint@3.19.0 › file-entry-cache@2.0.0 › flat-cache@^1.2.1(1.3.4) (04:42:27)√ All packages installed (322 packages installed from npm registry, used 17s(network 16s), speed 201.4kB/s, json 309(3.15MB), tarball 85.51kB) 解决：npm install wepy-compiler-less@2.0.0 –save 2.3.2 微信开发者工具打开 dist 文件夹是 后台报错1234567891011VM6906:1 thirdScriptError sdk uncaught third Error `Cannot read property 'Promise' of undefined` `TypeError: Cannot read property 'Promise' of undefined` #Promise 没有定义 at http://127.0.0.1:61988/appservice/npm/wepy-async-function/index.js:14:7 at require (http://127.0.0.1:61988/appservice/__dev__/WAService.js:23:12444) at http://127.0.0.1:61988/appservice/__dev__/WAService.js:23:12051 at http://127.0.0.1:61988/appservice/app.js:23:1 at require (http://127.0.0.1:61988/appservice/__dev__/WAService.js:23:12444) at &lt;anonymous&gt;:1:1 at HTMLScriptElement.scriptLoaded (http://127.0.0.1:61988/appservice/appservice?t=15374 这是因为，project.config.json 项目配置文件，与 MINA 框架的项目配置文件一样的，只是几个值一定要设置为 false 。如下是 这个文件的内容 12345678910111213141516// project.config.json 文件 内容//wepy 框架以为版本不同，生成的文件目录可能不同，//1.7.0 版本之后的版本会生成的这个文件，&#123; \"description\": \"project description\", \"setting\": &#123; \"urlCheck\": true, \"es6\": false, \"postcss\": false, \"minified\": false &#125;, \"compileType\": \"miniprogram\", \"appid\": \"touristappid\", \"projectname\": \"Project name\", \"miniprogramRoot\": \"./dist\"&#125; project.config.json 文件中我们已经用了 false 为什么还会报错呢，是因为在开发者工具中农我们没有设置为 false 。build 之后，用开发者工具打开 dist 文件内容，build 生成的 project.config.json 可能不正确，里面设置的值为 true 了需要注意修正，否则会报错，错误如下。除了在文件修正之外，在开发者工具可视化项目设置中也可以直接把 ES6 转 ES5。 三、WePY demo 项目的目录结构（含自定义）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162├── dist/ # （生成）小程序运行代码目录（该目录由 WePY 的 build 指令自动编译生成，请不要直接修改该目录下的文件）├── node_modules/ # （生成） 安装的依赖包├── src/ # （生成）代码编写的目录（该目录为使用 WePY 后的开发目录）| ├── assets/ # （创建） 自定义文件夹| | ├── images # （创建）自定义存放图片文件夹| | ├── svgs # （创建）自定义存放图片文件夹| | ├──| | └── styles # （创建/引用文件）引用的 css 或者 less 等文件| || ├── components # （生成） WePY 组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy # 可复用的 WePY 组件 a| | └── com_b.wpy # 可复用的 WePY 组件 b| || ├── mixins # （生成） Mixin 基类，用于复用不同组件中的相同功能。| | └── test.js| || ├──interceptor # （创建）拦截器:可以使用 WePY 提供的全局拦截器对原生 API 的请求进行拦截。| | └── index.js| || ├── pages # （生成）WePY 页面目录（属于完整页面）| | ├── index.wpy # index 页面（build 后，在 dist 目录下的 pages 目录| | | #生成 index.js、index.json、index.wxml、index.wxss 文件）| | └── other.wpy # other 页面（build 后，在 dist 目录下的 pages 目录）| | # 生成 other.js、other.json、other.wxml和other.wxss文件| || ├── store # （生成） Redux 状态管理器，类似 vue 的 vuex。对于构建大型应用，对里面共享数据、状态的管理非常方便| | ├── actions #（生成）| | | └──counter.js #（生成）| | | └──index.js #（生成）| | || | ├── reducers # （生成）reducers 文件件存放我们的纯函数，用来更改我们的状态| | | └──counter.js # （生成）定义函数| | | └──index.js # （生成）暴露函数| | || | ├── types # （生成）常量定义：用于定义我们要触发的 action 的名称| | | └──counter.js # （生成）定义常量| | | └──index.js # （生成）暴露常量| | || | └──index.js # （生成）入口文件，主要是 初始化 Redux，其中 promiseMiddleware 是一个中间件，方便后面 action 做异步处理| || ├──utils # （创建）自定义文件夹（工具文件夹）| | ├──util.js| | └──xxxx.js| ├──app.wpy # （生成）小程序配置项（全局数据、样式、声明钩子等；build 后。| | # 在 dist 目录下生成 app.js、app.json 和 app.wxss 文件）| └── index.template.html # 为模块配置文件：其中通过 wepy.app 创建入口文件， wepy.page 创建页面文件| # wepy.component 创建组件文件 （.wpy 就是模块文件）├──.editorconfig # 编辑器配置文件├──.eslintignore # 格式化 ESLint 忽略的文件├──.eslintrc.js # 格式化 ESLint 的格式样式├──.gitignore # 上传 github 忽略的文件├──.prettierrc # js 代码格式要求├──.wepycache # wepy 缓存├──.wepyignore # 是指有些文件不希望通过 wepy 编译，因此这个文件属于项目的一部分，不能在 git 中排除├── package.json # 项目的 package 配置,项目名称，版本，依赖包，类似 vue-cli 的 package.json├── project.config.json # 项目配置文件，与 MINA 框架的项目配置文件一样的，只是几个值一定要设置为 false└── wepy.config.js # 配置文件-----.npmignore-----LICENSE-----package-lock.json-----README.md-----yarn.lock 简单来说就是 assets 存放一些引入的 CSS JS 文件，以及一些图片（如果有需要的话创建这个文件夹） ①index.template.html: 页面的入口文件 ②wepy.config.js: webpack配置文件 ③project.config.json: 小程序项目配置文件 ④app.wpy: 小程序入口文件 ⑤pages: 存放页面（组件） ⑥components: 存放公共（组件） ⑦sotre: redux(如果你创建项目时使用了redux的话) ⑧mixins: 混合组件 ⑨interceptor：拦截器 ⑩utils：工具包 3.1 index.template.html: 页面的入口文件3.2 wepy.config.js: webpack配置文件3.3 project.config.json: 小程序项目配置文件3.4 app.wpy: 小程序入口文件：小程序入口 app.wpy 对应原生 MINA 框架的 app.json，app.js ，app.wxml，app.wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;style lang=\"less\"&gt;.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; box-sizing: border-box;&#125;&lt;/style&gt;&lt;script&gt;import wepy from 'wepy'import 'wepy-async-function'import &#123; setStore &#125; from 'wepy-redux'import configStore from './store'const store = configStore()setStore(store)//入口文件 app.wpy 中所声明的小程序实例继承自wepy.app类，export default class extends wepy.app &#123; //config 属性对应原生的 app.json 文件 // build 编译时会根据 config 属性自动生成 app.json 文件，如果需要修改 config 中的内容，请使用微信提供的相关 API。 config = &#123; //① 页面路径列表 pages: [ 'pages/index' ], //② 全局的默认窗口表现 window: &#123; navigationBarBackgroundColor: '#fff',//导航栏背景颜色，如 #000000 navigationBarTextStyle: 'black'//导航栏标题颜色，仅支持 black / white navigationBarTitleText: 'WeChat',//导航栏标题文字内容 navigationStyle:'default',//导航栏样式，仅支持以下值：default 默认样式 ,custom 自定义导航栏，只保留右上角胶囊按钮 backgroundColor:'#ffffff'//窗口的背景色 &#125;, // ③ 页面底部栏配置 tabBar: &#123; color: '#AEADAD',//tab 上的文字默认颜色 selectedColor: '#049BFF',//tab 上的文字选中时的颜色 backgroundColor: '#fff',//tab 的背景色 borderStyle: 'black',//tabbar上边框的颜色， 仅支持 black / white position:'bottom',//tabBar的位置，仅支持 bottom / top list: [//最少2个、最多5个 tab &#123; pagePath: 'pages/index', text: '游戏', iconPath: '', selectedIconPath: '' &#125;, &#123; pagePath: 'pages/ranking', text: '排名', iconPath: '', selectedIconPath: '' &#125; ] &#125; &#125; globalData = &#123; userInfo: null &#125; constructor () &#123; super() this.use('requestfix') &#125; onLaunch() &#123; this.testAsync() &#125; sleep (s) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('promise resolved') &#125;, s * 1000) &#125;) &#125; async testAsync () &#123; const data = await this.sleep(3) console.log(data) &#125; getUserInfo(cb) &#123; const that = this if (this.globalData.userInfo) &#123; return this.globalData.userInfo &#125; wepy.getUserInfo(&#123; success (res) &#123; that.globalData.userInfo = res.userInfo cb &amp;&amp; cb(res.userInfo) &#125; &#125;) &#125;&#125;&lt;/script&gt;&lt;/script&gt; 3.5 pages: 存放页面（组件） 小程序入口 pages.wpy 对应原生 MINA 框架的 pages.json，pages.js ，pages.wxml，pages.wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;style lang=\"less\"&gt; /* less */&lt;/style&gt;&lt;template&gt; &lt;view class=\"container\"&gt; &lt;!-- html --&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import wepy from 'wepy' import &#123; connect &#125; from 'wepy-redux' import Panel from '@/components/panel' // alias example import Counter from 'counter' // alias example import List from '../components/list' // aliasFields example import moduleA from 'module-a' // aliasFields ignore module example import Group from '../components/group' import Toast from 'wepy-com-toast' import testMixin from '../mixins/test' console.log('moduleA ignored: ', moduleA) // =&gt; moduleA ignored: &#123;&#125; @connect(&#123; num (state) &#123; return state.counter.num &#125;, asyncNum (state) &#123; return state.counter.asyncNum &#125;, sumNum (state) &#123; return state.counter.num + state.counter.asyncNum &#125; &#125;) export default class Index extends wepy.page &#123; //页面配置对象，对应于原生的 page.json 文件，类似于 app.wpy 中的 config, 页面设置支持支 window 设置 config = &#123; navigationBarBackgroundColor: '#fff', //导航栏背景颜色，如 #000000 navigationBarTitleText: 'WeChat',//导航栏标题文字内容 navigationBarTextStyle: 'black',//导航栏标题颜色，仅支持 black / white backgroundColor:'#ffffff',//窗口的背景色 backgroundTextStyle: 'light',//下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh:false,//是否全局开启下拉刷新。详见 Page.onPullDownRefresh onReachBottomDistance:50,//页面上拉触底事件触发时距页面底部距离，单位为px。详见 Page.onReachBottom disableScroll:false//设置为 true 则页面整体不能上下滚动； //disableScroll 这项 只在页面配置中有效，无法在 app.json 中设置该项!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#125; // 页面组件列表对象，声明页面所引入的组件列表 components = &#123; panel: Panel, counter1: Counter, counter2: Counter,//这个与上面引入的是一样的组件，但是用到不一样的地方显示？问题是一个变了另外一个会不会变啊？ list: List, group: Group, toast: Toast &#125; mixins = [testMixin] // 页面渲染数据对象，存放可用于页面模板绑定的渲染数据 data = &#123; mynum: 20, userInfo: &#123; nickName: '加载中...' &#125;, normalTitle: '原始标题', setTimeoutTitle: '标题三秒后会被修改', count: 0, netrst: '', groupList: [...`已略`...] &#125; computed = &#123; now () &#123; return +new Date() &#125; &#125; //wxml 事件处理函数对象，存放响应 wxml 中所捕获到的事件的函数，如 bindtap 、 bindchange methods = &#123; plus () &#123; this.mynum++ &#125;, toast () &#123; let promise = this.$invoke('toast', 'show', &#123; title: '自定义标题', img: 'https://raw.githubusercontent.com/kiinlam/wetoast/master/images/star.png' &#125;) promise.then((d) =&gt; &#123; console.log('toast done') &#125;) &#125;, tap () &#123; console.log('do noting from ' + this.$name) &#125;, communicate () &#123; console.log(this.$name + ' tap') this.$invoke('counter2', 'minus', 45, 6) this.$invoke('counter1', 'plus', 45, 6) this.$broadcast('index-broadcast', 1, 3, 4) &#125;, request () &#123; let self = this let i = 10 let map = ['MA==', 'MQo=', 'Mg==', 'Mw==', 'NA==', 'NQ==', 'Ng==', 'Nw==', 'OA==', 'OQ=='] while (i--) &#123; wepy.request(&#123; url: 'https://www.madcoder.cn/tests/sleep.php?time=1&amp;t=css&amp;c=' + map[i] + '&amp;i=' + i, success: function (d) &#123; self.netrst += d.data + '.' self.$apply() // wepy 中 props 传递需要加上 .sync 修饰符（类似VUE1.x）才能实现 props 动态更新， // 并且父组件再 变更传递给子组件 props 后要执行this.$apply() 方法才能更新 &#125; &#125;) &#125; &#125;, counterEmit (...args) &#123; let $event = args[args.length - 1] console.log(`$&#123;this.$name&#125; receive $&#123;$event.name&#125; from $&#123;$event.source.$name&#125;`) &#125; &#125; // WePY 组件事件处理函数对象，存放响应组件之间通过 $broadcast、$emit、$invoke 所传递的事件的函数 events = &#123; 'index-emit': (...args) =&gt; &#123; let $event = args[args.length - 1] console.log(`$&#123;this.$name&#125; receive $&#123;$event.name&#125; from $&#123;$event.source.$name&#125;`) &#125; &#125; onLoad() &#123; let self = this this.$parent.getUserInfo(function (userInfo) &#123; if (userInfo) &#123; self.userInfo = userInfo &#125; self.normalTitle = '标题已被修改' self.setTimeoutTitle = '标题三秒后会被修改' setTimeout(() =&gt; &#123; self.setTimeoutTitle = '到三秒了' self.$apply() &#125;, 3000) self.$apply() &#125;) &#125; &#125;&lt;/script&gt; 3.6 components: 存放公共（组件） 小程序入口 common.wpy 对应原生 MINA 框架的 pages.js ，pages.wxml，pages.wxss123├── components # （生成） WePY 组件目录（组件不属于完整页面，仅供完整页面或其他组件引用）| | ├── com_a.wpy # 可复用的 WePY 组件 a| | └── com_b.wpy # 可复用的 WePY 组件 b 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;style lang=\"less\"&gt; .counter &#123; text-align: left; font-size: 12px; &#125; .count &#123; font-size: 18px; font-weight: bold; &amp;.red &#123; color: red; &#125; &amp;.green &#123; color: green; &#125; &#125;&lt;/style&gt;&lt;template&gt; &lt;view class=\"counter &#123;&#123;style&#125;&#125;\"&gt; &lt;button @tap=\"plus\" size=\"mini\"&gt; + &lt;/button&gt; &lt;button @tap=\"minus\" size=\"mini\"&gt; - &lt;/button&gt; &lt;button @tap=\"incNum\" size=\"mini\"&gt; INCREMENT &lt;/button&gt; &lt;button @tap=\"decNum\" size=\"mini\"&gt; DECREMENT &lt;/button&gt; &lt;button @tap=\"asyncInc\" size=\"mini\"&gt; ASYNC INCREMENT &lt;/button&gt; &lt;text class=\"count\"&gt; &#123;&#123;num&#125;&#125; &lt;/text&gt; &lt;text class=\"count\"&gt; &#123;&#123;stateNum&#125;&#125; &lt;/text&gt; &lt;text class=\"count\"&gt; &#123;&#123;asyncNum&#125;&#125; &lt;/text&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;// 组件文件 com.wpy 中所声明的组件实例继承自 wepy.component 类// 不需要 config 配置以及页面特有的一些生命周期函数// 属性与页面属性大致相同。 import wepy from 'wepy' import &#123; connect &#125; from 'wepy-redux' import &#123; INCREMENT, DECREMENT &#125; from '../store/types/counter' import &#123; asyncInc &#125; from '../store/actions' @connect(&#123; stateNum (state) &#123; return state.counter.num &#125;, asyncNum (state) &#123; return state.counter.asyncNum &#125; &#125;, &#123; incNum: INCREMENT, decNum: DECREMENT, asyncInc &#125;) export default class Counter extends wepy.component &#123; props = &#123; num: &#123; type: [Number, String], coerce: function (v) &#123; return +v &#125;, default: 50 &#125; &#125; data = &#123; &#125; events = &#123; 'index-broadcast': (...args) =&gt; &#123; let $event = args[args.length - 1] console.log(`$&#123;this.$name&#125; receive $&#123;$event.name&#125; from $&#123;$event.source.$name&#125;`) &#125; &#125; watch = &#123; num (curVal, oldVal) &#123; console.log(`旧值：$&#123;oldVal&#125;，新值：$&#123;curVal&#125;`) &#125; &#125; methods = &#123; plus () &#123; this.num = this.num + 1 console.log(this.$name + ' plus tap') this.$emit('index-emit', 1, 2, 3) &#125;, minus () &#123; this.num = this.num - 1 console.log(this.$name + ' minus tap') &#125; &#125; &#125;&lt;/script&gt; 3.7 sotre: redux(如果你创建项目时使用了redux的话) Redux 状态管理器 使用，类似 vue 的 vuex学习网址学习网址 3.7.1 src/store/index.js 文件 :store 的入口文件123456789//src/store/index.jsimport &#123; createStore , applyMiddleware &#125; from 'redux'import promiseMiddleware from 'redux-promise'import reducer from './reducers'const Store = createStore( reducer , applyMiddleware(promiseMiddleware))export default configStore =&gt; Store 入口文件 index.js ，里面主要是 初始化 Redux ， 其中 promiseMiddleware 是一个中间件，方便后面 action 做异步处理~ reducers 是一个纯函数，用于接受 Action 和当前 State 作为参数，返回一个新的 State。 3.7.2 src/store/types 文件夹 常量定义用于定义我们要触发的 action 的名称，这里我定义了 counter 和 list 两个 types ，内容分别如下： 123//src/store/types/index.js 这里是 types 文件夹的入口文件 index.js，用于暴露 counter 和 list 两个 typesexport * from './counter'export * from './list' 1234//src/store/types/counter.js 这里是 wepy-cli 框架自带的。export const INCREMENT = 'INCREMENT' //递增export const DECREMENT = 'DECREMENT' //递减export const ASYNC_INCREMENT = 'ASYNC_INCREMENT' //异步递增 123//src/store/types/list.js 这个里是自己定义的export const ADD = 'ADD' //加export const REMOVE = 'REMOVE'//移除 3.7.3 src/store/reducers文件夹 函数定义12345678910//src/store/reducers/index.js reducersd 入口文件import &#123; combineReducers &#125; from 'redux'import counter from './counter'import list from './list'export default combineReducers(&#123; counter ,//wepy框架预定义的 list //自定义的&#125;)//首先将 counter 和 list 的分别引入进来，通过 redux 定义的 combineReducers 函数，//将所有的 reducers 合并成一个整体，方便我们后面对其进行管理 12345678910111213141516171819202122232425262728293031323334//src/store/reducers/counter.js/* 首先引入了 handleActions 方法用来创建 actions ， 它将多个相关的 reducer 写在一起也是 ，方面后期维护，也方便后期通过 dispatch 来调用他们更改 state 里面的状态，它主要接收两个参数，第一个参数时候个大对象，里面存放多个 reducer ，第二个参数是初始化的时候 state 的状态值，因此，我们一开始就定义了 defaultState ; */import &#123; handleActions &#125; from 'redux-actions'import &#123; INCREMENT , DECREMENT , ASYNC_INCREMENT &#125; from '../types/counter'const defaultState = &#123; num: 0 , asyncNum: 0&#125;export default handleActions(&#123;//分别定义了 INCREMENT、 DECREMENT 和 ASYNC_INCREMENT 三个 reducer ，//前两个比较简单，分别是对 state 里面的 num 值进行 加减操作 ，// 最后一个是通过 action.payload 的值来对 asyncNum 的值进行异步操作 [INCREMENT](state)&#123; return&#123; ...state, num : state.num + 1 &#125; &#125;, [DECREMENT](state)&#123; return&#123; ...state, num : state.num - 1 &#125; &#125;, [ASYNC_INCREMENT](state, action)&#123; return &#123; ...state , asyncNum : state.asyncNum + action.payload &#125; &#125;&#125;,defaultState) 1234567891011121314151617181920212223//src/store/reducers/list.js 这里是自定义的，类似 count.js 来编辑import &#123; handleActions &#125; from 'redux-actions'import &#123; ADD , REMOVE &#125; from '../types/list'const defaultState = [ &#123; title : '吃饭' , text : '今天我要吃火锅' &#125;, &#123; title : '工作' , text : '今天我要学习 Redux' &#125;]export default handleActions(&#123; [ADD]( state , action )&#123; state.push(action.payload) return [...state] &#125;, [REMOVE]( state , action )&#123; state.splice( action.payload , 1 ); return [ ...state ] &#125;&#125;,defaultState) 3.7.4 src/store/actions 文件夹12//src/store/actions/index.js 入口文件 index.js 将所需的 action 导出export * from './counter' 1234567891011121314//src/store/actions/counter.jsimport &#123; ASYNC_INCREMENT &#125; from '../types/counter'import &#123; createAction &#125; from 'redux-actions'export const asyncInc = createAction(ASYNC_INCREMENT,()=&gt;&#123; return new Promise(resolve=&gt;&#123; setTimeout(()=&gt;&#123; resolve(1) &#125;,1000) &#125;)&#125;)//这里跟 reducer 里面的要区分，这里是可以对数据进行一系列处理的，我们通过 createAction 创建一个 action ,//该方法主要有两个参数，第一个参数 type 表示 action 的类型，//第二个参数 payloadCreator 是一个 function，处理并返回需要的 payload ；//如果空缺，会使用默认方法。这里我们是延迟 1s 后返回一个 1； 3.7.5 在 pages.wepy 中使用 store例如我们创建一个 index.wpy 的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template lang=\"wxml\"&gt; &lt;view class=\"container\"&gt; &lt;text&gt;同步&#123;&#123; num &#125;&#125;&lt;/text&gt; &lt;text&gt;异步&#123;&#123; asyncNum &#125;&#125;&lt;/text&gt; &lt;button @tap=\"increment\" type=\"primary\"&gt;加一&lt;/button&gt; &lt;button @tap=\"decrement\" type=\"primary\"&gt;减一&lt;/button&gt; &lt;button @tap=\"asyncIncrement\" type=\"primary\"&gt;异步加一&lt;/button&gt; &lt;button @tap=\"addList\"&gt;添加&lt;/button&gt; &lt;view class=\"box\"&gt; &lt;view class=\"item\" wx:for-items=\"&#123;&#123; todoList &#125;&#125;\" wx:key=\"index\"&gt; &lt;view class=\"title\"&gt;&#123;&#123; item.title &#125;&#125;&lt;/view&gt; &lt;view class=\"content\"&gt;&#123;&#123; item.text &#125;&#125;&lt;/view&gt; &lt;button type=\"primary\" class=\"delete\" @tap=\"delete(&#123;&#123;index&#125;&#125;)\"&gt;删除&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt;&lt;script&gt; import wepy from 'wepy' import &#123; connect &#125; from 'wepy-redux' //从 wepy-redux 中 引入的 connect ，这个 connect 很关键，它是连接 组件 和 状态 的桥梁， //主要用法是 @connect(states, actions) //states: 访问 state 上的值，可以是数组或者对象，如果是对象的话，则包含的是 K-V 对，V 可以是函数还可以是字符串， //如果是字符串的话则默认获取 state[V]， 否则的话则是使用返回值； //而对于如果是数组的话（数组中的项只能为字符串），则认为是相同的 K-V 对象结构。 //states 最终会附加到组件的 computed 属性值上。 //actions: 只能传入对象，对象的 K-V 结构，如果 V 是字符串的话，则直接会 distatch,如下结构 // args 就是调用传入参数 /* &#123; type: val,// 修正一般情况下的参数 一般支持只传一个参数 payload: args.length &gt; 1 ? args : args[0] // 如果真的是多个参数的话 那么 payload 就是参数组成的数组 &#125; */ //如果是一个函数 fn，则会 dispatch(val.apply(store, args))，否则的话则直接 dispatch(V) import &#123; INCREMENT , DECREMENT &#125; from '../store/types/counter' //从 types/counter 导出所需的 action import &#123; asyncInc &#125; from '../store/actions'//从actions 导出所需的 action @connect(&#123; num(state)&#123; return state.counter.num; &#125;, asyncNum(state)&#123; return state.counter.asyncNum; &#125; &#125;,&#123; increment : INCREMENT , decrement : DECREMENT , asyncIncrement : asyncInc &#125;) export default class Index extends wepy.page &#123; components = &#123;&#125; computed = &#123; todoList()&#123; return wepy.$store.getState().list; &#125; &#125; methods = &#123; delete(index)&#123; wepy.$store.dispatch(&#123; type : 'REMOVE' , payload : index &#125;) &#125;, addList()&#123; wepy.$store.dispatch(&#123; type : 'ADD' , payload : &#123; title : '学习' , text : '好好学习' &#125;&#125;) &#125; &#125; onLoad () &#123; console.log(wepy.$store.getState()) &#125;&#125;&lt;/script&gt;&lt;style lang=\"less\"&gt; text&#123; display: block; text-align: center; margin: 10px auto; &#125; button&#123; width: 90%; display: block; margin: 10px auto; &#125; .item&#123; display: flex; align-items: center; text-align: center; padding: 0 15px; .title&#123; font-size: 14px; line-height: 20px; margin: 10px auto; &#125; .content&#123; font-size: 15px; flex: 1; &#125; .delete&#123; width: 70px; height: 40px; line-height: 40px; &#125; &#125;&lt;/style&gt; WePY 借鉴了 Vue.js（后文简称 Vue ）的语法风格和功能特性，如果你之前从未接触过 Vue，建议先阅读 Vue 的官方文档，以熟悉相关概念，否则在阅读 WePY 文档以及使用 WePY 进行开发的过程中，将会遇到比较多的障碍。 开发建议 使用第三方成熟IDE或编辑器(具体请参看后文的代码高亮部分)，微信开发者工具仅用于实时预览和调试。使用微信开发者工具–&gt;添加项目，项目目录请选择项目根目录即可根据配置完成项目信息自动配置。 如果 project.config.json 不存在，建议手动创建该文件后再添加项目。 project.config.json 文件内容如下： {&quot;description&quot;: &quot;project description&quot;, &quot;setting&quot;: { &quot;urlCheck&quot;: true, 对应不检查安全域名选项，开启。 如果已配置好安全域名则建议关闭。 &quot;es6&quot;: false, 对应关闭 ES6 转 ES5 选项，**关闭。 重要：未关闭会运行报错。** &quot;postcss&quot;: false, 对应关闭上传代码时样式自动补全选项，**关闭。 重要：某些情况下漏掉此项也会运行报**错。 &quot;minified&quot;: false 对应关闭代码压缩上传选项，**关闭。重要：开启后，会导致真机computed, props.sync 等等属性失效。** }, &quot;compileType&quot;: &quot;miniprogram&quot;, &quot;appid&quot;: &quot;touristappid&quot;, &quot;projectname&quot;: &quot;Project name&quot;, &quot;miniprogramRoot&quot;: &quot;./dist&quot; } 注：压缩功能可使用 WePY 提供的 build 指令代替，详见后文相关介绍以及 Demo 项目根目录中的 wepy.config.js 和 package.json 文件。 3.8 mixins: 混合组件 方法 js 文件mixins 是放混合组件的方法的地方，比如很多 page 中都要用到 wx.showToast 方法。那么我们可以在 mixins 文件夹里面创建一个 toast.js 12345678910111213141516171819202122232425262728//toast.js// mixins 是 js 文件不是 wpy 文件（当然我们需要看得懂 wepy 源码，拷源码过来自己会加功能是极好的）import wepy from 'wepy'export default class testMixin extends wepy.mixin &#123; onLoad () &#123; // onLoad生命周期钩子函数 this.showToast() &#125; noMore () &#123; // 普通方法直接定义到 class 的静态方法 wepy.showToast(&#123; // wepy.showToast 等同于 wx.showToast title: '没有更多了...', icon: 'none', duration: 1500 &#125;) &#125; showToast () &#123; wepy.showToast(&#123; title: '拼命加载中...', icon: 'loading', duration: 3000 &#125;) &#125; hideToast () &#123; wepy.hideToast() &#125;&#125;//其中 wepy 继承了 wx 对象的方法，建议在 wepy 框架开发中不要用到 wx 对象的方法，//虽然运行时效果是一样，但是打包时会 cli 报错（wepy 中没有 wx 对象）。 mixins 的方法定义好后，就可以在组件中使用 mixin 了。 12345678910111213141516&lt;!-- index.wpy page.wpy--&gt;&lt;script&gt; import wepy from 'wepy' import toast from 'mixins/toast' // 导入 mixins 组件 export default class Index extends wepy.page &#123; onLoad () &#123; this.showToast() // 导入和注册后，就可直接使用 this.getMovies() &#125; mixins = [ // 注册混合组件，注意 mixins 是一个数组 toast ] ...... &#125;&lt;/script&gt; 首先在引入和注册后，然后就可以直接调用 this.showToast() 注意在 wepy 中组件中使用的是 class ,而不是 vue 中使用的 Object。 3.9 interceptor：拦截器拦截器,可以使用全域拦截器配置API的config、fail、success、complete方法，参考示例： 123456789101112131415161718192021import wepy from 'wepy';export default class extends wepy.app &#123; constructor () &#123; this.intercept('request', &#123; config (p) &#123; p.timestamp = +new Date(); return p; &#125;, success (p) &#123; console.log('request success'); return p; &#125;, fail (p) &#123; console.log('request error'); return p; &#125; &#125;); &#125;&#125; 3.10 utils：工具包12345678910111213141516171819const formatTime = (time) =&gt; &#123; let h = Math.floor(time / 3600) h = (h &lt; 10) ? '0' + h : h let m = Math.floor(time % 3600 / 60) m = (m &lt; 10) ? '0' + m : m let s = time % 3600 % 60 s = (s &lt; 10) ? '0' + s : s return `$&#123;h&#125;:$&#123;m&#125;:$&#123;s&#125;`&#125;/* 可以将一些公共的代码抽离成为一个单独的 js (utils.js)文件，作为一个模块;模块只有通过 module.exports 或者 exports 才能对外暴露接口。所以当你在util.js里封装的方法想要在外部使用的话,必须通过 module.exports 或者 exports 对外暴露需要注意的是，这个文件名是指定的，只能是 utils 文件夹下的 util.js 文件，改变了就会出错的。问题是这个文件夹是只能有一个工具文件么？？？*/module.exports = &#123; formatTime: formatTime//'对外方法名':'本地方法名'&#125; 1234// 调用 util.js 中的函数import util from '../utils/util';// ES6 写法//var util= require('../utils/util.js') // ES5 写法util.formatTime(params)) 问题： 12Missing files: ../utils/utils.js in F:\\pages.wpy #出现这个问题就是不正确的命名了，不要去修改工具包的名字# 只能是 ../utils/util.js 数据绑定wepy 使用脏数据检查对 setData 进行封装，在函数运行周期结束时执行脏数据检查，一来可以不用关心页面多次 setData 是否会有性能上的问题，二来可以更加简洁去修改数据实现绑定，不用重复去写 setData 方法。代码如下： 1this.title = 'this is title';// 可以直接赋值 在异步函数中更新数据的时候，必须手动调用 $apply 方法，才会触发脏数据检查流程的运行。如：之前说的作为回调呢？子组件的 onload 里面也需要 this.$apply() 吧，还有其他的情况么？？网址：wepy props传值有说道网址：gitHub issue 也有说道 但需注意，在函数运行周期之外的函数里去修改数据需要手动调用 $apply方法。如： 1234setTimeout(() =&gt; &#123; this.title = 'this is title'; this.$apply();&#125;, 3000); 四、wepy 完整的属性/方法/配置 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!]4.1 app.wpy 的 config 选项/属性() ,data，生命周期，配置，等等App 小程序实例中主要包含小程序生命周期函数、 config 配置对象、 globalData 全局数据对象，以及其他自定义方法与属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import wepy from 'wepy';export default class MyAPP extends wepy.app &#123; //config 属性对应原生的 app.json 文件 // build 编译时会根据 config 属性自动生成 app.json 文件，如果需要修改 config 中的内容，请使用微信提供的相关 API。 config = &#123; //① 页面路径列表 pages: [ 'pages/index' ], //② 全局的默认窗口表现 window: &#123; navigationBarBackgroundColor: '#fff',//导航栏背景颜色，如 #000000 navigationBarTextStyle: 'black'//导航栏标题颜色，仅支持 black / white navigationBarTitleText: 'WeChat',//导航栏标题文字内容 navigationStyle:'default',//导航栏样式，仅支持以下值：default 默认样式 ,custom 自定义导航栏，只保留右上角胶囊按钮 backgroundColor:'#ffffff'//窗口的背景色 backgroundTextStyle: 'light',//下拉 loading 的样式，仅支持 dark / light backgroundColorTop:'#ffffff'//顶部窗口的背景色，仅 iOS 支持 backgroundColorBottom:'#ffffff'//底部窗口的背景色，仅 iOS 支持 enablePullDownRefresh:false,//是否开启当前页面的下拉刷新。详见 Page.onPullDownRefresh onReachBottomDistance:50,//页面上拉触底事件触发时距页面底部距离，单位为px。详见 Page.onReachBottom pageOrientation:'portrait'//屏幕旋转设置，仅支持 auto / portrait 详见 响应显示区域变化 &#125;, // ③ 页面底部栏配置 tabBar: &#123; color: '#AEADAD',//tab 上的文字默认颜色 selectedColor: '#049BFF',//tab 上的文字选中时的颜色 backgroundColor: '#fff',//tab 的背景色 borderStyle: 'black',//tabbar上边框的颜色， 仅支持 black / white position:'bottom',//tabBar的位置，仅支持 bottom / top list: [//最少2个、最多5个 tab &#123; pagePath: 'pages/index', text: '游戏', iconPath: '', selectedIconPath: '' &#125;, &#123; pagePath: 'pages/ranking', text: '排名', iconPath: '', selectedIconPath: '' &#125; ] &#125;, //④ 网络超时时间 默认都是 60000 ms networkTimeout: &#123; request: 10000,//wx.request 的超时时间，单位：毫秒。 downloadFile: 10000,//wx.downloadFile 的超时时间，单位：毫秒。 connectSocket:10000, uploadFile:10000 &#125;, debug: true, //⑥ 是否开启 debug 模式，默认关闭, 这个配置，项目上线要删除 functionalPages:true,//⑦ 启用插件功能页时 subpackages:,//⑧ subPackages 也行???? 启用分包加载时，声明项目分包结构。 workers:,//⑨ 使用 Worker 处理多线程任务时，设置 Worker 代码放置的目录 requiredBackgroundModes: ['audio'],//⑩ 申明需要后台运行的能力，类型为数组。 目前也只是支持 audio plugins:,//⑪ 声明小程序需要使用的插件。 preloadRule:,//⑫ 声明分包预下载的规则。 resizable:,//⑬在 iPad 上运行的小程序可以设置支持屏幕旋转。 //当小程序需要使用 wx.navigateToMiniProgram 接口跳转到其他小程序时， navigateToMiniProgramAppIdList:,//⑭需要先在配置文件中声明需要跳转的小程序 appId 列表，最多允许填写 10 个。 usingComponents://⑮ 开发者工具 1.02.1810190 及以上版本支持 usingComponents 字段， //在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。 &#125; //小程序的生命周期，周期函数 onLaunch () &#123;&#125; //小程序初始化完成时（全局只触发一次） onShow () &#123;&#125; // 小程序启动，或从后台进入前台显示时 onHide () &#123;&#125; // 小程序从前台进入后台时 onError() &#123;&#125; //小程序发生脚本错误，或者 api 调用失败时触发，会带上错误信息 onPageNotFound() &#123;&#125; //小程序要打开的页面不存在时触发，会带上页面信息回调该函数 //前台、后台定义： 当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台； //当再次进入微信或再次打开小程序，又会从后台进入前台。 //需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 globalData = &#123;&#125; //全局属性 // 全局方法 customData = &#123;&#125;; // 自定义数据 ？？？没有看到过这个啊？？ customFunction () &#123; &#125; //自定义函数&#125; 4.2 page.wpy 与 components.wpy 的 选项/属性：data，生命周期，配置，等等由于 Page 页面实际上继承自 Component 组件，即 Page 也是组件。除扩展了页面所特有的 config 配置以及特有的页面生命周期函数之外，其它属性和方法与 Component 一致，因此这里以 Page 页面为例进行介绍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import wepy from 'wepy';export default class MyPage extends wepy.page &#123;// export default class MyComponent extends wepy.component &#123; // 只在Page实例中存在的配置数据，对应于原生的page.json文件 只是 pages.wpy 中的有，components.wpy 中没有 config = &#123; navigationBarBackgroundColor: '#fff', //导航栏背景颜色，如 #000000 navigationBarTitleText: 'WeChat',//导航栏标题文字内容 navigationBarTextStyle: 'black',//导航栏标题颜色，仅支持 black / white backgroundColor:'#ffffff',//窗口的背景色 backgroundTextStyle: 'light',//下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh:false,//是否全局开启下拉刷新。详见 Page.onPullDownRefresh onReachBottomDistance:50,//页面上拉触底事件触发时距页面底部距离，单位为px。详见 Page.onReachBottom disableScroll:false//设置为 true 则页面整体不能上下滚动； //disableScroll 这项 只在页面配置中有效，无法在 app.json 中设置该项!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &#125; data = &#123;&#125;; // 页面所需数据均需在这里声明，可用于模板数据绑定 components = &#123;&#125;; // 声明页面中所引用的组件，或声明组件中所引用的子组件 mixins = []; // 声明页面所引用的Mixin实例 computed = &#123;&#125;; // 声明计算属性（详见后文介绍） watch = &#123;&#125;; // 声明数据 watcher（详见后文介绍） // 组件事件处理函数：页面中的某个元素触发的函数 methods = &#123;&#125;; // 声明页面 wxml 中标签的事件处理函数。用于 本组件 触发的事件处理 events = &#123;&#125;; // 声明组件之间的事件处理函数 用于 其他组件 触发的事件处理 customData = &#123;&#125; // 自定义数据 customFunction () &#123;&#125; //自定义方法，这里与 methods 平级，这些方法不能卸载 methods 里面 // 生命周期函数 onLoad () &#123;&#125; // 页面加载（执行 ？？ 次）：在 Page 和 Component 共用的生命周期函数 onShow () &#123;&#125; // 页面显示（执行很多次）：只在 Page 中存在的页面生命周期函数 onReady() &#123;&#125; // 页面初次渲染完成（执行 1 次）：只在？？？ onHide () &#123;&#125; // 页面隐藏（执行很多次）：只在 Page 中存在的页面生命周期函数 onUnload()&#123;&#125; //页面卸载（执行 ？？ 次）：在 Page 和 Component 共用的生命周期函数 // 页面事件处理函数：整个页面触发的函数 onPullDownRefresh()&#123;&#125; //监听用户下拉动作 onReachBottom()&#123;&#125; //页面上拉触底事件的处理函数 onShareAppMessage()&#123;&#125; //用户点击右上角转发 onPageScroll()&#123;&#125; //页面滚动触发事件的处理函数 onResize()&#123;&#125; //页面尺寸改变时触发 onTabItemTap()&#123;&#125; //当前是 tab 页时，点击 tab 时触发&#125; 4.2 components.wpy 的 选项/属性：data，生命周期，配置，等等除了 config 之外，拥有 page 页面的所有属性与方法/., Zxcvbvc选项 在 pages 页面中我们有几种函数 2、页面事件处理函数：eg：onPullDownRefresh() 3、组件事件处理函数 methods 内：自定义 4、props 传值处理函数 events 内：自定义 5、普通函数 为其他的函数做准备的函数：自定义 1234567891011121314151617181920212223242526272829303132//在 vue 中，所有方法都定义在 methods 里面。//而在 wepy 中，// ① 普通方法是直接定义在 class 静态方法里面。（就是与 methods events 平级的地方）// ② events 只定义组件间交互的方法。（它的父子组件，传递过来方法）// ③ methods只定义事件方法。（本组件事件触发的方法）/* index.wpy */getSliderImg (data) &#123; // ① 普通方法 this.sliderImg = data.slice(0, 10) this.$apply()&#125;onPullDownRefresh () &#123; // 页面事件处理函数：顶部下拉刷新（这是对整个页面而言触发的事件） this.showToast() this.sliderImg = null this.active = true this.$apply() this.getMovies()&#125;events = &#123; // ② 与子组件的交互，都要写到 events 里面 'showMovieDetail': (id) =&gt; &#123; wepy.navigateTo(&#123; url: `./movie-detail?locationId=$&#123;290&#125;&amp;movieId=$&#123;id&#125;` &#125;) &#125;&#125;methods = &#123; toggleType (flag) &#123; // ③ 组件事件处理函数：点击事件方法（这是对 页面中的某个元素操作 触发的事件） this.active = flag this.showToast() this.getMovies() &#125;&#125; 4.4 computed 属性/选项wepy 中也有 computed,props，data,watch 等 vue 中有的一些属性（没有filter, directive）。props,data,watch 和 vue 基本无异。 wpy 中是 watcher wepy 中 computed 计算属性是无法传参的（本人没能找到传参的方法，且官方文档没有提到），在处理一些动态数据的时候，只能通过其他方法来操作。比如，服务端获取到的的 JSON 对象内有条时间戳数据需要转换成字符串，我的做法是将时间戳另外传值给子组件，然后在子组件中使用 computed 对props 进行记算。 4.10 this.$parent.全局方法 this.$parent.全局属性在 Page 页面实例中，可以通过 this.$parent 来访问 App 实例 的方法与属性 五、wepy 继承 wx 对象的所有 API小程序官网 API 六、wepy 中的 API 类6.1 app ：wepy.app ClassApp 基类，小程序入口。 1234567891011121314151617181920212223242526272829303132333435363738export class App extends wepy.app &#123; // ① 属性 this.$wxapp // getApp() // ② 属性 this.$pages = &#123; './pages/index': IndexPage &#125; // ④ use() 使用中间件 constructor() &#123; super() this.use('requestfix'); //修复小程序请求并发问题。 this.use('promisify');//使用 wepy.xxx 的方式请求小程序原生 API 都将 Promise 化。 //③ $interceptors 拦截器属性 this.$interceptors = &#123; 'request': &#123; config (p) &#123; return p; &#125;, success (rst) &#123; &#125; &#125; /*⑤ intercept 拦截器 方法 //使用拦截器对原生 API 请求进行拦截。 this.intercept('request', &#123; config (p) &#123; p.timestamp = +new Date() return p &#125;, success (obj) &#123; console.log('request success') &#125; &#125;) */ &#125;&#125; 6.2 component &amp;&amp; page ：wepy.component Class &amp;&amp; wepy.page Class组件基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101export default class Counter extends wepy.component &#123; $name //① String: 组件名称。 $isComponent//② Boolean：是否是组件，如果是页面，此值为false。 $wxpage //③ :Object: 小程序原生page。 $parent //④ :Page|App：组件的父组件，如果当前是组件是Page对象，那么$parent的值为App对象。 $root //⑤ :Page: 组件所在的Page对象，如果当前组件是Page对象，那么$root的值就是自己本身。 $coms //⑥ :List&lt;Component&gt;：组件的子组件列表。 $mixins //⑦ :Array[Mixin]：组件所注入的Mixin对象。 data //⑧ :Object: 组件需要绑定的数据。 methods //⑨ :List&lt;Function&gt;：组件需要响应的事件列表。 props //⑩ :List&lt;Props&gt;：组件允许传递的props列表。 events //⑪:List&lt;Function&gt;：组件通信时所需要的事件表现。 this.setData('list', ['apple', 'pen']);//⑫ 对原有小程序的setData的封装。 this.setData(&#123; list: ['apple', 'pen']//因为 WePY 的脏检查流程会自动执行 setData 操作，所以通常情况下不需要使用此方法。 &#125;); this.getCurrentPages()// ⑬ 相当于全局方法 getCurrentPages() this.$getComponent('./coma/comb'); // ⑭ 通过组件名称路径查找组件对象。 this.$getComponent('../comc');//通过组件名称路径查找组件对象。 // ⑮ $invoke(com:String|Component)： //调用另一组件的方法。优先调用 methods 中方法，如果方法不存在，则调用组件的自定义方法，调用自定义方法时，不会传递事件 $event。 // comb.js /* export class ComB extends wepy.component &#123; methods = &#123; func1 (p1, p2, evt) &#123;&#125; &#125;, func2 (p1, p2) &#123;&#125; &#125; */ // coma.js ，假设这里是 coma.js this.$invoke('./ComB', 'func1', 'p1', 'p2'); this.$invoke('./ComB', 'func2', 'p1', 'p2'); //⑯ $broadcast(eventName:String, [args])：组件发起一个广播事件。 父 传 子 // coma.js 假设这里是 coma.js components = &#123; ComA &#125;; this.$broadcast('broadcast-event', 'p1', 'p2'); /* coma.js 的所有子组件，有需要的话 events = &#123; 'broadcast-event': (p1, p2, event) &#123;&#125; &#125; */ //⑰ $emit(eventName:String, [args])：组件发起一个冒泡事件。 子 传 父 // coma.js 假设这里是 coma.js this.$emit('emit-event', 'p1', 'p2'); /* coma.js 的所有 父 组件，有需要的话 components = &#123; ComA &#125;; events = &#123; 'emit-event': (p1, p2, event) =&gt; &#123;&#125; &#125; */ //⑱ $apply([func:Function])：组件发起脏检查 //正常流程下，改变数据后，组件会在流程结束时自动触发脏检查。 在异步或者回调流程中改变数据时，需要手动调用 $apply 方法。 this.userName = 'Gcaufy'; this.$apply(); this.$apply(() =&gt; &#123; this.userName = 'Gcaufy'; &#125;); //⑲ $nextTick([func:Function])：组件数据绑定完成后的回调事件，v1.6.1 以上可用。 // 数据绑定后的回调事件，在不传入function时，返回一个promise对象 this.userName = 'Gcaufy'; this.$nextTick(function () &#123; console.log('UI updated'); &#125;); // 或者 this.userName = 'Gcaufy'; this.$nextTick().then(function () &#123; console.log('UI updated'); &#125;); // 下面的 page 页面专有的属性与方法， common 组件是没有的。 //⑳$preload(key:String|Object, [value:Object])， // 加载 preload 数据后，跳转至另一个页面时，在 onLoad 方法中可以获取到上个页面的 preload 数据。 this.$preload('userName', 'Gcaufy'); this.$redirect('./page2'); // page2.js /* onLoad (params, data) &#123; console.log(data.preload.userName); &#125; */ //㉑ $redirect(url:String|Object, [params:Object])：wx.redirectTo的封装方法。 this.$redirect('./page2', &#123;a: 1, b: 2&#125;); this.$redirect(&#123; url: './pages?a=1&amp;b=2' &#125;); // page2.js /* onLoad (params, data) &#123; console.log(data.preload.userName); &#125; */ // ㉒ $navigate(url:String|Object, [params:Object])：wx.navigateTo的封装方法 //㉓ $switch(url:String|Object)：wx.switchTab的封装方法&#125; 预加载 ？？？、这个官网上面没有啊预加载请求数据是在 onLoad 中进行，但是小程序的 page 1跳转到 page 2，再到 page 2 的 onLoad 是存在一个 300ms ~ 400ms 的延时.wepy 扩展了生命周期，添加了onPrefetch 事件，会在 redirect 之时被主动调用。同时给 onLoad 事件添加了一个参数，用于接收预加载或者是预查询的数据： 1234567891011121314151617181920212223242526272829303132333435363738// params// data.from: 来源页面，page1// data.prefetch: 预查询数据// data.preload: 预加载数据onLoad (params, data) &#123;&#125;//预加载数据示例：// page1.wpy 预先加载 page2 需要的数据。methods: &#123; tap () &#123; this.$redirect('./page2'); &#125;&#125;,onLoad () &#123; setTimeout(() =&gt; &#123; this.$preload('list', api.getBigList()) &#125;, 3000)&#125;// page2.wpy 直接从参数中拿到 page1 中预先加载的数据onLoad (params, data) &#123; data.preload.list.then((list) =&gt; render(list));&#125;//预查询数据示例：// page1.wpy 使用封装的 redirect 方法跳转时，会调用 page2 的 onPrefetch 方法methods: &#123; tap () &#123; this.$redirect('./page2'); &#125;&#125;// page2.wpy 直接从参数中拿到 onPrefetch 中返回的数据onPrefetch () &#123; return api.getBigList();&#125;onLoad (params, data) &#123; data.prefetch.then((list) =&gt; render(list));&#125; 6.3 event ： wepy.event Class 小程序事件封装类七、组件之间通信与交互，事件通信交互-页面传参7.1 父子组件传值：props 传值：父组件 &lt;=&gt; 子组件也就是在父组件中 子组件处 ：写上传递的属性 与其对应的值。 props 传值在 WePY 中属于父子组件之间传值的一种机制，包括静态传值与动态传值。 静态传值：传值即使静态传值，静态传值为父组件向子组件传递常量数据，因此只能传递 String 字符串类型。 静态传值，使用静态传值时，子组件会接收到字符串的值。动态传值：动态传值是指父组件向子组件传递动态数据内容，父子组件数据完全独立互不干扰。!!!!!!!!!!!!!!!!! 7.1.1 静态传值：传递字符串 父组件 =&gt; 子组件只能是父组件传给子组件 1234&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;child title=\"mytitle\"&gt;&lt;/child&gt;&lt;/template&gt; 1234567891011&lt;!-- 子组件 --&gt;&lt;script&gt; export default class Index extends wepy.page &#123; props = &#123; title: String // 在子组件接收 父组件传递过来的值，这里是静态传值，数据类型值 字符串 &#125;; onLoad () &#123; console.log(this.title); // mytitle &#125; &#125;&lt;/script&gt; 7.1.2 动态态传值：父子组件的值互相不影响 父组件 &lt;=&gt; 子组件由于上面的静态传值，只能是父组件传值给子组件，在子组件是不能去修改父组件的属性值的，而有时候我们需要做到 父子组件的数据双向绑定，简单点的，目的也就是子组件可以修改值传递给父组件。 ①sync修饰符：其实就是做到子组件中修改属性并传递给父组件 父组件 &lt;= 子组件，:name.sync 就是 :name=&quot;name&quot; @update:name=&quot;name = $event&quot; 的缩写。 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名②twoWay:是否可以子组件向父组件传值，默认值为 false，也就是不允许子组件向父组件传值。 :name.sync 等价于 父组件向子组件传值 ，但是子组件不能传值给父组件，也就是静态传值的效果 :name.sync props 中 twoWay: true 等价于 双向传值 1234&lt;!-- 父组件 --&gt;&lt;template&gt; &lt;child :title=\"parentTitle\" :syncTitle.sync=\"parentTitle\" :twoWayTitle=\"parentTitle\"&gt;&lt;/child&gt;&lt;/template&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!-- 子组件 --&gt;&lt;script&gt; export default class Index extends wepy.page &#123; props = &#123; title: String, // 静态传值 （父组件中 title 属性没有 .sync 修饰，并且这里默认 twoWay: false） syncTitle: &#123; // 父向子单向动态传值 type: String, //（父组件中 syncTitle 属性有 .sync 修饰，但是这里默认 twoWay: false） default: 'null' // 因此只能是父组件传值给子组件 &#125;, twoWayTitle: &#123; // 双向传值 type: String, //（父组件中 syncTitle 属性有 .sync 修饰，这里 twoWay: true） default: 'nothing', //问题？这里默认值是什么？？？？ twoWay: true &#125;&#125;;onLoad () &#123; console.log(this.title); // p-Title console.log(this.syncTitle); // p-Title console.log(this.twoWayTitle); // p-Title this.title = 'c-title';// 修改子组件的属性值，因为 title 没有 sync 只能是 父 影响 子，子无法改变 父组件的 console.log(this.$parent.parentTitle); // p-Title this.twoWayTitle = 'two-way-title'; this.$apply(); //https://juejin.im/post/59bfe84351882531b730bac2 ， // wepy 中 props 传递需要加上 .sync 修饰符（类似VUE1.x）才能实现 props 动态更新， // 并且父组件再 变更传递给子组件 props 后要执行this.$apply() 方法才能更新 console.log(this.$parent.parentTitle); // two-way-title. --- twoWay为true时，子组件props中的属性值改变时，会同时改变父组件对应的值 this.$parent.parentTitle = 'p-title-changed'; this.$parent.$apply(); console.log(this.title); // 'c-title'; console.log(this.syncTitle); // 'p-title-changed' --- 有.sync修饰符的props属性值，当在父组件中改变时，会同时改变子组件对应的值。&#125;&lt;/script&gt; 问题： apply（） ，call 函数，等等，好难。上面的这个例子举例真是不让人理解、 apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数 123456VM139764:1 CLI报错：F:\\qianduan_dir\\00program\\wechat-wepy\\suduku\\src\\pages\\grid.wpy 240:10 error Missing space before value for key 'grid' key-spacing 269:10 error Missing space before value for key 'name' key-spacing✖ 2 problems (2 errors, 0 warnings) 解答：这个是因为 eslint 的要求，要求 对象中，key 与 value 之间是需要空格间隔的，否则就会报错，找到了原因，是因为在父组件中，data 部分写成了这样 123456789data = &#123; name:'xiaomi'// 这里 key 与 value 之间没有空格，eslint 是会当成错误报出来的。&#125;//解决办法就是 ctrl + s 多按几遍，就会自动的格式化了，这里 eslint 很烦人的一个地方，文件它也不报错，只是在控制台一直报错，// 明白了错误的意思之后，随手 ctrl + s 发现 data 中格式给改变了，data = &#123; name: 'xiaomi'// 格式化成这样就正确了。&#125; 然后又出来了一个问题 1234204:24 error Extra semicolon semi # 多余的 分号205:37 error Extra semicolon semi206:39 error Extra semicolon semi207:30 error Extra semicolon semi 这还是 eslint 的问题，要修改 .eslintrc.js 文件 12345678910111213141516171819202122232425262728293031323334module.exports = &#123; root: true, globals: &#123; wx: true &#125;, parser: 'babel-eslint', parserOptions: &#123; sourceType: 'module' &#125;, env: &#123; browser: true &#125;, // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style extends: [ 'standard', \"eslint:recommended\" //增加这一句，并且看到这里就变成一个数组了], // required to lint *.wpy files plugins: [ 'html' ], settings: &#123; 'html/html-extensions': ['.html', '.wpy'] &#125;, // add your custom rules here 'rules': &#123; // allow paren-less arrow functions 'arrow-parens': 0, // allow async-await 'generator-star-spacing': 0, // allow debugger during development 'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0, 'space-before-function-paren': 0, \"no-console\":0 // 增加这一句 &#125;&#125; 问题： 这个 .sync 与 twoWay 到底是怎么限制传值的？？？？？ 123456789&lt;!-- 父组件 --&gt;&lt;view class='grid'&gt; &lt;childrengrid :syncname.sync=\"name\" :syncTwoname.sync=\"name\" :twoName=\"name\"&gt;&lt;/childrengrid&gt;&lt;/view&gt;&lt;script&gt;data=&#123; name: 'xiaomi'&#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!-- 子组件 --&gt;&lt;style lang=\"less\"&gt; .common-grid&#123; width: 100%; height: 10%; background: red; &#125;&lt;/style&gt;&lt;template&gt; &lt;view class=\"common-grid\"&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import wepy from 'wepy' export default class CommonGrid extends wepy.component &#123; data = &#123; &#125; // :name='name' :syncname.sync='name' :syncTwoname.sync='name' :twoname='name' props=&#123; gridData: &#123; type: Array &#125;, syncname: &#123; type: String, twoWay: false &#125;, syncTwoname: &#123; type: String, twoWay: true &#125;, twoName: &#123; type: String, twoWay: true &#125; &#125; onLoad () &#123; console.log('this.syncname:' + this.syncname)//this.syncname:xiaomi console.log('this.syncTwoname:' + this.syncTwoname)//this.syncTwoname:xiaomi console.log('this.twoname:' + this.twoName)//this.twoName:xiaomi this.syncname = 'mei' this.$apply() console.log('this.$parent.name:' + this.$parent.name) //this.$parent.name:xiaomi // 说明 .sync 子组件 是无法改变 父组件 this.syncTwoname = 'mei1' this.$apply() console.log('this.$parent.name:' + this.$parent.name)//this.$parent.name:mei1 // .sync twoWay=true 子组件 可以修改 父组件 this.twoName = 'mei2' this.$apply() console.log('this.$parent.name:' + this.$parent.name)//this.$parent.name:mei2 // twoWay=true 子组件 可以修改 父组件 this.$parent.name = 'mei3' this.$parent.$apply() console.log('this.syncname:' + this.syncname)//this.syncname:mei // .sync 父组件也无法修改子组件啊 ？？？？？？？？ console.log('this.syncTwoname:' + this.syncTwoname)//this.syncTwoname:mei3 // .sync twoWay=true 父组件 可以修改 子组件 console.log('this.twoName:' + this.twoName)//this.twoName:xiaomi // twoWay=true 父组件 无法修改 子组件 &#125; &#125;&lt;/script&gt; 没有 .sync 与 twoWay 与静态传值是一样的，父子组件互补影响只有 .sync 貌似 父组件无法修改子组件啊！！！！！只有 twoWay=ture 子组件可以修改父zujian有 .sync 与 twoWay 父子组件可以互相修改 7.2 $emit 子组件 =&gt; 所有父组件$emit 与 $broadcast 正好相反，事件发起组件的所有祖先组件会依次接收到$emit事件。如果组件ComE发起一个$emit事件，那么接收到事件的先后顺序为：组件ComA、页面Page_Index。如下图： 123456789101112131415161718&lt;!-- 子组件：触发方法 --&gt;&lt;template&gt; &lt;view @tap='tap'&gt; 这里绑定事件 &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default class Com extends wepy.component &#123; components = &#123;&#125;; data = &#123;&#125;; methods = &#123; tap()&#123; this.$emit('some-event', 1, 2, 3, 4); // 事件方法, 使用 $emit 发起一个名为 some-event 的监听属性 传值为 1, 2, 3, 4 &#125; &#125;; &#125;&lt;/script&gt; 1234567891011121314151617181920&lt;!-- 父组件：接受事件 --&gt;&lt;script&gt; import wepy from 'wepy' export default class Com extends wepy.component &#123; components = &#123;&#125;; data = &#123;&#125;; methods = &#123;&#125;; // events对象中所声明的函数为用于监听组件之间的通信与交互事件的事件处理函数 events = &#123; 'some-event': (p1, p2, p3, $event) =&gt; &#123; console.log(`$&#123;this.$name&#125; receive $&#123;$event.name&#125; from $&#123;$event.source.$name&#125;`); &#125; // 监听 从 A 产来的 some-event 属性 &#125;; // Other properties &#125;&lt;/script&gt; 7.3 $broadcast 父组件 =&gt; 所有子组件$broadcast 事件是由父组件发起，所有子组件都会收到此广播事件，除非事件被手动取消。事件广播的顺序为广度优先搜索顺序，如上图，如果页面Page_Index 发起一个 $broadcast 事件，那么按先后顺序依次接收到该事件的组件为：ComA、ComB、ComC、ComD、ComE、ComF、ComG、ComH。如下图： 、$invoke 123456789101112131415161718&lt;!-- 父组件：触发方法 --&gt;&lt;template&gt; &lt;view @tap='tap'&gt; 这里绑定事件 &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default class Com extends wepy.component &#123; components = &#123;&#125;; data = &#123;&#125;; methods = &#123; tap()&#123; this.$emit('some-event', 1, 2, 3, 4); // 事件方法, 使用 $emit 发起一个名为 some-event 的监听属性 传值为 1, 2, 3, 4 &#125; &#125;; &#125;&lt;/script&gt; 1234567891011121314151617181920&lt;!-- 子组件：接受事件 --&gt;&lt;script&gt; import wepy from 'wepy' export default class Com extends wepy.component &#123; components = &#123;&#125;; data = &#123;&#125;; methods = &#123;&#125;; // events对象中所声明的函数为用于监听组件之间的通信与交互事件的事件处理函数 events = &#123; 'some-event': (p1, p2, p3, $event) =&gt; &#123; console.log(`$&#123;this.$name&#125; receive $&#123;$event.name&#125; from $&#123;$event.source.$name&#125;`); &#125; // 监听 从 A 产来的 some-event 属性 &#125;; // Other properties &#125;&lt;/script&gt; 7.4 $invoke A B 组件之间调用方法(父子组件，非父子组件中调用 其他组件的方法都是这样做)$invoke 是一个页面或组件对另一个组件中的方法的直接调用，通过传入组件路径找到相应的组件，然后再调用其方法。 123456789&lt;!-- 子组件：接受事件 --&gt;&lt;script&gt; import wepy from 'wepy' export default class Com extends wepy.component &#123; this.$invoke('B', 'someMethod', 'someArgs') // 调用 B 页面 的方法 this.$invoke('./../compsonent/C', 'someMethod', 'someArgs'); // 调用 C 组件 的方法 &#125;; &#125;&lt;/script&gt; 7.5 url 传值7.6.1 导航链标签 + url12345&lt;navigator class=\"message\" url=\"./pages/grid?level=&#123;&#123;level&#125;&#125;\"&gt; &lt;!-- 这里的的 路径不要搞错--&gt; &lt;i class=\"iconfont icon-message cfff\"&gt;&lt;/i&gt; &lt;view class=\"doc cfff\"&gt;消息&lt;/view&gt;&lt;/navigator&gt; 12345678 &lt;!-- &lt;view class='levels'&gt; 这里怎么就不对呢？？？ &lt;block for=\"&#123;&#123;levels&#125;&#125;\" key=\"index\" index=\"index\" item=\"level\" open-type=\"navigate\"&gt; &lt;navigator clas='level' url='./grid?level=&#123;&#123;level&#125;&#125;'&gt; &lt;text&gt;&#123;&#123;level&#125;&#125;&lt;/text&gt; &lt;/navigator&gt; &lt;/block&gt;&lt;/view&gt; --&gt; 7.6.2 事件 + 基本参数 + 花括号 传值（优化之后使用的方法）12&lt;!-- wepy中的事件可传递一些基本类型的参数，但是需使用双括号。否则获取到的参数是字符串类型。 --&gt; &lt;view @tap=\"toggleType(&#123;&#123;true&#125;&#125;)\"&gt; 123456&lt;view class=\"grid-row &#123;&#123;rowIndex % 3 == 0 ? 'grid-row-index' : ''&#125;&#125;\" wx:for-items=\"&#123;&#123;grids&#125;&#125;\" wx:for-index=\"rowIndex\" wx:for-item=\"items\" wx:key=\"rowIndex\"&gt; &lt;view class=\"grid-col &#123;&#123;colIndex % 3 == 0 ? 'grid-col-index' : ''&#125;&#125;\" wx:for-items=\"&#123;&#123;items&#125;&#125;\" wx:for-index=\"colIndex\" wx:for-item=\"item\" wx:key=\"colIndex\"&gt; &lt;view class=\"fixed\" wx:if=\"&#123;&#123;item&#125;&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;view @tab=\"fillNumber(&#123;&#123;rowIndex&#125;&#125;,&#123;&#123;colIndex&#125;&#125;)\" wx:else&gt;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 7.6.3 事件 + data- + e.currentTarget.dataset.level 传值（原生方法）12345678910&lt;template&gt;&lt;view data-movie=\"&#123;&#123;movie&#125;&#125;\" @tap=\"showMovie\"&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt;methods = &#123; showMovie (e) &#123; console.log(e.currentTarget.dataset.movie) # 这样就可以获取到data属性绑定的对象 &#125;&#125;&lt;/script&gt; 12345678910111213141516171819202122&lt;template&gt; &lt;view class='levels'&gt; &lt;block wx:for-items=\"&#123;&#123;levels&#125;&#125;\" wx:for-index=\"index\" wx:for-item=\"level\" wx:key=\"index\"&gt; &lt;view class='level' @tap='toPageGrid' data-level='&#123;&#123;level&#125;&#125;'&gt; &lt;text&gt;&#123;&#123;level&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; --&gt; &lt;/view&gt; &lt;!-- block 与 view 不同，block 不会在 DOM 中体现 ，这里 block 只是做循环用的--&gt;&lt;/template&gt;&lt;script&gt; methods = &#123; toPageGrid(e) &#123; // 这里的的 路径不要搞错 let urlStr = './grid?level=' + e.currentTarget.dataSet console.log(e) wx.navigateTo(&#123; url: urlStr &#125;) &#125; &#125;;&lt;/script&gt; ① @tap=&#39;toPageGrid&#39; data-level=&#39;&#39; toPageGrid 这里没有写传值，那么在 js 里面我们可以获取到事件 e 的，并且可以在 html 中以 data-level=&#39;&#39; 这种方式传值，在事件 e 的 e.currentTarget.dataSet 中可以获取到属性值。 ② @tap=&#39;toPageGrid(22)&#39; 如果我们这样传值，将获取不到事件 e， 它就是我们 在html 中传入的 22， e 只是一个参数，就是 7.6.3 节的基本参数传值 上面原生的方法与 wepy 优化之后的方法比较 12&lt;!-- // 原生的事件传参方式: --&gt;&lt;view data-id=\"&#123;&#123;index&#125;&#125;\" data-title=\"wepy\" data-other=\"otherparams\" bindtap=\"tapName\"&gt; Click me! &lt;/view&gt; 1234567Page(&#123; tapName: function (event) &#123; console.log(event.currentTarget.dataset.id)// output: 1 console.log(event.currentTarget.dataset.title)// output: wepy console.log(event.currentTarget.dataset.other)// output: otherparams &#125;&#125;); 123456789&lt;!-- WePY 1.1.8以后的版本，只允许传 string。 --&gt;&lt;view @tap=\"tapName(&#123;&#123;index&#125;&#125;, 'xiaomi', '18')\"&gt; Click me! &lt;/view&gt;&lt;script&gt;methods: &#123; tapName (index, name, age, event) &#123; console.log(index, name, age) // output: 1, xiaomi, 18 直接取值，不需要 event.currentTarget 这样取值了 &#125;&#125;&lt;/script&gt; 也就是说上面 7.6.3 的代码可以写成 12345678910111213141516171819202122&lt;template&gt; &lt;view class='levels'&gt; &lt;block wx:for-items=\"&#123;&#123;levels&#125;&#125;\" wx:for-index=\"index\" wx:for-item=\"level\" wx:key=\"index\"&gt; &lt;view class='level' @tap='toPageGrid(&#123;&#123;level&#125;&#125;)' data-level='&#123;&#123;level&#125;&#125;'&gt; &lt;text&gt;&#123;&#123;level&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/block&gt; --&gt; &lt;/view&gt; &lt;!-- block 与 view 不同，block 不会在 DOM 中体现 ，这里 block 只是做循环用的--&gt;&lt;/template&gt;&lt;script&gt; methods = &#123; toPageGrid(level,e) &#123; // 这里的的 路径不要搞错 let urlStr = './grid?level=' + level // ES6 字符串模板 let urlStr = `./grid?level=$&#123;level&#125;` wx.navigateTo(&#123; url: urlStr &#125;) &#125; &#125;;&lt;/script&gt; 7.6.4 获取 url 的传值获取 url 的传值，注意这里是小程序的传值，不是 web 中 js 的传值，因此这个链接也有告诉我们分二者的传值。 1234567891011// WEB 中的取值 function getUrlParam(name)&#123; // 获取参数 var url = window.location.search; // 正则筛选地址栏 var reg = new RegExp(\"(^|&amp;)\"+ name +\"=([^&amp;]*)(&amp;|$)\"); // 匹配目标参数 var result = url.substr(1).match(reg); //返回参数值 return result ? decodeURIComponent(result[2]) : null; &#125;, 1234567891011&lt;template&gt;&lt;/template&gt;&lt;script&gt;// 小程序取值 onLoad(options) &#123; // 小程序获取 url 传值：options 就是传过来的对象 // let urlStr = './grid?level=' + e.currentTarget.dataset.level + '&amp;id=3' 结果：&#123;level: \"1\", id: \"3\"&#125; // let urlStr = './grid?level=' + e.currentTarget.dataset.level 结果：&#123;level: \"1\"&#125; this.level = options.level &#125;&lt;/script&gt; 7.7 本地存储-页面传值12// A 组件 存值wepy.setStorageSync('level',level) 12// B 组件 取值wepy.getStorageSync('level') 7.8 全局属性传值12345// app.wepy globalData = &#123; userInfo: null, level:1 &#125;; 12// pages 取值this.$parent.globalData.level 7.9 正向传值 与 反向传值7.9.1 本次存储123456// 正向传值：pagesA=&gt;pagesB !!!!!!!!!!!!!!!!!!!!!!!!!// A 组件 存值wepy.setStorageSync('level',2)// B 组件 取值wepy.getStorageSync('level') //2 123456789// 反向传值：pagesB=&gt;pagesA !!!!!!!!!!!!!!!!!!!!!!!!!// B 组件 存值wepy.setStorageSync('level',5)wepy.navigatorBack() // 返回上一页面// A 组件 取值onshow()&#123; wepy.getStorageSync('level') //5&#125; 7.9.2 APP 全局属性123456789// 正向传值：app=&gt;pages !!!!!!!!!!!!!!!!!// app.wepy 存储 globalData = &#123; userInfo: null, level:1 &#125;;// pages 取值this.$parent.globalData.level 123456// 反向传值：pagesA=&gt;pagesB !!!!!!!!!!!!!!!!!!!!!!!!!// pagesA 存贮this.$parent.globalData.level=2// pagesB 取值this.$parent.globalData.level=2 八、wepy 中的指令 以及 class 动态操作8.1 class 的动态绑定1&lt;div class=\"class-a\" :class=\"&#123;true ? 'class-b': 'class-c'&#125;\"&gt;&lt;/div&gt; &lt;!-- 在vue中动态绑定class --&gt; 123&lt;!-- 在wepy中，要使用微信原生的绑定语法其中 class-a 是不需要动态绑定的class， 双括号中才是需要绑定的class --&gt;&lt;view class=\"class-a &#123;&#123;true ? 'class-b' : 'class-c'&#125;&#125;\"&gt; 8.1.1 单双引号的问题，外面单引号里面就双引号啊！！！！！！！！1234567&lt;view class='grid'&gt; &lt;view class='grid-row &#123;&#123;index % 3 == 0 ? 'grid-row-index' : ''&#125;&#125;' wx:for-items=\"&#123;&#123;grids&#125;&#125;\" wx:for-index=\"index\" wx:for-item=\"items\" wx:key=\"index\"&gt; &lt;view class='grid-col &#123;&#123;index % 3 == 0 ? 'grid-col-index' : ''&#125;&#125;' wx:for-items=\"&#123;&#123;items&#125;&#125;\" wx:for-index=\"index\" wx:for-item=\"item\" wx:key=\"index\"&gt; &lt;text&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 123[Error] ERROR IN : src\\pages\\grid.wpy[xmldom error] element parse error: Error: attribute value must after \"=\"@#[line:26,col:9] 错误解决：上面控制台说出了是单双引号的问题，命令行指出了 = 号的问题，是算是一个等号。注意这里一定要外面是双引号，里面是单引号，不然会出错的！！！！！！！！！！！！！！！！！！！！！！！！！！重要，重要，重要，更新如下 1234567&lt;view class='grid'&gt; &lt;view class=\"grid-row &#123;&#123;index % 3 == 0 ? 'grid-row-index' : ''&#125;&#125;\" wx:for-items=\"&#123;&#123;grids&#125;&#125;\" wx:for-index=\"index\" wx:for-item=\"items\" wx:key=\"index\"&gt; &lt;view class=\"grid-col &#123;&#123;index % 3 == 0 ? 'grid-col-index' : ''&#125;&#125;\" wx:for-items=\"&#123;&#123;items&#125;&#125;\" wx:for-index=\"index\" wx:for-item=\"item\" wx:key=\"index\"&gt; &lt;text&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 8.28.2 wx：for 与 repeat 循环渲染组件当想在wx:for中使用组件时，需要使用辅助标签？？？？有子组件的时候采用 repeat 把？？、其他的时候用 原生的 view 都可以的把。 wepy的循环渲染组件，使用 &lt;repeat/&gt;标签（1.4.6 版本新增），或者微信官方的标签(这两个标签不会渲染到视图层）否则就不会渲染成功。（但是用 view 与 wx：for 我成功了呀？？？？） 是不是说有子组件的时候使用 repeat 呀？？？？ 123456&lt;!-- # wepy 提供的repeat组件 --&gt;&lt;view class=\"movie\" wx:if=\"&#123;&#123;movies&#125;&#125;\"&gt; &lt;repeat for=\"&#123;&#123;movies&#125;&#125;\" key=\"index\" index=\"index\" item=\"item\"&gt; &lt;movie :movie.sync=\"item\"&gt;&lt;/movie&gt; &lt;/repeat&gt;&lt;/view&gt; 123456&lt;!-- # 微信提供的block组件 --&gt;&lt;block wx:for=\"&#123;&#123;imgArr&#125;&#125;\" wx:key=\"index\"&gt; &lt;swiper-item class=\"item\" data-movieId=\"&#123;&#123;item.id&#125;&#125;\" @tap=\"showMovieDetail\"&gt; &lt;image class=\"img\" src=\"&#123;&#123;item.img || item.image&#125;&#125;\"&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/block&gt; 8.2.1 问题？ 与 navigator 标签是怎么用的，123456789&lt;view class='levels'&gt; &lt;block for=\"&#123;&#123;levels&#125;&#125;\" key=\"index\" index=\"index\" item=\"level\"&gt; &lt;navigator clas='level' url='./grid?level=&#123;&#123;level&#125;&#125;' open-type=\"navigate\"&gt; &lt;text&gt;&#123;&#123;level&#125;&#125;&lt;/text&gt; &#123;&#123;level&#125;&#125; 这里怎么就不对呢？？？字怎么就不出来了，2 种办法都不出来，navigator 标签中部允许有字？？？？ &lt;/navigator&gt; &lt;/block&gt;&lt;/view&gt; 8.2.2 存在的问题WePY 1.x 版本中，组件使用的是静态编译组件，即组件是在编译阶段编译进页面的，每个组件都是唯一的一个实例，目前只提供简单的 repeat 支持。不支持在 repeat 的组件中去使用 props, computed, watch 等等特性。 123456789 &lt;!-- 错误使用 list.wpy --&gt;&lt;view&gt;&#123;&#123;test.name&#125;&#125;&lt;/view&gt;&lt;!-- // index.wpy --&gt;&lt;repeat for=\"&#123;&#123;mylist&#125;&#125;\"&gt; &lt;!-- 不要在 repeat 标签中使用 修饰 .sync --&gt; &lt;List :test.sync=\"item\"&gt;&lt;/List&gt;&lt;/repeat&gt; 1234567&lt;!-- 推荐用法 // list.wpy --&gt;&lt;repeat for=\"&#123;&#123;mylist&#125;&#125;\"&gt; &lt;view&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;&lt;/repeat&gt;&lt;!-- // index.wpy --&gt;&lt;List :mylist.sync=\"mylist\"&gt;&lt;/List&gt; 自定义事件1.4.8新增可以使用@customEvent.user绑定用户自定义组件事件。其中，@表示事件修饰符，customEvent表示事件名称，.user表示事件后缀。目前有三种后缀： .default: 绑定小程序冒泡事件事件，如bindtap。 .stop: 绑定小程序非冒泡事件，如catchtap。 .user: 绑定用户自定义组件事件，通过$emit触发。 九、项目编辑过程中的问题与优化9.1 后台报错的问题9.1.1 后台 VM17809:2 tabBar[0].pagePath tabBar[1].pagePath 报错12VM17809:2 tabBar[0].pagePath \"pages/index/index\" 需在 pages 数组中tabBar[1].pagePath \"pages/logs/logs\" 需在 pages 数组中 因为 页面与配置不匹配。 app.wpy 中 的 config 对象中的 pages 与 tabBar 要对应起来，路径也不要出错。 9.1.2 unclosed xml attribute 没有闭标签123unclosed xml attribute # 没有闭标签# 这个错误，就是我们复制粘贴的时候不小心，我们而且编辑器也不会提醒我们错误，如果是少了标签 斜杠，倒是简单，像上面的，其实是多了一个`&lt;/view&gt;` 标签，都没有发现。# 其实只要格式化页面，也比较好看出是多了呀一个标签。 9.2 less 与 css 的运用问题9.2.1 让小程序高度 100%12345/*在 app.wpy 文件中使用如下，这样所有的页面都是占据 100% 高度了然后就占满了，当然还有顶部与底部是导航栏的。*/page &#123; height: 100%;&#125; 9.2.2 让小程序高度==宽度1234567891011121314//css 原生.grid-col &#123; width: 10%; height: 10vw; line-height: 10vw;&#125;// 这里是 less， less 中关于运行的，都要使用 ~'' 括起来，// 包括 calc 的公式运行，具体看 less 与 calc 这篇文章。.grid-col &#123; width: 10%; height: ~'10vw'; line-height: ~'10vw';&#125; 9.3 第三方成熟 IDE 或编辑器-代码高亮wepy-cli 框架的项目文件后缀为 .wpy，可共用 Vue（.vue）的高亮规则，但需要手动设置。下面提供一些常见IDE或编辑器中实现代码高亮的相关设置步骤以供参考(也可通过更改文件后缀名的方式来实现高亮，详见后文相关介绍)。 ￥第三方成熟 IDE 或编辑器-代码高亮 wepy-cli 框架的项目文件后缀为 .wpy，可共用 Vue（.vue）的高亮规则，但需要手动设置。下面提供一些常见IDE或编辑器中实现代码高亮的相关设置步骤以供参考(也可通过更改文件后缀名的方式来实现高亮，详见后文相关介绍)。 4.3.1 WebStorm/PhpStorm 1. 打开 Settings，搜索 Plugins，搜索 Vue.js 插件并安装。 2. 打开 Settings，搜索 File Types，找到 Vue.js Template，在 Registered Patterns 添加 *.wpy，即可高亮。 4.3.2 VS Code 1. 在 Code 里先安装 Vue 的语法高亮插件 Vetur。 2. 打开任意 .wpy 文件。 3. 点击右下角的选择语言模式，默认为纯文本。 4. 在弹出的窗口中选择 .wpy 的配置文件关联…。(注意是灰色字体部分，不要去选择有颜色的 VUE，这样只是单个文件的语言选择) 5. 在选择要与 .wpy 关联的语言模式 中选择 Vue。(注意是灰色字体部分，不要去选择有颜色的 VUE，这样只是单个文件的语言选择) 或者我们直接在在 vscode 编辑器设置中去设置。”*.wpy”: “vue” 12345//文件-首选项-设置-settings.jsonsettings.json\"files.associations\": &#123;\"*.wpy\": \"vue\"&#125; 4.3.3 Sublime 1. 打开 Sublime-&gt;Preferences-&gt;Browse Packages..进入用户包文件夹。 2. 在此文件夹下打开 cmd，运行 git clone git@github.com:vuejs/vue-syntax-highlight.git，无 GIT 用户可以直接下载 zip 包解压至当前文件夹。 3. 关闭 .wpy 文件重新打开即可高亮。 其他的第三方编辑器查看官网介绍 9.4 wepy 框架中 自动补全的问题：minapp 插件minapp 插件 在 .wpy 文件中 的 &lt;template&gt; 开标签中使用如 &lt;template lang=&#39;wxml&#39; minapp=&#39;wepy&#39;&gt; 这样就可以自动补全了。不过要注意的是自动补全需要先打尖括号 &lt; 输入标签名，这样才能补全的。 9.4.1 使用 lang=’wxml’ minapp=’wepy’ 发生的问题发现使用了这个之后，文件就不能使用 shift + alt + f 来格式化了。 9.5 API 接口使用的是 wpy 而不是 wxwepy 框架中 wepy 继承了 mina 框架中 wx 对象的方法，因此在 wepy 框架中，所有的 API 都使用 wepy. 9.6 使用 async/await 的使用方式,需要开启 Promise 和 async/await 支持 123456789101112131415// 原生代码:wx.request(&#123; url: 'xxx', success: function (data) &#123; console.log(data); &#125;&#125;);// WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节wepy.request('xxxx').then((d) =&gt; console.log(d));// async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKIasync function request () &#123; let d = await wepy.request('xxxxx'); console.log(d);&#125; 十、代码规范10.1 变量 方法 驼峰式命名，并且注意避免使用 $ 开头。以 $ 开头的标识符为 WePY 框架的内建属性和方法（可在 JavaScript 脚本中以 this. 的方式直接使用，具体请参考 API 文档。） 用 $ 符号会让自己的代码很乱。也不好区分是 变量名/方法名 还是 内建 API 10.2 小程序入口、页面、组件文件名的后缀为 .wpy；外链的文件可以是其它后缀。具体请参考 wpy 文件说明。 10.3 使用 ES6 语法开发。框架在 ES6(ECMAScript 6) 下开发，因此也需要使用 ES6 开发小程序，ES6 中有大量的语法糖可以让我们的代码更加简洁高效。 使用 Promise。 框架默认对小程序提供的 API 全都进行了 Promise 处理，甚至可以直接使用 async/await 等新特性进行开发。启用 Promise方法 10.4 事件绑定语法使用优化语法代替。 @tap=&quot;click&quot; `@tap.stop=”click”` 简化写法原 bindtap=&quot;click&quot; 替换为 @tap=&quot;click&quot;，原 catchtap=&quot;click&quot; 替换为 @tap.stop=&quot;click&quot;。 原 capture-bind:tap=&quot;click&quot; 替换为 @tap.capture=&quot;click&quot;，原 capture-catch:tap=&quot;click&quot; 替换为@tap.capture.stop=&quot;click&quot;。 更多 @ 符用法，参见组件自定义事件。 事件传参使用优化后语法代替。 原 bindtap=&quot;click&quot; data-index={{index}} 替换为 @tap=&quot;click({{index}})&quot;。 10.4 自定义组件命名应 避开 微信原生组件名称以及功能标签 &lt;repeat&gt;。不可以使用 input、button、view、repeat 等微信小程序原生组件名称命名自定义组件；另外也不要使用 WePY 框架定义的辅助标签 repeat 命名。有关 repeat 的详细信息，请参见循环列表组件引用。 10.5 事件名不要重复，不同页面也不要重复原生小程序支持js模块化，但彼此独立，业务代码与交互事件仍需在页面处理。无法实现组件化的松耦合与复用的效果。 例如模板A中绑定一个bindtap=”myclick”，模板B中同样绑定一样bindtap=”myclick”，那么就会影响同一个页面事件。对于数据同样如此。因此，只有通过改变变量或者事件方法，或者给其加不同前缀才能实现绑定不同事件或者不同数据。当页面复杂之后就十分不利于开发维护。 十五、坑 与自己的放错15.1 js 中的逗号，分号，错误，导致 js 代码无法格式化，代码也无法运行123456789[Error] SyntaxError: unknown: Unexpected token, expected , (181:4) 179 | &#125; 180 | # 这里缺少 , 号&gt; 181 | del() &#123; | ^ 182 | this.grids[rowIndex][colIndex] == 0 183 | this.$apply() 184 | &#125; # 当发现自己的 js 代码无法格式化的话，就是自己的代码的逗号缺少或者是分号乱放了，看控制台或者是命令行有报错提示。 15.2 数据类型不对 data 中的数据给弄错了12345thirdScriptErrorCannot read property 'push' of null;at pages/grid page goBack functionTypeError: Cannot read property 'push' of null at _class.goBack (http://127.0.0.1:53324/appservice/pages/grid.js:209:24) at t.config.(anonymous function) (http://127.0.0.1:53324/appservice/npm/wepy/lib/bas 123456789101112131415161718192021222324 data=&#123; fillArray:&#123; rowIndex: null, colIndex: null, value: null &#125;, delArray: &#123; rowIndex: null, colIndex: null, value: null &#125; // 这里的数据设置成 对象了，怎么可以对一个 对象 中 push 元素呢。 &#125; goBack() &#123; let backCellObj = this.fillArray.pop(); if (backCellObj) &#123; let rowIndex = backCellObj.colIndex; let colIndex = backCellObj.colIndex; this.currentCell.currentCellRowIndex = rowIndex; this.currentCell.currentCellColIndex = colIndex; this.grids[rowIndex][colIndex] = 0; this.delArray.push(backCellObj);// push &#125;&#125; 重复路由设置/链接 跳转错误 VM292910:1 appLaunch with an already exist webviewId 45421VM292910:1 appLaunch with an already exist webviewId 4542 答案解析：网址 1234567891011121314151617181920212223242526272829303132333435//在 onLoad 的函数里面先实现了 navigateTo，再实现 redirectTo 就会报错。// 它们功能是一样的，这是一个 压入栈 可以返回一个不可以返回，不能两个都用onLoad()&#123; wx.navigateTo(&#123; url:'./page1' &#125;) wx.redirectTo(&#123; url:'./page2' &#125;)&#125;// 下面这样也是错误的。因为 onLoad 的执行顺序比 onReady 优先。onLoad()&#123; wx.navigateTo(&#123; url:'./page1' &#125;)&#125;onReady()&#123; wx.redirectTo(&#123; url:'./page2' &#125;)&#125;// 这样写就对了，先实现了redirectTo，再实现navigateTo就不会报这个错误。 为啥？？？？？ wx.redirectTo(&#123; url:'./page2' &#125;) wx.navigateTo(&#123; url:'./page1' &#125;)// 或者路由重复设置并不是写在一个页面中，是否在 app.js 中重复写了路由设置，链接跳转了、//如果不是上面的原因，就是把微信开发者工具的IDE关闭重新启动就可以了，目前微信开发者工具的IDE实在是不够完善，也会存在一些未知的问题，所以以后如果遇到一些奇怪的问题，或者实在找不到原因的，就直接重启微信开发者工具试试。 微信开发者工具 预览 真机测试预览的效果是不全的，调试的话还是使用真机测试，就比如说有的时候 class 是三元表达式动态绑定的，仅仅是预览的话效果可能不会表现出来，但是实际上功能已经做好了，就是预览没有把自己完整的代码上传，而真机测试是完整的代码。 类似 问题的 gitHub 网址，就是开启了代码上传 自动压缩，那么有部分代码可能就不会得到上传，自然效果就不会出来了。","tags":[]},{"title":"API 接口","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】wx-API 接口/","text":"一、前言API 是微信小程序的 API 接口，原生 MINA 框架下 API 接口都是在 wx 这个对象上，在 wepy 框架使用的是 wepy 对象，因为 wepy 对象继承了 wx 对象的所有属性与方法。 并且 wepy 还优化了 wx 的某些个方法。具体看 wepy-cli 的框架中的 API 二、网络2.1 下载2.1.1 wx.downloadFile 下载文件资源到本地。客户端直接发起一个 HTTPS GET 请求，返回文件的本地临时路径。使用前请注意阅读相关 使用说明。 注意：请在服务端响应的 header 中指定合理的 Content-Type 字段，以保证客户端正确处理文件类型。 12345678910111213141516171819202122// 返回值是一个 DownloadTask 实例 对象：一个可以监听下载进度变化事件和取消下载的对象const downloadTask = wx.downloadFile(&#123; url: 'https://example.com/audio/123', //下载资源的 url 必填 header:&#123;&#125;,//HTTP 请求的 Header，Header 中不能设置 Referer 否 filePath:'',//指定文件下载后存储的路径 否 success (res) &#123; // 只要服务器有响应数据，就会把响应内容写入文件并进入 success 回调，业务需要自行判断是否下载到了想要的内容 //res.statusCode // number开发者服务器返回的 HTTP 状态码 //res.tempFilePath//string 临时文件路径。如果没传入 filePath 指定文件存储路径，则下载后的文件会存储到一个临时文件 if (res.statusCode === 200) &#123; wx.playVoice(&#123; filePath: res.tempFilePath &#125;) &#125; &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;) 2.1.1 DownloadTask.abort（） 中断下载任务 无参数语法： 12const downloadTask = wx.downloadFile(&#123;....&#125;)downloadTask.abort() 2.1.1 DownloadTask.offHeadersReceived 取消监听 HTTP Response Header 事件。会比请求完成事件更早12345const downloadTask = wx.downloadFile(&#123;....&#125;)downloadTask.offHeadersReceived(()=&gt;&#123; //function callback //HTTP Response Header 事件的回调函数&#125;) 2.1.1 DownloadTask.offProgressUpdate 取消监听下载进度变化事件1234const downloadTask = wx.downloadFile(&#123;....&#125;)downloadTask.offProgressUpdate(()=&gt;&#123; //function callback&#125;) 2.1.1 DownloadTask.onHeadersReceived 监听 HTTP Response Header 事件。会比请求完成事件更早12345678const downloadTask = wx.downloadFile(&#123;....&#125;)downloadTask.onHeadersReceived((res)=&gt;&#123; //function callback //res.header:obj 开发者服务器返回的 HTTP Response Header /* &#123; // &#125; */&#125;) 2.1.1 DownloadTask.onProgressUpdate 监听下载进度变化事件123456const downloadTask = wx.downloadFile(&#123;....&#125;)downloadTask.onProgressUpdate((res)=&gt;&#123; res.progress//80, //下载进度百分比 res.totalBytesWritten//1024, //已经下载的数据长度，单位 Bytes res.totalBytesExpectedToWrite//5000,//预期需要下载的数据总长度，单位 Bytes&#125;) 2.2 mDNS 服务器/IP 使用在局域网内，你要通过一台主机和其他主机进行通信，你需要知道对方的 ip 地址，但是有些时候，你并不知道对方的 ip 地址，因为一般使用 DHCP 动态分配 ip 地址的局域网内，各个主机的 IP 地址是由 DHCP 服务器来帮你分配 IP 地址的。所以在很多情况下，你要知道对方的 IP 地址是比较麻烦的。 mDNS 的工作原理：首先，在 IP 协议里规定了一些保留地址，其中有一个是 224.0.0.251，对应的 IPv6 地址是 [FF02::FB]。mDNS 协议规定了一个端口，5353。mDNS 基于 UDP 协议。 每个进入局域网的主机，如果开启了 mDNS 服务的话，都会向局域网内的所有主机组播一个消息，我是谁，和我的 IP 地址是多少。然后其他也有该服务的主机就会响应，也会告诉你，它是谁，它的 IP 地址是多少。 2.2.1 wx.offLocalServiceDiscoveryStop 取消监听 mDNS 服务停止搜索的事件123wx.offLocalServiceDiscoveryStop(()=&gt;&#123; //mDNS 服务停止搜索的事件的回调函数&#125;) 2.2.1 wx.offLocalServiceFound 取消监听 mDNS 服务发现的事件123wx.offLocalServiceFound(()=&gt;&#123; //mDNS 服务发现的事件的回调函数&#125;) 2.2.1 wx.offLocalServiceLost 取消监听 mDNS 服务离开的事件123wx.offLocalServiceLost(()=&gt;&#123; //mDNS 服务离开的事件的回调函数&#125;) 2.2.1 wx.offLocalServiceResolveFail 取消监听 mDNS 服务解析失败的事件123wx.offLocalServiceResolveFail(()=&gt;&#123; //mDNS 服务解析失败的事件的回调函数&#125;) 2.2.1 wx.onLocalServiceDiscoveryStop 监听 mDNS 服务停止搜索的事件123wx.onLocalServiceDiscoveryStop(()=&gt;&#123; //mDNS 服务停止搜索的事件的回调函数&#125;) 2.2.1 wx.onLocalServiceFound 监听 mDNS 服务发现的事件1234567wx.onLocalServiceFound((res)=&gt;&#123; //mDNS 服务发现的事件的回调函数 res.serviceType:'',//服务的类型 res.serviceName:'',//服务的名称 res.ip:'',//服务的 ip 地址 res.port:8080//服务的端口&#125;) 2.2.1 wx.onLocalServiceLost 监听 mDNS 服务离开的事件12345wx.onLocalServiceLost((res)=&gt;&#123; //mDNS 服务离开的事件的回调函数 res.serviceType:'',//服务的类型 res.serviceName:''//服务的名称&#125;) 2.2.1 wx.onLocalServiceResolveFail 监听 mDNS 服务解析失败的事件12345wx.onLocalServiceResolveFail((res)=&gt;&#123; //mDNS 服务解析失败的事件的回调函数 res.serviceType:'',//服务的类型 res.serviceName:''//服务的名称&#125;) 2.2.1 wx.startLocalServiceDiscovery 开始搜索局域网下的 mDNS 服务。搜索的结果会通过 wx.onLocalService* 事件返回。12345678910111213141516wx.startLocalServiceDiscovery(&#123; //// 当前手机所连的局域网下有一个 _http._tcp. 类型的服务 serviceType:'_http._tcp.',//string 服务的类型 必填 success()&#123; // &#125;, fail(res)&#123; // console.log(res.errMsg) // string 错误信息 //值为：'invalid param' 表示： serviceType 为空 //值为：'scan task already exist' //表示：在当前 startLocalServiceDiscovery 发起的搜索未停止的情况下，再次调用 startLocalServiceDiscovery &#125;, complete()&#123; // &#125;) 注意 wx.startLocalServiceDiscovery 是一个消耗性能的行为，开始 30 秒后会自动 stop 并执行 wx.onLocalServiceDiscoveryStop 注册的回调函数。 在调用 wx.startLocalServiceDiscovery 后，在这次搜索行为停止后才能发起下次 wx.startLocalServiceDiscovery。停止本次搜索行为的操作包括调用 wx.stopLocalServiceDiscovery 和 30 秒后系统自动 stop 本次搜索。 2.2.1 wx.stopLocalServiceDiscovery 停止搜索 mDNS 服务12345678910111213wx.stopLocalServiceDiscovery(&#123; //// 当前手机所连的局域网下有一个 _http._tcp. 类型的服务 serviceType:'_http._tcp.',//string 服务的类型 必填 success()&#123; // &#125;, fail(res)&#123; // console.log(res.errMsg) // 得到值为：'task not found' 说明：在当前没有处在搜索服务中的情况下调用 stopLocalServiceDiscovery &#125;, complete()&#123; // &#125;) 2.3 发起请求 （请求后端数据）网络 2.3.1 wx.request 发起 HTTPS 网络请求。1234567891011121314151617181920212223242526272829303132333435// 返回一个 请求任务对象const request = wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 开发者服务器接口地址 必填 data: &#123; // data ：string/object/ArrayBuffer 请求的参数 否 x: '',// 可以是字符串，可以是对象，可以是 JavaScript 操作二进制数据的一个接口（ArrayBuffer 对象）。 y: '' &#125;, // 请求头，设置请求的 header， ① header 中不能设置 Referer， ② content-type 默认为 application/json 否 header: &#123; 'content-type': 'application/json' // 默认值 &#125;, method:'GET',//HTTP 请求方法 默认值为 'GET' 否 ,和法制学习 http 文档，看后端给的文档 dataType:'json',//返回的数据格式 默认值 'json' 否 //返回的数据为 JSON 格式，返回后自行会对返回的数据进行一次 JSON.parse，不需要开发者去解析（只有 JSON 格式） // 其他格式不对返回的内容进行 JSON.parse responseType:'text',//响应的数据类型 默认值 'text' 否 //① text 响应的数据为文本, ② arraybuffer 响应的数据为 ArrayBuffer success (res) &#123; console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header &#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail(res)&#123; // &#125;/* , complete(res)&#123; // &#125; */&#125;) 2.3.1.1 ArrayBuffer 对象(就是各种类数组对象)ArrayBuffer 对象 网址是 JavaScript 操作二进制数据的一个接口，代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。 rrayBuffer 有两种视图，一种是 TypedArray 视图，另一种是 DataView 视图。 1234567891011目前，TypedArray 视图一共包括 9 种类型，每一种视图都是一种构造函数。Int8Array： 8 位有符号整数，长度 1 个字节。Uint8Array： 8 位无符号整数，长度 1 个字节。Uint8ClampedArray： 8 位无符号整数，长度 1 个字节，溢出处理不同。Int16Array： 16 位有符号整数，长度 2 个字节。Uint16Array： 16 位无符号整数，长度 2 个字节。Int32Array： 32 位有符号整数，长度 4 个字节。Uint32Array： 32 位无符号整数，长度 4 个字节。Float32Array： 32 位浮点数，长度 4 个字节。Float64Array： 64 位浮点数，长度 8 个字节。 2.3.1.2 http 文档学习请求头请求头 学习-24.1-http-rumen/) 2.3.1.3 data 参数说明最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String 。转换规则如下： 对于 GET 方法的数据，会将数据转换成 query string（encodeURIComponent(k)=encodeURIComponent(v)&amp;encodeURIComponent(k)=encodeURIComponent(v)...） 对于 POST 方法且 header[‘content-type’] 为 application/json 的数据，会对数据进行 JSON 序列化 对于 POST 方法且 header[‘content-type’] 为 application/x-www-form-urlencoded 的数据，会将数据转换成 query string `（encodeURIComponent(k)=encodeURIComponent(v)&amp;encodeURIComponent(k)=encodeURIComponent(v)…） 2.3.1 RequestTask.abort 中断请求任务12const request = wx.request(&#123;....&#125;)request.abort() //中断请求，无参数 2.3.1 RequestTask.offHeadersReceived 取消监听 HTTP Response Header 事件。会比请求完成事件更早1234const request = wx.request(&#123;....&#125;)request.offHeadersReceived(()=&gt;&#123; //HTTP Response Header 事件的回调函数 //&#125;) 2.3.1 RequestTask.onHeadersReceived 监听 HTTP Response Header 事件。会比请求完成事件更早1234const request = wx.request(&#123;....&#125;)request.onHeadersReceived((res)=&gt;&#123; //HTTP Response Header 事件的回调函数 //res.header &#123;....&#125; 开发者服务器返回的 HTTP Response Header&#125;) 2.4 上传2.4.1 wx.uploadFile 将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。使用前请注意阅读相关说明。 使用说明。 123456789101112131415161718192021222324252627282930313233343536wx.chooseImage(&#123; success (res) &#123; const tempFilePaths = res.tempFilePaths // 返回一个 上传任务对象 const uploadFile = wx.uploadFile(&#123; url: 'https://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址 开发者服务器地址 必填 filePath: tempFilePaths[0],// 要上传文件资源的路径 必填 name: 'file', //文件对应的 key，开发者在服务端可以通过这个 key 获取文件的二进制内容 必填 // 请求头，设置请求的 header， ① header 中不能设置 Referer， ② content-type 默认为 application/json 否 header: &#123; // 否 'content-type': 'application/json' // 默认值 &#125;, formData: &#123; //HTTP 请求中其他额外的 form data 否 'user': 'test' &#125;, success (res)&#123; const data = res.data console.log(res.data)//'' 开发者服务器返回的数据 console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 &#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail(res)&#123; // &#125;/* , complete(res)&#123; // &#125; */ &#125;) &#125;&#125;) 2.4.2 UploadTask.abort 中断上传任务12const uploadFile = wx.uploadFile(&#123;....&#125;)uploadFile.abort() //中断上传任务，无参数 2.4.3 UploadTask.offHeadersReceived 取消监听 HTTP Response Header 事件。会比请求完成事件更早1234const uploadFile = wx.uploadFile(&#123;....&#125;)uploadFile.offHeadersReceived(()=&gt;&#123; //HTTP Response Header 事件的回调函数 //&#125;) 2.4.4 UploadTask.offProgressUpdate 取消监听上传进度变化事件1234const uploadFile = wx.uploadFile(&#123;....&#125;)uploadFile.offProgressUpdate(()=&gt;&#123; //上传进度变化事件的回调函数 //&#125;) 2.4.5 UploadTask.onHeadersReceived 监听 HTTP Response Header 事件。会比请求完成事件更早1234const uploadFile = wx.uploadFile(&#123;....&#125;)uploadFile.onHeadersReceived((res)=&gt;&#123; //HTTP Response Header 事件的回调函数 //res.header &#123;....&#125; 开发者服务器返回的 HTTP Response Header&#125;) 2.4.6 UploadTask.onProgressUpdate 监听上传进度变化事件123456const uploadFile = wx.uploadFile(&#123;....&#125;)uploadFile.onHeadersReceived((res)=&gt;&#123; //上传进度变化事件的回调函数 res.progress //80 上传进度百分比 res.totalBytesSent //80 已经上传的数据长度，单位 Bytes res.totalBytesExpectedToSend//200 预期需要上传的数据总长度，单位 Bytes&#125;) 2.5 WebSocket并发数 1.7.0 及以上版本，最多可以同时存在 5（小游戏）/2（小程序）个 WebSocket 连接。1.7.0 以下版本，一个小程序同时只能有一个 WebSocket 连接，如果当前已存在一个 WebSocket 连接，会自动关闭该连接，并重新创建一个 WebSocket 连接。 wx.connectSocket 创建一个 WebSocket 连接。 wx.onSocketOpen 监听 WebSocket 连接打开事件 wx.closeSocket 关闭 WebSocket 连接，需要先用wx.onSocketOpen 监听 WebSocket 连接打开事件，才能关闭 wx.onSocketClose 监听 WebSocket 连接关闭事件 wx.onSocketError 监听 WebSocket 错误事件 wx.onSocketMessage 监听 WebSocket 接受到服务器的消息事件 wx.sendSocketMessage 通过 WebSocket 连接发送数据。需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。 使用前请注意阅读相关说明。网络使用说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const socketOpen = falseconst socketMsgQueue = []// ① 返回一个 WebSocket 任务const socketTask = wx.connectSocket(&#123; url: 'wss://example.qq.com', //开发者服务器 wss 接口地址 必填 data:&#123; // 这个好像官网没有说啊？？？？官网写的文档有问题的啊？？？所以别的的接口应该也是可以传参的把？？？ x: '',// 比如 navigateBack 没有写传参，我想应该也是可以传参的？？？？？？ y: '' &#125;, header:&#123; //HTTP Header，Header 中不能设置 Referer 否 'content-type': 'application/json' &#125;, protocols: ['protocol1'], //子协议数组 否 method:\"GET\",//这个好像官网没有说啊？？？？ success()&#123; // &#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail()&#123; // &#125;/* , complete()&#123; // &#125; */&#125;)//注意这里有时序问题，//如果 wx.connectSocket 还没回调 wx.onSocketOpen，而先调用 wx.closeSocket，那么就做不到关闭 WebSocket 的目的。//必须在 WebSocket 打开期间调用 wx.closeSocket 才能关闭。// ② 监测 是否是链接状态wx.onSocketOpen((res)=&gt; &#123; //res.header//object 连接成功的 HTTP 响应 Header 2.0.0 socketOpen = true for (let i = 0; i &lt; socketMsgQueue.length; i++)&#123; //sendSocketMessage(socketMsgQueue[i]) 当然可以把这段写到外面的 作为一个函数调用 if (socketOpen) &#123; //通过 WebSocket 连接发送数据。需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。也是时序的问题 wx.sendSocketMessage(&#123; data:msg,// string/ArrayBuffer 需要发送的内容 必填 success()&#123;&#125;,// // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail()&#123;&#125;,// complete()&#123;&#125; &#125;) &#125; else &#123; socketMsgQueue.push(msg) &#125; &#125; socketMsgQueue = [] wx.closeSocket(&#123; code:1000,//一个数字值表示关闭连接的状态号，表示连接被关闭的原因。 默认值 1000，表示正常关闭连接 否 reason:'',//一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于 123 字节的 UTF-8 文本（不是字符） 否 success()&#123;&#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail()&#123;&#125;, complete()&#123;&#125; &#125;)&#125;)wx.onSocketClose((res)=&gt; &#123; console.log('WebSocket 已关闭！')&#125;)//下面这两个是应该写在这里的么？？？正确的应该是怎么样的wx.onSocketError((res)=&gt;&#123; //WebSocket 错误事件的回调函数 res.errMsg//''错误信息&#125;)wx.onSocketMessage((res)=&gt;&#123; res.data//string/ArrayBuffer 服务器返回的消息 //WebSocket 接受到服务器的消息事件的回调函数&#125;) 2.5.4 SocketTask.close，SocketTask.onClose，SocketTask.onError，SocketTask.onMessage，SocketTask.onOpen，SocketTask.send这里就是使用实例的方法来 监控操作 SocketTask 对象，不是使用 API 接口咯。功能与 wx 对象的方法是一样的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const socketOpen = falseconst socketMsgQueue = []// ① 创建/返回一个 WebSocket 任务const socketTask = wx.connectSocket(&#123; url: 'wss://example.qq.com', //开发者服务器 wss 接口地址 必填 data:&#123; // 这个好像官网没有说啊？？？？官网写的文档有问题的啊？？？所以别的的接口应该也是可以传参的把？？？ x: '',// 比如 navigateBack 没有写传参，我想应该也是可以传参的？？？？？？ y: '' &#125;, header:&#123; //HTTP Header，Header 中不能设置 Referer 否 'content-type': 'application/json' &#125;, protocols: ['protocol1'], //子协议数组 否 method:\"GET\",//这个好像官网没有说啊？？？？ success()&#123; // &#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail()&#123; // &#125;/* , complete()&#123; // &#125; */&#125;)//注意这里有时序问题，//如果 wx.connectSocket 还没回调 wx.onSocketOpen，而先调用 wx.closeSocket，那么就做不到关闭 WebSocket 的目的。//必须在 WebSocket 打开期间调用 wx.closeSocket 才能关闭。// ② 监测 是否是链接状态//wx.onSocketOpen((res)=&gt; &#123;&#125;) 上面的 API 是使用 wx.xxxx 这里换成 socketTask.xxxx 实例对象的 方法socketTask.onOpen((res)=&gt;&#123; //res.header//object 连接成功的 HTTP 响应 Header 2.0.0 socketOpen = true for (let i = 0; i &lt; socketMsgQueue.length; i++)&#123; //sendSocketMessage(socketMsgQueue[i]) 当然可以把这段写到外面的 作为一个函数调用 if (socketOpen) &#123; //通过 WebSocket 连接发送数据。需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。也是时序的问题 socketTask.send(&#123; data:msg,// string/ArrayBuffer 需要发送的内容 必填 success()&#123;&#125;,// // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail()&#123;&#125;,// complete()&#123;&#125; &#125;) &#125; else &#123; socketMsgQueue.push(msg) &#125; &#125; socketMsgQueue = [] socketTask.close(&#123; code:1000,//一个数字值表示关闭连接的状态号，表示连接被关闭的原因。 默认值 1000，表示正常关闭连接 否 reason:'',//一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于 123 字节的 UTF-8 文本（不是字符） 否 success()&#123;&#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail()&#123;&#125;, complete()&#123;&#125; &#125;)&#125;)wx.onClose((res)=&gt; &#123; console.log('WebSocket 已关闭！')&#125;)//下面这两个是应该写在这里的么？？？正确的应该是怎么样的wx.onError((res)=&gt;&#123; //WebSocket 错误事件的回调函数 res.errMsg//''错误信息&#125;)wx.onMessage((res)=&gt;&#123; res.data//string/ArrayBuffer 服务器返回的消息 //WebSocket 接受到服务器的消息事件的回调函数&#125;) 三、媒体3.1 音频 AudioContext 对象 （是单个组件的音频对象？？？？？）3.1.1 wx.createAudioContext 创建音频对象创建 音频 audio 上下文 AudioContext 对象。（返回一个 AudioContext 对象 12345&lt;audio poster=\"&#123;&#123;poster&#125;&#125;\" name=\"&#123;&#123;name&#125;&#125;\" author=\"&#123;&#123;author&#125;&#125;\" src=\"&#123;&#123;src&#125;&#125;\" id=\"myAudio\" controls loop&gt;&lt;/audio&gt;&lt;button type=\"primary\" bindtap=\"audioPlay\"&gt;播放&lt;/button&gt;&lt;button type=\"primary\" bindtap=\"audioPause\"&gt;暂停&lt;/button&gt;&lt;button type=\"primary\" bindtap=\"audio14\"&gt;设置当前播放时间为14秒&lt;/button&gt;&lt;button type=\"primary\" bindtap=\"audioStart\"&gt;回到开头&lt;/button&gt; 1wx.createAudioContext('myAudio',this)// this ：在自定义组件下，当前组件实例的this，以操作组件内 &lt;audio&gt; 组件 是可选参数 3.1.2 wx.getAvailableAudioSources 获取当前支持的音频输入源1234567891011121314wx.getAvailableAudioSources(&#123; success(res)&#123; //res.audioSources:['']//支持的音频输入源列表，可在 RecorderManager.start() 接口中使用。 &#125;, // 或者是可以写成下面这样的箭头函数 // success:(res)=&gt;&#123; // console.log(res.data)//string/Object/Arraybuffer 开发者服务器返回的数据 // console.log(res.statusCode)//200 开发者服务器返回的 HTTP 状态码 // console.log(res.header)//&#123;&#125; 开发者服务器返回的 HTTP Response Header // &#125; fail(res)&#123; &#125;,// complete(res)&#123;&#125;//&#125;) 返回值定义参考res.audioSources 的合法值 auto 自动设置，默认使用手机麦克风，插上耳麦后自动切换使用耳机麦克风，所有平台适用 buildInMic 手机麦克风，仅限 iOS headsetMic 耳机麦克风，仅限 iOS mic 麦克风（没插耳麦时是手机麦克风，插耳麦时是耳机麦克风），仅限 Android camcorder 同 mic，适用于录制音视频内容，仅限 Android voice_communication 同 mic，适用于实时沟通，仅限 Android voice_recognition 同 mic，适用于语音识别，仅限 Android 3.1.3 wx.playVoice、wx.pauseVoice、wx.stopVoice 暂停/播放/停止 正在播放的语音 wx.playVoice 开始播放语音。同时只允许一个语音文件正在播放，如果前一个语音文件还没播放完，将中断前一个语音播放。 wx.pauseVoice: 暂停正在播放的语音。再次调用 wx.playVoice 播放同一个文件时，会从暂停处开始播放。如果想从头开始播放，需要先调用 wx.stopVoice。 wx.stopVoice 结束播放语音。下次播放同一个文件，也只会从头开始播放。 1234567891011121314151617181920212223242526272829//wx.startRecord 开始录音wx.startRecord(&#123; success (res) &#123; const tempFilePath = res.tempFilePath //暂停正在播放的语音 wx.playVoice(&#123; filePath: tempFilePath,//string 需要播放的语音文件的文件路径 必填 duration:60,//指定录音时长，到达指定的录音时长后会自动停止录音，单位：秒 否 默认值 60 success(res)&#123;&#125;,//否 fail()&#123;&#125;,//否 /* complete()&#123;&#125; */ // 成功与失败都会执行 &#125;) // 为什么这里用 延迟执行？？？？？？ setTimeout(() =&gt; &#123; wx.pauseVoice(&#123; success(res)&#123;&#125;,//否 fail()&#123;&#125;,//否 /* complete()&#123;&#125; */ // 成功与失败都会执行 &#125;) // 暂停或者是停止 wx.stopVoice(&#123; success(res)&#123;&#125;,//否 fail()&#123;&#125;,//否 /* complete()&#123;&#125; */ // 成功与失败都会执行 &#125;) &#125;, 5000) &#125;&#125;) 3.1.4 AudioContext 音频对象的方法AudioContext.pause、 AudioContext.play、AudioContext.seek、AudioContext.setSrc 对象的方法，与上面的 wx 接口的方法功能一样的。 AudioContext.pause 暂停音频 AudioContext.play 播放音频 AudioContext.seek 跳转到指定位置 AudioContext.setSrc 设置音频地址 1234567891011121314151617181920212223242526272829303132&lt;!-- audio.wxml --&gt;&lt;audio src=\"&#123;&#123;src&#125;&#125;\" id=\"myAudio\" &gt;&lt;/audio&gt;&lt;button type=\"primary\" bindtap=\"audioPlay\"&gt;播放&lt;/button&gt;&lt;button type=\"primary\" bindtap=\"audioPause\"&gt;暂停&lt;/button&gt;&lt;button type=\"primary\" bindtap=\"audio14\"&gt;设置当前播放时间为14秒&lt;/button&gt;&lt;button type=\"primary\" bindtap=\"audioStart\"&gt;回到开头&lt;/button&gt;// audio.jsPage(&#123; onReady (e) &#123; // 使用 wx.createAudioContext 获取 audio 上下文 context // 创建音频对象 wx.createAudioContext('idNamd',this) this.audioCtx = wx.createAudioContext('myAudio') // 设置音频地址 AudioContext.setSrc('url') this.audioCtx.setSrc('http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&amp;fromtag=46') this.audioCtx.play()// 播放音频 无参数 &#125;, data: &#123; src: '' &#125;, audioPlay () &#123; this.audioCtx.play()// 播放音频 无参数 &#125;, audioPause () &#123; this.audioCtx.pause()// 暂停音频 无参数 &#125;, audio14 () &#123; this.audioCtx.seek(14)// 跳转位置，单位 s AudioContext.seek(number) 跳转到几秒的时间播放 &#125;, audioStart () &#123; this.audioCtx.seek(0) //从头开始播放 &#125;&#125;) 3.2 音频 InnerAudioContext 对象 （是整个小程序的音频对象？？？？？）3.2.1 wx.createInnerAudioContext 创建 内部音频对象创建 内部音频 audio 上下文 InnerAudioContext 对象。（返回一个 内部 InnerAudioContext 对象） 1wx.createInnerAudioContext() //无参数 3.2.2 wx.setInnerAudioOption 设置 InnerAudioContext 的播放选项。设置之后对当前小程序全局生效。1234567wx.setInnerAudioOption(&#123; mixWithOther:true,//是否与其他音频混播，设置为 true 之后，不会终止其他应用或微信内的音乐 否 默认值为 true obeyMuteSwitch:true,//（仅在 iOS 生效）是否遵循静音开关，设置为 false 之后，即使是在静音模式下，也能播放声音 否 默认值为 true success(res)&#123;&#125;,//否 fail()&#123;&#125;,//否 /* complete()&#123;&#125; */ // 成功与失败都会执行&#125;) 3.2.3 内部音频对象的方法 InnerAudioContext.destroy 销毁当前实例 无参数 InnerAudioContext.offCanplay 取消监听音频进入可以播放状态的事件。但不保证后面可以流畅播放 回调函数 InnerAudioContext.offEnded 取消监听音频自然播放至结束的事件 回调函数 InnerAudioContext.offError 取消监听音频播放错误事件 回调函数 InnerAudioContext.offPause 取消监听音频暂停事件 回调函数 InnerAudioContext.offPlay 取消监听音频播放事件 回调函数 InnerAudioContext.offSeeked 取消监听音频完成跳转操作的事件 回调函数 InnerAudioContext.offSeeking 取消监听音频进行跳转操作的事件 回调函数 InnerAudioContext.offStop 取消监听音频停止事件 回调函数 InnerAudioContext.offTimeUpdate 取消监听音频播放进度更新事件 InnerAudioContext.offWaiting 取消监听音频加载中事件。当音频因为数据不足，需要停下来加载时会触发 回调函数 InnerAudioContext.onCanplay 监听音频进入可以播放状态的事件。但不保证后面可以流畅播放 回调函数 InnerAudioContext.onEnded 监听音频自然播放至结束的事件 回调函数 InnerAudioContext.onError 监听音频播放错误事件 回调函数 audioContext.onError(()=&gt;{res.errCode// 10001 系统错误 10002 网络错误 10003 文件错误 10004 格式错误 -1 未知错误 }) InnerAudioContext.onPause 监听音频暂停事件 回调函数 InnerAudioContext.onPlay 监听音频播放事件 回调函数 InnerAudioContext.onSeeked 监听音频完成跳转操作的事件 回调函数 InnerAudioContext.onSeeking 监听音频进行跳转操作的事件 回调函数 InnerAudioContext.onStop 监听音频停止事件 回调函数 InnerAudioContext.onTimeUpdate 监听音频播放进度更新事件 回调函数 InnerAudioContext.onWaiting 监听音频加载中事件。当音频因为数据不足，需要停下来加载时会触发 回调函数 InnerAudioContext.pause 暂停。暂停后的音频再播放会从暂停处开始播放 无参数 InnerAudioContext.play 播放 无参数 InnerAudioContext.seek 跳转到指定位置 参数为 s InnerAudioContext.stop 停止。停止后的音频再播放会从头开始播放。 无参数 12345678910const innerAudioContext = wx.createInnerAudioContext()// ① 创建内部 音频对象 返回值赋值给 innerAudioContext 对象innerAudioContext.autoplay = true // data 数据innerAudioContext.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&amp;fromtag=46' // data 数据innerAudioContext.onPlay(() =&gt; &#123;//② 监听音频 播放音频 console.log('开始播放')&#125;)innerAudioContext.onError((res) =&gt; &#123;//③ 监听 音频回调错误 输出错误信息 console.log(res.errMsg)//这个有么？？？ console.log(res.errCode)&#125;) 3.3 背景音频 BackgroundAudioManager 对象 （背景音频对象）3.3.1 创建 背景音频 BackgroundAudioManager 对象1wx.getBackgroundAudioManager() //无参数 获取全局唯一的背景音频管理器。 小程序切入后台，如果音频处于播放状态，可以继续播放。但是后台状态不能通过调用API操纵音频的播放状态。 从微信客户端6.7.2版本开始，若需要在小程序切后台后继续播放音频，需要在 app.json 中配置 requiredBackgroundModes 属性。开发版和体验版上可以直接生效，正式版还需通过审核。 3.3.2 背景音频 BackgroundAudioManager 对象 wx.API 接口方法 wx.getBackgroundAudioPlayerState 获取后台音乐播放状态 success，fail ，complete 三个回调函数 wx.onBackgroundAudioPause 监听音乐暂停事件。 回调函数 wx.onBackgroundAudioPlay 监听音乐播放事件。回调函数 wx.onBackgroundAudioStop 监听音乐停止事件。回调函数 wx.pauseBackgroundAudio 暂停播放音乐。 success，fail ，complete 三个回调函数 wx.playBackgroundAudio 使用后台播放器播放音乐。三个回调函数，还有其他必填与不必填的属性 对于微信客户端来说，只能同时有一个后台音乐在播放。当用户离开小程序后，音乐将暂停播放；当用户在其他小程序占用了音乐播放器，原有小程序内的音乐将停止播放。 wx.seekBackgroundAudio 控制音乐播放进度。三个回调函数，还有个必填的位置属性 wx.stopBackgroundAudio 停止播放音乐。三个回调函数， 123456789101112131415161718192021222324252627282930313233343536373839wx.getBackgroundAudioPlayerState(&#123; success (res) &#123; const status = res.status// number 播放状态 0:暂停中 1:播放中 2：没有音乐播放 const dataUrl = res.dataUrl//'' 歌曲数据链接，只有在音乐播放中时返回 const currentPosition = res.currentPosition//number 选定音频的播放位置（单位：s），只有在音乐播放中时返回 const duration = res.duration//number 选定音频的长度（单位：s），只有在音乐播放中时返回 const downloadPercent = res.downloadPercent//number 音频的下载进度百分比，只有在音乐播放中时返回 &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.pauseBackgroundAudio(&#123; success (res) &#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.playBackgroundAudio(&#123; dataUrl: '',//音乐链接，目前支持的格式有 m4a, aac, mp3, wav 必填 title: '',//音乐标题 否 coverImgUrl: '',//封面URL 否 success (res) &#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.seekBackgroundAudio(&#123; position: 30,//s success (res) &#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.stopBackgroundAudio(&#123; success (res) &#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 3.3.2 背景音频 BackgroundAudioManager 对象 的方法 .onCanplay 监听背景音频进入可播放状态事件。但不保证后面可以流畅播放 回调函数 .onEnded 监听背景音频自然播放结束事件 回调函数 .onError 监听背景音频播放错误事件 回调函数 .onNext 监听用户在系统音乐播放面板点击下一曲事件（仅iOS） 回调函数 .onPause 监听背景音频暂停事件 回调函数 .onPlay 监听背景音频播放事件 回调函数 .onPrev 监听用户在系统音乐播放面板点击上一曲事件（仅iOS） 回调函数 .onSeeked 监听背景音频完成跳转操作事件 回调函数 .onSeeking 监听背景音频开始跳转操作事件 回调函数 .onStop 监听背景音频停止事件 回调函数 .onTimeUpdate 监听背景音频播放进度更新事件 回调函数 .onWaiting 监听音频加载中事件。当音频因为数据不足，需要停下来加载时会触发 回调函数 .pause 暂停音乐 无参数错误码 10001 系统错误 10002 网络错误 10003 文件错误 10004 格式错误 -1 未知错误 .play 播放音乐，无参数 ，错误码同 .pause .seek 跳转到指定位置 参数：跳转的位置，单位 s。精确到小数点后 3 位，即支持 ms 级别精确度。 错误码同 .pause .stop 停止音乐 错误码同 .pause 123456789101112const backgroundAudioManager = wx.getBackgroundAudioManager()// 创建 背景音频对象 赋值给 backgroundAudioManager 对象// 设置 data 值backgroundAudioManager.title = '此时此刻'backgroundAudioManager.epname = '此时此刻'backgroundAudioManager.singer = '许巍'backgroundAudioManager.coverImgUrl = 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000'// 设置了 src 之后会自动播放backgroundAudioManager.src = 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&amp;uin=346897220&amp;vkey=6292F51E1E384E061FF02C31F716658E5C81F5594D561F2E88B854E81CAAB7806D5E4F103E55D33C16F3FAC506D1AB172DE8600B37E43FAD&amp;fromtag=46'backgroundAudioManager.onCanplay(()=&gt;&#123;....&#125;)backgroundAudioManager.onEnded(()=&gt;&#123;....&#125;) 3.4 相机3.4.1 wx.createCameraContext 创建 相机上下文对象 [无参数]1wx.createCameraContext()//无参数 3.4.2 CameraContext 相机上下文对象 的方法 .startRecord 开始录像 .stopRecord 停止录像 .takePhoto 拍照 3.4.3 相机完整的代码实例效果图 123456789101112131415161718&lt;view class=\"page-body\"&gt; &lt;view class=\"page-body-wrapper\"&gt; &lt;camera device-position=\"back\" flash=\"off\" binderror=\"error\" style=\"width: 100%; height: 300px;\"&gt;&lt;/camera&gt; &lt;view class=\"btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"takePhoto\"&gt;拍照&lt;/button&gt; &lt;/view&gt; &lt;view class=\"btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"startRecord\"&gt;开始录像&lt;/button&gt; &lt;/view&gt; &lt;view class=\"btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"stopRecord\"&gt;结束录像&lt;/button&gt; &lt;/view&gt; &lt;view class=\"preview-tips\"&gt;预览&lt;/view&gt; &lt;image wx:if=\"&#123;&#123;src&#125;&#125;\" mode=\"widthFix\" src=\"&#123;&#123;src&#125;&#125;\"&gt;&lt;/image&gt; &lt;video wx:if=\"&#123;&#123;videoSrc&#125;&#125;\" class=\"video\" src=\"&#123;&#123;videoSrc&#125;&#125;\"&gt;&lt;/video&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Page(&#123; onLoad() &#123; this.ctx = wx.createCameraContext()// 创建 对象 赋值给 ctx &#125;, takePhoto() &#123; this.ctx.takePhoto(&#123; quality: 'high',//成像质量 否 'high': 高质量 'low':低质量 'normal':普通质量（默认值） success: (res) =&gt; &#123; //res.tempImagePath '' 照片文件的临时路径 this.setData(&#123; src: res.tempImagePath &#125;) &#125;, fail:(res) =&gt; &#123; // &#125;, complete:(res)=&gt;&#123;..&#125; &#125;) &#125;, startRecord() &#123; this.ctx.startRecord(&#123; timeoutCallback:(res)=&gt;&#123; //超过30s或页面 onHide 时会结束录像 否 res.tempThumbPath//string 封面图片文件的临时路径 res.tempVideoPath//string 视频的文件的临时路径 &#125;, success: (res) =&gt; &#123; console.log('startRecord') &#125;, fail:(res) =&gt; &#123; // &#125;, complete:(res)=&gt;&#123;..&#125; &#125;) &#125;, stopRecord() &#123; this.ctx.stopRecord(&#123; success: (res) =&gt; &#123; //res.tempThumbPath//string 封面图片文件的临时路径 //res.tempVideoPath//string 视频的文件的临时路径 this.setData(&#123; src: res.tempThumbPath, videoSrc: res.tempVideoPath &#125;) &#125;, fail:(res) =&gt; &#123; // &#125;, complete:(res)=&gt;&#123;..&#125; &#125;) &#125;, error(e) &#123; console.log(e.detail) &#125;&#125;) 12345678910//page.preview-tips &#123; margin: 20rpx 0; &#125;.video &#123; margin: 50px auto; width: 100%; height: 300px;&#125; 12345678910111213141516171819202122232425//apppage &#123; background-color: #F8F8F8; height: 100%; font-size: 32rpx; line-height: 1.6;&#125;.page-body &#123; padding: 20rpx 0;&#125;.page-body-wrapper &#123; display: flex; flex-direction: column; align-items: center; width: 100%;&#125;.btn-area &#123; margin-top: 60rpx; box-sizing: border-box; width: 100%; padding: 0 30rpx;&#125; 3.5 字体 wx.loadFontFace 动态加载网络字体。文件地址需为下载类型。iOS 仅支持 https 格式文件地址。 注意： 引入中文字体，体积过大时会发生错误，建议抽离出部分中文，减少体积，或者用图片替代 字体链接必须是 https（ios 不支持 http 仅支持 https 格式文件地址) 字体链接必须是同源下的，或开启了cors支持，小程序的域名是 servicewechat.com canvas 等原生组件不支持使用接口添加的字体 工具里提示 Faild to load font可以忽略 12345678910111213&lt;view class=\"container\"&gt; &lt;view class=\"page-body\"&gt; &lt;view class=\"page-section\"&gt; &lt;view class=\"page-body-info display-area &#123;&#123; loaded ? 'font-loaded' : '' &#125;&#125;\"&gt; &lt;text wx:if=\"&#123;&#123;!loaded&#125;&#125;\"&gt;Load &#123;&#123; fontFamily &#125;&#125;&lt;/text&gt; &lt;text wx:else&gt;&#123;&#123; fontFamily &#125;&#125; is loaded&lt;/text&gt; &lt;/view&gt; &lt;view class=\"btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"loadFontFace\"&gt;加载字体&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334Page(&#123; data: &#123; fontFamily: 'Bitstream Vera Serif Bold', loaded: false, &#125;, onLoad() &#123; this.setData(&#123; loaded: false &#125;) &#125;, loadFontFace() &#123; const self = this wx.loadFontFace(&#123; family: this.data.fontFamily,// 定义的字体名称 必填 source: 'url(\"https://sungd.github.io/Pacifico.ttf\")', //必填 //字体资源的地址。建议格式为 TTF 和 WOFF，WOFF2 在低版本的iOS上会不兼容。 desc:&#123; //可选的字体描述符 否 style: 'normal'// 否 字体样式，可选值为 normal / italic / oblique weight: 'normal'// 否 字体粗细，可选值为 normal / bold / 100 / 200../ 900 variant: 'normal'//否 设置小型大写字母的字体显示文本，可选值为 normal / small-caps / inherit &#125;, success(res) &#123; console.log(res.status) self.setData(&#123; loaded: true &#125;) &#125;, fail: function(res) &#123; console.log(res.status) &#125;, complete: function(res) &#123; console.log(res.status) &#125; &#125;); &#125;&#125;) 1234567891011121314.page-body-info &#123; align-items: center; padding: 200rpx 0;&#125;.font-loaded &#123; font-family: \"Bitstream Vera Serif Bold\";&#125;.display-area &#123; font-size: 40rpx; display: flex; justify-content: center;&#125; 3.6 图片 wx.chooseImage 从本地相册选择图片或使用相机拍照。 wx.compressImage 压缩图片接口，可选压缩质量 wx.getImageInfo 获取图片信息。网络图片需先配置 download 域名才能生效。 wx.previewImage 在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作。 wx.saveImageToPhotosAlbum 保存图片到系统相册。 调用前需要 用户授权 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586wx.chooseImage(&#123; count: 1,// 最多可以选择的图片张数 否，默认值为 9 sizeType: ['original', 'compressed'],//所选的图片的尺寸 否 默认值为 ['original', 'compressed'] //original : 原图 compressed:压缩图 sourceType: ['album', 'camera'],//选择图片的来源 否 默认值为 ['album', 'camera'] //album 从相册选图 camera 使用相机 success (res) &#123; // tempFilePath 可以作为 img 标签的 src 属性显示图片 const tempFilePaths = res.tempFilePaths//[''] 图片的本地临时文件 路径列表 const tempFiles = res.tempFiles //[&#123;&#125;] 图片的本地临时 文件列表 /* res.tempFiles&#123; path:'',//本地临时文件路径 size:200//本地临时文件大小，单位 B &#125; */ //网络图片需先配置 download 域名才能生效。！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！ wx.getImageInfo(&#123; src: res.tempFilePaths[0],//'images/a.jpg',//图片的路径，可以是相对路径、临时文件路径、存储文件路径、网络图片路径 必填 success (res) &#123; console.log(res.width)//number 图片原始宽度，单位px。不考虑旋转。 console.log(res.height)//number 图片原始高度，单位px。不考虑旋转。 res.path//'' 图片的本地路径 res.orientation//'' 拍照时设备方向 //'up' 默认方向（手机横持拍照），对应 Exif 中的 1。或无 orientation 信息。 //'up-mirrored' 同 up，但镜像翻转，对应 Exif 中的 2 //'down' 旋转180度，对应 Exif 中的 3 //'down-mirrored' 同 down，但镜像翻转，对应 Exif 中的 4 //'left-mirrored' 同 left，但镜像翻转，对应 Exif 中的 5 //'right' 顺时针旋转90度，对应 Exif 中的 6 //'right-mirrored' 同 right，但镜像翻转，对应 Exif 中的 7 //'left' 逆时针旋转90度，对应 Exif 中的 8 re.type//'' 图片格式 &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;) &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;)//两个方法的结合使用wx.chooseImage(&#123; success (res) &#123; wx.getImageInfo(&#123; src: res.tempFilePaths[0], success (res) &#123; console.log(res.width) console.log(res.height) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;) &#125;&#125;)//压缩图片接口，可选压缩质量wx.compressImage(&#123; src: '', // 图片路径,图片路径，图片的路径，可以是相对路径、临时文件路径、存储文件路径 必填 quality: 80, // 压缩质量，压缩质量，范围0～100，数值越小，质量越低，压缩率越高（仅对jpg有效）。 否 默认值 80 success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.previewImage(&#123; current: '', // 当前显示图片的 http 链接 否 默认值：urls 的第一张 urls: [], // 需要预览的图片 http 链接列表,2.2.3 起支持云文件ID。 必填 success(res) &#123; &#125;, fail(res) &#123; &#125;, complete(res) &#123; &#125;&#125;)wx.saveImageToPhotosAlbum(&#123; filePath:'',//图片文件路径，可以是临时文件路径或永久文件路径，不支持网络图片路径 必填 success(res) &#123; &#125;, fail(res) &#123; &#125;, complete(res) &#123; &#125;&#125;) 3.6.1 运用实例123456789101112&lt;view class=\"weui-panel\"&gt; &lt;view class=\"weui-panel__hd\"&gt;&lt;/view&gt; &lt;view class=\"weui-panel__bd\"&gt; &lt;image mode='widthFix' src=\"&#123;&#123;src&#125;&#125;\" style='width: 300px;'&gt;&lt;/image&gt; &lt;button bindtap=\"getImageInfo\"&gt;getImageInfo&lt;/button&gt; &lt;/view&gt; &lt;view class=\"weui-panel__ft\"&gt;&lt;/view&gt;&lt;/view&gt;&lt;view wx:if=\"&#123;&#123;!!info&#125;&#125;\" class='result'&gt; &lt;text space=\"nbsp\"&gt;&#123;&#123;info&#125;&#125;&lt;/text&gt;&lt;/view&gt; 1234567891011121314151617181920212223const app = getApp()Page(&#123; data: &#123; src: 'http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNTTiaKet81gQJDXYnPiaJFSzRlp9frTTX2hSN01xhiackVLHHrG7ZQI3XQsbM7Gr9USZdN4f26SO5xjg/0?wx_fmt=png', info: '', &#125;, getImageInfo() &#123; wx.getImageInfo(&#123; src: this.data.src, complete: (res) =&gt; &#123; this.setData(&#123; info: this.format(res) &#125;) &#125; &#125;) &#125;, format(obj) &#123; return '&#123;\\n' + Object.keys(obj).map(function (key) &#123; return ' ' + key + ': ' + obj[key] + ',' &#125;).join('\\n') + '\\n' + '&#125;' &#125;&#125;) 3.7 实时音视频 (直播)3.7.1 LivePlayerContext 对象 (观看直播) wx.createLivePlayerContext 创建对象 参数为 &lt;live-player&gt; 组件的 id, 第二个可选参数 this .exitFullScreen 退出全屏 三个回调函数 .mute 静音 三个回调函数 .pause 暂停 三个回调函数 .play 播放 三个回调函数 .requestFullScreen 进入全屏 direction 以及 三个回调函数 0：正常竖向 90：屏幕逆时针90度 -90：屏幕顺时针90度 .resume 恢复 三个回调函数 .stop 停止 三个回调函数 12345678910111213&lt;view class=\"page-body\"&gt; &lt;view class=\"page-section tc\"&gt; &lt;live-player id=\"player\" src=\"https://domain/pull_stream\" mode=\"RTC\" autoplay bindstatechange=\"statechange\" binderror=\"error\" /&gt; &lt;view class=\"btn-area\"&gt; &lt;button bindtap=\"bindPlay\" class=\"page-body-button\" type=\"primary\"&gt;播放&lt;/button&gt; &lt;button bindtap=\"bindPause\" class=\"page-body-button\" type=\"primary\"&gt;暂停&lt;/button&gt; &lt;button bindtap=\"bindStop\" class=\"page-body-button\" type=\"primary\"&gt;停止&lt;/button&gt; &lt;button bindtap=\"bindResume\" class=\"page-body-button\" type=\"primary\"&gt;恢复&lt;/button&gt; &lt;button bindtap=\"bindMute\" class=\"page-body-button\" type=\"primary\"&gt;静音&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Page(&#123; onReady(res) &#123; this.ctx = wx.createLivePlayerContext('player')// 创建 &#125;, statechange(e) &#123; console.log('live-player code:', e.detail.code) &#125;, error(e) &#123; console.error('live-player error:', e.detail.errMsg) &#125;, bindPlay() &#123; // 播放 this.ctx.play(&#123; success: res =&gt; &#123; console.log('play success') &#125;, fail: res =&gt; &#123; console.log('play fail') &#125;, complete:res =&gt; &#123;&#125; &#125;) &#125;, bindPause() &#123; this.ctx.pause(&#123; success: res =&gt; &#123; console.log('pause success') &#125;, fail: res =&gt; &#123; console.log('pause fail') &#125;, complete:res =&gt; &#123;&#125; &#125;) &#125;, bindStop() &#123; this.ctx.stop(&#123; success: res =&gt; &#123; console.log('stop success') &#125;, fail: res =&gt; &#123; console.log('stop fail') &#125;, complete:res =&gt; &#123;&#125; &#125;) &#125;, bindResume() &#123; this.ctx.resume(&#123; success: res =&gt; &#123; console.log('resume success') &#125;, fail: res =&gt; &#123; console.log('resume fail') &#125;, complete:res =&gt; &#123;&#125; &#125;) &#125;, bindMute() &#123; this.ctx.mute(&#123; success: res =&gt; &#123; console.log('mute success') &#125;, fail: res =&gt; &#123; console.log('mute fail') &#125;, complete:res =&gt; &#123;&#125; &#125;) &#125;&#125;) 12345678.page-body-button &#123; margin-bottom: 30rpx;&#125;live-player &#123; width: 100%; height: 225px;&#125; 3.7.2 LivePusherContext 对象 （开直播） wx.createLivePusherContext 创建对象 参数为 id .pause 暂停推流 三个回调函数 .pauseBGM 暂停背景音 三个回调函数 .playBGM 播放背景音 三个回调函数 必填 url 与 livePusherContext.playBGM({url:&apos;&apos;, // 加入背景混音的资源地址 必填 success(res){}, fail(res){}, complete(res){} }) .resume 恢复推流 三个回调函数 .resumeBGM 恢复背景音 三个回调函数 .setBGMVolume 设置背景音音量 三个回调函数 必填 Volume livePusherContext.setBGMVolume({Volume:&apos;&apos;, //音量大小 必填 success(res){}, fail(res){}, complete(res){} }) .snapshot 快照 三个回调函数 .start 播放推流 三个回调函数 .stop 停止推流 三个回调函数 .stopBGM 停止背景音 三个回调函数 .switchCamera 切换前后摄像头 三个回调函数 .toggleTorch 切换 三个回调函数 12345678910111213&lt;view class=\"page-body\"&gt; &lt;view class=\"page-section tc\"&gt; &lt;live-pusher id=\"pusher\" url=\"https://domain/push_stream\" mode=\"RTC\" autopush bindstatechange=\"statechange\" /&gt; &lt;view class=\"btn-area\"&gt; &lt;button bindtap=\"bindStart\" class=\"page-body-button\" type=\"primary\"&gt;播放推流&lt;/button&gt; &lt;button bindtap=\"bindPause\" class=\"page-body-button\" type=\"primary\"&gt;暂停推流&lt;/button&gt; &lt;button bindtap=\"bindStop\" class=\"page-body-button\" type=\"primary\"&gt;停止推流&lt;/button&gt; &lt;button bindtap=\"bindResume\" class=\"page-body-button\" type=\"primary\"&gt;恢复推流&lt;/button&gt; &lt;button bindtap=\"bindSwitchCamera\" class=\"page-body-button\" type=\"primary\"&gt;切换前后摄像头&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Page(&#123; onReady(res) &#123; this.ctx = wx.createLivePusherContext('pusher')// 创建对象 &#125;, statechange(e) &#123; console.log('live-pusher code:', e.detail.code) &#125;, bindStart() &#123; // 播放 this.ctx.start(&#123; success: res =&gt; &#123; console.log('start success') &#125;, fail: res =&gt; &#123; console.log('start fail') &#125;, complete:res=&gt;&#123; // &#125; &#125;) &#125;, bindPause() &#123; this.ctx.pause(&#123; success: res =&gt; &#123; console.log('pause success') &#125;, fail: res =&gt; &#123; console.log('pause fail') &#125; &#125;) &#125;, bindStop() &#123; this.ctx.stop(&#123; success: res =&gt; &#123; console.log('stop success') &#125;, fail: res =&gt; &#123; console.log('stop fail') &#125; &#125;) &#125;, bindResume() &#123; this.ctx.resume(&#123; success: res =&gt; &#123; console.log('resume success') &#125;, fail: res =&gt; &#123; console.log('resume fail') &#125; &#125;) &#125;, bindSwitchCamera() &#123; this.ctx.switchCamera(&#123; success: res =&gt; &#123; console.log('switchCamera success') &#125;, fail: res =&gt; &#123; console.log('switchCamera fail') &#125; &#125;) &#125;&#125;) 123456789.page-body-button &#123; margin-bottom: 30rpx;&#125;live-pusher &#123; margin: 0 auto; width: 300px; height: 225px;&#125; 3.7.3 实时音视频 (直播) 权限当然不是小程序使用了这些标签 &lt;live-pusher&gt;,&lt;live-player&gt; 就可以做到实时直播功能的，这个需要是符合微信的某些分类，并且在后台接口端设置之后才可以用的。符合类目要求的小程序，需要在小程序管理后台的 “设置 - 接口设置” 中自助开通该组件权限。 官网常见问题解析 3.7 录音3.7.1 wx.getRecorderManager 获取全局唯一的录音管理器 RecorderManager 对象 无参数123456789101112131415161718```#### 3.7.2 RecorderManager 的 wx.API- wx.startRecord 开始录音。**需要授权** 当主动调用 wx.stopRecord，或者录音超过1分钟时自动结束录音。当用户离开小程序时，此接口无法调用。 三个回电函数 success(res.tempFilePath) // 录音文件的临时路径- wx.stopRecord 停止录音。无参数```JSwx.startRecord(&#123; success (res) &#123; const tempFilePath = res.tempFilePath &#125;&#125;)setTimeout(function () &#123; wx.stopRecord() // 结束录音&#125;, 10000) 3.7.3 RecorderManager 对象的方法 .onError 监听录音错误事件 回调函数 (res)=&gt;{res.errMsg //&apos;&apos; 错误信息 } .onFrameRecorded 监听已录制完指定帧大小的文件事件。如果设置了 frameSize，则会回调此事件。 回调函数 (res)=&gt;{res.frameBuffer //ArrayBuffer 录音分片数据 res.isLastFrame //boolean 当前帧是否正常录音结束前的最后一帧 } .onInterruptionBegin 监听录音因为受到系统占用而被中断开始事件。 回调函数 以下场景会触发此事件：微信语音聊天、微信视频聊天。此事件触发后，录音会被暂停。pause 事件在此事件后触发 .onInterruptionEnd 监听录音中断结束事件。 回调函数 在收到 interruptionBegin 事件之后，小程序内所有录音会暂停，收到此事件之后才可再次录音成功。 .onPause 监听录音暂停事件 回调函数 .onResume 监听录音继续事件 回调函数 .onStart 监听录音开始事件 回调函数 .onStop 监听录音结束事件 回调函数 (res)=&gt;{res.tempFilePath //&apos;&apos; 录音文件的临时路径 } .pause 暂停录音 无参数 .resume 继续录音 无参数 .start 开始录音 recorderManager.start({duration:60000,//录音的时长，单位 ms，最大值 600000（10 分钟） 否，默认为 60000 即 10 分钟 sampleRate:8000,// 采样率 否，默认8000 numberOfChannels:2,//录音通道数 否，默认2 encodeBitRate:48000,//编码码率，有效值见下表格 否，默认48000 format:&apos;abc&apos;,//音频格式 否，默认 &apos;abc&apos; frameSize:90,//指定帧大小，单位 KB。 否 //传入 frameSize 后，每录制指定帧大小的内容后，会回调录制的文件内容，不指定则不会回调。暂仅支持 mp3 格式。 audioSource:&apos;auto&apos;//指定录音的音频输入源，可通过 wx.getAvailableAudioSources() 获取当前可用的音频源 否 [**以上这些返回值的可取值参考** 微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/RecorderManager.start.html) }) .stop 停止录音 无参数 123456789101112131415161718192021222324252627const recorderManager = wx.getRecorderManager()//获取全局唯一的录音管理器 RecorderManager 无参数recorderManager.onStart(() =&gt; &#123; console.log('recorder start')&#125;)recorderManager.onPause(() =&gt; &#123; console.log('recorder pause')&#125;)recorderManager.onStop((res) =&gt; &#123; console.log('recorder stop', res) const &#123; tempFilePath &#125; = res&#125;)recorderManager.onFrameRecorded((res) =&gt; &#123; const &#123; frameBuffer &#125; = res console.log('frameBuffer.byteLength', frameBuffer.byteLength)&#125;)const options = &#123; duration: 10000, sampleRate: 44100, numberOfChannels: 1, encodeBitRate: 192000, format: 'aac', frameSize: 50&#125;recorderManager.start(options) 3.8 视频3.8.1 VideoContext 的 wx.Api wx.createVideoContext 创建 video 上下文 VideoContext 对象 ，参数 id，第二个 可选参数 this wx.chooseVideo 拍摄视频或从手机相册中选视频。 wx.saveVideoToPhotosAlbum 保存视频到系统相册 需要先用户授权 1&lt;video id=\"myVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\" danmu-list=\"&#123;&#123;danmuList&#125;&#125;\" enable-danmu danmu-btn controls&gt;&lt;/video&gt; 1234567891011121314151617181920212223242526272829303132333435onReady: function (res) &#123; this.videoContext = wx.createVideoContext('myVideo')// 创建视频 对象&#125;,wx.saveVideoToPhotosAlbum(&#123; filePath: 'wxfile://xxx',//视频文件路径，可以是临时文件路径也可以是永久文件路径 必填 success (res) &#123; console.log(res.errMsg) &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;)wx.chooseVideo(&#123; sourceType: ['album','camera'],//视频选择的来源 否 默认值 ['album', 'camera'] //album 从相册选择视频 camera 使用相机拍摄视频 compressed:true,//是否压缩所选择的视频文件 否 默认值 true maxDuration: 60,//拍摄视频最长拍摄时间，单位秒 否 默认值 60 camera: 'back',//默认拉起的是前置或者后置摄像头。部分 Android 手机下由于系统 ROM 不支持无法生效 否 默认值 'back' //back 默认拉起后置摄像头 front 默认拉起前置摄像头 success(res) &#123; console.log(res.tempFilePath) empFilePath//string 选定视频的临时文件路径 duration//number 选定视频的时间长度 size//number 选定视频的数据量大小 height//number 返回选定视频的高度 width//number 返回选定视频的宽度 &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 3.8.1 VideoContext 对象的 方法 .exitFullScreen 退出全屏 无参数 .hideStatusBar 隐藏状态栏，仅在iOS全屏下有效 无参数 .pause 暂停视频 无参数 .play 播放视频 无参数 .playbackRate 设置倍速播放 参数：倍率，支持 0.5/0.8/1.0/1.25/1.5 （number） .requestFullScreen 进入全屏 参数：direction //设置全屏时视频的方向，不指定则根据宽高比自动判断。 否：不是必填（number）0 正常竖向 90 屏幕逆时针90度 -90 屏幕顺时针90度 .seek 跳转到指定位置 参数 position 跳转到的位置，单位 s（number） .sendDanmu 发送弹幕 （观看视频发送弹幕） (obj) videoContext.sendDanmu({text:&apos;&apos;,// tring 必填 弹幕文字 color:&apos;&apos;// tring 否 弹幕颜色 }) .showStatusBar 显示状态栏，仅在iOS全屏下有效 无参数 .stop 停止视频 无参数 123456789101112131415161718192021&lt;view class=\"page-body\"&gt; &lt;view class=\"page-section tc\"&gt; &lt;video id=\"myVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\" binderror=\"videoErrorCallback\" danmu-list=\"&#123;&#123;danmuList&#125;&#125;\" enable-danmu danmu-btn controls&gt;&lt;/video&gt; &lt;view class=\"weui-cells\"&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;弹幕内容&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &lt;input bindblur=\"bindInputBlur\" class=\"weui-input\" type=\"text\" placeholder=\"在此处输入弹幕内容\" /&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"btn-area\"&gt; &lt;button bindtap=\"bindSendDanmu\" class=\"page-body-button\" type=\"primary\" formType=\"submit\"&gt;发送弹幕&lt;/button&gt; &lt;button bindtap=\"bindPlay\" class=\"page-body-button\" type=\"primary\"&gt;播放&lt;/button&gt; &lt;button bindtap=\"bindPause\" class=\"page-body-button\" type=\"primary\"&gt;暂停&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getRandomColor () &#123; const rgb = [] for (let i = 0 ; i &lt; 3; ++i)&#123; let color = Math.floor(Math.random() * 256).toString(16) color = color.length == 1 ? '0' + color : color rgb.push(color) &#125; return '#' + rgb.join('')&#125;Page(&#123; onReady: function (res) &#123; this.videoContext = wx.createVideoContext('myVideo')// 创建 &#125;, inputValue: '', data: &#123; src: '', danmuList: [&#123; text: '第 1s 出现的弹幕', color: '#ff0000', time: 1 &#125;, &#123; text: '第 3s 出现的弹幕', color: '#ff00ff', time: 3 &#125;] &#125;, bindInputBlur: function(e) &#123; this.inputValue = e.detail.value &#125;, bindSendDanmu: function () &#123; // 发送弹幕 this.videoContext.sendDanmu(&#123; text: this.inputValue, color: getRandomColor() &#125;) &#125;, bindPlay: function() &#123; this.videoContext.play() &#125;, bindPause: function() &#123; this.videoContext.pause() &#125;, videoErrorCallback: function(e) &#123; console.log('视频错误信息:') console.log(e.detail.errMsg) &#125;&#125;) 12345678910111213@import \"../lib/weui.wxss\";.weui-cells&#123; margin-top: 80rpx; text-align: left;&#125;.weui-label&#123; width: 5em;&#125;.page-body-button &#123; margin-bottom: 30rpx;&#125; 四、文件wx.getFileInfowx.getFileSystemManagerwx.getSavedFileInfowx.getSavedFileListwx.openDocumentwx.removeSavedFilewx.saveFile FileSystemManager.access.accessSync.appendFile.appendFileSync.copyFile.copyFileSync.getFileInfo.getSavedFileList.mkdir.mkdirSync.readdir.readdirSync.readFile.readFileSync.removeSavedFile.rename.renameSync.rmdir.rmdirSync.saveFile.saveFileSync.stat.statSync.unlink.unlinkSync.unzip.writeFile.writeFileSync Stats.isDirectory.isFile 五、数据缓存synchronous：同步 sync 同步asynchronous：异步 async 异步 5.1 异步操作 wx.setStorage 将数据存储在本地缓存中指定的 key 中。会覆盖掉原来该 key 对应的内容。数据存储生命周期跟小程序本身一致，即除用户主动删除或超过一定时间被自动清理，否则数据都一直可用。单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。 wx.getStorage 从本地缓存中异步获取指定 key 的内容 wx.getStorageInfo 异步获取当前storage的相关信息 wx.clearStorage 清理本地数据缓存 wx.removeStorage 从本地缓存中移除指定 key 1234567891011121314151617181920212223242526272829303132333435363738394041wx.setStorage(&#123; key:\"key\",// 本地缓存中指定的 key 必填 data:\"value\",// 需要存储的内容。只支持原生类型、Date、及能够通过 JSON.stringify 序列化的对象。 必填 success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.getStorage(&#123; key: 'key',//本地缓存中指定的 key 必填 success (res) &#123; console.log(res.data)// Object/string key 对应的内容 &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.getStorageInfo(&#123; success (res) &#123; console.log(res.keys)//[''] 当前 storage 中所有的 key console.log(res.currentSize)//80 当前占用的空间大小, 单位 KB console.log(res.limitSize)//90 限制的空间大小，单位 KB &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.clearStorage(&#123; success (res) &#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.removeStorage(&#123; key: 'key',// 本地缓存中指定的 key 必填 success (res) &#123; console.log(res.data) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 5.2 同步操作 wx.setStorageSync wx.setStorage 的同步版本 wx.getStorageSync wx.getStorage 的同步版本 wx.getStorageInfoSync wx.getStorageInfo 的同步版本 wx.clearStorageSync wx.clearStorage 的同步版本 wx.removeStorageSync wx.removeStorage 的同步版本 1234567891011121314151617181920212223242526272829303132333435363738394041try &#123; wx.setStorageSync('key', 'value')&#125; catch (e) &#123; &#125;try &#123; var value = wx.getStorageSync('key') if (value) &#123; // Do something with return value &#125;&#125; catch (e) &#123; // Do something when catch error&#125;try &#123; wx.clearStorageSync()&#125; catch(e) &#123; // Do something when catch error&#125;try &#123; const res = wx.getStorageInfoSync() console.log(res.keys) console.log(res.currentSize) console.log(res.limitSize)&#125; catch (e) &#123; // Do something when catch error&#125;try &#123; wx.clearStorageSync()&#125; catch(e) &#123; // Do something when catch error&#125;try &#123; wx.removeStorageSync('key')&#125; catch (e) &#123; // Do something when catch error&#125; 六、位置（地理位置）调用前需要授权 wx.chooseLocation 打开地图选择位置。调用前需要授权 wx.getLocation 获取当前的地理位置、速度。当用户离开小程序后，此接口无法调用。调用前需要授权 wx.openLocation 使用微信内置地图查看位置 12345678910111213141516171819202122232425262728293031323334353637wx.chooseLocation(&#123; success(res)&#123; res.name//string 位置名称 res.address//string 详细地址 res.latitude//string 纬度，浮点数，范围为-90~90，负数表示南纬。使用 gcj02 国测局坐标系 res.longitude//string 经度，浮点数，范围为-180~180，负数表示西经。使用 gcj02 国测局坐标系 &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.getLocation(&#123; type: 'wgs84',// wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标 否 默认值 'wgs84' altitude:'false',//传入 true 会返回高度信息，由于获取高度需要较高精确度，会减慢接口返回速度 否，默认值是 'false' success (res) &#123; const latitude = res.latitude//80 纬度，范围为 -90~90，负数表示南纬 const longitude = res.longitude//100 经度，范围为 -180~180，负数表示西经 const speed = res.speed//2 速度，单位 m/s const accuracy = res.accuracy//2 位置的精确度 res.altitude //2 高度，单位 m res.verticalAccuracy //2 垂直精度，单位 m（Android 无法获取，返回 0） res.horizontalAccuracy//2 水平精度，单位 m wx.openLocation(&#123; latitude,//这里是外层 wx.getLocation 返回值来的，纬度，范围为-90~90，负数表示南纬。使用 gcj02 国测局坐标系 必填 longitude,//这里是外层 wx.getLocation 返回值来的，经度，范围为-180~180，负数表示西经。使用 gcj02 国测局坐标系 必填 scale: 18,// 缩放比例，范围5~18 否 name:'',//位置名 否 address:'',//地址的详细说明 否 success(res)&#123;&#125;， fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 注意工具中定位模拟使用 IP 定位，可能会有一定误差。且工具目前仅支持 gcj02 坐标。使用第三方服务进行逆地址解析时，请确认第三方服务默认的坐标系，正确进行坐标转换。 七、设备7.1 加速计wx.onAccelerometerChange 获取设备电量。同步 API wx.getBatteryInfoSync 在 iOS 上不可用。wx.startAccelerometerwx.stopAccelerometer 123456789101112131415161718192021222324```### 7.2 电量wx.getBatteryInfo 异步获取设备电量。wx.getBatteryInfoSync 同步获取设备电量。 顾名思义，这个api是需要同步的，所以可能会对游戏造成一定的卡顿；而且，这个api在iOS上是不可用的。 所以说同步的版本我们是不会用的咯？其他的接口我们也是不会用同步版本的咯。**在这里说一下小程序与小游戏的区别：他们的接口方法是不太一样的。** 在小游戏中 wx.getSystemInfo 系统的接口中 wx.getSystemInfo 中 success的参数res中，res.battery是代表电量的，我们可以用来设置界面上的电量显示。 但是我们在小程序中 wx.getSystemInfo 系统的接口中 wx.getSystemInfo 中 success的参数res中 是没有 res.battery ，所以我们是获取不到这个电量的。以上几个api都是只获取一次电量的值，所以我们在程序中需要做一个计时器以在固定的时间去获取电量值，这样才能保证实时更新电量。```JSwx.getBatteryInfo(&#123; success(res)&#123; res.level//string 设备电量，范围 1 - 100 isCharging//boolean 是否正在充电中 &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 7.3 蓝牙wx.closeBluetoothAdapterwx.getBluetoothAdapterStatewx.getBluetoothDeviceswx.getConnectedBluetoothDeviceswx.onBluetoothAdapterStateChangewx.onBluetoothDeviceFoundwx.openBluetoothAdapterwx.startBluetoothDevicesDiscoverywx.stopBluetoothDevicesDiscovery 7.4 低功耗蓝牙wx.closeBLEConnectionwx.createBLEConnectionwx.getBLEDeviceCharacteristicswx.getBLEDeviceServiceswx.notifyBLECharacteristicValueChangewx.onBLECharacteristicValueChangewx.onBLEConnectionStateChangewx.readBLECharacteristicValuewx.writeBLECharacteristicValue 7.5 剪贴板wx.getClipboardDatawx.setClipboardData 7.6 罗盘wx.onCompassChangewx.startCompasswx.stopCompass 7.7 联系人 wx.addPhoneContact7.8 陀螺仪wx.onGyroscopeChangewx.startGyroscopewx.stopGyroscopeiBeaconwx.getBeaconswx.onBeaconServiceChangewx.onBeaconUpdatewx.startBeaconDiscoverywx.stopBeaconDiscoveryIBeaconInfo 7.9 设备方向wx.onDeviceMotionChangewx.startDeviceMotionListeningwx.stopDeviceMotionListening 7.10 网络wx.getNetworkTypewx.onNetworkStatusChange 7.10 NFCwx.getHCEStatewx.onHCEMessagewx.sendHCEMessagewx.startHCEwx.stopHCE 7.11 性能wx.onMemoryWarning 7.12 电话wx.makePhoneCall 7.13 扫码wx.scanCode 7.14 屏幕wx.getScreenBrightnesswx.onUserCaptureScreenwx.setKeepScreenOnwx.setScreenBrightness 7.15 振动wx.vibrateLongwx.vibrateShort 7.16 Wi-Fi wx.startWifi 初始化 Wi-Fi 模块。 wx.getConnectedWifi wx.getWifiList wx.onGetWifiList wx.onWifiConnected wx.setWifiList wx.stopWifi WifiInfo wx.connectWifi 连接 Wi-Fi。若已知 Wi-Fi 信息，可以直接利用该接口连接。仅 Android 与 iOS 11 以上版本支持。 1234567891011121314151617181920212223242526272829303132wx.startWifi(&#123; success (res) &#123; console.log(res.errMsg) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.connectWifi(&#123; SSID: '',//SSID 必填 BSSID: '',// Wi-Fi 设备 BSSID 必填 password:'',//Wi-Fi 设备密码 否 success (res) &#123; console.log(res.errMsg) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)//0 ok 正常//12000 not init 未先调用 startWifi 接口//12001 system not support 当前系统不支持相关能力//12002 password error Wi-Fi 密码错误//12003 connection timeout 连接超时//12004 duplicate request 重复连接 Wi-Fi//12005 wifi not turned on Android 特有，未打开 Wi-Fi 开关//12006 gps not turned on Android 特有，未打开 GPS 定位开关//12007 user denied 用户拒绝授权链接 Wi-Fi//12008 invalid SSID 无效 SSID//12009 system config err 系统运营商配置拒绝连接 Wi-Fi//12010 system internal error 系统其他错误，需要在 errmsg 打印具体的错误原因//12011 weapp in background 应用在后台无法配置 Wi-Fi 7.16.2 实例123456789101112131415161718192021222324&lt;view class=\"container\"&gt; &lt;view class=\"page-body\"&gt; &lt;view class=\"page-body-info\"&gt; &lt;scroll-view class=\"device-list\" scroll-y&gt; &lt;view class=\"item\" wx:for=\"&#123;&#123;wifiList&#125;&#125;\" wx:key=\"&#123;&#123;index&#125;&#125;\"&gt; &lt;view class=\"list\"&gt; &lt;text&gt;&#123;&#123; item.SSID &#125;&#125;&lt;/text&gt; &lt;span class=\"wifi-icon\"&gt; &lt;span class=\"wifi-1\"&gt;&lt;/span&gt; &lt;span class=\"wifi-2 &#123;&#123;item.strength &lt; 2 ? 'off' : ''&#125;&#125;\"&gt;&lt;/span&gt; &lt;span class=\"wifi-3 &#123;&#123;item.strength &lt; 3 ? 'off' : ''&#125;&#125;\"&gt;&lt;/span&gt; &lt;span class=\"wifi-4 &#123;&#123;item.strength &lt; 4 ? 'off' : ''&#125;&#125;\"&gt;&lt;/span&gt; &lt;span class=\"lock\" wx:if=\"&#123;&#123;item.secure&#125;&#125;\"&gt;&lt;/span&gt; &lt;/span&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; &lt;view class=\"btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"startSearch\"&gt;搜索Wi-Fi&lt;/button&gt; &lt;button bindtap=\"stopSearch\"&gt;停止搜索&lt;/button&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Page(&#123; data: &#123; wifiList: [] &#125;, onUnload() &#123; this.stopSearch(); &#125;, startSearch() &#123; const getWifiList = () =&gt; &#123; wx.getWifiList(&#123; success: (res) =&gt; &#123; wx.onGetWifiList((res) =&gt; &#123; const wifiList = res.wifiList .sort((a, b) =&gt; b.signalStrength - a.signalStrength) .map(wifi =&gt; &#123; const strength = Math.ceil(wifi.signalStrength * 4) return Object.assign(wifi, &#123; strength &#125;) &#125;) this.setData(&#123; wifiList &#125;) &#125;) &#125;, fail(err) &#123; console.error(err); &#125; &#125;) &#125; const startWifi = () =&gt; &#123; wx.startWifi(&#123; success: getWifiList, fail(err) &#123; console.error(err); &#125; &#125;) &#125; wx.getSystemInfo(&#123; success(res) &#123; const isIOS = res.platform === 'ios' if (isIOS) &#123; wx.showModal(&#123; title: '提示', content: '由于系统限制，iOS用户请手动进入系统WiFi页面，然后返回小程序。', showCancel: false, success() &#123; startWifi() &#125; &#125;) return &#125; startWifi() &#125; &#125;) &#125;, stopSearch() &#123; wx.stopWifi(&#123; success(res) &#123; console.log(res); &#125;, fail(err) &#123; console.error(err); &#125; &#125;) &#125;&#125;) 八、界面8.1 动画8.1.1 wx.createAnimation 创建 动画对象创建一个动画实例 animation。调用实例的方法来描述动画。最后通过动画实例的 export 方法导出动画数据传递给组件的 animation 属性。 1&lt;view animation=\"&#123;&#123;animationData&#125;&#125;\" style=\"background:red;height:100rpx;width:100rpx\"&gt;&lt;/view&gt; 12345678910111213const animation = wx.createAnimation(&#123; duration:400,//动画持续时间，单位 ms 否，默认值 400 timingFunction:'linear',// 动画的效果 否，默认值 'linear' delay:0,//动画延迟时间，单位 ms 否，默认值 0 transformOrigin:'50% 50% 0' //否默认值 '50% 50% 0' /* 'linear' 动画从头到尾的速度是相同的 'ease' 动画以低速开始，然后加快，在结束前变慢 'ease-in' 动画以低速开始 'ease-in-out' 动画以低速开始和结束 'ease-out' 动画以低速结束 'step-start' 动画第一帧就跳至结束状态直到结束 'step-end' 动画一直保持开始状态，最后一帧跳到结束状态 */&#125;) 8.1.2 Animation 动画对象的方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 6 个长度单位制，可以是 number 类型，可以是 字符串 '' 类型，# ① 如果传入 number 则默认使用 px，# ② 希望可传入其他自定义单位的长度值，就用字符串的形式.width 设置宽度 返回新的 Animation对象.height 设置高度 返回新的 Animation对象.left 设置 left， 返回新的 Animation对象.right 设置 right 返回新的 Animation对象.bottom 设置 bottom 返回新的 Animation对象.top 设置 top， 返回新的 Animation对象.backgroundColor 设置背景色 参数 '' 颜色值 返回新的 Animation对象.opacity 设置透明度 参数 透明度，范围 0-1 返回新的 Animation对象.rotate 从 【原点】顺时针旋转一个角度 参数：旋转的角度。范围 [-180, 180] 返回新的 Animation对象.rotate3d 从 【X】 轴顺时针旋转一个角度 animation.rotate3d(x,y,z,angle) 旋转轴 x，y，z 轴的坐标 旋转的角度：[-180, 180] 返回新的 Animation对象.rotateX 从 X 轴顺时针旋转一个角度 旋转的角度：[-180, 180] 返回新的 Animation对象.rotateY 从 Y 轴顺时针旋转一个角度 旋转的角度：[-180, 180] 返回新的 Animation对象.rotateZ 从 Z 轴顺时针旋转一个角度 旋转的角度：[-180, 180] 返回新的 Animation对象.scale 缩放 animation.scale(sx,sy) sx:在 X 轴缩放 sx 倍数 当仅有 sx 参数时，表示在 X 轴、Y 轴同时缩放sx倍数 sy:在 Y 轴缩放 sy 倍数.scale3d 缩放 animation.scale3d(sx,sy,sz) sx:在 X 轴缩放 sx 倍数 sy:在 Y 轴缩放 sy 倍数 sz:在 Z 轴缩放 sz 倍数.scaleX(sx) 缩放 X 轴.scaleY(sy) 缩放 Y 轴.scaleZ(sz) 缩放 Z 轴.skew 对 X、Y 轴坐标进行倾斜 animation.skew(number ax, number ay) ax:对 X 轴坐标倾斜的角度，范围 [-180, 180] ay:对 Y 轴坐标倾斜的角度，范围 [-180, 180].skewX 对 X 轴坐标进行倾斜.skewY 对 Y 轴坐标进行倾斜.translate 平移变换 animation.translate(number tx, number ty) tx:在 X 轴平移的距离，单位为 px，当仅有该参数时表示在 X 轴偏移 tx，单位 px ty:在 X 轴平移的距离，单位为 px.translate3d 对 xyz 坐标进行平移变换 animation.translate3d(number tx, number ty, number tz) tx:在 X 轴平移的距离，单位为 px ty:在 X 轴平移的距离，单位为 px tz:在 Z 轴平移的距离，单位为 px.translateX 对 X 轴平移.translateY 对 Y 轴平移.translateZ 对 Z 轴平移.matrix matrix(a, b, c, d, tx, ty) 是 matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) 的简写.matrix3d matrix3d（a1，b1，c1，d1，a2，b2，c2，d2，a3，b3，c3，d3，a4，b4，c4，d4）# .step 表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画。 animation.step(&#123; duration:400, # 动画持续时间，单位 ms 否 默认值 400 timingFunction:'linear', # 动画的效果 否 默认值 'linear' delay:0, #动画延迟时间，单位 ms 否 默认值 0 transformOrigin:'50% 50% 0' # 否 默认值 '50% 50% 0' &#125;)# timingFunction 的合法值'linear' 动画从头到尾的速度是相同的'ease' 动画以低速开始，然后加快，在结束前变慢'ease-in' 动画以低速开始'ease-in-out' 动画以低速开始和结束'ease-out' 动画以低速结束'step-start' 动画第一帧就跳至结束状态直到结束'step-end' 动画一直保持开始状态，最后一帧跳到结束状态 */.export 导出动画队列。 无参数 返回 animationData [&#123;&#125;] export 方法每次调用后会清掉之前的动画操作 总结一下：就是 ① 创建 动画对象， ② 给对象添加各种动作。 ③ 使用 .step 结束本轮动作。 ④ 使用 .export 导出并且清除原来的动作。 123456789101112131415161718192021&lt;view class=\"container\"&gt; &lt;view class=\"page-body\"&gt; &lt;view class=\"page-section\"&gt; &lt;view class=\"animation-element-wrapper\"&gt; &lt;view class=\"animation-element\" animation=\"&#123;&#123;animation&#125;&#125;\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"animation-buttons\" scroll-y=\"true\"&gt; &lt;button class=\"animation-button\" bindtap=\"rotate\"&gt;旋转&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"scale\"&gt;缩放&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"translate\"&gt;移动&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"skew\"&gt;倾斜&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"rotateAndScale\"&gt;旋转并缩放&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"rotateThenScale\"&gt;旋转后缩放&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"all\"&gt;同时展示全部&lt;/button&gt; &lt;button class=\"animation-button\" bindtap=\"allInQueue\"&gt;顺序展示全部&lt;/button&gt; &lt;button class=\"animation-button animation-button-reset\" bindtap=\"reset\"&gt;还原&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Page(&#123; onReady: function () &#123; this.animation = wx.createAnimation()//创建动画 &#125;, rotate: function () &#123; this.animation.rotate(Math.random() * 720 - 360).step()// 围绕圆点旋转，然后停止 本轮动画 this.setData(&#123;animation: this.animation.export()&#125;)//导出动画（给到页面展现），并且清除原来的动画 &#125;, scale: function () &#123; this.animation.scale(Math.random() * 2).step()//缩放 this.setData(&#123;animation: this.animation.export()&#125;) &#125;, translate: function () &#123; this.animation.translate(Math.random() * 100 - 50, Math.random() * 100 - 50).step()//平移 this.setData(&#123;animation: this.animation.export()&#125;) &#125;, skew: function () &#123; this.animation.skew(Math.random() * 90, Math.random() * 90).step()//倾斜 this.setData(&#123;animation: this.animation.export()&#125;) &#125;, rotateAndScale: function () &#123; this.animation.rotate(Math.random() * 720 - 360)//旋转 然后 缩放 .scale(Math.random() * 2) .step() this.setData(&#123;animation: this.animation.export()&#125;) &#125;, rotateThenScale: function () &#123; this.animation.rotate(Math.random() * 720 - 360).step() .scale(Math.random() * 2).step() this.setData(&#123;animation: this.animation.export()&#125;) &#125;, all: function () &#123; this.animation.rotate(Math.random() * 720 - 360) .scale(Math.random() * 2) .translate(Math.random() * 100 - 50, Math.random() * 100 - 50) .skew(Math.random() * 90, Math.random() * 90) .step() this.setData(&#123;animation: this.animation.export()&#125;) &#125;, allInQueue: function () &#123; this.animation.rotate(Math.random() * 720 - 360).step() .scale(Math.random() * 2).step() .translate(Math.random() * 100 - 50, Math.random() * 100 - 50).step() .skew(Math.random() * 90, Math.random() * 90).step() this.setData(&#123;animation: this.animation.export()&#125;) &#125;, reset: function () &#123; this.animation.rotate(0, 0) .scale(1) .translate(0, 0) .skew(0, 0) .step(&#123;duration: 0&#125;) this.setData(&#123;animation: this.animation.export()&#125;) &#125;&#125;) 123456789101112131415161718192021222324252627282930.animation-element-wrapper &#123; display: flex; width: 100%; padding-top: 150rpx; padding-bottom: 150rpx; justify-content: center; overflow: hidden; background-color: #ffffff;&#125;.animation-element &#123; width: 200rpx; height: 200rpx; background-color: #1AAD19;&#125;.animation-buttons &#123; padding: 30rpx 50rpx 10rpx; width: 100%; height: 700rpx; box-sizing: border-box;&#125;.animation-button &#123; float: left; line-height: 2; width: 300rpx; margin: 15rpx 12rpx;&#125;.animation-button-reset &#123; width: 620rpx;&#125; 8.2 背景wx.setBackgroundColor 动态设置窗口的背景色wx.setBackgroundTextStyle 动态设置下拉背景字体、loading 图的样式 123456789101112131415wx.setBackgroundColor(&#123; backgroundColor: '#ffffff', // 窗口的背景色，必须为十六进制颜色值 否 backgroundColorTop: '#ffffff', // 顶部窗口的背景色，必须为十六进制颜色值，仅 iOS 支持 否 backgroundColorBottom: '#ffffff', // 底部窗口的背景色，必须为十六进制颜色值，仅 iOS 支持 否 success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.setBackgroundTextStyle(&#123; textStyle: 'dark', // 下拉背景字体、loading 图的样式。 必填 'light'，'dark' success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 8.3 自定义组件 wx.nextTick 延迟一部分操作到下一个时间片再执行。（类似于 setTimeout）？？？？？？？？12345678910111213141516171819202122// 以 wepy 框架的来编辑示例data = &#123; isplay:false, intervalId = null, text:'等会看我变'&#125;methods =&#123; pause() &#123; this.isplay = false; clearTimeout(this.intervalId); &#125;, play() &#123; this.isplay = true; this.setTimeoutFunc(); &#125;,&#125;setTimeoutFunc() &#123; this.intervalId = clearTimeout(() =&gt; &#123; this.text='3 秒过了，我变啦' this.$apply();// wepy 框架如是编辑 &#125;, 3000); &#125; 1234567891011121314151617Component(&#123; doSth() &#123; this.setData(&#123; number: 1 &#125;) // 直接在当前同步流程中执行 wx.nextTick(() = &gt; &#123; this.setData(&#123; number: 3 &#125;) // 在当前同步流程结束后，下一个时间片执行 &#125;) this.setData(&#123; number: 2 &#125;) // 直接在当前同步流程中执行 &#125;&#125;) 说明因为自定义组件中的 setData 和 triggerEvent 等接口本身是同步的操作，当这几个接口被连续调用时，都是在一个同步流程中执行完的，因此若逻辑不当可能会导致出错。 一个极端的案例：当父组件的 setData 引发了子组件的 triggerEvent，进而使得父组件又进行了一次 setData，期间有通过 wx:if 语句对子组件进行卸载，就有可能引发奇怪的错误，所以对于不需要在一个同步流程内完成的逻辑，可以使用此接口延迟到下一个时间片再执行。 8.4 交互（提示框，对话框）wx.showActionSheet ​显示操作菜单wx.showLoading 显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框wx.hideLoading 隐藏 loading 提示框 三个回调函数wx.showModal 显示模态对话框wx.showToast 显示消息提示框wx.hideToast 隐藏消息提示框 三个回调函数 loading 提示框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475wx.showActionSheet(&#123; itemList: ['A', 'B', 'C'],//按钮的文字数组，数组长度最大为 6 必填 itemColor:'#000000',//按钮的文字颜色 否 success (res) &#123; console.log(res.tapIndex)//9 用户点击的按钮序号，从上到下的顺序，从0开始 &#125;, fail (res) &#123; console.log(res.errMsg) &#125;, complete(res)&#123;&#125;&#125;)//注意//Android 6.7.2 以下版本，点击取消或蒙层时，回调 fail, errMsg 为 \"fail cancel\"；//Android 6.7.2 及以上版本 和 iOS 点击蒙层不会关闭模态弹窗，所以尽量避免使用「取消」分支中实现业务逻辑wx.showLoading(&#123; title: '加载中', //提示的内容 必填 mask:false,//是否显示透明蒙层，防止触摸穿透 否 默认值 false success(res)&#123;&#125;, fail (res) &#123;&#125;, complete(res)&#123;&#125;&#125;)setTimeout(function () &#123; wx.hideLoading(&#123; success(res)&#123;&#125;, fail (res) &#123;&#125;, complete(res)&#123;&#125; &#125;)&#125;, 2000)//注意//wx.showLoading 和 wx.showToast 同时只能显示一个//wx.showLoading 应与 wx.hideLoading 配对使用wx.showModal(&#123; title: '提示',// 提示的标题 必填 content: '这是一个模态弹窗',//提示的内容 必填 showCancel:true, //是否显示取消按钮 否 默认值true cancelText:'取消',//取消按钮的文字，最多 4 个字符 否 默认值 '取消' cancelColor:'#000000',//取消按钮的文字颜色，必须是 16 进制格式的颜色字符串 否 默认值 '#000000' confirmText:'确定',//确认按钮的文字，最多 4 个字符 否 默认值 '确定' confirmColor:'#3cc51f',//确认按钮的文字颜色，必须是 16 进制格式的颜色字符串 否 默认值 #3cc51f success (res) &#123; res.confirm//boolean 为 true 时，表示用户点击了确定按钮 res.cancel//boolean 为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭） if (res.confirm) &#123; console.log('用户点击确定') &#125; else if (res.cancel) &#123; console.log('用户点击取消') &#125; &#125;, fail (res) &#123;&#125;, complete(res)&#123;&#125;&#125;)//注意//Android 6.7.2 以下版本，点击取消或蒙层时，回调 fail, errMsg 为 \"fail cancel\"；//Android 6.7.2 及以上版本 和 iOS 点击蒙层不会关闭模态弹窗，所以尽量避免使用「取消」分支中实现业务逻辑wx.showToast(&#123; title: '成功',//提示的内容 必填 icon: 'success',//图标 否 默认值 'success' //success 显示成功图标，此时 title 文本最多显示 7 个汉字长度 //loading 显示加载图标，此时 title 文本最多显示 7 个汉字长度 //none 不显示图标，此时 title 文本最多可显示两行，1.9.0及以上版本支持 image:'',//自定义图标的本地路径，image 的优先级高于 icon duration: 2000,// 提示的延迟时间 默认值 1500 mask:false,//是否显示透明蒙层，防止触摸穿透 否 默认值 false success(res)&#123;&#125;, fail (res) &#123;&#125;, complete(res)&#123;&#125;&#125;)//注意//wx.showLoading 和 wx.showToast 同时只能显示一个//wx.showToast 应与 wx.hideToast 配对使用 8.5 菜单（导航栏） wx.getMenuButtonBoundingClientRect 获取菜单按钮（右上角胶囊按钮）的布局位置信息。坐标信息以屏幕左上角为原点。 1234567const menuButtonBoundingClientRect = wx.getMenuButtonBoundingClientRect()menuButtonBoundingClientRect.width//number 宽度，单位：pxmenuButtonBoundingClientRect.height//number 高度，单位：pxmenuButtonBoundingClientRect.top//number 上边界坐标，单位：pxmenuButtonBoundingClientRect.right//number 右边界坐标，单位：pxmenuButtonBoundingClientRect.bottom//number 下边界坐标，单位：pxmenuButtonBoundingClientRect.left//number 左边界坐标，单位：px 8.5.1 自定义导航栏自定义导航栏 8.6 导航栏wx.hideNavigationBarLoading 在当前页面隐藏导航条加载动画（就是一个加载转动圆圈） 三个回调函数wx.setNavigationBarColor 设置页面导航条颜色wx.setNavigationBarTitle 动态设置当前页面的标题wx.showNavigationBarLoading 在当前页面显示导航条加载动画（就是一个加载转动圆圈） 三个回调函数 12345678910111213141516171819202122wx.setNavigationBarColor(&#123; frontColor: '#ffffff',//前景颜色值，包括按钮、标题、状态栏的颜色，仅支持 #ffffff 和 #000000 必填 backgroundColor: '#ff0000',//背景颜色值，有效值为十六进制颜色 必填 animation: &#123;//动画效果 必填 duration: 400,//动画变化时间，单位 ms 否，默认值 0 timingFunc: 'easeIn'//动画变化方式 否，默认值 'linear' //'linear' 动画从头到尾的速度是相同的 //'easeIn' 动画以低速开始 //'easeOut' 动画以低速结束 //'easeInOut' 动画以低速开始和结束 &#125;, success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;)wx.setNavigationBarTitle(&#123; title: '当前页面',//页面标题 必填 success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 8.7 下拉刷新wx.startPullDownRefresh 开始下拉刷新。调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。 三个回调函数wx.stopPullDownRefresh 停止当前页面下拉刷新。 三个回调函数 12345Page(&#123; onPullDownRefresh () &#123; wx.stopPullDownRefresh() &#125;&#125;) 8.8 滚动 wx.pageScrollTo 将页面滚动到目标位置1234567wx.pageScrollTo(&#123; scrollTop: 0,//滚动到页面的目标位置，单位 px 必填 duration: 300,//滚动动画的时长，单位 ms 否， 默认 300 success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 8.9 置顶 （动态设置导航栏 与 tabbar 栏）8.9.1 wx.setTopBarText 动态设置置顶栏文字内容。基础库 1.4.3 开始支持，低版本需做兼容处理。从基础库 1.9.9 开始，本接口停止维护?????几个意思 只有当前小程序被置顶时能生效，如果当前小程序没有被置顶，也能调用成功，但是不会立即生效，只有在用户将这个小程序置顶后才换上设置的文字内容. 123456wx.setTopBarText(&#123; text: 'hello, world!',//置顶栏文字 必填 success(res)&#123;&#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125;&#125;) 注意调用成功后，需间隔 5s 才能再次调用此接口，如果在 5s 内再次调用此接口，会回调fail，errMsg：&quot;setTopBarText: fail invoke too frequently&quot; 8.9.2 Tab Bar 动态设置 tabbar 栏官方文档：网址 wx.hideTabBar 隐藏 tabBarwx.hideTabBarRedDot 隐藏 tabBar 某一项的右上角的红点wx.removeTabBarBadge 移除 tabBar 某一项右上角的文本wx.setTabBarBadge 为 tabBar 某一项的右上角添加文本wx.setTabBarItem 动态设置 tabBar 某一项的内容wx.setTabBarStylewx.showTabBarwx.showTabBarRedDot 8.10 窗口（窗口尺寸变化处理）wx.onWindowResize 监听窗口尺寸变化事件wx.offWindowResize 取消监听窗口尺寸变化事件 12345678910wx.onWindowResize((res)=&gt;&#123; res.size /* &#123; windowWidth// number 变化后的窗口宽度，单位 px windowHeight// number 变化后的窗口高度，单位 px &#125; */&#125;)wx.offWindowResize(()=&gt;&#123; //&#125;) 九、开放接口 (就是获取到用户的各种数据 的接口，开方消息的意思么)https://blog.csdn.net/weixin_39735923/article/details/79202563 后面看下这个文章是什么意思。 9.1 接口调用凭证9.1.1 什么是调用凭证，就是凭什么给你资料咯，就是给微信要的 tokenaccess_token 是公众号的全局唯一票据，公众号调用各接口时都需使用 access_token。开发者需要进行妥善保存。access_token 的存储至少要保留512 个字符空间。access_token 的有效期目前为 2 个小时，需定时刷新，重复获取将导致上次获取的 access_token 失效。 公众平台的 API 调用所需的 access_token 的使用及生成方式说明： 为了保密 appsecrect，第三方需要一个 access_token 获取和刷新的中控服务器。而其他业务逻辑服务器所使用的 access_token 均来自于该中控服务器，不应该各自去刷新，否则会造成 access_token 覆盖而影响业务； 目前 access_token 的有效期通过返回的 expire_in 来传达，目前是 7200 秒之内的值。中控服务器需要根据这个有效时间提前去刷新新access_token。在刷新过程中，中控服务器对外输出的依然是老 access_token，此时公众平台后台会保证在刷新短时间内，新老 access_token 都可用，这保证了第三方业务的平滑过渡； access_token 的有效时间可能会在未来有调整，所以中控服务器不仅需要内部定时主动刷新，还需要提供被动刷新 access_token 的接口，这样便于业务服务器在 API 调用获知 access_token 已超时的情况下，可以触发 access_token 的刷新流程。 9.1.2 getAccessToken 获取小程序全局唯一后台接口调用凭据（access_token）。9.1.2.1 获取Access Token的3种方式：【微信公众平台】网址当然 获取 token 是后端的工作。前端只要使用就好了。并且不要把 token 写在自己的前端代码中，这样做看到代码不就入侵了。总之就是后端写这个获取接口就对了。官方获取接口方法/参数要求 官方的接口调试工具。调试 token 官方网址 9.1.2.2 **调用各后台接口时都需使用 access_token，开发者需要进行妥善保存。本章下面所有的 API 接口都需要使用这个凭证才可以成功调用的。当然不能讲对应的值写在代码中，用变量保存就ok。并且 token 是有时效的，2 小时。如果请求很多，还不保存，系统应付不来这么多请求，就会崩溃的。每天仅限2000次。检查是否有效，重新请求也是后端的事情，不是前端干的事情。后端 php 代码 9.2 wx.getAccountInfoSync 获取当前帐号信息语法：Object wx.getAccountInfoSync() 无参数？？？ 不是说本章的 token 要带上的么？？ 1234567891011121314const accountInfo = wx.getAccountInfoSync();accountInfo.miniProgram//小程序帐号信息/* &#123; appId:''//小程序 appId&#125; */console.log(accountInfo.miniProgram.appId) // 小程序 appIdaccountInfo.plugin//插件帐号信息（仅在插件中调用时包含这一项）&#123; appId:'',//插件 appId version:'1.0.0'//插件版本号&#125;console.log(accountInfo.plugin.appId) // 插件 appIdconsole.log(accountInfo.plugin.version) // 插件版本号， 'a.b.c' 这样的形式 9.3 wx.chooseAddress 获取用户收货地址。调起用户编辑收货地址原生界面，并在编辑完成后返回用户选择的地址。9.3.1 调用前需要 用户授权 scope.address，用户授权????????? 9.3.2 语法：wx.chooseAddress(Object object) 获取用户收货地址 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;view class=\"container\"&gt; &lt;form&gt; &lt;view class=\"page-section\"&gt; &lt;view class=\"weui-cells weui-cells_after-title\"&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;收货人姓名&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &#123;&#123; addressInfo.userName &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;邮编&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &#123;&#123; addressInfo.postalCode &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input region\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;地区&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &#123;&#123; addressInfo.provinceName &#125;&#125; &#123;&#123; addressInfo.cityName &#125;&#125; &#123;&#123; addressInfo.countyName &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input detail\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;收货地址&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &#123;&#123; addressInfo.detailInfo &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;国家码&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &#123;&#123; addressInfo.nationalCode &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell weui-cell_input\"&gt; &lt;view class=\"weui-cell__hd\"&gt; &lt;view class=\"weui-label\"&gt;手机号码&lt;/view&gt; &lt;/view&gt; &lt;view class=\"weui-cell__bd\"&gt; &#123;&#123; addressInfo.telNumber &#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/form&gt; &lt;view class=\"btn-area\"&gt; &lt;button type=\"primary\" bindtap=\"chooseAddress\"&gt;获取收货地址&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930Page(&#123; data: &#123; addressInfo: null &#125;, chooseAddress() &#123; //获取用户收货地址。调起用户编辑收货地址原生界面，并在编辑完成后返回用户选择的地址。 wx.chooseAddress(&#123; success: (res) =&gt; &#123; console.log(res.userName)//收货人姓名 console.log(res.postalCode)//邮编 console.log(res.provinceName)//国标收货地址第一级地址 console.log(res.cityName)//国标收货地址第一级地址 console.log(res.countyName)//国标收货地址第一级地址 console.log(res.detailInfo)//详细收货地址信息 console.log(res.nationalCode)//收货地址国家码 console.log(res.telNumber)//收货人手机号码 console.log(res.errMsg)//错误信息 String ????错误信息是在这里么？？？ this.setData(&#123; addressInfo: res &#125;) &#125;, fail: function(err) &#123; console.log(err) &#125;, /* complete(res)&#123; // &#125; */ &#125;) &#125;&#125;) 12345678910111213141516@import \"../lib/weui.wxss\";form &#123; margin-top: 30rpx;&#125;.weui-cell__bd &#123; display: flex; justify-content: flex-start; padding: 20rpx 0; min-height: 60rpx;&#125;.btn-area &#123; margin-top: 30rpx;&#125; 1/*lib/weui.css*/ 9.4 wx.authorize 授权: 提前向用户发起授权请求。调用后会立刻弹窗询问用户是否同意授权小程序使用某项功能或获取用户的某些数据，但不会实际调用对应接口。如果用户之前已经同意授权，则不会出现弹窗，直接返回成功。更多用法详见 用户授权。 12345678910111213141516171819202122// 可以通过 wx.getSetting 先查询一下用户是否授权了 \"scope.record\" 这个 scopewx.getSetting(&#123; success(res) &#123; if (!res.authSetting['scope.record']) &#123; //提前向用户发起授权请求。 wx.authorize(&#123; scope: 'scope.record',//需要获取权限的 scope，详见 scope 列表 必填 success () &#123; wx.startRecord() // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问 &#125;, fail()&#123; // &#125;, complete()&#123; // &#125; &#125;) &#125; &#125;&#125;) 9.5 卡券9.5.1 小程序 认证只有 通过 认证 的小程序 才能使用卡券 功能。更多文档请参考 微信卡券接口文档。 小程序认证微信卡券接口文档。 9.5.2 wx.addCard(Object object) 批量添加卡券。小程序先要认证code 解码接口 12345678910111213141516171819202122wx.addCard(&#123; cardList: [ //参数：需要添加的卡券列表 必填 &#123; cardId: '',//卡券 ID 必填 // 卡券的扩展参数。需进行 JSON 序列化为字符串传入 必填 cardExt: '&#123;\"code\": \"\", \"openid\": \"\", \"timestamp\": \"\", \"signature\":\"\"&#125;' &#125;, &#123; cardId: '', cardExt: '&#123;\"code\": \"\", \"openid\": \"\", \"timestamp\": \"\", \"signature\":\"\"&#125;' &#125; ], success (res) &#123; console.log(res.cardList) // 卡券添加结果 &#123; code:'', //加密 code，为用户领取到卡券的code加密后的字符串，解密请参照：code 解码接口 cardId: '',//用户领取到卡券的 ID cardExt: '',//卡券的扩展参数，结构请参考前文 isSuccess://numean 是否成功 &#125; &#125;&#125;) cardExt 的结构:cardExt 是卡券的扩展参数，其值是一个 JSON 字符串。 ‘code’: ‘’, //否 用户领取的 code，仅自定义 code 模式的卡券须填写，非自定义 code 模式卡券不可填写，详情 ‘openid’: ‘’, // 否 指定领取者的 openid，只有该用户能领取。 bind_openid 字段为 true 的卡券必须填写，bind_openid 字段为 false 不可填写。 ‘timestamp’: 8, 必填 时间戳，东八区时间,UTC+8，单位为秒 // number？？？？那上面的示例代码为什么是字符串？？？ ‘nonce_str’: ‘’, 随机字符串，由开发者设置传入，加强安全性（若不填写可能被重放请求）。随机字符串，不长于 32 位。推荐使用大小写字母和数字，不同添加请求的 nonce_str 须动态生成，若重复将会导致领取失败。 ‘fixed_begintimestamp’: 8, // number // number？？？？那上面的示例代码为什么是字符串？？？ 卡券在第三方系统的实际领取时间，为东八区时间戳（UTC+8,精确到秒）。当卡券的有效期类为 DATE_TYPE_FIX_TERM 时专用，标识卡券的实际生效时间，用于解决商户系统内起始时间和领取微信卡券时间不同步的问题。 ‘outer_str’:’’, // 否 领取渠道参数，用于标识本次领取的渠道值。 ‘signature’:’’, // 必填 签名，商户将接口列表中的参数按照指定方式进行签名,签名方式使用 SHA1，具体签名方案参见：卡券签名 9.5.3 wx.openCard(Object object) 查看微信卡包中的卡券。小程序先要认证code 解码接口 123456789101112131415161718wx.openCard(&#123; cardList: [&#123;//需要打开的卡券列表 必填 cardId: '',//卡券 ID 必填 code: ''//由 wx.addCard 的返回对象中的加密 code 通过解密后得到，解密请参照：code 解码接口 必填 &#125;, &#123; cardId: '', code: '' &#125;], success (res) &#123; // &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;) 9.6 客服消息？？？？？？？？？？？？？？？？？？？不知道具体是怎么做的9.6.1 customerTyping 客服输入状态接口下发客服当前输入状态给用户。详见 客服消息输入状态 客服输入状态:开发者可通过调用 [客服输入状态接口] customerTyping，返回客服当前输入状态给用户。 此接口需要客服消息接口权限。 如果不满足发送客服消息的触发条件，则无法下发输入状态。 下发输入状态，需要客服之前 30 秒内跟用户有过消息交互。 在输入状态中（持续 15 秒），不可重复下发输入态。 在输入状态中，如果向用户下发消息，会同时取消输入状态。 9.6.1 getTempMedia 获取客服消息内的临时素材。即下载临时的多媒体文件。目前小程序仅支持下载图片文件。9.6.1 sendCustomerMessage 发送客服消息给用户。详细规则见 发送客服消息 发送客服消息当用户和小程序客服产生特定动作的交互时（具体动作列表请见下方说明），微信将会把消息数据推送给开发者，开发者可以在一段时间内（目前为 48 小时）调用客服接口，通过调用 发送客服消息接口 来发送消息给普通用户。此接口主要用于客服等有人工消息处理环节的功能，方便开发者为用户提供更加优质的服务。 目前允许的动作列表如下，不同动作触发后，允许的客服接口下发消息条数和下发时限不同。 用户动作 允许下发条数限制 下发时限用户发送消息 5 条 48 小时 9.6.1 uploadTempMedia 把媒体文件上传到微信服务器。目前仅支持图片。用于发送客服消息或被动回复用户消息。9.7 数据分析9.7.1 wx.reportAnalytics 自定义分析数据上报接口。使用前，需要在小程序管理后台自定义分析中新建事件，配置好事件名与字段 12345678910wx.reportAnalytics('purchase', &#123; price: 120, color: 'red'&#125;)//'purchase' 自动事件名 必填/* &#123; price: 120, 配置中的字段名 price 上报的数据 120 color: 'red' 配置中的字段名 color 上报的数据 'red'&#125; */ 9.7.1 getAnalysisDailyRetain 获取用户访问小程序日留存 (本接口应在后端服务器调用!!!!!所以这个是后端的工作咯)官网地址 9.7.1 getAnalysisDailySummary 获取用户访问小程序数据概况 本接口应在后端服务器调用官网地址 9.7.1 getAnalysisDailyVisitTrend 获取用户访问小程序数据日趋势 本接口应在后端服务器调用9.7.1 getAnalysisMonthlyRetain 获取用户访问小程序周留存 本接口应在后端服务器调用9.7.1 getAnalysisMonthlyVisitTrend 获取用户访问小程序数据月趋势 本接口应在后端服务器调用9.7.1 getAnalysisUserPortrait 获取小程序新增或活跃用户的画像分布数据。本接口应在后端服务器调用时间范围支持昨天、最近7天、最近30天。其中，新增用户数为时间范围内首次访问小程序的去重用户数，活跃用户数为时间范围内访问过小程序的去重用户数。 9.7.1 getAnalysisVisitDistribution 获取用户小程序访问分布数据 本接口应在后端服务器调用9.7.1 getAnalysisVisitPage 访问页面。目前只提供按 page_visit_pv 排序的 top200。 本接口应在后端服务器调用9.7.1 getAnalysisWeeklyRetain 获取用户访问小程序周留存 本接口应在后端服务器调用9.7.1 getAnalysisWeeklyVisitTrend 获取用户访问小程序数据周趋势 本接口应在后端服务器调用9.8 发票9.8.1 用户授权调用前需要 scope.invoice 用户授权 9.8.1 wx.chooseInvoice 选择用户已有的发票调用前需要 scope.invoice 用户授权 语法：wx.chooseInvoice(Object object) 基础库 2.3.0 开始支持，低版本需做兼容处理。 12345678910111213141516wx.chooseInvoice(&#123; success(res)&#123; //res.invoiceInfo 用户选中的发票列表 /* &#123; ardId: '',//所选发票卡券的 cardId encryptCode: '',//所选发票卡券的加密 code，报销方可以通过 cardId 和 encryptCode 获得报销发票的信息 publisherAppId:''//发票方的 appId &#125; */ &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;) 通过 cardId 和 encryptCode 获得报销发票的信息请参考微信电子发票文档中，「查询报销发票信息」部分。 其中 access_token 的获取请参考getAccessToken文档 微信电子发票文档getAccessToken文档 9.8.2 wx.chooseInvoiceTitle 选择用户的发票抬头调用前需要 scope.invoiceTitle 用户授权 语法：wx.chooseInvoiceTitle(Object object) 123456789101112131415161718wx.chooseInvoiceTitle(&#123; success(res)&#123; res.type:'0',//string 抬头类型 0：单位 1：个人 res.title:'',//抬头名称 res.taxNumber:'',//抬头税号 res.companyAddress:'',//单位地址 res.telephone:'',//手机号码 res.bankName:'',//银行名称 res.bankAccount:'',//银行账号 res.errMsg:''//错误信息 &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;) 9.9 登录官网小程序登录流程图 小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。 9.9.1 wx.checkSession 检查登录态是否过期。通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。 登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期。更多使用方法详见 小程序登录。(就是 9.9 解释的流程) 9.9.2 wx.login 调用接口获取登录凭证 code （这个code是临时登录凭证，用于获取 openid 的）通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。更多使用方法详见 小程序登录。(就是 9.9 解释的流程) 9.9.3 前端登录代码123456789101112131415161718192021222324252627282930313233343536wx.checkSession(&#123; success () &#123; //session_key 未过期，并且在本生命周期一直有效 &#125;, fail () &#123; // session_key 已经失效，需要重新执行登录流程 //重新登录 wx.login(&#123; success (res) &#123; if (res.code) &#123; //发起网络请求 wepy 框架对这个有封装了。 wx.request(&#123; url: 'https://test.com/onLogin', data: &#123; code: res.code &#125; &#125;) &#125; else &#123; console.log('登录失败！' + res.errMsg) &#125; &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125; &#125;) &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;) 12345678910//wepy 框架的写法// 方法一、WePY 使用方式, 需要开启 Promise 支持，参考开发规范章节wepy.request('xxxx').then((d) =&gt; console.log(d));// 方法二、async/await 的使用方式, 需要开启 Promise 和 async/await 支持，参考 WIKIasync function request () &#123; let d = await wepy.request('xxxxx'); console.log(d);&#125; 9.9.4 code2Session 登录凭证校验。 本接口应在后端服务器调用官网地址 9.10 小程序跳转 (从一个小程序 跳转 另外一个小程序)9.10.1 wx.navigateToMiniProgram 返回到上一个小程序。只有在当前小程序是被其他小程序打开时可以调用成功小程序 1.3.0，小游戏 2.2.0 12345678910111213141516171819//A 小程序 =&gt; B 小程序wx.navigateToMiniProgram(&#123; appId: '',//要打开的小程序 appId 必填 path: 'page/index/index?id=123',//打开的页面路径，如果为空则打开首页 否 extraData: &#123;// 需要传递给目标小程序的数据，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据。 否 foo: 'bar' &#125;, envVersion: 'develop',//要打开的小程序版本。否 默认值 'release':正式版本，'develop':开发版本，'trial':体验版 //仅在当前小程序为开发版或体验版时此参数有效。如果当前小程序是正式版，则打开的小程序必定是正式版。 success(res) &#123; // 打开成功 &#125;, fail(res)&#123; // &#125;, complete(res)&#123; // &#125;&#125;) 12345678910// B 小程序(app.js 或者 app.wpy 中)onShow()&#123; //获取到这份数据。extraData&#125;//或者onLaunch()&#123; //获取到这份数据。extraData&#125; 使用限制： 需要用户触发跳转： 从 2.3.0 版本开始，若用户未点击小程序页面任意位置，则开发者将无法调用此接口自动跳转至其他小程序。 需要用户确认跳转： 从 2.3.0 版本开始，在跳转至其他小程序前，将统一增加弹窗，询问是否跳转，用户确认后才可以跳转其他小程序。如果用户点击取消，则回调 fail cancel。 每个小程序可跳转的其他小程序数量限制为不超过 10 个： 从 2.4.0 版本以及指定日期（具体待定）开始，开发者提交新版小程序代码时，如使用了跳转其他小程序功能，则需要在代码配置中声明将要跳转的小程序名单，限定不超过 10 个，否则将无法通过审核。该名单可在发布新版时更新，不支持动态修改。配置方法详见 配置。调用此接口时，所跳转的 appId 必须在配置列表中，否则回调 fail appId &quot;${appId}&quot; is not in navigateToMiniProgramAppIdList。 在 app.json / 或者是 app.wpy 中设置如下 &quot;navigateToMiniProgramAppIdList&quot;: [&quot;wxe5f52902cf4de896&quot;] 该项配置 关于调试 在开发者工具上调用此 API 并不会真实的跳转到另外的小程序，但是开发者工具会校验本次调用跳转是否成功。详情 开发者工具上支持被跳转的小程序处理接收参数的调试。详情 9.10.2 wx.navigateBackMiniProgram 打开另一个小程序基础库 1.3.0 开始支持，低版本需做兼容处理。注意：微信客户端 iOS 6.5.9，Android 6.5.10 及以上版本支持 12345678910111213141516// B 小程序 =&gt; A 小程序wx.navigateBackMiniProgram(&#123; // 需要返回给上一个小程序的数据，上一个小程序可在 App.onShow 中获取到这份数据。 extraData: &#123; foo: 'bar' &#125;, success(res) &#123; // 返回成功 &#125;, fail(res)&#123; // &#125;/* , complete(res)&#123; // &#125; */&#125;) 1234// A 小程序(app.js 或者 app.wpy 中)onShow()&#123; //获取到这份数据。extraData&#125; 9.11 附近的小程序（后端的工作）官网文档地址 9.11.1 addNearbyPoi 添加地点 本接口应在后端服务器调用9.11.1 deleteNearbyPoi 删除地点 本接口应在后端服务器调用9.11.1 getNearbyPoiList 查看地点列表 本接口应在后端服务器调用9.11.1 setNearbyPoiShowStatus 展示/取消展示附近小程序 本接口应在后端服务器调用9.12 支付（仅仅是微信支付）9.12.1 wx.requestPayment 发起微信支付。了解更多信息，请查看微信支付接口文档了解更多信息，小程序支付接口文档 12345678910wx.requestPayment(&#123; timeStamp: '', // 必填 时间戳，从 1970 年 1 月 1 日 00:00:00 至今的秒数，即当前的时间 nonceStr: '', // 必填 随机字符串，长度为32个字符以下 package: '', // 必填 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*** signType: 'MD5',// 否 签名算法 2 个合法值：'MD5', 'HMAC-SHA256' paySign: '', // 必填 签名，具体签名方案参见 小程序支付接口文档 success (res) &#123; &#125;, fail (res) &#123; &#125; /* complete(res)&#123;&#125; */&#125;) 9.13 插件管理 （本接口应在后端服务器调用）官网教程 9.13.1applyPlugin 向插件开发者发起使用插件的申请（本接口应在后端服务器调用）9.13.1getPluginDevApplyList 获取当前所有插件使用方（供插件开发者调用）（本接口应在后端服务器调用）9.13.1getPluginList 查询已添加的插件（本接口应在后端服务器调用）9.13.1setDevPluginApplyStatus 修改插件使用申请的状态（供插件开发者调用）（本接口应在后端服务器调用）9.13.1unbindPlugin 删除已添加的插件（本接口应在后端服务器调用）9.14 二维码 （本接口应在后端服务器调用）9.14.1 createWXAQRCode 获取 [小程序二维码]，适用于需要的码数量 [较少] 的业务场景。 （本接口应在后端服务器调用）通过该接口生成的小程序码，永久有效，有数量限制，详见获取二维码 9.14.1 getWXACode 获取 [小程序码]，适用于需要的码数量 [较少] 的业务场景。 （本接口应在后端服务器调用）通过该接口生成的小程序码，永久有效，有数量限制，详见获取二维码 9.14.1 getWXACodeUnlimit 获取 [小程序码]，适用于需要的码数量 [极多] 的业务场景。 （本接口应在后端服务器调用）通过该接口生成的小程序码，永久有效，数量暂无限制。 详见获取二维码 9.15 内容安全（检查 用户 图片 或者 文本 的安全性）（本接口应在后端服务器调用）官网教程 9.15.1 imgSecCheck 校验一张图片是否含有违法违规内容。（本接口应在后端服务器调用）9.15.1 msgSecCheck 检查一段文本是否含有违法违规内容。（本接口应在后端服务器调用）9.16 设置9.16.1 AuthSettingAuthSetting用户授权设置信息，详情参考权限 属性boolean scope.userInfo是否授权用户信息，对应接口 wx.getUserInfo boolean scope.userLocation是否授权地理位置，对应接口 wx.getLocation, wx.chooseLocation boolean scope.address是否授权通讯地址，对应接口 wx.chooseAddress boolean scope.invoiceTitle是否授权发票抬头，对应接口 wx.chooseInvoiceTitle boolean scope.invoice是否授权获取发票，对应接口 wx.chooseInvoice boolean scope.werun是否授权微信运动步数，对应接口 wx.getWeRunData boolean scope.record是否授权录音功能，对应接口 wx.startRecord boolean scope.writePhotosAlbum是否授权保存到相册 wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum boolean scope.camera是否授权摄像头，对应 组件 9.16.2 wx.getSetting 获取用户的当前设置。返回值中只会出现小程序已经向用户请求过的权限。 123456789wx.getSetting(&#123; success (res) &#123; console.log(res.authSetting)//用户授权结果 // res.authSetting = &#123; // \"scope.userInfo\": true, // \"scope.userLocation\": true // &#125; &#125;&#125;) 9.16.3 wx.openSetting 调起客户端小程序设置界面，返回用户设置的操作结果。设置界面只会出现小程序已经向用户请求过的权限注意：2.3.0 版本开始，用户发生点击行为后，才可以跳转打开设置页，管理授权信息。详情 123456789wx.openSetting(&#123; success (res) &#123; console.log(res.authSetting)//用户授权结果 // res.authSetting = &#123; // \"scope.userInfo\": true, // \"scope.userLocation\": true // &#125; &#125;&#125;) 9.17 生物认证(指纹识别，人脸识别，声纹识别)9.17.1 wx.checkIsSoterEnrolledInDevice 获取设备内是否录入如指纹等生物信息的接口12345678910wx.checkIsSoterEnrolledInDevice(&#123; checkAuthMode: 'fingerPrint', //Array.&lt;string&gt; 不是字符串数组 么？？？？？这里好像不对把？？？ 认证方式 必填 // 'fingerPrint':指纹识别 'facial':人脸识别（暂未支持） 'speech':声纹识别（暂未支持） success(res) &#123; console.log(res.isEnrolled)//是否已录入信息 boolean console.log(res.errMs)//错误信息 string &#125;, fail(res)&#123;&#125;, //complete(res)&#123;&#125;&#125;) 9.17.1 wx.checkIsSupportSoterAuthentication9.17.1 wx.startSoterAuthentication9.18 模板消息 （本接口应在后端服务器调用）官网文档 9.18.1 addTemplate 组合模板并添加至帐号下的个人模板库（本接口应在后端服务器调用）9.18.1 deleteTemplate 删除帐号下的某个模板（本接口应在后端服务器调用）9.18.1 getTemplateLibraryById 获取模板库某个模板标题下关键词库（本接口应在后端服务器调用）9.18.1 getTemplateLibraryList 获取小程序模板库标题列表（本接口应在后端服务器调用）9.18.1 getTemplateList 获取帐号下已存在的模板列表（本接口应在后端服务器调用）9.18.1 sendTemplateMessage 发送模板消息（本接口应在后端服务器调用）9.19 统一服务消息 （本接口应在后端服务器调用）9.19.1 sendUniformMessage 下发小程序和公众号统一的服务消息 （本接口应在后端服务器调用）9.20 动态消息 （本接口应在后端服务器调用）动态消息 9.20.1 createActivityId 创建被分享动态消息的 activity_id。 （本接口应在后端服务器调用）9.20.2 setUpdatableMsg 修改被分享的动态消息。详见动态消息。（本接口应在后端服务器调用）9.21 用户信息 (调用前需要 用户授权)9.21.1 UserInfo 用户信息 nickName：string avatarUrl：string 用户头像图片的 URL。URL 最后一个数值代表正方形头像大小（有 0、46、64、96、132 数值可选，0 代表 640x640 的正方形头像，46 表示 46x46 的正方形头像，剩余数值以此类推。默认132），用户没有头像时该项为空。若用户更换头像，原有头像 URL 将失效。 gender:number 0:未知 1:男性 2:女性 country:’’ 用户所在国家 province:’’ 用户所在省份 city:’’ 用户所在城市 ‘language’:’’ 显示 country，province，city 所用的语言 en: 英文 zh_CN:简体中文 zh_TW:体中文 9.21.2 wx.getUserInfo 获取用户信息。userInfo 类型的数据：就是 9.21.1 中说的类型加密数据解密算法 123456789101112131415161718192021222324// 必须是在用户已经授权的情况下调用wx.getUserInfo(&#123; withCredentials:true,//是否带上登录态信息。 否 //当 withCredentials 为 true 时，要求此前有调用过 wx.login 且登录态尚未过期， //此时返回的数据会包含 encryptedData, iv 等敏感信息； //当 withCredentials 为 false 时，不要求有登录态，返回的数据不包含 encryptedData, iv 等敏感信息。 lang:'en',//显示用户信息的语言 否 默认值'en'：英文 zh_CN：简体中文 zh_TW：繁体中文 success: function(res) &#123; var userInfo = res.userInfo// UserInfo 用户信息对象，不包含 openid 等敏感信息 res.rawData = ''//不包括敏感信息的原始数据字符串，用于计算签名 res.signature = ''//使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，详见 用户数据的签名验证和加解密 res.encryptedData = ''//包括敏感数据在内的完整用户信息的加密数据，详见 用户数据的签名验证和加解密 res.iv = ''//加密算法的初始向量，详见 用户数据的签名验证和加解密 var nickName = userInfo.nickName var avatarUrl = userInfo.avatarUrl var gender = userInfo.gender //性别 0：未知、1：男、2：女 var province = userInfo.province var city = userInfo.city var country = userInfo.country &#125;, fail(res)&#123;&#125;, /* complete(res)&#123;&#125; */&#125;) encryptedData 解密后为以下 json 结构，详见加密数据解密算法 1234567891011121314&#123; \"openId\": \"OPENID\", \"nickName\": \"NICKNAME\", \"gender\": GENDER, \"city\": \"CITY\", \"province\": \"PROVINCE\", \"country\": \"COUNTRY\", \"avatarUrl\": \"AVATARURL\", \"unionId\": \"UNIONID\", \"watermark\": &#123; \"appid\": \"APPID\", \"timestamp\": TIMESTAMP &#125;&#125; 9.21.1.1 在用户未授权过的情况下调用此接口，将不再出现授权弹窗!!!!!!!!!!!!!!!!!!!!!!!!!!!!每次小程序都提示的消息会直接进入 fail 回调（详见《公告》)。在用户已授权的情况下调用此接口，可成功获取用户信息。 123456&lt;!-- 如果只是展示用户头像昵称，可以使用 &lt;open-data /&gt; 组件 --&gt;&lt;open-data type=\"userAvatarUrl\"&gt;&lt;/open-data&gt;&lt;open-data type=\"userNickName\"&gt;&lt;/open-data&gt;&lt;!-- 需要使用 button 来授权登录 --&gt;&lt;button wx:if=\"&#123;&#123;canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\"&gt;授权登录&lt;/button&gt;&lt;view wx:else&gt;请升级微信版本&lt;/view&gt; 1234567891011121314151617181920212223Page(&#123; data: &#123; canIUse: wx.canIUse('button.open-type.getUserInfo') &#125;, onLoad: function() &#123; // 查看是否授权 wx.getSetting(&#123; success (res)&#123; if (res.authSetting['scope.userInfo']) &#123; // 已经授权，可以直接调用 getUserInfo 获取头像昵称 wx.getUserInfo(&#123; success: function(res) &#123; console.log(res.userInfo) &#125; &#125;) &#125; &#125; &#125;) &#125;, bindGetUserInfo (e) &#123; console.log(e.detail.userInfo) &#125;&#125;) 9.22微信运动 (调用前需要 用户授权)9.22.1 wx.getWeRunData 获取用户过去三十天微信运动步数。调用前需要 用户授权 scope.werun。需要先调用 wx.login 接口。步数信息会在用户主动进入小程序时更新。 加密数据解密算法 123456789wx.getWeRunData(&#123; success(res) &#123; //res.encryptedData:'', 包括敏感数据在内的完整用户信息的加密数据，详细见加密数据解密算法。 //res.iv:'' 加密算法的初始向量 const encryptedData = res.encryptedData &#125;, fail(res) &#123;&#125;, /* complete (res) &#123;&#125; */&#125;) 12345678910111213//encryptedData 解密后 JSON 结构&#123; \"stepInfoList\": [ &#123; \"timestamp\": 1445866601,//时间戳，表示数据对应的时间 \"step\": 100//微信运动步数 &#125;, &#123; \"timestamp\": 1445876601, \"step\": 120 &#125; ]&#125; 十、更新 UpdateManager(小程序版本更新)（个人中心提示用户版本升级用的）UpdateManager 对象，用来管理更新，可通过 wx.getUpdateManager 接口获取实例。 10.1 wx.getUpdateManager 获取全局唯一的版本更新管理器，用于管理小程序更新。关于小程序的更新机制，可以查看运行机制文档。小程序运行机制 小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。（这个跟小车的启动方式么~） 热启动：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动； 冷启动：指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。 10.2 UpdateManager.applyUpdate 强制小程序重启并使用新版本。在小程序新版本下载完成后（即收到 onUpdateReady 回调）调用。 10.3 UpdateManager.onCheckForUpdate 监听向微信后台请求检查更新结果事件。微信在小程序冷启动时自动检查更新，不需由开发者主动触发。 10.4 UpdateManager.onUpdateFailed 监听小程序更新失败事件。小程序有新版本，客户端主动触发下载（无需开发者触发），下载失败（可能是网络原因等）后回调 10.5 UpdateManager.onUpdateReady 监听小程序有版本更新事件。客户端主动触发下载（无需开发者触发），下载成功后回调 10.6 完整示例代码123456789101112131415161718192021222324252627const updateManager = wx.getUpdateManager()//获取全局唯一的版本更新管理器，用于管理小程序更新。(更新管理器对象)//监听向微信后台请求检查更新结果事件。微信在小程序冷启动时自动检查更新，不需由开发者主动触发。updateManager.onCheckForUpdate((res)=&gt;&#123; // 请求完新版本信息的回调 console.log(res.hasUpdate)//是否有新版本 boolean&#125;)//监听小程序有版本更新事件。客户端主动触发下载（无需开发者触发），下载成功后回调updateManager.onUpdateReady(function () &#123; wx.showModal(&#123; title: '更新提示', content: '新版本已经准备好，是否重启应用？', success: function (res) &#123; if (res.confirm) &#123; // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 // 强制小程序重启并使用新版本。在小程序新版本下载完成后（即收到 onUpdateReady 回调）调用。 updateManager.applyUpdate() &#125; &#125; &#125;)&#125;)//监听小程序更新失败事件。小程序有新版本，客户端主动触发下载（无需开发者触发），下载失败（可能是网络原因等）后回调updateManager.onUpdateFailed(function () &#123; // 新版本下载失败&#125;) 注意：Tips微信开发者工具上可以通过「编译模式」下的「下次编译模拟更新」开关来调试小程序开发版/体验版没有「版本」概念，所以无法在开发版/体验版上测试更版本更新情况 十一、Worker（运行一些异步处理的任务）（就是变成语言中的单线程 与 多线程 js 中是单线程工作的）Worker 实例，主线程中可通过 wx.createWorker 接口获取，worker 线程中可通过全局变量 worker 获取。 一些异步处理的任务，可以放置于 Worker 中运行，待运行结束后，再把结果返回到小程序主线程。Worker 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法。 Worker 与主线程之间的数据传输，双方使用 Worker.postMessage() 来发送数据，Worker.onMessage() 来接收数据，传输的数据并不是直接共享，而是被复制的。 11.1 wx.createWorker 创建一个 Worker 线程。目前限制最多只能创建一个 Worker，创建下一个 Worker 前请先调用 Worker.terminate 11.2 Worker.onMessage 监听主线程/Worker 线程向当前线程发送的消息的事件。11.3 Worker.postMessage 向主线程/Worker 线程发送的消息。语法：Worker.postMessage(Object message) 参数：需要发送的消息，必须是一个可序列化的 JavaScript 对象。 11.4 Worker.terminate() 结束当前 Worker 线程。仅限在主线程 worker 对象上调用。无参数 11.5 完整的示例代码！！！！！！！！！！！！！运行以下代码需先进行基础配置，详细请查阅 多线程 文档了解基础知识和配置方法。 11.5.1 使用流程：配置过程官网网址 1234567891011const worker = wx.createWorker('workers/request/index.js') // 文件名指定 worker 的入口文件路径，绝对路径worker.onMessage((res)=&gt; &#123; console.log(res)&#125;)worker.postMessage(&#123; msg: 'hello worker'&#125;)worker.terminate() 十二、数据上报（小程序管理后台-运维中心-性能监控-业务数据监控）（说白了就是小程序的用户使用各种情况数据？？？）12.1 wx.reportMonitor 自定义业务数据监控上报接口。语法：wx.reportMonitor(string name, number value) 123wx.reportMonitor('1', 1)// 参数 ① string 监控 ID，在「小程序管理后台」新建数据指标后获得// 参数 ② number 上报数值，经处理后会在「小程序管理后台」上展示每分钟的上报总量 使用前，需要在「小程序管理后台-运维中心-性能监控-业务数据监控」中新建监控事件，配置监控描述与告警类型。每一个监控事件对应唯一的监控 ID，开发者最多可以创建 128 个监控事件。 十三、小程序（事件错误 与 生命周期）13.1 wx.offError 事件：取消监听小程序错误事件。语法：wx.offError(function callback) 123wx.offError((res)=&gt;&#123; //&#125;) 13.2 wx.onError 事件：监听小程序错误事件。如脚本错误或API调用报错等。？？？？？看不懂啊？？？？语法：wx.onError(function callback) 123wx.offError((res)=&gt;&#123; //错误信息，包含堆栈&#125;) 13.3 wx.getLaunchOptionsSync 生命周期 ：获取小程序启动时的参数。与 App.onLaunch 的回调参数一致。12345678910111213const obj = wx.getLaunchOptionsSync()obj.path//打开小程序的路径obj.scene//打开小程序的场景值 numberobj.query//打开小程序的启动参数 Object 所以原生的 onload 接收参数就是 option.query 就是这个 url 传参的对象!!!obj.shareTicket//获取更多转发信息 Stringobj.referrerInfo//Object 来源信息。从另一个小程序、公众号或 App 进入小程序时返回。否则返回 &#123;&#125;。(参见后文注意)referrerInfo:&#123; appId:'',//来源小程序、公众号或 App 的 appId extraData:&#123; //来源小程序传过来的数据，scene=1037 或 1038 时支持， 13.3.4 中的其他值呢？？？支持么？？？？ &#125;&#125; 13.3.1 scene 场景值官网网址 1005 ，1104 等 对于小程序，可以在 App 的 onLaunch 和 onShow，或 wx.getLaunchOptionsSync 中获取上述场景值。 对于小游戏，可以在 wx.getLaunchOptionsSync 和 wx.onShow 中获取上述场景值 小游戏于小程序什么区别？？？？？？部分场景值下还可以获取来源应用、公众号或小程序的 appId。 Tip: 由于 Android 系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。 13.3.2 wx.getLaunchOptionsSync 返回有效 referrerInfo 的场景1234561020 公众号 profile 页相关小程序列表 来源公众号1035 公众号自定义菜单 来源公众号1036 App 分享消息卡片 来源App1037 小程序打开小程序 来源小程序1038 从另一个小程序返回 来源小程序1043 公众号模板消息 来源公众号 13.3.3 注意部分版本在无 referrerInfo 的时候会返回 undefined，建议使用 wx.canIUse 接口进行判断。 1wx.canIUse('options.referrerInfo &amp;&amp; options.referrerInfo.appId') 十四、基础（判断是否可以 某些 API 接口：当然是能用才可以用）14.1 wx.canIUse 判断小程序的API，回调，参数，组件等是否在当前版本可用。1234567891011参数的写法：①： $&#123;API&#125;.$&#123;method&#125;.$&#123;param&#125;.$&#123;options&#125; # API.method.param.options②: $&#123;component&#125;.$&#123;attribute&#125;.$&#123;option&#125; # component.attribute.option参数说明:$&#123;API&#125; 代表 API 名字$&#123;method&#125; 代表调用方式，有效值为return, success, object, callback$&#123;param&#125; 代表参数或者返回值$&#123;options&#125; 代表参数的可选值$&#123;component&#125; 代表组件名字$&#123;attribute&#125; 代表组件属性$&#123;option&#125; 代表组件属性的可选值 12345678910wx.canIUse('openBluetoothAdapter') //APIwx.canIUse('getSystemInfoSync.return.screenWidth')//API.method.optionswx.canIUse('getSystemInfo.success.screenWidth')//API.method.optionswx.canIUse('showToast.object.image')wx.canIUse('onCompassChange.callback.direction')wx.canIUse('request.object.method.GET')//？？？？？？？？？？？？？这个就看不懂了呀wx.canIUse('live-player')wx.canIUse('text.selectable')wx.canIUse('button.open-type.contact') 十五、画布（是不是做动画的？？？？？后面再学习吧）15.1 Color 颜色。可以用以下几种方式来表示 canvas 中使用的颜色：1234# RGB 颜色： 如 'rgb(255, 0, 0)'# RGBA 颜色： 如 'rgba(255, 0, 0, 0.3)' 带有透明度# 16 进制颜色： 如 '#FF0000'，大小写不敏感# 预定义的颜色： 如 'red'， 大小写不敏感 预定义的颜色官网网址 15.2 CanvasContext 是 canvas 组件的绘图上下文官网地址 15.2.1 wx.createCanvasContext（） 创建 创建 CanvasContext 对象一个参数 1&lt;canvas canvas-id=\"myCanvas\" class=\"myCanvas\" &gt;&lt;/canvas&gt; 1234567onLoad()&#123; // 一、创建对象 const ctx = wx.createCanvasContext('myCanvas')// //对应的参数 // 参数 ① ：是 &lt;canvas&gt; 组件的 canvas-id 属性值 //没有 this（省略第二个参数），则不在任何自定义组件内查找，就是重新绘制。？？？？&#125; 2 个参数 12345&lt;canvas canvas-id=\"canvasIn\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;canvas canvas-id=\"canvasOut\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;button bindtap=\"openAndDraw\"&gt;打开图片并绘制&lt;/button&gt;&lt;button bindtap=\"process\"&gt;处理图像&lt;/button&gt;&lt;button bindtap=\"export\"&gt;导出画布至图片&lt;/button&gt; 1234567891011 openAndDraw() &#123; wx.chooseImage(&#123; success: (res) =&gt; &#123; const ctx = wx.createCanvasContext('canvasIn', this); ctx.drawImage(res.tempFilePaths[0], 0, 0) ctx.draw() &#125; &#125;) &#125;// 参数 ① ： 是 &lt;canvas&gt; 组件的 canvas-id 属性值// 参数 ② ： 在自定义组件下，当前组件实例的 this，表示在这个自定义组件下查找拥有 canvas-id 的 &lt;canvas&gt; ， 15.2.1 CanvasContext.arc 与 CanvasContext.arcTo 绘制一段弧线1&lt;canvas canvas-id=\"myCanvas\" class=\"myCanvas\" &gt;&lt;/canvas&gt; 1234567891011121314onLoad()&#123; const ctx = wx.createCanvasContext('myCanvas')// //对应的参数是 &lt;canvas&gt; 组件的 canvas-id 属性值 //绘制弧线 ctx.arc(100, 75, 50, 0, 2 * Math.PI) // 参数 ： ① 圆心 x 坐标, ② y 坐标,③ r 半径， ④ 起始弧度,单位弧度（在3点钟方向）???， ⑤ 终止弧度???， // ⑥ 弧度的方向是否是逆时针 number???? //根据 控制点 和 半径 绘制圆弧路径 ctx.arcTo(0, 0, 50, 50, 50) // 参数 ： ① 第 1 个控制点的 x 轴坐标, ② 第 1 个控制点的 y 轴坐标 // ③ 第2 个控制点的 x 轴坐标, ④ 第 2 个控制点的 y 轴坐标，⑤ 圆弧的半径&#125; 15.2.2 CanvasContext.rect 绘制矩形1&lt;canvas canvas-id=\"myCanvas\" class=\"myCanvas\" &gt;&lt;/canvas&gt; 123456789101112onLoad()&#123; // 一、创建对象 const ctx = wx.createCanvasContext('myCanvas')// //对应的参数是 &lt;canvas&gt; 组件的 canvas-id 属性值 //绘制矩形路径 ctx.rect(10, 10, 150, 75) // 参数 ： ① 矩形路径左上角的横坐标, ② 矩形路径左上角的横坐标 // ③ 矩形路径的宽度 ④ 矩形路径的高度 //清除画布上在该矩形区域内的内容&#125; 15.2.3 CanvasContext.bezierCurveTo() 绘制三次方贝塞尔曲线路径。曲线的起始点为路径中前一个点。1&lt;canvas canvas-id=\"myCanvas\" class=\"myCanvas\" &gt;&lt;/canvas&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950onLoad()&#123; // 一、创建对象 const ctx = wx.createCanvasContext('myCanvas')// //对应的参数是 &lt;canvas&gt; 组件的 canvas-id 属性值 // 二、 ctx.setFillStyle('#EEEEEE')// 三、 设置填充色。 ctx.fill()//对当前路径中的内容进行填充。无参数，颜色由 setFillStyle() 决定，没有设置的话就 默认的填充色为黑色。 // 如果当前路径没有闭合，fill() 方法会将起点和终点进行连接，然后填充。也就数把弧度首位链接填充起来 ctx.beginPath() ctx.moveTo(40, 75) ctx.lineTo(160, 75) ctx.moveTo(100, 15) ctx.lineTo(100, 135) ctx.setStrokeStyle('#AAAAAA') ctx.stroke() ctx.setFontSize(12) ctx.setFillStyle('black') ctx.fillText('0', 165, 78) ctx.fillText('0.5*PI', 83, 145) ctx.fillText('1*PI', 15, 78) ctx.fillText('1.5*PI', 83, 10) // Draw points ctx.beginPath() ctx.arc(100, 75, 2, 0, 2 * Math.PI) ctx.setFillStyle('lightgreen') ctx.fill() ctx.beginPath() ctx.arc(100, 25, 2, 0, 2 * Math.PI) ctx.setFillStyle('blue') ctx.fill() ctx.beginPath() ctx.arc(150, 75, 2, 0, 2 * Math.PI) ctx.setFillStyle('red') ctx.fill() // Draw arc ctx.beginPath() ctx.arc(100, 75, 50, 0, 1.5 * Math.PI) ctx.setStrokeStyle('#333333') ctx.stroke() ctx.draw()&#125; 15.3 CanvasGradient 渐变对象15.3.1 CanvasGradient.addColorStop 添加颜色的渐变点。小于最小 stop 的部分会按最小 stop 的 color 来渲染，大于最大 stop 的部分会按最大 stop 的 color 来渲染 语法：CanvasGradient.addColorStop(number stop, Color color) 12345678910111213141516const ctx = wx.createCanvasContext('myCanvas')// Create circular gradientconst grd = ctx.createLinearGradient(30, 10, 120, 10)grd.addColorStop(0, 'red')// 0 表示渐变中开始与结束之间的位置，范围 0-1。grd.addColorStop(0.16, 'orange')// orange 渐变点的颜色。grd.addColorStop(0.33, 'yellow')grd.addColorStop(0.5, 'green')grd.addColorStop(0.66, 'cyan')grd.addColorStop(0.83, 'blue')grd.addColorStop(1, 'purple')// Fill with gradientctx.setFillStyle(grd)ctx.fillRect(10, 10, 150, 80)ctx.draw() 15.4 wx.canvasGetImageData 获取 canvas 区域隐含的像素数据。语法：wx.canvasGetImageData(Object object, Object this) 第二个参数：this 在自定义组件下，当前组件实例的this，以操作组件内 组件 可选 12345&lt;canvas canvas-id=\"canvasIn\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;canvas canvas-id=\"canvasOut\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;button bindtap=\"openAndDraw\"&gt;打开图片并绘制&lt;/button&gt;&lt;button bindtap=\"process\"&gt;处理图像&lt;/button&gt;&lt;button bindtap=\"export\"&gt;导出画布至图片&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839const cfg = &#123; x: 0, y: 0, width: 300, height: 300,&#125;wx.canvasGetImageData(&#123; canvasId: 'canvasIn',// 画布标识，传入 &lt;canvas&gt; 组件的 canvas-id 属性。 必填 //x:0,//将要被提取的图像数据矩形区域的左上角横坐标 必填 //y:0,//将要被提取的图像数据矩形区域的左上角纵坐标 必填 //width:300,//将要被提取的图像数据矩形区域的宽度 必填 //height:300,//将要被提取的图像数据矩形区域的高度 必填 ...cfg,//以这种方法把上面的几个属性移到外面写 success: (res) =&gt; &#123; const data = convertToGrayscale(res.data) //console.log(res.width) // 300 图像数据矩形的宽度 //console.log(res.height) // 300 图像数据矩形的高度 //console.log(res.data instanceof Uint8ClampedArray) // true //Uint8ClampedArray data 图像像素点数据，一维数组，每四项表示一个像素点的 rgba //console.log(res.data.length) // 300 * 300 * 4 wx.canvasPutImageData(&#123; canvasId: 'canvasOut', data, ...cfg, success: (res) =&gt; &#123; console.log(res) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125;, complete:(res)=&gt;&#123; // &#125; ) 15.5 wx.canvasPutImageData 将像素数据绘制到画布。在自定义组件下，第二个参数传入自定义组件实例 this，以操作组件内 &lt;canvas&gt; 组件 语法：wx.canvasPutImageData(Object object, Object this) 12345&lt;canvas canvas-id=\"canvasIn\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;canvas canvas-id=\"canvasOut\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;button bindtap=\"openAndDraw\"&gt;打开图片并绘制&lt;/button&gt;&lt;button bindtap=\"process\"&gt;处理图像&lt;/button&gt;&lt;button bindtap=\"export\"&gt;导出画布至图片&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041process() &#123; const cfg = &#123; x: 0, y: 0, width: 300, height: 300, &#125; // 获取 canvas 区域隐含的像素数据。 wx.canvasGetImageData(&#123; canvasId: 'canvasIn', ...cfg, success: (res) =&gt; &#123; const data = convertToGrayscale(res.data)// 在这里定义了data //将像素数据绘制到画布。 wx.canvasPutImageData(&#123; canvasId: 'canvasOut',// 画布标识，传入 &lt;canvas&gt; 组件的 canvas-id 属性。 必填 data,//这样使用外面定义的参数，//Uint8ClampedArray 图像像素点数据，一维数组，每四项表示一个像素点的 rgba 必填 //x:0,//将要被提取的图像数据矩形区域的左上角横坐标 必填 //y:0,//将要被提取的图像数据矩形区域的左上角纵坐标 必填 //width:300,//将要被提取的图像数据矩形区域的宽度 必填 //height:300,//将要被提取的图像数据矩形区域的高度 必填 ...cfg,//这样使用外面定义的参数对象 success: (res) =&gt; &#123; console.log(res) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125;, complete:(res)=&gt;&#123; // &#125; &#125;) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125;, complete:(res)=&gt;&#123; // &#125; &#125;) &#125; 15.6 wx.canvasToTempFilePath 把当前画布指定区域的内容导出生成指定大小的图片。在 draw() 回调里调用该方法才能保证图片导出成功。 语法：wx.canvasToTempFilePath(Object object, Object this)第二个参数：在自定义组件下，当前组件实例的 this，以操作组件内 &lt;canvas&gt; 组件 12345&lt;canvas canvas-id=\"canvasIn\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;canvas canvas-id=\"canvasOut\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;button bindtap=\"openAndDraw\"&gt;打开图片并绘制&lt;/button&gt;&lt;button bindtap=\"process\"&gt;处理图像&lt;/button&gt;&lt;button bindtap=\"export\"&gt;导出画布至图片&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132333435363738export() &#123; const cfg = &#123; x: 0, y: 0, width: 300, height: 300, destWidth: 100, destHeight: 100 &#125; //把当前画布指定区域的内容导出生成指定大小的图片。 wx.canvasToTempFilePath(&#123; canvasId: 'canvasOut',// 画布标识，传入 &lt;canvas&gt; 组件的 canvas-id 必填 //x:0,//将要被提取的图像数据矩形区域的左上角横坐标 否 //y:0,//将要被提取的图像数据矩形区域的左上角纵坐标 否 //width:300,//将要被提取的图像数据矩形区域的宽度 否 canvas宽度-x //height:300,//将要被提取的图像数据矩形区域的高度 否 canvas高度-y //destWidth: 100,//指定的画布区域的高度 否 width*屏幕像素密度 //destHeight: 100//输出的图片的宽度 否 height*屏幕像素密度 ...cfg,// 上面几个参数的外面 定义里面应用 fileType:'png',// 目标文件的类型（jpg/png） 否 默认为 png 格式 quality:0.8,//图片的质量，目前仅对 jpg 有效。取值范围为 (0, 1]，不在范围内时当作 1.0 处理。 必填 success: (res) =&gt; &#123; //res.tempFilePath wx.saveImageToPhotosAlbum(&#123; filePath: res.tempFilePath,//res.tempFilePath 生成文件的临时路径，wx.canvasToTempFilePath 接口的 成功回调 success: (res) =&gt; &#123; console.log(res) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;, this)//第二个 参数 在自定义组件下，当前组件实例的this，以操作组件内 &lt;canvas&gt; 组件&#125; 15.7 完整的示例!!!!!!!!!!!!!!!!!!12345&lt;canvas canvas-id=\"canvasIn\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;canvas canvas-id=\"canvasOut\" class=\"canvas\"&gt;&lt;/canvas&gt;&lt;button bindtap=\"openAndDraw\"&gt;打开图片并绘制&lt;/button&gt;&lt;button bindtap=\"process\"&gt;处理图像&lt;/button&gt;&lt;button bindtap=\"export\"&gt;导出画布至图片&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 function convertToGrayscale(data) &#123; let g = 0 for (let i = 0; i &lt; data.length; i += 4) &#123; g = (data[i] * 0.3 + data[i+1] * 0.59 + data[i+2] * 0.11) data[i] = g data[i+1] = g data[i+2] = g &#125; return data&#125;Page(&#123; onReady() &#123; &#125;,//打开图片并绘制 openAndDraw() &#123; wx.chooseImage(&#123; success: (res) =&gt; &#123; const ctx = wx.createCanvasContext('canvasIn', this); //wx.createCanvasContext 创建上下文对象 ctx.drawImage(res.tempFilePaths[0], 0, 0) ctx.draw() &#125; &#125;) &#125;, //导出画布至图片 export() &#123; wx.canvasToTempFilePath(&#123; canvasId: 'canvasOut', success: (res) =&gt; &#123; wx.saveImageToPhotosAlbum(&#123; filePath: res.tempFilePath, success: (res) =&gt; &#123; console.log(res) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;, this) &#125;,//处理图像 process() &#123; const cfg = &#123; x: 0, y: 0, width: 300, height: 300, &#125; wx.canvasGetImageData(&#123; canvasId: 'canvasIn', ...cfg, success: (res) =&gt; &#123; const data = convertToGrayscale(res.data) wx.canvasPutImageData(&#123; canvasId: 'canvasOut', data, ...cfg, success: (res) =&gt; &#123; console.log(res) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;) &#125;, fail: (err) =&gt; &#123; console.error(err) &#125; &#125;) &#125;&#125;) 十六、调试（开发过程中对 小程序代码的调试）16.1 LogManager 日志管理器实例，可以通过 wx.getLogManager 获取。 最多保存 5M 的日志内容，超过 5M 后，旧的日志内容会被删除。 用户可以通过使用 &lt;Button&gt; 组件的 open-type=&quot;feedback&quot; 来上传打印的日志。 开发者可以通过小程序管理后台左侧菜单“客服反馈”页面查看。日志 基础库默认会把 App、Page 的生命周期函数和 wx 命名空间下的函数调用写入日志。？？？？？？什么东西？？ 16.1.1 wx.getLogManager 创建 日志管理器实例 对象参数：取值为 0/1，取值为0：表示是否会把 App、Page 的生命周期函数和 wx 命名空间下的函数调用写入日志，默认值是 0取值为1 ：则不会….写入日志 12345const logger = wx.getLogManager()// 不给参数 默认为 0logger.log(&#123;str: 'hello world'&#125;, 'basic log', 100, [1, 2, 3])logger.info(&#123;str: 'hello world'&#125;, 'info log', 100, [1, 2, 3])logger.debug(&#123;str: 'hello world'&#125;, 'debug log', 100, [1, 2, 3])logger.warn(&#123;str: 'hello world'&#125;, 'warn log', 100, [1, 2, 3]) 16.1.2 LogManager.debug 写 debug 日志Object|Array.|number|string …args日志内容，可以有任意多个。每次调用的参数的总大小不超过100Kb 16.1.3 LogManager.info 写 info 日志Object|Array.|number|string …args日志内容，可以有任意多个。每次调用的参数的总大小不超过100Kb 16.1.4 LogManager.log 写 log 日志Object|Array.|number|string …args日志内容，可以有任意多个。每次调用的参数的总大小不超过100Kb 16.1.5 LogManager.warn 写 warn 日志Object|Array.|number|string …args日志内容，可以有任意多个。每次调用的参数的总大小不超过100Kb 16.2 wx.setEnableDebug 设置是否打开调试开关。此开关对正式版也能生效。123456wx.setEnableDebug(&#123; enableDebug:true,//是否打开调试 必填 success(res)&#123;&#125;,//回调函数 fail(res)&#123;&#125;,//回调函数 complete(res)&#123;&#125;//回调函数&#125;) 16.2.1 在正式版打开调试还有一种方法，就是先在开发版或体验版打开调试，再切到正式版就能看到vConsole。16.3 console 向调试面板中打印日志。console 是一个全局对象，可以直接访问。console 是一个全局对象，可以直接访问。在微信客户端中，向 vConsole 中输出日志。 16.3.1 console.debug 向调试面板中打印 debug 日志any …args日志内容，可以有任意多个。 16.3.2 console.error 向调试面板中打印 error 日志any …args日志内容，可以有任意多个。 16.3.3 console.group 在调试面板中创建一个新的分组。console.group(string label) 分组标记，可选。注意：仅在工具中有效，在 vConsole 中为空函数实现。 随后输出的内容都会被添加一个缩进，表示该内容属于当前分组。调用 console.groupEnd之后分组结束。 16.3.1 console.groupEnd() 结束由 console.group 创建的分组,无参数注意：仅在工具中有效，在 vConsole 中为空函数实现。 16.3.4 console.info 向调试面板中打印 info 日志any …args日志内容，可以有任意多个。 16.3.5 console.log 向调试面板中打印 log 日志any …args日志内容，可以有任意多个。 16.3.6 console.warn 向调试面板中打印 warn 日志any …args日志内容，可以有任意多个。 16.3.7 注意事项 由于 vConsole 功能有限，以及不同客户端对 console 方法的支持情况有差异，建议开发者在小程序中只使用本文档中提供的方法。 部分内容展示的限制请参见调试 十七、第三方平台17.1 wx.getExtConfig 获取第三方平台自定义的数据字段。语法：wx.getExtConfig(Object object) 17.1.1 本接口暂时无法通过 wx.canIUse 判断是否兼容，开发者需要自行判断 wx.getExtConfig 是否存在来兼容123456789if (wx.getExtConfig) &#123;// 判断兼容 wx.getExtConfig(&#123; success(res)&#123; res.extConfig// Object 第三方平台自定义的数据 &#125;, fail()&#123;&#125;, complete()&#123;&#125; &#125;)&#125; 17.2 wx.getExtConfigSync() 是 wx.getExtConfig 的同步版本。 无参数!!!!!!!!!!!语法：Object getExtConfigSync() 17.2.1 本接口暂时无法通过 wx.canIUse 判断是否兼容，开发者需要自行判断 wx.getExtConfigSync 是否存在来兼容12let extConfig = wx.getExtConfigSync? wx.getExtConfigSync(): &#123;&#125;console.log(extConfig) 17.3 wx.getExtConfigSync（） 与 wx.getExtConfig（obj） 的区别？？？？？？？？？？？？？？？？？？wx.getExtConfigSync（） 是不带参数的，它的返回值就是 extConfig 对象，也就是 第三方数据字段。 wx.getExtConfig(obj) 带参数，返回值在 success 回调函数里面。 十八、地图 map18.1 MapContext map 上下文 MapContext 对象。mapContext 通过 id 跟一个 &lt;map&gt; 组件绑定，操作对应的 &lt;map&gt; 组件。 18.2 wx.createMapContext 创建 map 上下文 MapContext 对象。语法：MapContext wx.createMapContext(string mapId, Object this) 1&lt;map id=\"map\" longitude=\"&#123;&#123;longitude&#125;&#125;\" latitude=\"&#123;&#123;latitude&#125;&#125;\" show-location scale=\"12\" style=\"width: 100%; height: 00px;\"&gt;&lt;/map&gt; 1234onReady: function(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;, 18.3 MapContext.getCenterLocation 获取当前地图中心的经纬度。返回的是 gcj02 坐标系，可以用于 wx.openLocation()语法：MapContext.getCenterLocation(Object object) 1234567891011121314151617181920212223242526272829303132333435363738// 以下 为 mina 框架写法onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取地图中心点getCenterPoint(e)&#123; var that = this; this.mapCtx.getCenterLocation(&#123; success(res)&#123; that.setData(&#123; longitude: res.longitude,//经度,number latitude: res.latitude//纬度,number &#125;) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;)&#125;,// wepy 框架onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取地图中心点getCenterPoint(e)&#123; var that = this; this.mapCtx.getCenterLocation(&#123; success(res)&#123; that.longitude = res.longitude,//经度,number that.latitude = res.latitude//纬度,number &#125;) &#125;, fail(res)&#123;&#125;, complete()&#123;res&#125; &#125;)&#125;, 18.3 MapContext.getRegion 获取当前地图的视野范围语法:MapContext.getRegion(Object object) 1234567891011121314151617181920212223242526272829303132333435363738// 以下 为 mina 框架写法onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取视野范围getRegionFunc(e)&#123; var that = this; this.mapCtx.getRegion(&#123; success(res)&#123; that.setData(&#123; southwest: res.southwest,//西南角经纬度,number northeast: res.latitude//东北角经纬度,number &#125;) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;)&#125;,// wepy 框架onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取视野范围getRegionFunc(e)&#123; var that = this; this.mapCtx.getRegion(&#123; success(res)&#123; that.southwest = res.southwest,//西南角经纬度,number that.northeast = res.northeast//东北角经纬度,number &#125;) &#125;, fail(res)&#123;&#125;, complete()&#123;res&#125; &#125;)&#125;, 18.3 MapContext.getScale 获取当前地图的缩放级别语法:MapContext.getScale(Object object) 123456789101112131415161718192021222324252627282930313233343536// 以下 为 mina 框架写法onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取缩放级别getScaleFunc(e)&#123; var that = this; this.mapCtx.getScale(&#123; success(res)&#123; that.setData(&#123; scale: res.scale//缩放值,number &#125;) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;)&#125;,// wepy 框架onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//缩放级别getScaleFunc(e)&#123; var that = this; this.mapCtx.getScale(&#123; success(res)&#123; that.scale = res.scale//缩放值,number &#125;) &#125;, fail(res)&#123;&#125;, complete()&#123;res&#125; &#125;)&#125;, 18.3 MapContext.includePoints 缩放视野展示所有经纬度语法:MapContext.includePoints(Object object) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 以下 为 mina 框架写法onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取 缩放视野展示所有经纬度getIncludePointsFunc(e)&#123; var that = this; this.mapCtx.includePoints(&#123; points:[// 要显示在可视区域内的坐标点列表 必填 &#123; latitude: 30.4919168,//纬度 longitude: 114.3061654//经度 &#125;, &#123; latitude: 30.4919168, longitude: 114.3061654 &#125; ], padding:[],// 否 坐标点形成的矩形边缘到地图边缘的距离，单位像素。 //格式为[上,右,下,左]，安卓上只能识别数组第一项，上下左右的padding一致。开发者工具暂不支持padding参数。 success(res)&#123; that.setData(&#123; scale: res.scale//缩放值,number &#125;) &#125;, fail(res)&#123;&#125;, complete(res)&#123;&#125; &#125;)&#125;,// wepy 框架onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,// 缩放视野展示所有经纬度getIncludePointsFunc(e)&#123; var that = this; this.mapCtx.includePoints(&#123; success(res)&#123; that.scale = res.scale//缩放值,number &#125;) &#125;, fail(res)&#123;&#125;, complete()&#123;res&#125; &#125;)&#125;, 18.3 MapContext.moveToLocation() 将地图中心移动到当前定位点。 无参数语法：MapContext.moveToLocation() 需要配合 map 组件的 show-location 使用，&lt;map&gt; 组件中要有 show-location 属性 1&lt;map id=\"map\" longitude=\"&#123;&#123;longitude&#125;&#125;\" latitude=\"&#123;&#123;latitude&#125;&#125;\" show-location scale=\"12\" style=\"width: 100%; height: 00px;\"&gt;&lt;/map&gt; 12345678910111213141516171819202122onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取地图中心点getCenterPoint(e)&#123; var $this = this; this.mapCtx.getCenterLocation(&#123; success(res)&#123; $this.setData(&#123; latitude: res.latitude, longitude: res.longitude &#125;) &#125;, fail()&#123;&#125;, complete()&#123;&#125; &#125;)&#125;,//将地图中心点移动到当前位置setCenterPoint(e)&#123; this.mapCtx.moveToLocation()&#125; 18.3 MapContext.translateMarker 平移 marker，带动画语法：MapContext.translateMarker(Object object) 12345678910111213141516171819202122232425262728293031323334onReady(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。&#125;,//获取地图中心点translateMarkerFunc(e)&#123; var $this = this; this.mapCtx.translateMarker(&#123; markerId:999,//number 指定 marker 必填 destination:&#123; //指定 marker 移动到的目标点 必填 latitude: 30.4919168,//纬度 longitude: 114.3061654//经度 &#125;, autoRotate:true, //移动过程中是否自动旋转 marker 必填 rotate:90,//marker 的旋转角度 必填 duration:1000,//动画持续时长，平移与旋转分别计算 否 默认值 1000 animationEnd()&#123; // 否 动画结束回调函数 &#125; success(res)&#123; $this.setData(&#123; latitude: res.latitude, longitude: res.longitude &#125;) &#125;, fail()&#123;&#125;, complete()&#123;&#125; &#125;)&#125;,//将地图中心点移动到当前位置setCenterPoint(e)&#123; this.mapCtx.moveToLocation()&#125; 18.4 综合示例以下示例 为 mina 框架的示例。 1234567&lt;view class=\"container\"&gt; &lt;map id=\"map\" longitude=\"&#123;&#123;longitude&#125;&#125;\" latitude=\"&#123;&#123;latitude&#125;&#125;\" show-location scale=\"12\" style=\"width: 100%; height: 00px;\"&gt;&lt;/map&gt; &lt;button bindtap=\"getCenterPoint\"&gt;获取地图中心点&lt;/button&gt; &lt;text&gt;中心点经度：&#123;&#123;longitude&#125;&#125;&lt;/text&gt; &lt;text&gt;中心点纬度：&#123;&#123;latitude&#125;&#125;&lt;/text&gt; &lt;button bindtap=\"setCenterPoint\"&gt;移动到当前位置&lt;/button&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829//index.js//获取应用实例var app = getApp()Page(&#123; data: &#123; latitude: 30.4919168, longitude: 114.3061654 &#125;, onReady: function(e)&#123; //关联&lt;map /&gt;组件 this.mapCtx = wx.createMapContext('map') // 创建 map 上下文 MapContext 对象。 &#125;, //获取地图中心点 getCenterPoint: function(e)&#123; var $this = this; this.mapCtx.getCenterLocation(&#123; success: function(res)&#123; $this.setData(&#123; latitude: res.latitude, longitude: res.longitude &#125;) &#125; &#125;) &#125;, //将地图中心点移动到当前位置 setCenterPoint: function(e)&#123; this.mapCtx.moveToLocation() &#125;&#125;) 十九、路由(页面跳转)以下是 原生的 API ，如果是 wepy 框架又对这几个 API 进行封装了 19.1 wx.navigateTo 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。也就是说需要跳转到某个不在 tabbar 设置过的页面，并且需要返回 原来的页面的话就使用这个方法 wx.navigateTo。 调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。需要返回 原来的页面的话就使用这个方法 wx.navigateTo。将经历过 的页面压入栈，后面就可以使用 wx.navigateBack 调用跳转回来。 12345678910111213141516171819202122232425262728293031323334353637// A 页面 =&gt; B 页面// ①：原生写法wx.navigateTo(&#123; url: './B?id=1', // 必填 需要跳转的应用内非 tabBar 的页面的路径, 路径后可以带参数。 //参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 'path?key=value&amp;key2=value2 success(res)&#123; //否 &#125;, fail()&#123; // 否 &#125;, complete()&#123; // 否 &#125;&#125;)//wepy 框架 可以使用上面的方法，并且还封装了方法 注意这里没有 TO 了 哦!!!!!!!!!!!!!!!!!!!!!!!!!!//②：wepy 框架包装写法 this.$navigate(&#123; url: './B?id=1', success(res)&#123;&#125;, fail()&#123;&#125;, complete()&#123;&#125; &#125;)//wepy 框架 或者更加直接的//③：wepy 框架包装写法 this.$navigate('./B',&#123;id:1&#125;) // 问题：然后这里的 success 这 3 个属性是怎么用的？？？是下面这样么 this.$navigate('./B',&#123;id:1&#125;).success(res=&gt;&#123; // &#125;).fail(res=&gt;&#123; // &#125;).complete(res=&gt;&#123; // &#125;) 123456789101112131415// B.js 页面//① mina 框架Page(&#123; onLoad: function(option)&#123; console.log(option.query) &#125;&#125;)//② wepy 框架export default class Index extends wepy.page &#123; onLoad(options) &#123; this.pageBId = options.id; console.log(options.id) &#125;&#125; 19.2 wx.navigateBack 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。当前页面是通过 wx.navigateTo 接口过来的话，那么可以使用 wx.navigateBack 返回原来的页面。 调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。需要返回 原来的页面的话就使用这个方法 wx.navigateTo。将经历过 的页面压入栈，后面就可以使用 wx.navigateBack 调用跳转回来。 12345678910111213// 此处是 A 页面 =&gt; B 页面toPageB()&#123; wx.navigateTo(&#123; url: './B?id=1' &#125;)&#125;// 此处是 B 页面 =&gt; C 页面toPageC()&#123; wx.navigateTo(&#123; url: './C?id=1' &#125;)&#125; 12345678910// 此处是 C 页面 =&gt; A 页面Back()&#123; wx.navigateBack(&#123; delta:2,//number 必填 返回的页面数，如果 delta 大于现有页面数，则返回到首页。 // delta:1 返回 B 页面， delta:2/3/4..... 返回 A页面（这里假设 A 是首页） success(res)&#123;&#125;,// 否 接口调用成功的回调函数 fail(res)&#123;&#125;,// 否 接口调用失败的回调函数 complete(res)&#123;&#125;// 否 接口调用结束的回调函数（调用成功、失败都会执行） &#125;)&#125; 19.2.1 wx.navigateBack 返回上一个页面并且带参数看上面的内容之后发现，wx.navigateBack 只有三个回调函数参数，没有其他的参数，那么如果希望返回上面一个页面，并且传参怎么办？ 文档文档这里只是 mina 框架可以这样用，发现并不能用在 wepy 框架。 1234567891011// A页面data=&#123; this.title='title'&#125;onLoad()&#123; this.$navigate('./B') this.title//'title'&#125;onShow()&#123; this.title//'title' 这里希望会改变&#125; 123456789101112//b 页面 methods = &#123; test() &#123; var pages = this.getCurrentPages(); console.log(pages) var prevPage = pages[pages.length - 2]; console.log(prevPage) prevPage.title = 'newTitle';// prevPage 改变了，但是 A 页面的值没有被改变，这个压入栈的东西是不是要自己取出来使用呀？ // this.$apply() 可以使用么？ 是 this 么？？ 原生的 setData 还这样用么？ wepy.navigateBack(&#123; delta: 1 &#125;); &#125; &#125;; 问题？success(res){}, 不能传么？？后面做到的时候自己研究一下。 19.3 wx.redirectTo 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 wx.redirectTo 不会压入栈，不能使用 返回 API 接口。 12345678910111213141516171819202122232425262728293031323334353637// A 页面 =&gt; B 页面// ①：原生写法wx.redirectTo(&#123; url: './B?id=1', // 必填 需要跳转的应用内非 tabBar 的页面的路径, 路径后可以带参数。 //参数与路径之间使用 ? 分隔，参数键与参数值用 = 相连，不同参数用 &amp; 分隔；如 'path?key=value&amp;key2=value2 success(res)&#123; //否 &#125;, fail()&#123; // 否 &#125;, complete()&#123; // 否 &#125;&#125;)//wepy 框架 可以使用上面的方法，并且还封装了方法//②：wepy 框架包装写法 this.$redirectTo(&#123; url: './B?id=1', success(res)&#123;&#125;, fail()&#123;&#125;, complete()&#123;&#125; &#125;)//wepy 框架 或者更加直接的//③：wepy 框架包装写法 this.$redirectTo('./B',&#123;id:1&#125;) // 问题：然后这里的 success 这 3 个属性是怎么用的？？？是下面这样么 this.$redirectTo('./B',&#123;id:1&#125;).success(res=&gt;&#123; // &#125;).fail(res=&gt;&#123; // &#125;).complete(res=&gt;&#123; // &#125;) 123456789101112131415// B.js 页面//① mina 框架Page(&#123; onLoad: function(option)&#123; console.log(option.query) &#125;&#125;)//② wepy 框架export default class Index extends wepy.page &#123; onLoad(options) &#123; this.pageBId = options.id; console.log(options.id) &#125;&#125; 19.4 wx.reLaunch 关闭所有页面，打开到应用内的某个页面123456789101112131415// A 页面 =&gt; B 页面 （可以是任意的页面）// ①：原生写法wx.reLaunch(&#123; url: './B?id=1', //需要跳转的应用内页面路径，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔； //如 'path?key=value&amp;key2=value2'，如果跳转的页面路径是 tabBar 页面则不能带参数 success(res)&#123; //否 &#125;, fail()&#123; // 否 &#125;, complete()&#123; // 否 &#125;&#125;) 123456789101112131415// B.js 页面//① mina 框架Page(&#123; onLoad: function(option)&#123; console.log(option.query)// 如果是 tabbar 页面就没有这里了 &#125;&#125;)//② wepy 框架export default class Index extends wepy.page &#123; onLoad(options) &#123; this.pageBId = options.id; // 如果是 tabbar 页面就没有这里了 console.log(options.id) &#125;&#125; 19.5 wx.switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面1234567891011121314// A 页面 =&gt; index 页面（ index 页面必须以是 tebbar 页面）// ①：原生写法wx.switchTab(&#123; url: './index' //不能带参数的 success(res)&#123; //否 &#125;, fail()&#123; // 否 &#125;, complete()&#123; // 否 &#125;&#125;) 123456789101112//app.wpy 中的 cinfig&#123; \"tabBar\": &#123; \"list\": [&#123; \"pagePath\": \"index\", \"text\": \"首页\" &#125;,&#123; \"pagePath\": \"other\", \"text\": \"其他\" &#125;] &#125;&#125; 二十、转发（右上角的转发功能，或者在其他地方自定义的转发功能）20.1 wx.getShareInfo 获取转发详细信息 基础库 1.1.0 开始支持，低版本需做兼容处理。wx.getShareInfo 接口是在 页面的周期函数 onShareAppMessage 函数中 中设置分享的界面。 20.1.3 实例中有几个相关的 api 接口完整的示例。 12345678910111213141516171819202122232425262728onShareAppMessage()&#123; if (res.from === 'button') &#123; console.log(res.target) &#125; return &#123; title: '自定义转发标题', path: '/pages/main', success(res) &#123; let shareId = res.shareTickets[0] wx.getShareInfo(&#123; shareTicket:shareId,//string 必填 shareTicket 获取分享信息 timeout:1000,//number 否 超时时间，单位 ms 1.9.90 success(res)&#123; //function 否 接口调用成功的回调函数 res.errMsg //string 错误信息 res.encryptedData //string 包括敏感数据在内的完整转发信息的加密数据，详细见加密数据解密算法 res.iv //string 加密算法的初始向量，详细见加密数据解密算法 &#125;, fail(res)&#123; //function 否 接口调用失败的回调函数 &#125;, complete(res)&#123; //function 否 接口调用结束的回调函数（调用成功、失败都会执行 &#125; &#125;) &#125; &#125;&#125; 20.1.1 加密数据解密算法官网网址 加密数据解密算法：接口如果涉及敏感数据（如wx.getUserInfo当中的 openId 和 unionId），接口的明文内容将不包含这些敏感数据。开发者如需要获取敏感数据，需要对接口返回的加密数据(encryptedData) 进行对称解密。 解密算法如下： 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。 对称解密的目标密文为 Base64_Decode(encryptedData)。 对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。 对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回。 微信官方提供了多种编程语言的示例代码（点击下载）。每种语言类型的接口名字均一致。调用方式可以参照示例。 另外，为了应用能校验数据的有效性，会在敏感数据加上数据水印( watermark ) watermark参数说明： 参数 类型 说明appid String 敏感数据归属 appId，开发者可校验此参数与自身 appId 是否一致timestamp Int 敏感数据获取的时间戳, 开发者可以用于数据时效性校验如接口 wx.getUserInfo 敏感数据当中的 watermark： { “openId”: “OPENID”, “nickName”: “NICKNAME”, “gender”: GENDER, “city”: “CITY”, “province”: “PROVINCE”, “country”: “COUNTRY”, “avatarUrl”: “AVATARURL”, “unionId”: “UNIONID”, “watermark”: { “appid”:”APPID”, “timestamp”:TIMESTAMP }}注： 解密后得到的json数据根据需求可能会增加新的字段，旧字段不会改变和删减，开发者需要预留足够的空间会话密钥 session_key 有效性开发者如果遇到因为 session_key 不正确而校验签名失败或解密失败，请关注下面几个与 session_key 有关的注意事项。 wx.login 调用时，用户的 session_key 可能会被更新而致使旧 session_key 失效（刷新机制存在最短周期，如果同一个用户短时间内多次调用 wx.login，并非每次调用都导致 session_key 刷新）。开发者应该在明确需要重新登录时才调用 wx.login，及时通过 code2Session 接口更新服务器存储的 session_key。微信不会把 session_key 的有效期告知开发者。我们会根据用户使用小程序的行为对 session_key 进行续期。用户越频繁使用小程序，session_key 有效期越长。开发者在 session_key 失效时，可以通过重新执行登录流程获取有效的 session_key。使用接口 wx.checkSession可以校验 session_key 是否有效，从而避免小程序反复执行登录流程。当开发者在实现自定义登录态时，可以考虑以 session_key 有效期作为自身登录态有效期，也可以实现自定义的时效性策略。 20.1.2 如需要展示群名称，可以使用开放数据组件 open-data官网开方组件网址 open-data基础库 1.4.0 开始支持，低版本需做兼容处理。 用于展示微信开放的数据。 属性名 类型 默认值 说明type String 开放数据类型open-gid String 当 type=”groupName” 时生效, 群idlang String en 当 type=”user*” 时生效，以哪种语言展示 userInfo，有效值有：en, zh_CN, zh_TWtype 有效值： 值 说明 最低版本groupName 拉取群名称 1.4.0userNickName 用户昵称 1.9.90userAvatarUrl 用户头像 1.9.90userGender 用户性别 1.9.90userCity 用户所在城市 1.9.90userProvince 用户所在省份 1.9.90userCountry 用户所在国家 1.9.90userLanguage 用户的语言 1.9.90Tips: 只有当前用户在此群内才能拉取到群名称 示例： 在开发者工具中预览效果 Tips: 关于open-gid的获取请使用 wx.getShareInfo 20.2 wx.hideShareMenu 隐藏转发按钮 基础库 1.1.0 开始支持，低版本需做兼容处理。1234567891011wx.hideShareMenu(&#123; success (res) &#123; // 接口调用成功的回调函数 &#125;, fail(res)&#123; //② 接口调用失败的回调函数 &#125;, complete(res)&#123; //② 接口调用结束的回调函数（调用成功、失败都会执行) &#125;&#125;) 20.3 wx.showShareMenu 显示当前页面的转发按钮 基础库 1.1.0 开始支持，低版本需做兼容处理。这个接口是在 onload 周期函数中使用的。 1234567891011121314onload()&#123; wx.showShareMenu(&#123; withShareTicket: true,//获取更多转发信息 否(不是必须的) // 用于显示分享的群列表 success (res) &#123; // 接口调用成功的回调函数 否 &#125;, fail(res)&#123; //② 接口调用失败的回调函数 否 &#125;, complete(res)&#123; //② 接口调用结束的回调函数（调用成功、失败都会执行) 否 &#125; &#125;)&#125; 20.3.1 获取更多转发信息通常开发者希望转发出去的小程序被二次打开的时候能够获取到一些信息，例如群的标识。现在通过调用 wx.showShareMenu 并且设置 withShareTicket 为 true ，当用户将小程序转发到任一群聊之后，此转发卡片在群聊中被其他用户打开时，可以在 App.onLaunch 或 App.onShow 获取到一个 shareTicket。通过调用 wx.getShareInfo() 接口传入此 shareTicket 可以获取到转发信息。 20.4 wx.updateShareMenu 更新转发属性 基础库 1.2.0 开始支持，低版本需做兼容处理。123456789101112131415161718192021222324wx.updateShareMenu(&#123; withShareTicket: true,//是否使用带 shareTicket 的转发 否(不是必须的) 默认值为 false isUpdatableMessage:true,//是否是动态消息 否(不是必须的) 默认值为 false activityId:'',//string 动态消息的 activityId。通过 createActivityId 接口获取 否(不是必须的) templateInfo:&#123; //动态消息的模板信息 否(不是必须的), parameterList: [&#123;// 参数列表 name: 'member_count',//参数名 value: '1' // 参数值 &#125;, &#123; name: 'room_limit', value: '3' &#125;] &#125;, success (res) &#123; // 接口调用成功的回调函数 否 &#125;, fail(res)&#123; //② 接口调用失败的回调函数 否 &#125;, complete(res)&#123; //② 接口调用结束的回调函数（调用成功、失败都会执行) 否 &#125;&#125;) 20.4.1 获取更多转发消息通常开发者希望转发出去的小程序被二次打开的时候能够获取到一些信息，例如群的标识。现在通过调用 wx.showShareMenu 并且设置 withShareTicket 为 true ，当用户将小程序转发到任一群聊之后，此转发卡片在群聊中被其他用户打开时，可以在 App.onLaunch 或 App.onShow 获取到一个 shareTicket。通过调用 wx.getShareInfo() 接口传入此 shareTicket 可以获取到转发信息。 20.4.2 动态消息官网动态消息网址 动态消息从基础库 2.4.0 开始，支持转发动态消息。动态消息对比普通消息，有以下特点： 消息发出去之后，开发者可以通过后台接口修改部分消息内容。消息有对应的提醒按钮，用户点击提醒按钮可以订阅提醒，开发者可以通过后台修改消息状态并推送一次提醒消息给订阅了提醒的用户消息属性动态消息有状态、文字内容、文字颜色。 状态消息有两个状态，分别有其对应的文字内容和颜色。其中状态 0 可以转移到状态 0 和 1，状态 1 无法再转移。 状态 文字内容 颜色 允许转移的状态0 “成员正在加入，当前 {member_count}/{room_limit} 人” #FA9D39 0, 11 “已开始” #CCCCCC 无状态参数每个状态转移的时候可以携带参数，具体参数说明如下。 参数 类型 说明member_count string 状态 0 时有效，文字内容模板中 member_count 的值room_limit string 状态 0 时有效，文字内容模板中 room_limit 的值path string 状态 1 时有效，点击「进入」启动小程序时使用的路径。对于小游戏，没有页面的概念，可以用于传递查询字符串（query），如 “?foo=bar”version_type string 状态 1 时有效，状态 1 时有效，点击「进入」启动小程序时使用的版本。有效参数值为：develop（开发版），trial（体验版），release（正式版）使用方法一、创建 activity_id每条动态消息可以理解为一个活动，活动发起前需要通过 createActivityId 接口创建 activity_id。后续转发动态消息以及更新动态消息都需要传入这个 activity_id。 活动的默认有效期是 24 小时。活动结束后，消息内容会变成统一的样式： 文字内容：“已结束”文字颜色：#00ff00二、在转发之前声明消息类型为动态消息通过调用 wx.updateShareMenu 接口，传入 isUpdatableMessage: true，以及 templateInfo、activityId 参数。其中 activityId 从步骤一中获得。 三、修改动态消息内容动态消息发出去之后，可以通过 setUpdatableMsg 修改消息内容。 低版本兼容对于不支持动态消息的客户端版本，收到动态消息后会展示成普通消息 20.5 转发功能 实际使用示例：群转发设置!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!以下实例是在 wepy 框架下写的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//在wpy类型文件的onload中设置 eg： 用于显示分享的群列表onload()&#123; wepy.showShareMenu(&#123; withShareTicket: true &#125;)&#125;//在 onShareAppMessage 页面周期函数中 中设置分享的界面，在分享成功后的回调函数中通过 wepy.getShareInfo 获取分享群的信息。//群的信息是经过加密的，需要通过后台来进行解密操作。onShareAppMessage (res) &#123; if (res.from === 'button') &#123; console.log(res.target) &#125; return &#123; title: '自定义转发标题', path: '/pages/main', success(res) &#123; let shareId = res.shareTickets[0] // 转发成功 wepy.getShareInfo(&#123; shareTicket: shareId, success: (data) =&gt; &#123; var appId = '小程序的appID' var encryptedData = data.encryptedData var iv = data.iv wepy.request(&#123; url: 'http://localhost:3000/api/decode', method: 'post', data: &#123; appId: appId, encryptedData: encryptedData, iv: iv &#125;, success: (info) =&gt; &#123; console.log('info:' + info) &#125;, fail: (info) =&gt; &#123; console.log(info) &#125; &#125;) console.log(data) &#125;, fail: (data) =&gt; &#123; console.log(data) &#125; &#125;) console.log(res) &#125;, fail(res) &#123; // 转发失败 console.log(res) &#125; &#125;&#125; 二十一、系统 (手机系统，设备系统)21.1 wx.getSystemInfo 获取系统信息wx.getSystemInfo 有三种状态 success，fail，complete 1234567891011121314151617181920212223242526272829wx.getSystemInfo(&#123; success (res) &#123; // 接口调用成功的回调函数,目前 success 的回调数据中有 16 个数据 res.brand //①string 手机品牌 1.5.0 res.model //②String 手机型号 res.pixelRatio //③number 设备像素比 res.screenWidth //④number 屏幕宽度 res.screenHeight//⑤number屏幕高度 res.windowWidth //⑥number 可使用窗口宽度 res.windowHeight//⑦number 可使用窗口高度 res.statusBarHeight//⑧number 状态栏的高度 1.9.0 res.language //⑨string 微信设置的语言 res.version //⑩string 微信版本号 res.system //⑪string 操作系统版本 res.platform //⑫string 客户端平台 res.fontSizeSetting//⑬number 用户字体大小设置。以“我-设置-通用-字体大小”中的设置为准，单位 px。 1.5.0 res.SDKVersion //⑭string 客户端基础库版本 1.1.0 res.benchmarkLevel //⑮(仅Android小游戏) 性能等级， 1.8.0 //-2 或 0：该设备无法运行小游戏， //-1：性能未知， //&gt;=1 设备性能值，该值越高，设备性能越好 (目前设备最高不到50) &#125;, fail(res)&#123; //② 接口调用失败的回调函数 &#125;, complete(res)&#123; //② 接口调用结束的回调函数（调用成功、失败都会执行) &#125;&#125;) 21.2 wx.getSystemInfoSync 获取系统信息 wx.getSystemInfo 的同步版本wx.getSystemInfoSync 有 2 种状态 try ，catch 1234567891011121314try &#123; const res = wx.getSystemInfoSync() // try 返回的数据与 wx.getSystemInfo 中 success 一致。 // 上面有的在这都有的 console.log(res.model) console.log(res.pixelRatio) console.log(res.windowWidth) console.log(res.windowHeight) console.log(res.language) console.log(res.version) console.log(res.platform)&#125; catch (e) &#123; // Do something when catch error&#125; 21.3 wx.getSystemInfoSync() 与 wx.getSystemInfo(obj) 区别wx.getSystemInfoSync() 是不带参数的，它的返回值就是 res 对象。 wx.getSystemInfo(obj) 带参数，返回值在 success 回调函数里面。 二十二、定时器22.1 setInterval &amp;&amp; clearInterval 设定/取消一个定时器。间隔执行（多次）语法 number setInterval(function callback, number delay, any rest) 按照指定的周期（以毫秒计）来执行注册的回调函数 参数： function callback : 回调函数 number delay : 执行回调函数之间的时间间隔，单位 ms。 any rest : param1, param2, …, paramN 等附加参数，它们会作为参数传递给回调函数。（可选参数） 返回值: number 定时器的编号。这个值可以传递给 clearInterval 来取消该定时。 12345678910111213141516171819202122// 以 wepy 框架的来编辑示例data = &#123; isplay:false, intervalId:null, useTime:0&#125;methods =&#123; pause() &#123; this.isplay = false; clearInterval(this.intervalId); &#125;, play() &#123; this.isplay = true; this.setIntervalFunc(); &#125;,&#125;setIntervalFunc() &#123; this.intervalId = setInterval(() =&gt; &#123; this.useTime++; this.$apply();// wepy 框架如是编辑 &#125;, 1000); &#125; 22.2 setTimeout &amp;&amp; clearTimeout 设定/取消一个定时器。延迟执行（1 次）在定时到期以后执行注册的回调函数 语法 number setTimeout(function callback, number delay, any rest) 按照指定的周期（以毫秒计）来执行注册的回调函数 参数： function callback : 回调函数 number delay : 延迟的时间，函数的调用会在该延迟之后发生，单位 ms。 any rest : param1, param2, …, paramN 等附加参数，它们会作为参数传递给回调函数。（可选参数） 返回值: number 定时器的编号。这个值可以传递给 clearInterval 来取消该定时。 12345678910111213141516171819202122// 以 wepy 框架的来编辑示例data = &#123; isplay:false, intervalId = null, text:'等会看我变'&#125;methods =&#123; pause() &#123; this.isplay = false; clearTimeout(this.intervalId); &#125;, play() &#123; this.isplay = true; this.setTimeoutFunc(); &#125;,&#125;setTimeoutFunc() &#123; this.intervalId = clearTimeout(() =&gt; &#123; this.text='3 秒过了，我变啦' this.$apply();// wepy 框架如是编辑 &#125;, 3000); &#125; 二十三、WXML23.1 IntersectionObserver 布局相交状态 对象IntersectionObserver 对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。 23.1.1 IntersectionObserver.disconnectt() 停止监听。回调函数将不再触发注意：与页面显示区域的相交区域并不准确代表用户可见的区域，因为参与计算的区域是“布局区域”，布局区域可能会在绘制时被其他节点裁剪隐藏（如遇祖先节点中 overflow 样式为 hidden 的节点）或遮盖（如遇 fixed 定位的节点）。 23.1.2 IntersectionObserver.observet() 指定目标节点并开始监听相交状态变化情况IntersectionObserver.observet(string targetSelector, function callback) 参数string targetSelector：选择器 function callback：监听相交状态变化的回调函数 参数Object res 属性 类型 说明 最低版本intersectionRatio number 相交比例intersectionRect Object 相交区域的边界boundingClientRect Object 目标边界relativeRect Object 参照区域的边界time number 相交检测时的时间戳 es.intersectionRect 的结构 属性 类型 说明 最低版本left number 左边界right number 右边界top number 上边界bottom number 下边界res.boundingClientRect 的结构 属性 类型 说明 最低版本left number 左边界right number 右边界top number 上边界bottom number 下边界res.relativeRect 的结构 属性 类型 说明 最低版本left number 左边界right number 右边界top number 上边界bottom number 下边界 23.1.3 IntersectionObserver.relativeTot() 使用选择器指定一个节点，作为参照区域之一。IntersectionObserver.relativeTo(string selector, Object margins) 参数string selector选择器 Object margins用来扩展（或收缩）参照节点布局区域的边界 属性 类型 默认值 必填 说明 最低版本left number 否 节点布局区域的左边界right number 否 节点布局区域的右边界top number 否 节点布局区域的上边界bottom number 否 节点布局区域的下边界 23.1.4 IntersectionObserver.relativeToViewportt() 指定页面显示区域作为参照区域之一IntersectionObserver.relativeToViewport(Object margins) 参数Object margins用来扩展（或收缩）参照节点布局区域的边界 属性 类型 默认值 必填 说明 最低版本left number 否 节点布局区域的左边界right number 否 节点布局区域的右边界top number 否 节点布局区域的上边界bottom number 否 节点布局区域的下边界示例代码下面的示例代码中，如果目标节点（用选择器 .target-class 指定）进入显示区域以下 100px 时，就会触发回调函数。 123456789101112Page(&#123; onLoad: function()&#123; wx.createIntersectionObserver().relativeToViewport(&#123;bottom: 100&#125;).observe('.target-class', (res) =&gt; &#123; res.intersectionRatio // 相交区域占目标节点的布局区域的比例 res.intersectionRect // 相交区域 res.intersectionRect.left // 相交区域的左边界坐标 res.intersectionRect.top // 相交区域的上边界坐标 res.intersectionRect.width // 相交区域的宽度 res.intersectionRect.height // 相交区域的高度 &#125;) &#125;&#125;) 23.2 wx.createIntersectionObserver 创建布局相交状态语法：wx.createIntersectionObserver(Object this, Object options)，在自定义组件中，可以使用 this.createIntersectionObserver([options]) 来代替 参数：Object this：自定义组件实例 Object options：选项 返回值：IntersectionObserver 对象实例 开发者工具中查看效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;style&gt;.scroll-view &#123; height: 400rpx; background: #fff; border: 1px solid #ccc; box-sizing: border-box;&#125;.scroll-area &#123; height: 1300rpx; display: flex; flex-direction: column; align-items: center; transition: .5s;&#125;.notice &#123; margin-top: 150rpx;&#125;.ball &#123; width: 200rpx; height: 200rpx; background: #1AAD19; border-radius: 50%;&#125;.filling &#123; height: 400rpx;&#125;.message &#123; width: 100%; display: flex; justify-content: center;&#125;.message text &#123; font-size: 40rpx; font-family: -apple-system-font, Helvetica Neue,Helvetica,sans-serif;&#125;&lt;/style&gt;&lt;view class=\"container\"&gt; &lt;view class=\"page-body\"&gt; &lt;view class=\"page-section message\"&gt; &lt;text wx:if=\"&#123;&#123;appear&#125;&#125;\"&gt; 小球出现 &lt;/text&gt; &lt;text wx:else&gt; 小球消失 &lt;/text&gt; &lt;/view&gt; &lt;view class=\"page-section\"&gt; &lt;scroll-view class=\"scroll-view\" scroll-y&gt; &lt;view class=\"scroll-area\" style=\"&#123;&#123;appear ? 'background: #ccc' : ''&#125;&#125;\"&gt; &lt;text class=\"notice\"&gt;向下滚动让小球出现&lt;/text&gt; &lt;view class=\"filling\"&gt;&lt;/view&gt; &lt;view class=\"ball\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;script&gt;Page(&#123; data: &#123; appear: false &#125;, onLoad() &#123; this._observer = wx.createIntersectionObserver(this) this._observer .relativeTo('.scroll-view') .observe('.ball', (res) =&gt; &#123; console.log(res); this.setData(&#123; appear: res.intersectionRatio &gt; 0 &#125;) &#125;) &#125;, onUnload() &#123; if (this._observer) this._observer.disconnect() &#125;&#125;)&lt;/script&gt; 23.5 SelectorQuery 查询节点信息的对象23.1.1 SelectorQuery.exec23.1.1 SelectorQuery.in23.1.1 SelectorQuery.select23.1.1 SelectorQuery.selectAll23.1.1 SelectorQuery.selectViewport23.4 wx.createSelectorQuery1234567const query = wx.createSelectorQuery()query.select('#the-id').boundingClientRect()query.selectViewport().scrollOffset()query.exec(function(res)&#123; res[0].top // #the-id节点的上边界坐标 res[1].scrollTop // 显示区域的竖直滚动位置&#125;) 23.5 NodesRef23.5.1 .boundingClientRect23.5.2 .fields23.5.3 .scrollOffset","tags":[]},{"title":"小程序账号申请","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑦ - 【小程序】 申请账号/","text":"一、前言设计小程序之前，需要有一个账号，用来登录微信开发者工具，以便开发。","tags":[]},{"title":"react 中使用 less 或者 scss","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/⑤ -【react.js 框架】-less-scss 在 react中使用/","text":"一、前言其实 create-react-app 2.0 已经不需要这么麻烦了，不需要做下面的工作了。2.0 版本的脚手架已经默认的制作 css 的预处理了，不需要再进行下面麻烦的操作了，下面的操作还是留着吧！！！！！！！！！！1 但是问题是 它是在 2018年10月1日 发布的，不知道现在是否已经可以使用了，这个还是大家都用，都熟练的时候再用好了。react 官网博客页面 create-react-app 2.0 二、react 中使用 less2.1 配置命令步骤react 项目没有原生的支持 css 预处理器（使用create-react-app 创建的项目默认不支持 less，以下增加 less 配置的步骤） 配置步骤 123$ npm run eject #暴露配置文件$ npm install less-loader less --save-dev #安装 less-loader 和 less# 编辑配置文件 2.2 2.2 配置文件编辑暴露配置之后，项目目录会多处两个文件夹，修改里面的文件 1234567891011//webpack.config.dev.jsexclude: [ /\\.html$/, /\\.(js|jsx)$/, /\\.(css|less)$/,// ①①①①① 把 /\\.css$/ 改为 /\\.(css|less)$/ /\\.json$/, /\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/,], 12345678910111213141516171819202122232425262728293031323334353637//webpack.config-prod.js&#123; test: /\\.(css|less)$/,//①①①①① 把 test: /\\.css$/ 改为 /\\.(css|less)$/ use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') // compiles Less to CSS， //②②②②② 把 test: /\\.css$/ 的 use 数组配置增加 less-loader &#125; ],&#125;, 三、react 中使用 scss2.1 配置命令步骤react 项目没有原生的支持 css 预处理器（使用 create-react-app 创建的项目默认不支持 scss，以下增加 scss 配置的步骤） 配置步骤 123$ npm run eject #暴露配置文件$ npm install sass-loader node-sass --save-dev #安装 less-loader 和 less# 编辑配置文件 2.2 2.2 配置文件编辑暴露配置之后，项目目录会多处两个文件夹，修改里面的文件 1234567891011//webpack.config.dev.jsexclude: [ /\\.html$/, /\\.(js|jsx)$/, /\\.(css|less)$/,// ①①①①① 把 /\\.css$/ 改为 /\\.(css|less)$/ /\\.json$/, /\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/,], 12345678910111213141516171819202122232425262728293031323334353637//webpack.config-prod.js&#123; test: /\\.(css|less)$/,//①①①①① 把 test: /\\.css$/ 改为 /\\.(css|less)$/ use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') // compiles Less to CSS， //②②②②② 把 test: /\\.css$/ 的 use 数组配置增加 less-loader &#125; ],&#125;,","tags":[]},{"title":"scss/less 与 calc 公式配合使用","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-scss 与 calc 公式使用/","text":"一、前言在 css3 中使用 calc 的方式就不能直接的使用在 scss 的处理中了。如果需要使用，还需要做额外的处理。 二、scss 与 calc 公式配合使用12345678/* css3 */.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(100vw - 20px);&#125; 123456789// scss.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(100vw - 20px);// scss 会比 less 简单一点，没有变量的话，就是直接像是 css3 与 calc 的使用 width:calc(100vw - #&#123;$--sidewidth*2&#125;); //scss 变量 配合 calc 公式使用需要使用 #&#123;&#125; 包裹起来&#125; 三、less 与 calc 公式配合使用12345678/* css3 */.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(100vw - 20px);&#125; 12345678// less.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(~\"100vw - 20px\");// 就是用 ~\"\" 包裹里面的公式，less 中只要涉及 calc 公式就要包裹起来&#125; 1234567891011// less 中使用 calc 并且带上变量//目标`width:calc(100% + 50px);`以下两种办法都是正确的//法一@extra:50px;width:calc(~\"100% + @&#123;extra&#125;\"); //√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√// 还是用方法一比较好记吧，也比较好看，而且好像有的时候 2 会有错？？？？//法二@extra:50px;width:calc(~\"100% +\"(@extra)); //变量外一定要加括号，结果中会自动添加空格","tags":[]},{"title":"less/scss 与 calc 公式配合使用","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-less 与 calc 公式使用.1/","text":"一、前言在 css3 中使用 calc 的方式就不能直接的使用在 less 的处理中了。如果需要使用，还需要做额外的处理。 二、scss 与 calc 公式配合使用12345678/* css3 */.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(100vw - 20px);&#125; 123456789// scss.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(100vw - 20px);// scss 会比 less 简单一点，没有变量的话，就是直接像是 css3 与 calc 的使用 width:calc(100vw - #&#123;$--sidewidth*2&#125;); //scss 变量 配合 calc 公式使用需要使用 #&#123;&#125; 包裹起来&#125; 三、less 与 calc 公式配合使用12345678/* css3 */.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(100vw - 20px);&#125; 12345678// less.left&#123; width:20px; height:100vh;&#125;.right&#123; width:calc(~\"100vw - 20px\");// 就是用 ~\"\" 包裹里面的公式，less 中只要涉及 calc 公式就要包裹起来&#125; 1234567891011// less 中使用 calc 并且带上变量//目标`width:calc(100% + 50px);`以下两种办法都是正确的//法一@extra:50px;width:calc(~\"100% + @&#123;extra&#125;\"); //√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√// 还是用方法一比较好记吧，也比较好看，而且好像有的时候 2 会有错？？？？//法二@extra:50px;width:calc(~\"100% +\"(@extra)); //变量外一定要加括号，结果中会自动添加空格","tags":[]},{"title":"less--[less，css 中的 calc 公式运用]","date":"2018-08-18T13:57:28.000Z","path":"2018/08/18/[html-css]-css3-calc 计算公式/","text":"一、前言习惯用 Less 之后，简直一点都不想再乖乖地写 CSS 了。光是“嵌套”的语法特性就让人爱不释手。但是 less 也会有 less 的问题。 二、css3 中使用 calc 函数5.1 css 中 felx 与 calc 公式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; padding: 0; margin: 0; &#125; .head&#123; height: 50px; background: firebrick; &#125; .content&#123; display: flex; width: 100%; background: blue; height: calc(100vh - 100px); &#125; .left&#123; width: 240px; background: red; height: 100%; &#125; .right&#123; width: calc(100vw - 240px); background: yellow; height: 100%; overflow:auto; //这里是auto，是hidden的话就不对的 &#125; .footer&#123; height: 50px; background: teal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"head\"&gt;head&lt;/div&gt; &lt;div class=\"content\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt; right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right right &lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上代码的效果图如下 5.2 css 中 calc 与 100%123456789#div1 &#123; position: absolute; left: 50px; width: calc(100% - 100px); border: 1px solid black; background-color: yellow; padding: 5px; text-align: center;&#125; 5.3 css 中让 高度 == 宽度1234&#123; width:50%; height: calc(width);&#125; 12345678910111213141516171819202122//通过 js 动态生成 DOM&lt;script type=\"text/javascript\"&gt;$(document).ready(function()&#123; $('#box1').css('height',$('#box1').css('width'));&#125;)&lt;/script&gt;&lt;style type=\"text/css\"&gt;#box&#123; width: 900px; height: 400px; border:1px solid red;&#125;#box1&#123; width:50%; border:1px solid green;&#125;&lt;/style&gt;&lt;body&gt;&lt;div id='box'&gt; &lt;div id='box1'&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt; 三、 Less 中使用 CSS3 的 calc 函数（有时候很有用），怎么都不起作用。运算符前后不要忘记空格，否则公式是没有效果的！！！！！！！！！！！！！！运算符前后不要忘记空格，否则公式是没有效果的！！！！！！！！！！！！！！运算符前后不要忘记空格，否则公式是没有效果的！！！！！！！！！！！！！！ 2.1 原因原来是跟 Less 的语法冲突了，Less 把 calc 的参数当作运算式执行了。解决方式是使用 Less 的转义字符~。它的具体用法可以看文章结尾的参考阅读中的 Less Language Escaping。文档中说到：GIT:https://github.com/SomMeri/less4j/wiki/Less-Language-Escaping 这个文档就有说明. 2.2 普通加减123CSS3：width:calc(100% + 50px); 编译为width:calc(100% + 50px); //CSS3less：width:calc(100% + 50px); 编译为width:calc(150%); //错误的lessless：width:calc(~\"100% + 50px\");编译为width:calc(100% + 50px); //正确less使用 123CSS3：width:calc(100% - 50px); 编译为width:calc(100% - 50px);//CSS3less：width:calc(100% - 50px); 编译为width:calc(59%); //错误的lessless：width:calc(~\"100% - 50px\");编译为width:calc(100% - 50px);//正确less使用 2.3 带变量加减1234567//目标`width:calc(100% + 50px);`以下两种办法都是正确的//法一@extra:50px;width:calc(~\"100% + @&#123;extra&#125;\");//法二@extra:50px;width:calc(~\"100% +\"(@extra)); //变量外一定要加括号，结果中会自动添加空格 1234567//目标`width:calc(100% + 50px + 2em);`以下两种办法都是正确的//法一@extra:50px;width:calc(~\"100% + @&#123;extra&#125; + 2em\");//法二@extra:50px;width:calc(~\"100% +\"(@extra)~\"+ 2em\"); //变量外一定要加括号，结果中会自动添加空格 顺便，如果习惯使用 Less 语法，但是又不想在 HTML 中引入Less.js等其他的库，可以使用编辑器的插件，把 Less 文件编译成 CSS 文件之后，再引入到 HTML 中。比如，VSCode 有一个插件叫 Easy LESS。每当 Less 文件被保存时，就会自动编译生成对应的 CSS 文件。","tags":[]},{"title":"CSS3 深入了解--[弹性盒子模型：display:flex]","date":"2018-08-17T13:57:27.000Z","path":"2018/08/17/[html-css]-css3-flex 布局/","text":"一、前言网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案：Flex 布局，弹性盒子布局模式。CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。 二、属性学习2.1 弹性容器 与 弹性子元素弹性盒子由弹性容器 (Flex container) 和弹性子元素 (Flex item) 组成。弹性容器通过设置 display 属性的值为 flex 或 inline-flex 将其定义为弹性容器。弹性容器内包含了一个或多个弹性子元素。 注意： 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局(简单的说就是没有继承性别)。弹性子元素内的元素渲染可以将弹性子元素用 display 属性的值为 flex 或 inline-flex 将其定义为弹性容器也变成容器，其内部的就可以使用了。 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。 属性 描述 用于 display 指定 HTML 元素盒子类型。指定元素为容器 容器 flex-direction 指定了弹性容器中子元素的排列方式 容器 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。 容器 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。 容器 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行。 容器 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 容器 flex-flow flex-direction 和 flex-wrap 的简写 容器 order 设置弹性盒子的子元素排列顺序。 项目/子元素 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 项目/子元素 flex 设置弹性盒子的子元素如何分配空间。 项目/子元素 2.1 几个比较难以区分的属性。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!重点，重点，重点12345justify-content:center; 子容器/项目/子元素文本框 在 父容器中的 水平对齐方式（一行）align-items: center; 子容器/项目/子元素文本框 在 父容器中的 垂直对齐方式（一行）align-content: cecnter; 子容器/项目/子元素文本框 在 父容器中的 垂直对齐方式（多行）text-align: center; 文本在文本框中的 水平对齐方式vertical-align: middle; 文本在文本框中的 垂直对齐方式（但是只能是行内，table-cell等） 2.2 弹性容器(Flex container)2.2.1 display 让元素称为弹性容器在容器这里，我们使用的 display 的值是 flex，或者 inline-flex 使其成为容器。 我们还可以了解一下 display 的其他值。 123456789101112131415161718# none 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间# inline 指定对象为内联元素。# block 指定对象为块元素。# inline-block 指定对象为内联块元素。（CSS2）# list-item 指定对象为列表项目。# run-in 根据上下文决定对象是内联对象还是块级对象。（CSS3）# table 指定对象作为块元素级的表格。类同于html标签`&lt;table&gt;`（CSS2）# inline-table 指定对象作为内联元素级的表格。类同于html标签`&lt;table&gt;`（CSS2）# table-caption 指定对象作为表格标题。类同于html标签`&lt;caption&gt;`（CSS2）# table-cell 指定对象作为表格单元格。类同于html标签`&lt;td&gt;`（CSS2）# table-row 指定对象作为表格行。类同于html标签`&lt;tr&gt;`（CSS2）# table-row-group 指定对象作为表格行组。类同于html标签`&lt;tbody&gt;`（CSS2）# table-column 指定对象作为表格列。类同于html标签`&lt;col&gt;`（CSS2）# table-column-group 指定对象作为表格列组显示。类同于html标签`&lt;colgroup&gt;`（CSS2）# table-header-group 指定对象作为表格标题组。类同于html标签`&lt;thead&gt;`（CSS2）# table-footer-group 指定对象作为表格脚注组。类同于html标签`&lt;tfoot&gt;`（CSS2）# flex 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3）# inline-flex 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） 以下是旧伸缩属性值，已经不使用了。box：将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）inline-box：将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3）flexbox：将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3）inline-flexbox：将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） 2.2.2 flex-direction 子容器 在 父容器 排列方式 值 描述 flex-direction:row 默认值。灵活的项目将水平显示，正如一个行一样。 flex-direction:row-reverse 与 row 相同，但是以相反的顺序。 flex-direction:column 灵活的项目将垂直显示，正如一个列一样。 flex-direction:column-reverse 与 column 相同，但是以相反的顺序。 flex-direction:initial 设置该属性为它的默认值。 flex-direction:inherit 从父元素继承该属性。 12345678&lt;div id=\"main\"&gt; &lt;div style=\"background-color:coral;\"&gt;A&lt;/div&gt; &lt;div style=\"background-color:lightblue;\"&gt;B&lt;/div&gt; &lt;div style=\"background-color:khaki;\"&gt;C&lt;/div&gt; &lt;div style=\"background-color:pink;\"&gt;D&lt;/div&gt; &lt;div style=\"background-color:lightgrey;\"&gt;E&lt;/div&gt; &lt;div style=\"background-color:lightgreen;\"&gt;F&lt;/div&gt;&lt;/div&gt; 各个值效果图展示： 2.2.3 justify-content 子容器 在 父容器 水平对齐方式 值 描述 justify-content:flex-start 默认值。项目位于容器的开头 justify-content:flex-end 项目位于容器的结尾。 justify-content:center 项目位于容器的中心。 justify-content:space-between 项目位于各行之间留有空白的容器内。 justify-content:space-around 项目位于各行之前、之间、之后都留有空白的容器内。 各个值效果图展示： 2.2.4 align-items 子容器 在 父容器 垂直对齐方式 值 描述 align-items:stretch 默认值。元素被拉伸以适应容器。如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。 align-items:center 元素位于容器的中心。弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。 align-items:flex-start 元素位于容器的开头。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。 align-items:flex-end 元素位于容器的结尾。弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。 align-items:baseline 元素位于容器的基线上。如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。 各个值效果图展示： 2.2.5 flex-wrap 子容器 在 父容器 超出是否换行 值 描述 flex-wrap:nowrap 默认值。规定灵活的项目不拆行或不拆列。 flex-wrap:wrap 规定灵活的项目在必要的时候拆行或拆列。 flex-wrap:wrap-reverse 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。 flex-wrap:initial 设置该属性为它的默认值。请参阅 initial。 各个值效果图展示： 2.2.6 flex-flow :flex-direction 和 flex-wrap 的简写2.2.7 多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 值 描述 flex-wrap:stretch元素被拉伸以适应容器。各行将会伸展以占用剩余的空间。如果剩余的空间是负数，该值等效于’flex-start’。在其它情况下，剩余空间被所有行平分，以扩大它们的侧轴尺寸。 flex-wrap:center 元素位于容器的中心。各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一行之间的距离相等。（如果剩下的空间是负数，则各行会向两个方向溢出的相等距离。） flex-wrap:flex-start 元素位于容器的开头。各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行。 flex-wrap:flex-end 元素位于容器的结尾。各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行。 flex-wrap:space-between 元素位于各行之间留有空白的容器内。各行在弹性盒容器中平均分布。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于’flex-start’。在其它情况下，第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等。 flex-wrap:space-around 元素位于各行之前、之间、之后都留有空白的容器内。各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。如果剩余的空间是负数或弹性盒容器中只有一行，该值等效于’center’。在其它情况下，各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后一行后面的空间是其他空间的一半。 flex-wrap:initial 设置该属性为它的默认值。请参阅 initial。 各个值效果图展示： |order|设置弹性盒子的子元素排列顺序。|||align-self|在弹性子元素上使用。覆盖容器的 align-items 属性。|||flex|设置弹性盒子的子元素如何分配空间。|| 2.2 弹性子元素(Flex item)2.2.1 order 子容器 中子元素的排列顺序order：项目的排列顺序。数值越小，排列越靠前，默认为0。可以为负数，负数值肯定是小的，在最前面。 12345678910111213141516171819#main1 &#123; width: 400px; height: 150px; border: 1px solid #c3c3c3; display: -webkit-flex; /* Safari */ display: flex;&#125;#main2 &#123; width: 400px; height: 150px; border: 1px solid #c3c3c3; display: -webkit-flex; /* Safari */ display: flex; flex-direction:row-reverse;&#125;div#myRedDIV &#123;order: 2;&#125;div#myBlueDIV &#123;order: 4;&#125;div#myGreenDIV &#123;order: 3;&#125;div#myPinkDIV &#123;order: 1;&#125; 123456789101112&lt;div id=\"main1\"&gt; &lt;div style=\"background-color:coral;\" id=\"myRedDIV\"&gt;order: 2&lt;/div&gt; &lt;div style=\"background-color:lightblue;\" id=\"myBlueDIV\"&gt;order: 4&lt;/div&gt; &lt;div style=\"background-color:lightgreen;\" id=\"myGreenDIV\"&gt;order: 3&lt;/div&gt; &lt;div style=\"background-color:pink;\" id=\"myPinkDIV\"&gt;order: 1&lt;/div&gt;&lt;/div&gt;&lt;div id=\"main2\"&gt; &lt;div style=\"background-color:coral;\" id=\"myRedDIV\"&gt;order: 2&lt;/div&gt; &lt;div style=\"background-color:lightblue;\" id=\"myBlueDIV\"&gt;order: 4&lt;/div&gt; &lt;div style=\"background-color:lightgreen;\" id=\"myGreenDIV\"&gt;order: 3&lt;/div&gt; &lt;div style=\"background-color:pink;\" id=\"myPinkDIV\"&gt;order: 1&lt;/div&gt;&lt;/div&gt; 各个值效果图展示： 2.2.2 align-self 覆盖容器的 align-items 属性，允许单个项目有与其他项目不一样的对齐方式，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性可能取6个值，除了auto，其他都与 align-items 属性完全一致。各个值效果图展示： 2.2.3 flex 子容器 在 父容器 占据的比例大小MDN 1234567891011121314151617181920flex-grow # 取 值：number 负值无效。 # 定 义：规定项目将相对于其他灵活的项目进行扩展的量。其实就是每个子元素在容器中的空间占比。 # 拉伸因子，定义项目的放大比例 # 默认值：默认为 0 ，即如果存在 【剩余空间】，也不放大。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! # 举 例：如果所有子项目的 flex-grow 属性都为 1 ，则它们将 【等分剩余】空间（如果有的话）。 # 如果一个项目的 flex-grow 属性为 2，其他项目都为 1 ，则前者占据的 【剩余空间】将比其他项多一倍。- flex-shrink # 取 值：number 负值无效。 # 定 义：规定项目将相对于其他灵活的项目进行收缩的量。空间不足时子元素的缩小选项。 # 缩小因子 # 默认值：默认值 1 ,即如果空间不足，该项目将缩小。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! # 举 例：如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。 # 如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。- flex-basis # 取 值：合法值：\"auto\"、\"inherit\" 或一个后跟 \"%\"、\"px\"、\"em\" 或任何其他长度单位的数字。 # 定 义：柔性项目的初始主长度。定义了在分配多余空间之前，项目占据的主轴空间（main size）。 # 浏览器根据这个属性，计算主轴是否有多余空间。 # 它可以设为跟 width 或 height 属性一样的值（比如 350px ），则项目将占据 【固定空间】。 # 默认值：默认值 auto ,即项目的本来大小。 12345678910111213141516171819202122232425262728/* 缩写属性：flex: flex-grow、flex-shrink、flex-basis 默认值 `flex: 0 1 auto;` *//* flex 属性可以指定 1 个，2 个或 3 个值。 *//* 1111 个值 */flex: auto; // 等价于 1 1 autoflex: initial;// 等价于默认值 flex: 0 1 auto;flex: none; // 等价于 0 0 autoflex: 2;// 指的是的拉伸值 flex-grow ，后面两个可选属性还是默认值 相当于 flex: 2 1 0%; // 为什么 flex-basis 是 0% 呢，因为当使用一个或两个无单位数时, flex-basis 会从 默认值 auto 变为 0flex: 1;// 指的是的拉伸值 flex-grow ，后面两个可选属性还是默认值 相当于 flex: 1 1 0%;flex: 10em;// 指的是的固定尺寸 flex-basis 等价于 1 1 10em ？？？？？？？？？？？？？？？？？？？？？？？flex: 30px;// 指的是的固定尺寸 flex-basis 等价于 1 1 30px ？？？？？？？？？？？？？？？？？？？？？？flex: 50%;// 指的是的固定尺寸 flex-basis 等价于 1 1 50% ？？？？？？？？？？？？？？？？？？？？、？flex: inherit;//继承父元素flex: initial;//初始值，默认值 flex: 0 1 auto;flex: unset;// 未设置/* 2222 个值 */flex: 2 30px;// 指的是 flex-grow | flex-basis 等价于 flex:2 1 30px; //就是 拉伸因子 与 固定值【第二个值不能省略单位，否则就变成 flex-shrink 了】 // 默认的 flex-shrink 会变成 1 ？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？flex: 2 2; // flex-grow | flex-shrink 等价于 flex:2 2 0%; // 为什么 flex-basis 是 0% 呢，因为当使用一个或两个无单位数时, flex-basis 会从 默认值 auto 变为 0/* 3333 个值 */flex: 2 2 10%;//flex-grow、flex-shrink、flex-basis flex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。这里主要讨论以下 flex-basis 的取值情况： auto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。 content：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。 百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。 segmentfault 三、兼容问题3.1 块状元素 flex 布局123.box&#123; display: flex;&#125; 3.2 行内元素也可以使用 Flex 布局。123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 四、bug 或者 特别注意注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 五、使用 felx 以及 calc 计算公式布局。5.1 css 中 felx 与 calc 公式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; padding: 0; margin: 0; &#125; .head&#123; height: 50px; background: firebrick; &#125; .content&#123; display: flex; width: 100%; background: blue; height: calc(100vh - 100px); &#125; .left&#123; width: 240px; background: red; height: 100%; &#125; .right&#123; width: calc(100vw - 240px); background: yellow; height: 100%; overflow:auto; //这里是auto，是hidden的话就不对的!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111 .main&#123; height:1500px; background: red; &#125; &#125; .footer&#123; height: 50px; background: teal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"head\"&gt;head&lt;/div&gt; &lt;div class=\"content\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"main\"&gt; 11 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt;footer&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上代码的效果图如下 5.2 less 中 calc 公式使用less 中 calc 公式使用：网址","tags":[{"name":"flex","slug":"flex","permalink":"https://liuxmoo.com/tags/flex/"}]},{"title":"css--[盒状模型：display:inline-block + position 属性 + float 属性]","date":"2018-08-15T13:57:26.000Z","path":"2018/08/15/[html-css]-css-float 浮动/","text":"一、前言网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。 但是它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案：Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。flex布局：网址 本文还是继续说依赖 display 属性 + position 属性 + float 属性的布局方式。","tags":[]},{"title":"html5 高级篇","date":"2018-08-13T13:57:25.000Z","path":"2018/08/13/[html-css]-html-高级/","text":"前言","tags":[]},{"title":"静态网页生成器--hexo 的使用","date":"2018-08-13T13:57:25.000Z","path":"2018/08/13/⑭ 【静态网站生成器】-hexo-vuepress==-/","text":"一、前言Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 二、Quick Start 快速上手 2.1 Create a new post 创建新文章12# 创建新的文章，当然最简单的方式就是手动的添加一个 md 文件就是新的文章啦$ hexo new \"My New Post\" More info: Writing 2.2 Run server 本地服务器运行123# 在本地服务器运行$ hexo server$ hexo s # 简写 More info: Server 2.3 Generate static files 生成静态文件123# 生成静态文件$ hexo generate$ hexo g # 简写 More info: Generating 2.4 Deploy to remote sites 远程部署12# 部署$ hexo deploy More info: Deployment 五、使用过程中遇到的问题5.1 没有找到 hexo 依赖包1234liuxm@me ~/work/xiaomiblog (master)λ hexo g`ERROR Local hexo not found in ~\\work\\xiaomiblog`# 没有找到 hexo 包`ERROR Try running: 'npm install hexo --save'` 问题-解决： 可能是路径不对 -&gt; 更新到正确的路径 刚克隆/下载下来的项目，没有下载依赖包 -&gt; npm install 5.2 cnpm install 安装依赖包出错1234567891011121314151617liuxm@me ~/work/xiaomiblog (master)`λ cnpm install`/ [12/15] Installing through@&gt;=2.2.7 &lt;3platform unsupported hexo-abbrlink@2.0.5 › hexo-fs@0.2.3 › chokidar@1.7.0 › fsevents@^1.0.0 Package require os(darwin) not compatible with your platform(win32)- [12/15] Installing through@&gt;=2.2.7 &lt;3[fsevents@^1.0.0] optional install error: Package require os(darwin) not compatible with your platform(win32)√ Installed 15 packages√ Linked 295 latest versions√ Run 0 scripts`deprecate hexo-renderer-jade@0.3.0 › jade@^1.11.0 Jade has been renamed to pug, please install the latest version of pug instead of jade`# 不推荐使用 hexo-renderer-jade@0.3.0&gt; jade@^1.11.0 Jade 已经改名为 pug，请安装最新版本的 pug 代替 jade`deprecate hexo-renderer-jade@0.3.0 › jade@1.11.0 › transformers@2.1.0 Deprecated, use jstransformer`# hexo-renderer-jade@0.3.0&gt; jade@1.11.0&gt; transformers@2.1.0 已弃用，请使用 jstransformer`deprecate hexo-renderer-jade@0.3.0 › jade@1.11.0 › constantinople@~3.0.1 Please update to at least constantinople 3.1.1`# 弃用 constantinople@~3.0.1 请至少更新 constantinople@3.1.1`deprecate hexo@3.8.0 › titlecase@^1.1.2 no longer maintained`# titlecase@^1.1.2 已经不再维护Recently updated (since 2019-01-12): 3 packages (detail see file C:\\Users\\liuxm\\work\\xiaomiblog\\node_modules\\.recently_updates.txt)√ All packages installed (375 packages installed from npm registry, used 4s(network 4s), speed 140.33kB/s, json 310(551.22kB), tarball 0B) github 问题网址","tags":[]},{"title":"解决 input 高度不一致的问题","date":"2018-08-11T16:57:25.000Z","path":"2018/08/12/[html-css]-css4-解决 input 高度不一致的问题/","text":"一、前言input 输入框的高度与 button 还有 select 都是不同的，怎么让他们变得一致。 二、解决原因：其实是因为 padding 导致的，修改 padding 也可以的，但是我们还是直接使得盒子模型是 border-box 就不需要考虑 padding 的问题了。 12345678910111213141516&lt;style&gt; input,select &#123; height: 50px; &#125; input&#123; box-sizing: border-box; &#125;&lt;/style&gt;&lt;div&gt; 如何解决input和select的宽高不一致问题&lt;/div&gt;&lt;input type=\"text\"&gt;&lt;input type=\"button\" value=\"22222\"&gt;&lt;select name=\"\" id=\"\"&gt;&lt;/select&gt;","tags":[]},{"title":"html 快速入门篇","date":"2018-08-11T16:57:25.000Z","path":"2018/08/12/[html-css]-html-入门级别/","text":"一、前言","tags":[]},{"title":"CSS3 深入理解--[视差滚动]","date":"2018-08-11T16:57:25.000Z","path":"2018/08/12/[html-css]-css3-视差滚动设计/","text":"一、前言1.1 什么是滚动视差？视差滚动（Parallax Scrolling）是指让多层背景以不同的速度移动，形成立体的运动效果，带来非常出色的视觉体验。 视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。 当我们坐在车上向车窗外 看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。许多游戏中都使用视差效果来增加场景的立体感。说的简单点就是网页内的元素 在滚动屏幕时发生的位置的变化，然而各个不同的元素位置变化的速度不同，导致网页内的元素有层次错落的错觉，这和我们人体的眼球效果很像。我看到多家产品 商用视差滚动效果来展示产品，从不同的空间角度和用户体验，起到了非常不错的效果。其实 马里奥小游戏就是使用了这个设计效果。 1.2 滚动视差网站的特点 多场景 大图片 多屏 净色 横向分割 适合特性介绍 限制元素显示范围 1.3 视差设计应该注意的问题 以大量图片为特色的网站应该考虑 图像的预加载问题，以便 为用户提供更好更流畅的视觉体验； 某些网站页面在移动设备上的效果可能较之在 PC上 有所不同，一些功能也可能无法正常使用。 二、UI 设计过程2.1 滚动视差网站设计流程（UI 设设计师） 1 了解需求分析交互： 前期先要了解需求，决定是否要采用滚动视差毕竟不是所有项目都适合（UI 设计师需要考虑的问题）2 整理内容构思场景 这时脑海里要有一个大概的成品的构思（UI 设计师需要考虑的问题）3 设计页面图形化场景 设计稿毕竟不能“动”，这个时候需要输出关键状态的设计稿（UI 设计师需要考虑的问题）4 沟通讲解述说思路 需要跟重构人员当面详细讲解你的设计思路以及动画效果 （UI 设计师、前端设计师）5 优化设计修改反馈 当一些效果无法实现或成本过高时需要及时修改自己的设计稿 （UI 设计师、前端设计师）6 不断优化追求完美 不断跟重构开发沟通，调整设计稿 （UI 设计师、前端设计师） 毕竟视觉设计师输出的视觉稿都是静态图片，而滚动视差网站时一个随着滚动不断变化的，所以设计时与传统网页有很多不同。在设计初期设计师要判断这个页面适不适合采用滚动视差。 在决定采用滚动视差之后就需要设计者整理现有的内容资料，将其故事化或场景化，然后根据构思设计出关键状态的视觉设计稿。 传统 网页设计师做到这一步基本上工作就已经完成，可以交给其他人不管了。但是滚动视差的网站不行，视觉设计的工作才刚刚开始，这时，你需要负责跟重构设计师讲 解你的设计思路，你需要怎么分层怎么运动。 在重构设计师实现的时候通常并不会一帆风顺，通常会因为实现成本等各种问题需要设计师返回去重新修改设计稿。通 过反复的沟通，反复的磨合才能完成预想中的漂亮的滚动视差网站。 2.2 滚动视差网站设计中的一些小技巧和小细节（UI 设计师）① 别忘了loading 滚动视差网站由于内容分层会用到很多 大尺寸图片 或者 png 图片，所以体积往往比较大，所以这个时候千万别忘了设计 loading 动画。？？？？是什么意思？？？？？？？② 斜线的巧妙运用 当斜线从底部向上划入的时候，通常视觉上会给人一种是从右下角以一定角度划入的错觉。所以斜线的布局也经常被采用在滚动视差网站的设计中去。③ 纯色的运用 没有比纯色的背景更直观更简洁。纯色可以有很多种表达方式 纯色比渐变和图片更容易延展，并且纯色很容易区分视差区间。在使用时我们可以调整颜色的透明度，来达到各种视觉效果。所以纯色的运用也是滚动视差设计者的大爱。 三、前端设计师滚动视差在前端需要辅助 Javascript 才能实现。当然，其实 CSS 在实现滚动视差效果方面，也有着不俗的能力。 3.1 css + js 做成视差3.2 css3 做视差3.2.1 使用 background-attachment 属性具体的去学习 background 简写属性 1234567background-attachment #设置背景图像是否固定或者随着页面的其余部分滚动 scroll # 背景图片随页面的其余部分滚动。这是默认值!!!!!!!!!!!!!!!!!!!!!!!! # 背景图像相对于元素本身固定!!!!!!!,它在的位置的内容走去别的的地方了它不动。但是窗口滚动的话，它就要动了 fixed # 背景图像相对于窗体固定（相对于窗口时固定的位置不变的）# 移动的只有视口，而背景图是一直固定死的。！！！！！！！！！！！！！！！？？ local # 背景图像相对于元素内容固定!!!!!!!,它在的位置的内容移动了它就会移动。（CSS3） inherit # 指定 background-attachment 的设置应该从父元素继承 123/* 可以设置多个背景，然后固定模式也是一一对应的 */background-image: url(\"https://mdn.mozillademos.org/files/12057/starsolid.gif\"),url(\"https://mdn.mozillademos.org/files/12059/startransparent.gif\");background-attachment: fixed, scroll; 做视差的时候，就是一些图片固定，一些图片滚动，就做成了简单的视差效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css视差滚动&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"flowImage fixed-bg bg1\"&gt; &lt;p&gt; 这个西红柿死了吗&lt;br&gt; 可是它的颜色&lt;br&gt; 还像鲜花一样奔放 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"flowImage fixed-bg bg2\"&gt; &lt;p&gt;为了跳到天上&lt;br&gt; 月亮先爬到树上。 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"flowImage fixed-bg bg3\"&gt; &lt;p&gt; 晚上&lt;br&gt; 我打着手电筒散步&lt;br&gt; 累了就拿它当拐杖&lt;br&gt; 我拄着一束光 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"flowImage fixed-bg bg4\"&gt; &lt;p&gt; 我是在摸一颗星星&lt;br&gt; 因为地球&lt;br&gt; 也是一颗星星 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"flowImage fixed-bg bg5\"&gt; &lt;p&gt; 我在家等爸爸妈妈&lt;br&gt; 我饿了&lt;br&gt; 这时飞来一只金龟子&lt;br&gt; 可能金龟子也饿了 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"flowImage fixed-bg bg6\"&gt; &lt;p&gt; 每当见到加油站&lt;br&gt; 我就在心里大声地喊&lt;br&gt; 加油加油加油&lt;br&gt; 也不知为了谁 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455body, html &#123; height: 100%; margin: 0; padding: 0&#125;.box &#123; height: 100%; position: relative; z-index: 1;&#125;.flowImage &#123; position: relative; height: 500px; background-size: cover; background-repeat: no-repeat; background-position: center center; z-index: 1; background-attachment: fixed; //划重点！！！&#125;.flowImage&gt;p &#123; margin: 0; position: absolute; top: 50%; left: 10%; color: #fff; font-size: 30px; transform: translate(-10%, -50%);&#125;.bg1 &#123; background-image: url(images/1.jpg);&#125;.bg2:nth-child(2) &#123; background-image: url(images/2.jpg);&#125;.bg3:nth-child(3) &#123; background-image: url(images/3.jpg);&#125;.bg4:nth-child(4) &#123; background-image: url(images/4.jpg);&#125;.bg5:nth-child(5) &#123; background-image: url(images/5.jpg);&#125;.bg6:nth-child(6) &#123; background-image: url(images/6.jpg);&#125; 3.2.2 使用 transform: translate3d 实现滚动视差利用 CSS 3D 来做视差滚动 原理：① 我们给 父容器设置上 transform-style: preserve-3d; 和 perspective: xpx;，那么处于这个容器的 子元素就将位于 3D 空间中，② 再给子元素设置不同的 transform: translateZ()，这个时候，不同元素在 3D Z 轴方向距离屏幕（我们的眼睛）的距离也就不一样③ 滚动滚动条，由于子元素设置了不同的 transform: translateZ()，那么他们滚动的上下距离 translateY 相对屏幕（我们的眼睛），也是不一样的，这就达到了滚动视差的效果。 12345&lt;div class=\"g-container\"&gt; &lt;div class=\"section-one\"&gt;translateZ(-1)&lt;/div&gt; &lt;div class=\"section-two\"&gt;translateZ(-2)&lt;/div&gt; &lt;div class=\"section-three\"&gt;translateZ(-3)&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526html &#123; height: 100%; overflow: hidden;&#125;body &#123; perspective: 1px; transform-style: preserve-3d; height: 100%; overflow-y: scroll; overflow-x: hidden;&#125;.g-container &#123; height: 150%; .section-one &#123; transform: translateZ(-1px); &#125; .section-two &#123; transform: translateZ(-2px); &#125; .section-three &#123; transform: translateZ(-3px); &#125;&#125; 十、视差滚动10.1 左右移动效果 1234&lt;div id=\"wrapper\"&gt; &lt;div id=\"clouds\"&gt;&lt;/div&gt; &lt;!-- 天空和云 --&gt; &lt;div id=\"ground\"&gt;&lt;/div&gt; &lt;!-- 地面草地 --&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445html &#123; height:100%; background:#63D0FF;&#125;body&#123; margin:0; padding:0; background:#63D0FF; height:100%; #wrapper &#123; position:relative; width:100%; height:100%; #clouds&#123; background:url(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/56901/bg-clouds2-tinypng.png\") repeat-x 0 bottom #ACE6FF; width:100%; height:230px; /*190px*/ min-height:230px; position:absolute; top:0; left:0; z-index:1; -webkit-transform:translate3d(0,0,0.01);/* 3D 转换 */ transform:translate3d(0,0,0.01); &#125; #ground &#123; background:url(\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/56901/grass_tile-tinypng.png\") repeat-x 0 0 transparent; position: absolute; bottom: 0; left: 0; z-index:2; width: 100%; height: 192px; min-height:192px; border:0 none transparent; outline:0 none transparent; -webkit-transform:translate3d(0,0,0.01); transform:translate3d(0,0,0.01); will-change: transform; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// wait until DOM is ready 监听 DOM 加载完成// 就像是 vue.js 的 mounted() 的周期函数// 也像是 react.js 的 componentDidMount() 周期函数一样document.addEventListener(\"DOMContentLoaded\", function(event) &#123; function ground() &#123; var tl = new TimelineMax(&#123; repeat: -1 &#125;); tl.to(\"#ground\", 20, &#123; backgroundPosition: \"1301px 0px\", force3D:true, rotation:0.01, z:0.01, autoRound:false, ease: Linear.easeNone &#125;); return tl; &#125; function clouds() &#123; var tl = new TimelineMax(&#123; repeat: -1 &#125;); tl.to(\"#clouds\", 52, &#123; backgroundPosition: \"-2247px bottom\", force3D:true, rotation:0.01, z:0.01, //autoRound:false, ease: Linear.easeNone &#125;); return tl; &#125; var masterTL = new TimelineMax(&#123; repeat: -1 &#125;); // window load event makes sure image is // loaded before running animation window.onload = function() &#123; masterTL .add(ground(),0) .add(clouds(),0) .timeScale(0.7) .progress(1).progress(0) .play(); &#125;;&#125;); 这个例子使用到了 GASP 这个动画插件，如果搭配 vue.js 或者是 react.js 使用，要去 GASP 官网去学习。 10.2 滚动模糊视觉效果滚动模糊这种视觉效果也应用的非常广，特别是当你想使用背景图片吸引用户而且还能让用户在滚动的时候阅读图片上文字的时候，就很适合使用它。只需要借助一点点 JavaScript 来改变图片的 background-size 属性就可以实现这样的效果： 1234567891011&lt;style&gt; p&#123; height:1500px; &#125;&lt;/style&gt;&lt;div class=\"feature\"&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;h2&gt;Heading&lt;/h2&gt; &lt;p&gt;111111&lt;/p&gt;&lt;/div&gt;&lt;!--[if IE 8]&gt; &lt;/div&gt; &lt;![endif]--&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142* &#123;box-sizing:border-box&#125;body, html &#123; padding:0; margin:0&#125;body &#123; background:#232323; color:#fff&#125;.opaque &#123; position:absolute; top:0; left:0; right:0; bottom:0; opacity:0; background:#d2d6f1;&#125;.lt-ie9 .opaque &#123; display:none;&#125;.content &#123; position:relative; z-index:1; padding-top:45%; width:90%; margin:0 auto; .feature &#123; position:fixed; top:0; z-index:0; width:100%; padding-top:50%; background: url(http://s3.nikecdn.com/pass/NikeBasketball/LeBron_Poster.jpg) center center no-repeat; -webkit-background-size:250%; -moz-background-size:250%; -o-background-size:250%; background-size:250%; -webkit-box-shadow: 0 -50px 20px -20px #232323 inset; -moz-box-shadow: 0 -50px 20px -20px #232323 inset; box-shadow: 0 -50px 20px -20px #232323 inset; &#125;&#125;@media only screen and (min-width:36.250em) &#123; .content &#123; width:60%; padding-top:35% &#125;&#125; 123456789101112131415161718192021222324252627282930313233$(function()&#123; zoom = $('.feature').css('background-size') zoom = parseFloat(zoom)/100 size = zoom * $('.feature').width(); $(window).on('scroll', function()&#123; fromTop = $(window).scrollTop(); newSize = size - (fromTop/3); if (newSize &gt; $('.feature').width()) &#123; $('.feature').css(&#123; '-webkit-background-size': newSize, '-moz-background-size': newSize, '-o-background-size': newSize, 'background-size': newSize, '-webkit-filter':'blur('+ 0 + (fromTop/100) + 'px)', 'opacity': 1 - ((fromTop / $('html').height()) * 1.3) &#125;); &#125; &#125;);&#125;);$(function ()&#123; var isChrome = /Chrome/.test(navigator.userAgent) &amp;&amp; /Google Inc/.test(navigator.vendor); var isSafari = /Safari/.test(navigator.userAgent) &amp;&amp; /Apple Computer/.test(navigator.vendor); if (isChrome || isSafari) &#123; &#125; else &#123; $('.feature').append('&lt;div class=\"opaque\"&gt;&lt;/div&gt;'); $(window).on('scroll', function()&#123; var opacity = 0 + ($(window).scrollTop()/5000); $('.opaque').css('opacity', opacity); &#125;); &#125;&#125;); 10.3 视差滚动Hero Image图片效果这个没有使用到 JS 代码。 12345678910&lt;header&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;-Do Work That Matters-&lt;/h1&gt; &lt;h3&gt;You'll never regret it.&lt;/h3&gt; &lt;/div&gt;&lt;!-- /.container --&gt;&lt;/header&gt;&lt;section&gt; &lt;div class=\"container\"&gt; &lt;/div&gt;&lt;!-- /.container --&gt;&lt;/section&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* Variables */$bg-image: \"https://images.unsplash.com/photo-1441716844725-09cedc13a4e7?q=80&amp;fm=jpg&amp;s=c895a1f219d174952415b9b7a0811e62\";$bg-overlay: rgba(0,235,235,0.7);$primary-color: #FFFFFF;$primary-font: \"Amatic SC\", cursive;$secondary-color: #FFF0A5;$secondary-font: \"Abril Fatface\", cursive;$body-color: #999999;$body-font: Helvetica, Arial, sans-serif;/* Fonts */@import url(https://fonts.googleapis.com/css?family=Abril+Fatface);@import url(https://fonts.googleapis.com/css?family=Amatic+SC);/* Mixins */@mixin bg-images( $image-path: \"https://images.unsplash.com/photo-1441716844725-09cedc13a4e7?q=80&amp;fm=jpg&amp;s=c895a1f219d174952415b9b7a0811e62\", $overlay-color: rgba(255,255,255,0.8), $position: center center) &#123; animation: bgFadeIn 1s ease-in both; position: relative; &amp;:before &#123; background: linear-gradient( $overlay-color, $overlay-color ), url($image-path); background-color: #CCCCCC; background-attachment: fixed; background-position: $position; background-repeat: no-repeat; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover; bottom: 0; content: ' '; left: 0; position: absolute; right: 0; top: 0; z-index: -1; &#125; @keyframes bgFadeIn &#123; 0% &#123; background-color: rgba(255, 255, 255, 1); &#125; 100% &#123; background-color: rgba(255, 255, 255, 0); &#125; &#125;&#125;/* Base Styles */* &#123; box-sizing: border-box;&#125;html, body &#123; color: $body-color; font-family: $body-font; font-size: 10px; font-weight: 100; margin: 0; padding: 0;&#125;.container &#123; margin: 0 auto; max-width: 750px; padding: 0 24px;&#125;header &#123; @include bg-images( $image-path: $bg-image, $overlay-color: $bg-overlay ); padding: 28px; text-align: center; .container &#123; margin: 12rem auto; &#125; h1 &#123; border-bottom: 2px solid $primary-color; border-top: 2px solid $primary-color; color: $primary-color; font-family: $primary-font; font-size: 8.75rem; margin: 0; &#125; h3 &#123; color: $secondary-color; font-family: $secondary-font; font-size: 3.75rem; font-style: italic; font-weight: 100; margin: 0; &#125;&#125;section &#123; padding: 2rem; p &#123; font-size: 2.5rem; line-height: 3.5rem; &amp;.lead-in &#123; font-size: 3rem; &amp;:first-letter &#123; font-size: 7.25rem; display: block; float: left; position: relative; line-height: .1; top: -0.200em; &#125; &#125; &#125;&#125;","tags":[]}]
<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="小米粥e博客"><meta name="keywords" content="html, css, vue, JavaScript,js,vuex,element-ui,iveiw-ui,axios"><title>vue--[ 生命周期钩子函数] | liuxmoo</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">vue--[ 生命周期钩子函数]</h1><a id="logo" href="/.">liuxmoo</a><p class="description">半路被拎来的前端。(*^▽^*)。学习最快的方法→慢慢来</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">vue--[ 生命周期钩子函数]</h1><div class="post-meta"><a href="/2018/08/19/{ vue.js 框架 }-生命周期钩子函数/#comments" class="comment-count"></a><p><span class="date">Aug 19, 2018</span><span><a href="/categories/④-vue-js/" class="category">④ vue.js</a><a href="/categories/④-vue-js/vue-js-框架学习/" class="category">vue.js 框架学习</a></span></p></div><div class="post-content"><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>生命周期是一个重点，也是比较难以区分的选项。</p>
<h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><p><img src="http://liuxmoo.foryung.com/20180203220502151.png" alt="周期图解"></p>
<p>在谈到 Vue 的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了 init（init 是 vue 组件里面默认去执行的），在 init 的过程当中首先调用了 beforeCreate，然后在 injections（注射）和 reactivity（反应性）的时候，它会再去调用 created。所以在 init 的时候，事件已经调用了，我们在beforeCreate 的时候千万不要去修改 data 里面赋值的数据，最早也要放在 created 里面去做（添加一些行为）。</p>
<p>当 created 完成之后，它会去判断 instance（实例）里面是否含有 “el”option（选项），如果没有的话，它会调用 vm.$mount(el) 这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有 “template” 这个选项，如果有的话，它会把 template 解析成一个 render function ，这是一个 template 编译的过程，结果是解析成了render 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render (h) &#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, &#123;&#125;, <span class="keyword">this</span>.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>render 函数里面的传参 h 就是 Vue 里面的 createElement 方法，return 返回一个 createElement 方法，其中要传 3 个参数，第一个参数就是创建的 div 标签；第二个参数传了一个对象，对象里面可以是我们组件上面的 props，或者是事件之类的东西；第三个参数就是 div 标签里面的内容，这里我们指向了 data 里面的 text。</p>
<p>使用 render 函数的结果和我们之前使用 template 解析出来的结果是一样的。render 函数是发生在 beforeMount 和 mounted 之间的，这也从侧面说明了，在 beforeMount 的时候，$el 还只是我们在  HTML 里面写的节点，然后到 mounted 的时候，它就把渲染出来的内容挂载到了 DOM 节点上。这中间的过程其实是执行了 render function 的内容。</p>
<p>在使用 .vue 文件开发的过程当中，我们在里面写了 template 模板，在经过了 vue-loader 的处理之后，就变成了 render function，最终放到了 vue-loader 解析过的文件里面。这样做有什么好处呢？原因是由于在解析 template 变成 render function 的过程，是一个非常耗时的过程，vue-loader 帮我们处理了这些内容之后，当我们在页面上执行vue 代码的时候，效率会变得更高。</p>
<p>beforeMount 在有了 render function 的时候才会执行，当执行完 render function 之后，就会调用 mounted 这个钩子，在 mounted 挂载完毕之后，这个实例就算是走完流程了。</p>
<p>后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用 beforeUpdate，然后经过 Virtual DOM，最后 updated 更新完毕。当组件被销毁的时候，它会调用 beforeDestory，以及 destoryed。</p>
<p>以上就是 vue实例从新建到销毁的一个完整流程，以及在这个过程中它会触发哪些生命周期的钩子函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    message:<span class="string">'xxx'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeCreate()&#123;</span><br><span class="line"><span class="comment">// 状态：实例初始化之后，this 指向创建的实例。**数据观测 (data observer)** 和 **event/watcher 事件配置** 之前被调用。</span></span><br><span class="line"><span class="comment">//      此时 $el 和 data 都为 undefined,没有初始化</span></span><br><span class="line"><span class="comment">// 场景：常用于初始化非响应式变量。不能直接访问到 data、computed、watch、methods 上的方法和数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用：</span></span><br><span class="line"><span class="comment">//         可以进行 loading 事件 之类的动画加载，在加载实例时触发（就是避免 created 出现白屏，在这个钩子做的一个动画加载 ），在 created 时进行移除</span></span><br><span class="line"><span class="comment">//         但是通常我们使用 css 来做到 loading 的效果，没有接触到使用 js 来做的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题：vue 怎么在 beforeCreate 里获取 data</span></span><br><span class="line"><span class="comment">// 实际上 data 的是 created() 初始化的，但是我们要在这里获取数据的话，就需要是使用到 this.$nextTick(callBack) 异步操作。</span></span><br><span class="line"><span class="comment">// 这个 this.$nextTick 可以使得里面的 回调函数 到下次 DOM 更新循环结束后才会执行。（循环：数据更新--下一次数据更新之前）</span></span><br><span class="line"><span class="comment">// this.$nextTick(function () &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.message);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// 但是我们还是不要去这样做吧？ vue 给了我们什么周期该干什么就干什么，这样才能很好的利用啊。</span></span><br><span class="line">&#125;</span><br><span class="line">created()&#123;</span><br><span class="line">  <span class="comment">// 状态：在实例创建完成后被立即调用。，可访问 data、computed、watch、methods 上的方法和数据，未挂载到 DOM，不能访问到 $el 属性，$ref 属性内容为空数组</span></span><br><span class="line">  <span class="comment">//      创建后 data 初始化了,而 $el 没有</span></span><br><span class="line">  <span class="comment">// 场景：对 data 数据进行操作，常用于简单的 ajax 请求，页面初始化，将 ajax 请求将返回的数据赋给 data，还可以进行网络接口的请求操作；</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际应用：</span></span><br><span class="line">  <span class="comment">//        在这结束 loading，然后做一些数据的初始化，实现函数自执行（这个在 Vue 的生命周期只会执行一次）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际工作：假如你需要中 vux 中取数据，在模版中使用，那么你需要在 dom 挂载之前获取到数据，这个操作就在 created 里面做</span></span><br><span class="line">  <span class="comment">//问题：页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态</span></span><br><span class="line">&#125;</span><br><span class="line">beforeMount()&#123;</span><br><span class="line">  <span class="comment">// 状态：在挂载开始之前被调用，beforeMount 之前，会找到对应的 template，并编译成 render 函数</span></span><br><span class="line">  <span class="comment">//      $el和data都初始化了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//在挂载开始之前被调用：相关的 render 函数首次被调用。</span></span><br><span class="line">&#125;</span><br><span class="line">mounted()&#123;</span><br><span class="line">  <span class="comment">// 状态：实例挂载到 DOM 上，此时可以通过 DOM API 获取到 DOM 节点，$ref 属性可以访问</span></span><br><span class="line">  <span class="comment">// 场景：常用于获取 VNode 信息和操作，ajax 请求，也可以进行后台获取数据操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际应用：</span></span><br><span class="line">  <span class="comment">//        在这发起后端请求，拿回数据，配合路由钩子做一些事情 （会经常进行数据处理和更新）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//el 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标</span></span><br><span class="line">  <span class="comment">//注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted：</span></span><br><span class="line">  <span class="comment">// 实际工作：如果需要手工操作 dom 或者其它非 vue 插件需要操作 dom，那么必须得在 dom 生成后，那这时候就得在 mounted 触发。</span></span><br><span class="line">  <span class="comment">// 问题：不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 this.$nextTick</span></span><br><span class="line">&#125;</span><br><span class="line">beforeUpdate()&#123;</span><br><span class="line">  <span class="comment">//状态：响应式数据更新时调用之前，发生在虚拟 DOM 打补丁之前。</span></span><br><span class="line">  <span class="comment">//场景：适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际应用：</span></span><br><span class="line">  <span class="comment">//        因为在 mounted 的时候就会经常进行数据的更新，所以就没必要在这个生命周期进行数据处理了</span></span><br><span class="line">  <span class="comment">//        可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom</span></span><br><span class="line">&#125;</span><br><span class="line">updated()&#123;</span><br><span class="line">  <span class="comment">//状态：虚拟 DOM 重新渲染和打补丁之后调用，组件 DOM 已经更新，可执行依赖于 DOM 的操作</span></span><br><span class="line">  <span class="comment">//      由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</span></span><br><span class="line">  <span class="comment">//updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated</span></span><br><span class="line">  <span class="comment">// 避免在这个钩子函数中操作数据，可能陷入死循环</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际应用：</span></span><br><span class="line">  <span class="comment">//        对数据统一处理，在这里写上相应函数</span></span><br><span class="line">&#125;</span><br><span class="line">activated()&#123;</span><br><span class="line">  <span class="comment">//keep-alive 组件激活时调用。</span></span><br><span class="line">  <span class="comment">//在使用 vue-router 时有时需要使用 &lt;keep-alive&gt;&lt;/keep-alive&gt;来缓存组件状态，这样可以避免 created 钩子就不会被重复调用了，</span></span><br><span class="line">  <span class="comment">//场景：如果我们的子组件需要在每次加载的时候进行某些操作，可以使用 activated 钩子触发。</span></span><br><span class="line">&#125;</span><br><span class="line">deactivated()&#123;</span><br><span class="line">  <span class="comment">//keep-alive 组件停用时调用。</span></span><br><span class="line">&#125;</span><br><span class="line">beforeDestroy()&#123;</span><br><span class="line">  <span class="comment">// 状态：实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例</span></span><br><span class="line">  <span class="comment">// 场合：常用于销毁定时器、解绑全局事件、销毁插件对象等操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际应用：你确认删除 XX 吗、 点击下一步的时候、或者需要是存浏览器储存的时候、清除定时器等等，</span></span><br><span class="line">  <span class="comment">//          因为 vue 是一个单页面，如果定时器在 vue 生命周期销毁之前不清除的话，那就会导致定时器一直在运行，影响性能!!!!!!!!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line">destroyed()&#123;</span><br><span class="line">  <span class="comment">//场合：Vue 实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</span></span><br><span class="line">  <span class="comment">//调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际应用；</span></span><br><span class="line">  <span class="comment">//        当前组件已被删除，清空相关内容。下一步，跳转路由。等等？？？？？？？？？？不懂这里</span></span><br><span class="line">&#125;</span><br><span class="line">errorCaptured(err,vm,info)&#123;</span><br><span class="line">  <span class="comment">//当捕获一个来自子孙组件的错误时被调用。</span></span><br><span class="line">  <span class="comment">//(err: Error, vm: Component, info: string) =&gt; ?boolean</span></span><br><span class="line">  <span class="comment">//错误对象，发生错误的组件实例，错误来源信息的字符串</span></span><br><span class="line">  <span class="comment">//此钩子可以返回 false 以阻止该错误继续向上传播。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-created-阶段的-ajax-请求与-mounted-请求的区别："><a href="#2-1-created-阶段的-ajax-请求与-mounted-请求的区别：" class="headerlink" title="2.1 created 阶段的 ajax 请求与 mounted 请求的区别："></a>2.1 created 阶段的 ajax 请求与 mounted 请求的区别：</h3><ul>
<li>created：页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态</li>
<li>mounted ：不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 this.$nextTick</li>
</ul>
<h3 id="2-2-生命周期的执行情况"><a href="#2-2-生命周期的执行情况" class="headerlink" title="2.2 生命周期的执行情况"></a>2.2 生命周期的执行情况</h3><blockquote>
<p>单组件</p>
</blockquote>
<ul>
<li>初始化组件时，仅执行了beforeCreate、created、beforeMount、mounted 四个钩子函数（执行一次）</li>
<li>当改变 data 中定义的变量（响应式变量）时，会执行 beforeUpdate、updated 钩子函数（ —–可多次执行）</li>
<li>当切换组件（当前组件未缓存）时，会执行 beforeDestory、destroyed        钩子函数（执行一次）</li>
<li>初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate、updated 可多次执行</li>
</ul>
<blockquote>
<p>父子组件</p>
</blockquote>
<ul>
<li>仅当子组件完成挂载后，父组件才会挂载</li>
<li>当子组件完成挂载后，父组件会主动执行一次beforeUpdate/updated钩子函数（仅首次）</li>
<li>父子组件在data变化中是分别监控的，但是在更新props中的数据是关联的（可实践）</li>
<li>销毁父组件时，先将子组件销毁后才会销毁父组件</li>
</ul>
<p>1.父 beforeCreate、created、beforeMount<br>2.子 beforeCreate、created、beforeMount、mounted<br>3.父 mounted、beforeUpdate、updated（加载子组件之后自动的执行一次更新：理论上单组件的更新钩子是由于用户的操作 数据更新才会执行的，<br>                                  里相当于 子组件使得父组件的数据更新了）</p>
<p>4.在这里中间，如果用户操作数据更新，相应的执行父子组件中的周期钩子函数 beforeUpdate、updated。各自数据更新，执行各自的（自己的 data 改变，互不相干）<br>5.如果 props 发生改变，（父子有关系的）执行 父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated<br>6.子组件销毁，子组件的 beforeDestory、destroyed<br>7.父组件销毁，子组件的  父 beforeDestory → 子 beforeDestory → 子 destroyed → 父 destroyed</p>
<blockquote>
<p>父、兄弟组件的生命周期</p>
</blockquote>
<ul>
<li>组件的初始化（mounted 之前）分开进行，挂载是从上到下依次进行</li>
<li>当没有数据关联时，兄弟组件之间的更新和销毁是互不关联的</li>
</ul>
<p>给子组件增加兄弟姐妹之后</p>
<p>1.父 beforeCreate、created、beforeMount<br>2.子一 beforeCreate、created、beforeMount<br>  子二 beforeCreate、created、beforeMount<br>  子一 mounted<br>  子二 mounted<br>3.父 mounted、beforeUpdate、updated（加载子组件之后自动的执行一次更新：理论上单组件的更新钩子是由于用户的操作 数据更新才会执行的，<br>                                  里相当于 子组件使得父组件的数据更新了）</p>
<p>4.在这里中间，如果用户操作数据更新，相应的执行父子组件中的周期钩子函数 beforeUpdate、updated。各自数据更新，执行各自的（自己的 data 改变，互不相干）<br>  子一更新数据：子一 beforeUpdate、updated<br>  子二更新数据：子二 beforeUpdate、updated<br>5.如果 props 发生改变，（父子有关系的）执行 父 beforeUpdate → 子 beforeUpdate → 子 updated → 父 updated<br>6.子组件销毁，子组件的 beforeDestory、destroyed<br>7.父组件销毁，子组件的  父 beforeDestory → 子一 beforeDestory → 子一 destroyed → 子二 beforeDestory → 子二 destroyed → 父 destroyed</p>
<blockquote>
<p>宏 mixin 的生命周期</p>
</blockquote>
<ul>
<li>mixin 中的生命周期与引入该组件的生命周期是紧密关联的，且 mixin 的生命周期优先执行</li>
</ul>
<p>1.mixin-beforeCreate 、beforeCreate、mixin-created、created、mixin-beforeMount、beforeMount、mixin-mounted、mounted<br>  如果有子组件，就会在 beforeMount 与  mounted 之间去执行<br>2.mixin-beforeUpdate、beforeUpdate、mixin-updated、updated<br>3.mixin-beforeDestory、beforeDestory、mixin-destroyed 、destroyed<br>  如果有子组件，就会在 beforeDestory 与 destroyed 之间去执行</p>
<p>总结执行顺序，对照 DOM 事件的捕获和冒泡过程来看：</p>
<ul>
<li>beforeCreate 、 created 、 beforeUpdate 、 beforeDestroy 是在“捕获”过程中调用的；</li>
<li>mounted 、 updated 、 destroyed 是在“冒泡”过程中调用的。</li>
</ul>
<p>同时，可以看到，在初始化流程、 update 流程和销毁流程中，子级的相应声明周期方法都是在父级相应周期方法之间调用的。<br>比如子级的初始化钩子函数（ beforeCreate 、 created 、 mounted ）都是在父级的 created 和 mounted 之间调用的，<br>这实际上说明等到子级准备好了，父级才会将自己挂载到上一层 DOM 树中去，从而保证界面上不会闪现脏数据。</p>
<blockquote>
<p>路由切换时，组件生命周期的执行（就不考虑 update 了）</p>
</blockquote>
<p>可以看到，从 A 组件切换到 B 组件时<br>A beforeCreate<br>A created<br>A beforeMount<br>A mounted<br>要是 A update 就是在这里<br>就是在这个时候 从 A 切换到 B 页面的。<br>B beforeCreate<br>B created<br>B beforeMount<br>A beforeDestroy<br>A destroyed<br>B mounted，<br>要是 B update 就是在这里，然后再切换别的就是</p>
<h2 id="三、实际应用"><a href="#三、实际应用" class="headerlink" title="三、实际应用"></a>三、实际应用</h2><p>根据第二章的总结，对照 DOM 事件的捕获和冒泡过程来看：</p>
<ul>
<li>beforeCreate 、 created 、 beforeUpdate 、 beforeDestroy 是在“捕获”过程中调用的；</li>
<li>mounted 、 updated 、 destroyed 是在“冒泡”过程中调用的。</li>
</ul>
<p>同时，可以看到，在初始化流程、 update 流程和销毁流程中，子级的相应声明周期方法都是在父级相应周期方法之间调用的。<br>比如子级的初始化钩子函数（ beforeCreate 、 created 、 mounted ）都是在父级的 created 和 mounted 之间调用的，<br>这实际上说明等到子级准备好了，父级才会将自己挂载到上一层 DOM 树中去，从而保证界面上不会闪现脏数据。</p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/08/19/{ vue.js 框架 }-API 接口/" class="pre">vue---API 接口</a><a href="/2018/08/19/⑤ -【react.js 框架 】-事件处理/" class="next">react.js--[事件处理]</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、生命周期"><span class="toc-text">二、生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-created-阶段的-ajax-请求与-mounted-请求的区别："><span class="toc-text">2.1 created 阶段的 ajax 请求与 mounted 请求的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-生命周期的执行情况"><span class="toc-text">2.2 生命周期的执行情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、实际应用"><span class="toc-text">三、实际应用</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/①-html-css/">① html-css</a><span class="category-list-count">17</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/①-html-css/Normalize-css/">Normalize.css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/①-html-css/css/">css</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/①-html-css/html/">html</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/①-html-css/less/">less</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/①-html-css/scss/">scss</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/②-Javascript-ES6-Typescript/">② Javascript-ES6-Typescript</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/②-Javascript-ES6-Typescript/ES6/">ES6</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/②-Javascript-ES6-Typescript/Javascript/">Javascript</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/②-Javascript-ES6-Typescript/TypeScript/">TypeScript</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/③-Jquery-js/">③ Jquery.js</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/③-Jquery-js/JQurey-UI/">JQurey-UI</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/③-Jquery-js/Jquery-js-框架学习/">Jquery.js 框架学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/③-Jquery-js/ajax-前后端数据交互/">ajax 前后端数据交互</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/">④ vue.js</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/axios-前后端数据交互/">axios 前后端数据交互</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/vue-中使用-less-scss-等预处理器/">vue 中使用 less/scss 等预处理器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/vue-cli-脚手架/">vue-cli 脚手架</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/vue-router-路由设置/">vue-router 路由设置</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/vue-js-框架学习/">vue.js 框架学习</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/vue-js-的-UI-组件库/">vue.js 的 UI 组件库</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/④-vue-js/vuex-状态管理器/">vuex 状态管理器</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/">⑤ react.js</a><span class="category-list-count">15</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/axios-在-react-js-中使用/">axios 在 react.js 中使用</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/create-react-app-脚手架/">create-react-app 脚手架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/less-scss-在-react-中使用/">less/scss 在 react 中使用</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/mixins-混合组件-与-hoc-高阶组件/">mixins 混合组件 与 hoc 高阶组件</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/react-router-v4-路由管理器/">react-router v4 路由管理器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/react-js-框架学习/">react.js 框架学习</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/react-js-的-UI-组件库/">react.js 的 UI 组件库</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/taro-js-多终端框架-京东/">taro.js 多终端框架(京东)</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑤-react-js/状态管理器/">状态管理器</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑥-react-native-js/">⑥ react-native.js</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑥-react-native-js/react-native-框架/">react-native 框架</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑦-小程序/">⑦ 小程序</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑦-小程序/MINA-框架/">MINA 框架</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑦-小程序/mpvue-框架/">mpvue 框架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑦-小程序/wepy-框架/">wepy 框架</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/">⑧ JS 工具集/ JS拓展语言</a><span class="category-list-count">9</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/Chrome-开发者工具/">Chrome 开发者工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/JSL-拓展语言/">JSL 拓展语言</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/day-js-框架/">day.js 框架</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/markdown/">markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/node-js-语言/">node.js 语言</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/render-函数/">render 函数</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑧-JS-工具集-JS拓展语言/阿里矢量图用法（字符实体）/">阿里矢量图用法（字符实体）</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑨-HTTP/">⑨ HTTP</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑩-打包工具-命令行工具-包管理器-github/">⑩ 打包工具-命令行工具-包管理器-github</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑩-打包工具-命令行工具-包管理器-github/github/">github</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑩-打包工具-命令行工具-包管理器-github/npm-yarn/">npm & yarn</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑩-打包工具-命令行工具-包管理器-github/webpack/">webpack</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑩-打包工具-命令行工具-包管理器-github/编辑器/">编辑器</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑪-网站部署/">⑪ 网站部署</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑫-综合实战项目/">⑫ 综合实战项目</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑫-综合实战项目/jQuery/">jQuery</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑫-综合实战项目/vue/">vue</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑬-数据结构与算法/">⑬ 数据结构与算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑭-静态网页生成器/">⑭ 静态网页生成器</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑭-静态网页生成器/hexo/">hexo</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/⑮-bug-集合/">⑮ bug 集合</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/⑮-bug-集合/vue-中遇到的-bug/">vue 中遇到的 bug</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/㊿-无关编程/">㊿ 无关编程</a><span class="category-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/animation-动画/" style="font-size: 15px;">animation 动画</a> <a href="/tags/cookie-session-token/" style="font-size: 15px;">cookie,session,token</a> <a href="/tags/立即执行函数/" style="font-size: 15px;">立即执行函数</a> <a href="/tags/gradients-线性/" style="font-size: 15px;">gradients 线性</a> <a href="/tags/Jquery-ajax/" style="font-size: 15px;">Jquery->ajax</a> <a href="/tags/interceptor-请求拦截器/" style="font-size: 15px;">interceptor 请求拦截器</a> <a href="/tags/v-charts-图标库/" style="font-size: 15px;">v-charts 图标库</a> <a href="/tags/react-js-组件传值/" style="font-size: 15px;">react.js 组件传值</a> <a href="/tags/递归函数/" style="font-size: 15px;">递归函数</a> <a href="/tags/transition-过渡/" style="font-size: 15px;">transition 过渡</a> <a href="/tags/react-js事件处理/" style="font-size: 15px;">react.js事件处理</a> <a href="/tags/react-js-生命周期/" style="font-size: 15px;">react.js 生命周期</a> <a href="/tags/transform-转换-变形/" style="font-size: 15px;">transform 转换/变形</a> <a href="/tags/flex/" style="font-size: 15px;">flex</a> <a href="/tags/ESlint之坑/" style="font-size: 15px;">ESlint之坑</a> <a href="/tags/axios-使用于-vue-js-react-js/" style="font-size: 15px;">axios(使用于 vue.js react.js)</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/15/[html-css]-css-float 浮动/">css--[盒状模型：display:inline-block + position 属性 + float 属性]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/06/⑧-【JS 工具集-拓展语言】-node.js- 爬虫/">node.js--爬虫</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-ES6-基础入门/">ES6【1】--[ECMAScript 6 入门]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-js-new Date() 日期时间处理/">JavaScript---new Date]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-js-正则表达式/">JavaScript--正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-js-递归函数/">JavaScript【2】--[递归函数的深入了解]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-js-立即执行函数/">JavaScript【4】--[立即执行函数 IIFE ]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-js-高质量高效率代码编辑/">[编写高质量 JS 代码 ]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/[Javascript]-js-cookie-token/">JavaScript【1】--[cookie,session,token 详解]</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/⑬ -数据结构与算法-JS-入门/">JavaScript 数据结构与算法【1】--[入门版]</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://gofoer.com/" title="Gofoer" target="_blank">Gofoer</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p></p><p><span> &nbsp;&nbsp;Copyright &copy;2018&nbsp;<a href="/." rel="nofollow">小米粥.</a></span><span> <a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> </a></span><span> <a rel="nofollow" target="_blank" href="https://hexo.io"> </a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>